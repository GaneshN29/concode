{"code": "  import java.io.Serializable; import java.lang.reflect.AnnotatedElement; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; import java.util.concurrent.Future; import java.util.concurrent.RejectedExecutionException; import java.util.concurrent.SynchronousQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException;  import javax.inject.Singleton; import javax.persistence.EntityManager; import javax.persistence.EntityManagerFactory; import javax.persistence.EntityNotFoundException; import javax.persistence.OneToMany; import javax.persistence.Transient; import javax.persistence.Version; import javax.validation.Configuration; import javax.validation.Validation; import javax.validation.Validator; import javax.validation.ValidatorFactory;  import org.apache.shiro.authc.credential.PasswordService; import org.apache.shiro.authz.UnauthorizedException; import org.apache.shiro.guice.aop.ShiroAopModule; import org.apache.shiro.mgt.RememberMeManager; import org.apache.shiro.realm.Realm; import org.apache.shiro.web.filter.mgt.FilterChainManager; import org.apache.shiro.web.filter.mgt.FilterChainResolver; import org.apache.shiro.web.mgt.WebSecurityManager; import org.apache.shiro.web.servlet.ShiroFilter; import org.apache.wicket.Application; import org.apache.wicket.core.request.mapper.StalePageException; import org.apache.wicket.protocol.http.PageExpiredException; import org.apache.wicket.protocol.http.WebApplication; import org.apache.wicket.protocol.http.WicketFilter; import org.apache.wicket.protocol.http.WicketServlet; import org.eclipse.jetty.servlet.ServletContextHandler; import org.eclipse.jetty.websocket.api.WebSocketPolicy; import org.glassfish.jersey.server.ResourceConfig; import org.glassfish.jersey.servlet.ServletContainer; import org.hibernate.CallbackException; import org.hibernate.Interceptor; import org.hibernate.ObjectNotFoundException; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.StaleStateException; import org.hibernate.boot.model.naming.PhysicalNamingStrategy; import org.hibernate.collection.internal.PersistentBag; import org.hibernate.exception.ConstraintViolationException; import org.hibernate.type.Type; import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;  import com.fasterxml.jackson.databind.ObjectMapper; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.inject.Provider; import com.google.inject.matcher.AbstractMatcher; import com.google.inject.matcher.Matchers; import com.thoughtworks.xstream.XStream; import com.thoughtworks.xstream.annotations.XStreamOmitField; import com.thoughtworks.xstream.converters.basic.NullConverter; import com.thoughtworks.xstream.converters.extended.ISO8601DateConverter; import com.thoughtworks.xstream.converters.extended.ISO8601SqlTimestampConverter; import com.thoughtworks.xstream.converters.reflection.ReflectionProvider; import com.thoughtworks.xstream.core.JVM; import com.thoughtworks.xstream.mapper.MapperWrapper; import com.vladsch.flexmark.Extension;  import io.onedev.commons.launcher.bootstrap.Bootstrap; import io.onedev.commons.launcher.loader.AbstractPlugin; import io.onedev.commons.launcher.loader.AbstractPluginModule; import io.onedev.commons.launcher.loader.ImplementationProvider; import io.onedev.commons.utils.ExceptionUtils; import io.onedev.commons.utils.StringUtils; import io.onedev.server.buildspec.job.DefaultJobManager; import io.onedev.server.buildspec.job.JobManager; import io.onedev.server.buildspec.job.log.DefaultLogManager; import io.onedev.server.buildspec.job.log.LogManager; import io.onedev.server.buildspec.job.log.instruction.LogInstruction; import io.onedev.server.entitymanager.BuildDependenceManager; import io.onedev.server.entitymanager.BuildManager; import io.onedev.server.entitymanager.BuildParamManager; import io.onedev.server.entitymanager.BuildQuerySettingManager; import io.onedev.server.entitymanager.CodeCommentManager; import io.onedev.server.entitymanager.CodeCommentQuerySettingManager; import io.onedev.server.entitymanager.CodeCommentRelationManager; import io.onedev.server.entitymanager.CodeCommentReplyManager; import io.onedev.server.entitymanager.CommitQuerySettingManager; import io.onedev.server.entitymanager.GroupAuthorizationManager; import io.onedev.server.entitymanager.GroupManager; import io.onedev.server.entitymanager.IssueChangeManager; import io.onedev.server.entitymanager.IssueCommentManager; import io.onedev.server.entitymanager.IssueFieldManager; import io.onedev.server.entitymanager.IssueManager; import io.onedev.server.entitymanager.IssueQuerySettingManager; import io.onedev.server.entitymanager.IssueVoteManager; import io.onedev.server.entitymanager.IssueWatchManager; import io.onedev.server.entitymanager.MembershipManager; import io.onedev.server.entitymanager.MilestoneManager; import io.onedev.server.entitymanager.ProjectManager; import io.onedev.server.entitymanager.PullRequestBuildManager; import io.onedev.server.entitymanager.PullRequestChangeManager; import io.onedev.server.entitymanager.PullRequestCommentManager; import io.onedev.server.entitymanager.PullRequestManager; import io.onedev.server.entitymanager.PullRequestQuerySettingManager; import io.onedev.server.entitymanager.PullRequestReviewManager; import io.onedev.server.entitymanager.PullRequestUpdateManager; import io.onedev.server.entitymanager.PullRequestWatchManager; import io.onedev.server.entitymanager.RoleManager; import io.onedev.server.entitymanager.SettingManager; import io.onedev.server.entitymanager.UrlManager; import io.onedev.server.entitymanager.UserAuthorizationManager; import io.onedev.server.entitymanager.UserManager; import io.onedev.server.entitymanager.impl.DefaultBuildDependenceManager; import io.onedev.server.entitymanager.impl.DefaultBuildManager; import io.onedev.server.entitymanager.impl.DefaultBuildParamManager; import io.onedev.server.entitymanager.impl.DefaultBuildQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentRelationManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentReplyManager; import io.onedev.server.entitymanager.impl.DefaultCommitQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultGroupAuthorizationManager; import io.onedev.server.entitymanager.impl.DefaultGroupManager; import io.onedev.server.entitymanager.impl.DefaultIssueChangeManager; import io.onedev.server.entitymanager.impl.DefaultIssueCommentManager; import io.onedev.server.entitymanager.impl.DefaultIssueFieldManager; import io.onedev.server.entitymanager.impl.DefaultIssueManager; import io.onedev.server.entitymanager.impl.DefaultIssueQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultIssueVoteManager; import io.onedev.server.entitymanager.impl.DefaultIssueWatchManager; import io.onedev.server.entitymanager.impl.DefaultMembershipManager; import io.onedev.server.entitymanager.impl.DefaultMilestoneManager; import io.onedev.server.entitymanager.impl.DefaultProjectManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestBuildManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestChangeManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestCommentManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestReviewManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestUpdateManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestWatchManager; import io.onedev.server.entitymanager.impl.DefaultRoleManager; import io.onedev.server.entitymanager.impl.DefaultSettingManager; import io.onedev.server.entitymanager.impl.DefaultUserAuthorizationManager; import io.onedev.server.entitymanager.impl.DefaultUserManager; import io.onedev.server.git.GitFilter; import io.onedev.server.git.GitPostReceiveCallback; import io.onedev.server.git.GitPreReceiveCallback; import io.onedev.server.git.config.GitConfig; import io.onedev.server.infomanager.CodeCommentRelationInfoManager; import io.onedev.server.infomanager.CommitInfoManager; import io.onedev.server.infomanager.DefaultCodeCommentRelationInfoManager; import io.onedev.server.infomanager.DefaultCommitInfoManager; import io.onedev.server.infomanager.DefaultUserInfoManager; import io.onedev.server.infomanager.UserInfoManager; import io.onedev.server.maintenance.ApplyDatabaseConstraints; import io.onedev.server.maintenance.BackupDatabase; import io.onedev.server.maintenance.CheckDataVersion; import io.onedev.server.maintenance.CleanDatabase; import io.onedev.server.maintenance.DataManager; import io.onedev.server.maintenance.DefaultDataManager; import io.onedev.server.maintenance.ResetAdminPassword; import io.onedev.server.maintenance.RestoreDatabase; import io.onedev.server.maintenance.Upgrade; import io.onedev.server.model.support.administration.GroovyScript; import io.onedev.server.model.support.administration.authenticator.Authenticator; import io.onedev.server.model.support.administration.jobexecutor.AutoDiscoveredJobExecutor; import io.onedev.server.model.support.administration.jobexecutor.JobExecutor; import io.onedev.server.notification.BuildNotificationManager; import io.onedev.server.notification.CodeCommentNotificationManager; import io.onedev.server.notification.CommitNotificationManager; import io.onedev.server.notification.DefaultMailManager; import io.onedev.server.notification.IssueNotificationManager; import io.onedev.server.notification.MailManager; import io.onedev.server.notification.PullRequestNotificationManager; import io.onedev.server.notification.WebHookManager; import io.onedev.server.persistence.DefaultIdManager; import io.onedev.server.persistence.DefaultPersistManager; import io.onedev.server.persistence.DefaultSessionManager; import io.onedev.server.persistence.DefaultTransactionManager; import io.onedev.server.persistence.HibernateInterceptor; import io.onedev.server.persistence.IdManager; import io.onedev.server.persistence.PersistListener; import io.onedev.server.persistence.PersistManager; import io.onedev.server.persistence.PrefixedNamingStrategy; import io.onedev.server.persistence.SessionFactoryProvider; import io.onedev.server.persistence.SessionInterceptor; import io.onedev.server.persistence.SessionManager; import io.onedev.server.persistence.SessionProvider; import io.onedev.server.persistence.TransactionInterceptor; import io.onedev.server.persistence.TransactionManager; import io.onedev.server.persistence.annotation.Sessional; import io.onedev.server.persistence.annotation.Transactional; import io.onedev.server.persistence.dao.Dao; import io.onedev.server.persistence.dao.DefaultDao; import io.onedev.server.rest.RestConstants; import io.onedev.server.rest.jersey.DefaultServletContainer; import io.onedev.server.rest.jersey.JerseyConfigurator; import io.onedev.server.rest.jersey.ResourceConfigProvider; import io.onedev.server.search.code.DefaultIndexManager; import io.onedev.server.search.code.DefaultSearchManager; import io.onedev.server.search.code.IndexManager; import io.onedev.server.search.code.SearchManager; import io.onedev.server.security.BasicAuthenticationFilter; import io.onedev.server.security.CodePullAuthorizationSource; import io.onedev.server.security.FilterChainConfigurator; import io.onedev.server.security.OneAuthorizingRealm; import io.onedev.server.security.OneFilterChainResolver; import io.onedev.server.security.OnePasswordService; import io.onedev.server.security.OneRememberMeManager; import io.onedev.server.security.OneWebSecurityManager; import io.onedev.server.storage.AttachmentStorageManager; import io.onedev.server.storage.DefaultAttachmentStorageManager; import io.onedev.server.storage.DefaultStorageManager; import io.onedev.server.storage.StorageManager; import io.onedev.server.util.SecurityUtils; import io.onedev.server.util.jackson.ObjectMapperConfigurator; import io.onedev.server.util.jackson.ObjectMapperProvider; import io.onedev.server.util.jackson.git.GitObjectMapperConfigurator; import io.onedev.server.util.jackson.hibernate.HibernateObjectMapperConfigurator; import io.onedev.server.util.jetty.DefaultJettyRunner; import io.onedev.server.util.jetty.JettyRunner; import io.onedev.server.util.markdown.DefaultMarkdownManager; import io.onedev.server.util.markdown.EntityReferenceManager; import io.onedev.server.util.markdown.MarkdownManager; import io.onedev.server.util.markdown.MarkdownProcessor; import io.onedev.server.util.schedule.DefaultTaskScheduler; import io.onedev.server.util.schedule.TaskScheduler; import io.onedev.server.util.script.ScriptContribution; import io.onedev.server.util.validation.DefaultEntityValidator; import io.onedev.server.util.validation.EntityValidator; import io.onedev.server.util.validation.ValidatorProvider; import io.onedev.server.util.work.BatchWorkManager; import io.onedev.server.util.work.DefaultBatchWorkManager; import io.onedev.server.util.work.DefaultWorkExecutor; import io.onedev.server.util.work.WorkExecutor; import io.onedev.server.util.xstream.CollectionConverter; import io.onedev.server.util.xstream.HibernateProxyConverter; import io.onedev.server.util.xstream.MapConverter; import io.onedev.server.util.xstream.ReflectionConverter; import io.onedev.server.util.xstream.StringConverter; import io.onedev.server.util.xstream.VersionedDocumentConverter; import io.onedev.server.web.DefaultUrlManager; import io.onedev.server.web.DefaultWicketFilter; import io.onedev.server.web.DefaultWicketServlet; import io.onedev.server.web.ExpectedExceptionContribution; import io.onedev.server.web.OneWebApplication; import io.onedev.server.web.ResourcePackScopeContribution; import io.onedev.server.web.WebApplicationConfigurator; import io.onedev.server.web.avatar.AvatarManager; import io.onedev.server.web.avatar.DefaultAvatarManager; import io.onedev.server.web.component.diff.DiffRenderer; import io.onedev.server.web.component.markdown.AttachmentUploadServlet; import io.onedev.server.web.component.markdown.SourcePositionTrackExtension; import io.onedev.server.web.component.markdown.emoji.EmojiExtension; import io.onedev.server.web.component.taskbutton.TaskButton; import io.onedev.server.web.editable.DefaultEditSupportRegistry; import io.onedev.server.web.editable.EditSupport; import io.onedev.server.web.editable.EditSupportLocator; import io.onedev.server.web.editable.EditSupportRegistry; import io.onedev.server.web.mapper.OnePageMapper; import io.onedev.server.web.page.DashboardPage; import io.onedev.server.web.page.base.BasePage; import io.onedev.server.web.page.layout.BuildListTab; import io.onedev.server.web.page.layout.IssueListTab; import io.onedev.server.web.page.layout.MainTab; import io.onedev.server.web.page.layout.ProjectListTab; import io.onedev.server.web.page.layout.PullRequestListTab; import io.onedev.server.web.page.layout.UICustomization; import io.onedev.server.web.page.project.blob.render.BlobRendererContribution; import io.onedev.server.web.page.test.TestPage; import io.onedev.server.web.websocket.BuildEventBroadcaster; import io.onedev.server.web.websocket.CodeCommentEventBroadcaster; import io.onedev.server.web.websocket.CommitIndexedBroadcaster; import io.onedev.server.web.websocket.DefaultWebSocketManager; import io.onedev.server.web.websocket.IssueEventBroadcaster; import io.onedev.server.web.websocket.PullRequestEventBroadcaster; import io.onedev.server.web.websocket.WebSocketManager; import io.onedev.server.web.websocket.WebSocketPolicyProvider;   public class CoreModule extends AbstractPluginModule {  @Override protected void configure() { super.configure();  bind(JettyRunner.class).to(DefaultJettyRunner.class); bind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);  bind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);  bind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {  @Override public ValidatorFactory get() { Configuration<?> configuration = Validation .byDefaultProvider() .configure() .messageInterpolator(new ParameterMessageInterpolator()); return configuration.buildValidatorFactory(); }  }).in(Singleton.class);  bind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);  bind(MarkdownManager.class).to(DefaultMarkdownManager.class);  configurePersistence(); configureRestServices(); configureWeb(); configureBuild();  bind(GitConfig.class).toProvider(GitConfigProvider.class);   bind(StorageManager.class).to(DefaultStorageManager.class); bind(SettingManager.class).to(DefaultSettingManager.class); bind(DataManager.class).to(DefaultDataManager.class); bind(TaskScheduler.class).to(DefaultTaskScheduler.class); bind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class); bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class); bind(PullRequestManager.class).to(DefaultPullRequestManager.class); bind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class); bind(ProjectManager.class).to(DefaultProjectManager.class); bind(UserManager.class).to(DefaultUserManager.class); bind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class); bind(BuildManager.class).to(DefaultBuildManager.class); bind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class); bind(JobManager.class).to(DefaultJobManager.class); bind(LogManager.class).to(DefaultLogManager.class); bind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class); bind(MailManager.class).to(DefaultMailManager.class); bind(IssueManager.class).to(DefaultIssueManager.class); bind(IssueFieldManager.class).to(DefaultIssueFieldManager.class); bind(BuildParamManager.class).to(DefaultBuildParamManager.class); bind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class); bind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class); bind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class); bind(RoleManager.class).to(DefaultRoleManager.class); bind(CommitInfoManager.class).to(DefaultCommitInfoManager.class); bind(UserInfoManager.class).to(DefaultUserInfoManager.class); bind(BatchWorkManager.class).to(DefaultBatchWorkManager.class); bind(GroupManager.class).to(DefaultGroupManager.class); bind(MembershipManager.class).to(DefaultMembershipManager.class); bind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class); bind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class); bind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class); bind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class); bind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class); bind(WorkExecutor.class).to(DefaultWorkExecutor.class); bind(PullRequestNotificationManager.class); bind(CommitNotificationManager.class); bind(BuildNotificationManager.class); bind(IssueNotificationManager.class); bind(EntityReferenceManager.class); bind(CodeCommentNotificationManager.class); bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class); bind(IssueWatchManager.class).to(DefaultIssueWatchManager.class); bind(IssueChangeManager.class).to(DefaultIssueChangeManager.class); bind(IssueVoteManager.class).to(DefaultIssueVoteManager.class); bind(MilestoneManager.class).to(DefaultMilestoneManager.class); bind(Session.class).toProvider(SessionProvider.class); bind(EntityManager.class).toProvider(SessionProvider.class); bind(SessionFactory.class).toProvider(SessionFactoryProvider.class); bind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class); bind(IssueCommentManager.class).to(DefaultIssueCommentManager.class); bind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class); bind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class); bind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class); bind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class); bind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class); bind(WebHookManager.class);  contribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);     contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);      bind(Realm.class).to(OneAuthorizingRealm.class); bind(RememberMeManager.class).to(OneRememberMeManager.class); bind(WebSecurityManager.class).to(OneWebSecurityManager.class); bind(FilterChainResolver.class).to(OneFilterChainResolver.class); bind(BasicAuthenticationFilter.class); bind(PasswordService.class).to(OnePasswordService.class); bind(ShiroFilter.class); install(new ShiroAopModule());         contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {              @Override             public void configure(FilterChainManager filterChainManager) {                 filterChainManager.createChain(\"info/refs\", \"noSessionCreation, authcBasic\");                 filterChainManager.createChain(\"git-upload-pack\", \"noSessionCreation, authcBasic\");                 filterChainManager.createChain(\"git-receive-pack\", \"noSessionCreation, authcBasic\");             }                      });         contributeFromPackage(Authenticator.class, Authenticator.class);          contribute(ImplementationProvider.class, new ImplementationProvider() {  @Override public Class<?> getAbstractClass() { return JobExecutor.class; }  @Override public Collection<Class<?>> getImplementations() { return Sets.newHashSet(AutoDiscoveredJobExecutor.class); }  });  contribute(CodePullAuthorizationSource.class, DefaultJobManager.class);          bind(IndexManager.class).to(DefaultIndexManager.class); bind(SearchManager.class).to(DefaultSearchManager.class);  bind(EntityValidator.class).to(DefaultEntityValidator.class);  bind(GitFilter.class); bind(GitPreReceiveCallback.class); bind(GitPostReceiveCallback.class);      bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {  @Override public ExecutorService get() {         return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,          new SynchronousQueue<Runnable>()) {  @Override public void execute(Runnable command) { try { super.execute(SecurityUtils.inheritSubject(command)); } catch (RejectedExecutionException e) { if (!isShutdown()) throw ExceptionUtils.unchecked(e); } }          }; }          }).in(Singleton.class);          bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {  @Override public ForkJoinTask<?> submit(Runnable task) { return super.submit(SecurityUtils.inheritSubject(task)); }  @Override public void execute(Runnable task) { super.execute(SecurityUtils.inheritSubject(task)); }  @Override public <T> ForkJoinTask<T> submit(Callable<T> task) { return super.submit(SecurityUtils.inheritSubject(task)); }  @Override public <T> ForkJoinTask<T> submit(Runnable task, T result) { return super.submit(SecurityUtils.inheritSubject(task), result); }  @Override public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException { return super.invokeAny(SecurityUtils.inheritSubject(tasks)); }  @Override public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { return super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit); }  @Override public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,  long timeout, TimeUnit unit) throws InterruptedException { return super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit); }  @Override public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) { return super.invokeAll(SecurityUtils.inheritSubject(tasks)); }      }); }  private void configureRestServices() { bind(ResourceConfig.class).toProvider(ResourceConfigProvider.class).in(Singleton.class); bind(ServletContainer.class).to(DefaultServletContainer.class);  contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {  @Override public void configure(FilterChainManager filterChainManager) { filterChainManager.createChain(\"/rest/**\", \"noSessionCreation, authcBasic\"); }  });  contribute(JerseyConfigurator.class, new JerseyConfigurator() {  @Override public void configure(ResourceConfig resourceConfig) { resourceConfig.packages(RestConstants.class.getPackage().getName()); }  }); }  private void configureWeb() { bind(WicketServlet.class).to(DefaultWicketServlet.class); bind(WicketFilter.class).to(DefaultWicketFilter.class); bind(WebSocketPolicy.class).toProvider(WebSocketPolicyProvider.class); bind(EditSupportRegistry.class).to(DefaultEditSupportRegistry.class); bind(WebSocketManager.class).to(DefaultWebSocketManager.class);  bind(AttachmentUploadServlet.class);  contributeFromPackage(EditSupport.class, EditSupport.class);  bind(WebApplication.class).to(OneWebApplication.class); bind(Application.class).to(OneWebApplication.class); bind(AvatarManager.class).to(DefaultAvatarManager.class); bind(WebSocketManager.class).to(DefaultWebSocketManager.class);  contributeFromPackage(EditSupport.class, EditSupportLocator.class);  contribute(WebApplicationConfigurator.class, new WebApplicationConfigurator() {  @Override public void configure(WebApplication application) { application.mount(new OnePageMapper(\"/test\", TestPage.class)); }  });  bind(CommitIndexedBroadcaster.class);  contributeFromPackage(DiffRenderer.class, DiffRenderer.class); contributeFromPackage(BlobRendererContribution.class, BlobRendererContribution.class);  contribute(Extension.class, new EmojiExtension()); contribute(Extension.class, new SourcePositionTrackExtension());  contributeFromPackage(MarkdownProcessor.class, MarkdownProcessor.class);  contribute(ResourcePackScopeContribution.class, new ResourcePackScopeContribution() {  @Override public Collection<Class<?>> getResourcePackScopes() { return Lists.newArrayList(OneWebApplication.class); }  }); contribute(ExpectedExceptionContribution.class, new ExpectedExceptionContribution() {  @SuppressWarnings(\"unchecked\") @Override public Collection<Class<? extends Exception>> getExpectedExceptionClasses() { return Sets.newHashSet(ConstraintViolationException.class, EntityNotFoundException.class,  ObjectNotFoundException.class, StaleStateException.class, UnauthorizedException.class,  OneException.class, PageExpiredException.class, StalePageException.class); }  });  bind(UrlManager.class).to(DefaultUrlManager.class); bind(CodeCommentEventBroadcaster.class); bind(PullRequestEventBroadcaster.class); bind(IssueEventBroadcaster.class); bind(BuildEventBroadcaster.class);  bind(TaskButton.TaskFutureManager.class);  bind(UICustomization.class).toInstance(new UICustomization() {  @Override public Class<? extends BasePage> getHomePage() { return DashboardPage.class; }  @Override public List<MainTab> getMainTabs() { return Lists.newArrayList( new ProjectListTab(), new IssueListTab(),  new PullRequestListTab(), new BuildListTab()); }  ", "nl": "  import java.io.Serializable; import java.lang.reflect.AnnotatedElement; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; import java.util.concurrent.Future; import java.util.concurrent.RejectedExecutionException; import java.util.concurrent.SynchronousQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException;  import javax.inject.Singleton; import javax.persistence.EntityManager; import javax.persistence.EntityManagerFactory; import javax.persistence.EntityNotFoundException; import javax.persistence.OneToMany; import javax.persistence.Transient; import javax.persistence.Version; import javax.validation.Configuration; import javax.validation.Validation; import javax.validation.Validator; import javax.validation.ValidatorFactory;  import org.apache.shiro.authc.credential.PasswordService; import org.apache.shiro.authz.UnauthorizedException; import org.apache.shiro.guice.aop.ShiroAopModule; import org.apache.shiro.mgt.RememberMeManager; import org.apache.shiro.realm.Realm; import org.apache.shiro.web.filter.mgt.FilterChainManager; import org.apache.shiro.web.filter.mgt.FilterChainResolver; import org.apache.shiro.web.mgt.WebSecurityManager; import org.apache.shiro.web.servlet.ShiroFilter; import org.apache.wicket.Application; import org.apache.wicket.core.request.mapper.StalePageException; import org.apache.wicket.protocol.http.PageExpiredException; import org.apache.wicket.protocol.http.WebApplication; import org.apache.wicket.protocol.http.WicketFilter; import org.apache.wicket.protocol.http.WicketServlet; import org.eclipse.jetty.servlet.ServletContextHandler; import org.eclipse.jetty.websocket.api.WebSocketPolicy; import org.glassfish.jersey.server.ResourceConfig; import org.glassfish.jersey.servlet.ServletContainer; import org.hibernate.CallbackException; import org.hibernate.Interceptor; import org.hibernate.ObjectNotFoundException; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.StaleStateException; import org.hibernate.boot.model.naming.PhysicalNamingStrategy; import org.hibernate.collection.internal.PersistentBag; import org.hibernate.exception.ConstraintViolationException; import org.hibernate.type.Type;  import com.fasterxml.jackson.databind.ObjectMapper; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.inject.Provider; import com.google.inject.matcher.AbstractMatcher; import com.google.inject.matcher.Matchers; import com.thoughtworks.xstream.XStream; import com.thoughtworks.xstream.annotations.XStreamOmitField; import com.thoughtworks.xstream.converters.basic.NullConverter; import com.thoughtworks.xstream.converters.extended.ISO8601DateConverter; import com.thoughtworks.xstream.converters.extended.ISO8601SqlTimestampConverter; import com.thoughtworks.xstream.converters.reflection.ReflectionProvider; import com.thoughtworks.xstream.core.JVM; import com.thoughtworks.xstream.mapper.MapperWrapper; import com.vladsch.flexmark.Extension;  import io.onedev.commons.launcher.bootstrap.Bootstrap; import io.onedev.commons.launcher.loader.AbstractPlugin; import io.onedev.commons.launcher.loader.AbstractPluginModule; import io.onedev.commons.launcher.loader.ImplementationProvider; import io.onedev.commons.utils.ExceptionUtils; import io.onedev.commons.utils.StringUtils; import io.onedev.server.buildspec.job.DefaultJobManager; import io.onedev.server.buildspec.job.JobManager; import io.onedev.server.buildspec.job.log.DefaultLogManager; import io.onedev.server.buildspec.job.log.LogManager; import io.onedev.server.buildspec.job.log.instruction.LogInstruction; import io.onedev.server.entitymanager.BuildDependenceManager; import io.onedev.server.entitymanager.BuildManager; import io.onedev.server.entitymanager.BuildParamManager; import io.onedev.server.entitymanager.BuildQuerySettingManager; import io.onedev.server.entitymanager.CodeCommentManager; import io.onedev.server.entitymanager.CodeCommentQuerySettingManager; import io.onedev.server.entitymanager.CodeCommentRelationManager; import io.onedev.server.entitymanager.CodeCommentReplyManager; import io.onedev.server.entitymanager.CommitQuerySettingManager; import io.onedev.server.entitymanager.GroupAuthorizationManager; import io.onedev.server.entitymanager.GroupManager; import io.onedev.server.entitymanager.IssueChangeManager; import io.onedev.server.entitymanager.IssueCommentManager; import io.onedev.server.entitymanager.IssueFieldManager; import io.onedev.server.entitymanager.IssueManager; import io.onedev.server.entitymanager.IssueQuerySettingManager; import io.onedev.server.entitymanager.IssueVoteManager; import io.onedev.server.entitymanager.IssueWatchManager; import io.onedev.server.entitymanager.MembershipManager; import io.onedev.server.entitymanager.MilestoneManager; import io.onedev.server.entitymanager.ProjectManager; import io.onedev.server.entitymanager.PullRequestBuildManager; import io.onedev.server.entitymanager.PullRequestChangeManager; import io.onedev.server.entitymanager.PullRequestCommentManager; import io.onedev.server.entitymanager.PullRequestManager; import io.onedev.server.entitymanager.PullRequestQuerySettingManager; import io.onedev.server.entitymanager.PullRequestReviewManager; import io.onedev.server.entitymanager.PullRequestUpdateManager; import io.onedev.server.entitymanager.PullRequestWatchManager; import io.onedev.server.entitymanager.RoleManager; import io.onedev.server.entitymanager.SettingManager; import io.onedev.server.entitymanager.UrlManager; import io.onedev.server.entitymanager.UserAuthorizationManager; import io.onedev.server.entitymanager.UserManager; import io.onedev.server.entitymanager.impl.DefaultBuildDependenceManager; import io.onedev.server.entitymanager.impl.DefaultBuildManager; import io.onedev.server.entitymanager.impl.DefaultBuildParamManager; import io.onedev.server.entitymanager.impl.DefaultBuildQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentRelationManager; import io.onedev.server.entitymanager.impl.DefaultCodeCommentReplyManager; import io.onedev.server.entitymanager.impl.DefaultCommitQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultGroupAuthorizationManager; import io.onedev.server.entitymanager.impl.DefaultGroupManager; import io.onedev.server.entitymanager.impl.DefaultIssueChangeManager; import io.onedev.server.entitymanager.impl.DefaultIssueCommentManager; import io.onedev.server.entitymanager.impl.DefaultIssueFieldManager; import io.onedev.server.entitymanager.impl.DefaultIssueManager; import io.onedev.server.entitymanager.impl.DefaultIssueQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultIssueVoteManager; import io.onedev.server.entitymanager.impl.DefaultIssueWatchManager; import io.onedev.server.entitymanager.impl.DefaultMembershipManager; import io.onedev.server.entitymanager.impl.DefaultMilestoneManager; import io.onedev.server.entitymanager.impl.DefaultProjectManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestBuildManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestChangeManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestCommentManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestQuerySettingManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestReviewManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestUpdateManager; import io.onedev.server.entitymanager.impl.DefaultPullRequestWatchManager; import io.onedev.server.entitymanager.impl.DefaultRoleManager; import io.onedev.server.entitymanager.impl.DefaultSettingManager; import io.onedev.server.entitymanager.impl.DefaultUserAuthorizationManager; import io.onedev.server.entitymanager.impl.DefaultUserManager; import io.onedev.server.git.GitFilter; import io.onedev.server.git.GitPostReceiveCallback; import io.onedev.server.git.GitPreReceiveCallback; import io.onedev.server.git.config.GitConfig; import io.onedev.server.infomanager.CodeCommentRelationInfoManager; import io.onedev.server.infomanager.CommitInfoManager; import io.onedev.server.infomanager.DefaultCodeCommentRelationInfoManager; import io.onedev.server.infomanager.DefaultCommitInfoManager; import io.onedev.server.infomanager.DefaultUserInfoManager; import io.onedev.server.infomanager.UserInfoManager; import io.onedev.server.maintenance.ApplyDatabaseConstraints; import io.onedev.server.maintenance.BackupDatabase; import io.onedev.server.maintenance.CheckDataVersion; import io.onedev.server.maintenance.CleanDatabase; import io.onedev.server.maintenance.DataManager; import io.onedev.server.maintenance.DefaultDataManager; import io.onedev.server.maintenance.ResetAdminPassword; import io.onedev.server.maintenance.RestoreDatabase; import io.onedev.server.maintenance.Upgrade; import io.onedev.server.model.support.administration.GroovyScript; import io.onedev.server.model.support.administration.authenticator.Authenticator; import io.onedev.server.model.support.administration.jobexecutor.AutoDiscoveredJobExecutor; import io.onedev.server.model.support.administration.jobexecutor.JobExecutor; import io.onedev.server.notification.BuildNotificationManager; import io.onedev.server.notification.CodeCommentNotificationManager; import io.onedev.server.notification.CommitNotificationManager; import io.onedev.server.notification.DefaultMailManager; import io.onedev.server.notification.IssueNotificationManager; import io.onedev.server.notification.MailManager; import io.onedev.server.notification.PullRequestNotificationManager; import io.onedev.server.notification.WebHookManager; import io.onedev.server.persistence.DefaultIdManager; import io.onedev.server.persistence.DefaultPersistManager; import io.onedev.server.persistence.DefaultSessionManager; import io.onedev.server.persistence.DefaultTransactionManager; import io.onedev.server.persistence.HibernateInterceptor; import io.onedev.server.persistence.IdManager; import io.onedev.server.persistence.PersistListener; import io.onedev.server.persistence.PersistManager; import io.onedev.server.persistence.PrefixedNamingStrategy; import io.onedev.server.persistence.SessionFactoryProvider; import io.onedev.server.persistence.SessionInterceptor; import io.onedev.server.persistence.SessionManager; import io.onedev.server.persistence.SessionProvider; import io.onedev.server.persistence.TransactionInterceptor; import io.onedev.server.persistence.TransactionManager; import io.onedev.server.persistence.annotation.Sessional; import io.onedev.server.persistence.annotation.Transactional; import io.onedev.server.persistence.dao.Dao; import io.onedev.server.persistence.dao.DefaultDao; import io.onedev.server.rest.RestConstants; import io.onedev.server.rest.jersey.DefaultServletContainer; import io.onedev.server.rest.jersey.JerseyConfigurator; import io.onedev.server.rest.jersey.ResourceConfigProvider; import io.onedev.server.search.code.DefaultIndexManager; import io.onedev.server.search.code.DefaultSearchManager; import io.onedev.server.search.code.IndexManager; import io.onedev.server.search.code.SearchManager; import io.onedev.server.security.BasicAuthenticationFilter; import io.onedev.server.security.CodePullAuthorizationSource; import io.onedev.server.security.FilterChainConfigurator; import io.onedev.server.security.OneAuthorizingRealm; import io.onedev.server.security.OneFilterChainResolver; import io.onedev.server.security.OnePasswordService; import io.onedev.server.security.OneRememberMeManager; import io.onedev.server.security.OneWebSecurityManager; import io.onedev.server.storage.AttachmentStorageManager; import io.onedev.server.storage.DefaultAttachmentStorageManager; import io.onedev.server.storage.DefaultStorageManager; import io.onedev.server.storage.StorageManager; import io.onedev.server.util.SecurityUtils; import io.onedev.server.util.jackson.ObjectMapperConfigurator; import io.onedev.server.util.jackson.ObjectMapperProvider; import io.onedev.server.util.jackson.git.GitObjectMapperConfigurator; import io.onedev.server.util.jackson.hibernate.HibernateObjectMapperConfigurator; import io.onedev.server.util.jetty.DefaultJettyRunner; import io.onedev.server.util.jetty.JettyRunner; import io.onedev.server.util.markdown.DefaultMarkdownManager; import io.onedev.server.util.markdown.EntityReferenceManager; import io.onedev.server.util.markdown.MarkdownManager; import io.onedev.server.util.markdown.MarkdownProcessor; import io.onedev.server.util.schedule.DefaultTaskScheduler; import io.onedev.server.util.schedule.TaskScheduler; import io.onedev.server.util.script.ScriptContribution; import io.onedev.server.util.validation.DefaultEntityValidator; import io.onedev.server.util.validation.EntityValidator; import io.onedev.server.util.validation.ValidatorProvider; import io.onedev.server.util.work.BatchWorkManager; import io.onedev.server.util.work.DefaultBatchWorkManager; import io.onedev.server.util.work.DefaultWorkExecutor; import io.onedev.server.util.work.WorkExecutor; import io.onedev.server.util.xstream.CollectionConverter; import io.onedev.server.util.xstream.HibernateProxyConverter; import io.onedev.server.util.xstream.MapConverter; import io.onedev.server.util.xstream.ReflectionConverter; import io.onedev.server.util.xstream.StringConverter; import io.onedev.server.util.xstream.VersionedDocumentConverter; import io.onedev.server.web.DefaultUrlManager; import io.onedev.server.web.DefaultWicketFilter; import io.onedev.server.web.DefaultWicketServlet; import io.onedev.server.web.ExpectedExceptionContribution; import io.onedev.server.web.OneWebApplication; import io.onedev.server.web.ResourcePackScopeContribution; import io.onedev.server.web.WebApplicationConfigurator; import io.onedev.server.web.avatar.AvatarManager; import io.onedev.server.web.avatar.DefaultAvatarManager; import io.onedev.server.web.component.diff.DiffRenderer; import io.onedev.server.web.component.markdown.AttachmentUploadServlet; import io.onedev.server.web.component.markdown.SourcePositionTrackExtension; import io.onedev.server.web.component.markdown.emoji.EmojiExtension; import io.onedev.server.web.component.taskbutton.TaskButton; import io.onedev.server.web.editable.DefaultEditSupportRegistry; import io.onedev.server.web.editable.EditSupport; import io.onedev.server.web.editable.EditSupportLocator; import io.onedev.server.web.editable.EditSupportRegistry; import io.onedev.server.web.mapper.OnePageMapper; import io.onedev.server.web.page.DashboardPage; import io.onedev.server.web.page.base.BasePage; import io.onedev.server.web.page.layout.BuildListTab; import io.onedev.server.web.page.layout.IssueListTab; import io.onedev.server.web.page.layout.MainTab; import io.onedev.server.web.page.layout.ProjectListTab; import io.onedev.server.web.page.layout.PullRequestListTab; import io.onedev.server.web.page.layout.UICustomization; import io.onedev.server.web.page.project.blob.render.BlobRendererContribution; import io.onedev.server.web.page.test.TestPage; import io.onedev.server.web.websocket.BuildEventBroadcaster; import io.onedev.server.web.websocket.CodeCommentEventBroadcaster; import io.onedev.server.web.websocket.CommitIndexedBroadcaster; import io.onedev.server.web.websocket.DefaultWebSocketManager; import io.onedev.server.web.websocket.IssueEventBroadcaster; import io.onedev.server.web.websocket.PullRequestEventBroadcaster; import io.onedev.server.web.websocket.WebSocketManager; import io.onedev.server.web.websocket.WebSocketPolicyProvider;   public class CoreModule extends AbstractPluginModule {  @Override protected void configure() { super.configure();  bind(JettyRunner.class).to(DefaultJettyRunner.class); bind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);  bind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);  bind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {  @Override public ValidatorFactory get() { Configuration<?> configuration = Validation.byDefaultProvider().configure(); return configuration.buildValidatorFactory(); }  }).in(Singleton.class);  bind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);  bind(MarkdownManager.class).to(DefaultMarkdownManager.class);  configurePersistence(); configureRestServices(); configureWeb(); configureBuild();  bind(GitConfig.class).toProvider(GitConfigProvider.class);   bind(StorageManager.class).to(DefaultStorageManager.class); bind(SettingManager.class).to(DefaultSettingManager.class); bind(DataManager.class).to(DefaultDataManager.class); bind(TaskScheduler.class).to(DefaultTaskScheduler.class); bind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class); bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class); bind(PullRequestManager.class).to(DefaultPullRequestManager.class); bind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class); bind(ProjectManager.class).to(DefaultProjectManager.class); bind(UserManager.class).to(DefaultUserManager.class); bind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class); bind(BuildManager.class).to(DefaultBuildManager.class); bind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class); bind(JobManager.class).to(DefaultJobManager.class); bind(LogManager.class).to(DefaultLogManager.class); bind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class); bind(MailManager.class).to(DefaultMailManager.class); bind(IssueManager.class).to(DefaultIssueManager.class); bind(IssueFieldManager.class).to(DefaultIssueFieldManager.class); bind(BuildParamManager.class).to(DefaultBuildParamManager.class); bind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class); bind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class); bind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class); bind(RoleManager.class).to(DefaultRoleManager.class); bind(CommitInfoManager.class).to(DefaultCommitInfoManager.class); bind(UserInfoManager.class).to(DefaultUserInfoManager.class); bind(BatchWorkManager.class).to(DefaultBatchWorkManager.class); bind(GroupManager.class).to(DefaultGroupManager.class); bind(MembershipManager.class).to(DefaultMembershipManager.class); bind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class); bind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class); bind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class); bind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class); bind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class); bind(WorkExecutor.class).to(DefaultWorkExecutor.class); bind(PullRequestNotificationManager.class); bind(CommitNotificationManager.class); bind(BuildNotificationManager.class); bind(IssueNotificationManager.class); bind(EntityReferenceManager.class); bind(CodeCommentNotificationManager.class); bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class); bind(IssueWatchManager.class).to(DefaultIssueWatchManager.class); bind(IssueChangeManager.class).to(DefaultIssueChangeManager.class); bind(IssueVoteManager.class).to(DefaultIssueVoteManager.class); bind(MilestoneManager.class).to(DefaultMilestoneManager.class); bind(Session.class).toProvider(SessionProvider.class); bind(EntityManager.class).toProvider(SessionProvider.class); bind(SessionFactory.class).toProvider(SessionFactoryProvider.class); bind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class); bind(IssueCommentManager.class).to(DefaultIssueCommentManager.class); bind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class); bind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class); bind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class); bind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class); bind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class); bind(WebHookManager.class);  contribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);     contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);      bind(Realm.class).to(OneAuthorizingRealm.class); bind(RememberMeManager.class).to(OneRememberMeManager.class); bind(WebSecurityManager.class).to(OneWebSecurityManager.class); bind(FilterChainResolver.class).to(OneFilterChainResolver.class); bind(BasicAuthenticationFilter.class); bind(PasswordService.class).to(OnePasswordService.class); bind(ShiroFilter.class); install(new ShiroAopModule());         contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {              @Override             public void configure(FilterChainManager filterChainManager) {                 filterChainManager.createChain(\"info/refs\", \"noSessionCreation, authcBasic\");                 filterChainManager.createChain(\"git-upload-pack\", \"noSessionCreation, authcBasic\");                 filterChainManager.createChain(\"git-receive-pack\", \"noSessionCreation, authcBasic\");             }                      });         contributeFromPackage(Authenticator.class, Authenticator.class);          contribute(ImplementationProvider.class, new ImplementationProvider() {  @Override public Class<?> getAbstractClass() { return JobExecutor.class; }  @Override public Collection<Class<?>> getImplementations() { return Sets.newHashSet(AutoDiscoveredJobExecutor.class); }  });  contribute(CodePullAuthorizationSource.class, DefaultJobManager.class);          bind(IndexManager.class).to(DefaultIndexManager.class); bind(SearchManager.class).to(DefaultSearchManager.class);  bind(EntityValidator.class).to(DefaultEntityValidator.class);  bind(GitFilter.class); bind(GitPreReceiveCallback.class); bind(GitPostReceiveCallback.class);      bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {  @Override public ExecutorService get() {         return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,          new SynchronousQueue<Runnable>()) {  @Override public void execute(Runnable command) { try { super.execute(SecurityUtils.inheritSubject(command)); } catch (RejectedExecutionException e) { if (!isShutdown()) throw ExceptionUtils.unchecked(e); } }          }; }          }).in(Singleton.class);          bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {  @Override public ForkJoinTask<?> submit(Runnable task) { return super.submit(SecurityUtils.inheritSubject(task)); }  @Override public void execute(Runnable task) { super.execute(SecurityUtils.inheritSubject(task)); }  @Override public <T> ForkJoinTask<T> submit(Callable<T> task) { return super.submit(SecurityUtils.inheritSubject(task)); }  @Override public <T> ForkJoinTask<T> submit(Runnable task, T result) { return super.submit(SecurityUtils.inheritSubject(task), result); }  @Override public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException { return super.invokeAny(SecurityUtils.inheritSubject(tasks)); }  @Override public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { return super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit); }  @Override public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,  long timeout, TimeUnit unit) throws InterruptedException { return super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit); }  @Override public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) { return super.invokeAll(SecurityUtils.inheritSubject(tasks)); }      }); }  private void configureRestServices() { bind(ResourceConfig.class).toProvider(ResourceConfigProvider.class).in(Singleton.class); bind(ServletContainer.class).to(DefaultServletContainer.class);  contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {  @Override public void configure(FilterChainManager filterChainManager) { filterChainManager.createChain(\"/rest/**\", \"noSessionCreation, authcBasic\"); }  });  contribute(JerseyConfigurator.class, new JerseyConfigurator() {  @Override public void configure(ResourceConfig resourceConfig) { resourceConfig.packages(RestConstants.class.getPackage().getName()); }  }); }  private void configureWeb() { bind(WicketServlet.class).to(DefaultWicketServlet.class); bind(WicketFilter.class).to(DefaultWicketFilter.class); bind(WebSocketPolicy.class).toProvider(WebSocketPolicyProvider.class); bind(EditSupportRegistry.class).to(DefaultEditSupportRegistry.class); bind(WebSocketManager.class).to(DefaultWebSocketManager.class);  bind(AttachmentUploadServlet.class);  contributeFromPackage(EditSupport.class, EditSupport.class);  bind(WebApplication.class).to(OneWebApplication.class); bind(Application.class).to(OneWebApplication.class); bind(AvatarManager.class).to(DefaultAvatarManager.class); bind(WebSocketManager.class).to(DefaultWebSocketManager.class);  contributeFromPackage(EditSupport.class, EditSupportLocator.class);  contribute(WebApplicationConfigurator.class, new WebApplicationConfigurator() {  @Override public void configure(WebApplication application) { application.mount(new OnePageMapper(\"/test\", TestPage.class)); }  });  bind(CommitIndexedBroadcaster.class);  contributeFromPackage(DiffRenderer.class, DiffRenderer.class); contributeFromPackage(BlobRendererContribution.class, BlobRendererContribution.class);  contribute(Extension.class, new EmojiExtension()); contribute(Extension.class, new SourcePositionTrackExtension());  contributeFromPackage(MarkdownProcessor.class, MarkdownProcessor.class);  contribute(ResourcePackScopeContribution.class, new ResourcePackScopeContribution() {  @Override public Collection<Class<?>> getResourcePackScopes() { return Lists.newArrayList(OneWebApplication.class); }  }); contribute(ExpectedExceptionContribution.class, new ExpectedExceptionContribution() {  @SuppressWarnings(\"unchecked\") @Override public Collection<Class<? extends Exception>> getExpectedExceptionClasses() { return Sets.newHashSet(ConstraintViolationException.class, EntityNotFoundException.class,  ObjectNotFoundException.class, StaleStateException.class, UnauthorizedException.class,  OneException.class, PageExpiredException.class, StalePageException.class); }  });  bind(UrlManager.class).to(DefaultUrlManager.class); bind(CodeCommentEventBroadcaster.class); bind(PullRequestEventBroadcaster.class); bind(IssueEventBroadcaster.class); bind(BuildEventBroadcaster.class);  bind(TaskButton.TaskFutureManager.class);  bind(UICustomization.class).toInstance(new UICustomization() {  @Override public Class<? extends BasePage> getHomePage() { return DashboardPage.class; }  @Override public List<MainTab> getMainTabs() { return Lists.newArrayList( new ProjectListTab(), new IssueListTab(),  new PullRequestListTab(), new BuildListTab()); }  }); }  private void configureBuild() { contribute(ScriptContribution.class, new ScriptContribution() {  @Override public Groov"}
{"code": "import java.io.Serializable;import java.lang.reflect.AnnotatedElement;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Collection;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.Future;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;import javax.inject.Singleton;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityNotFoundException;import javax.persistence.OneToMany;import javax.persistence.Transient;import javax.persistence.Version;import javax.validation.Configuration;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.ValidatorFactory;import org.apache.shiro.authc.credential.PasswordService;import org.apache.shiro.authz.UnauthorizedException;import org.apache.shiro.guice.aop.ShiroAopModule;import org.apache.shiro.mgt.RememberMeManager;import org.apache.shiro.realm.Realm;import org.apache.shiro.web.filter.mgt.FilterChainManager;import org.apache.shiro.web.filter.mgt.FilterChainResolver;import org.apache.shiro.web.mgt.WebSecurityManager;import org.apache.shiro.web.servlet.ShiroFilter;import org.apache.sshd.common.keyprovider.KeyPairProvider;import org.apache.wicket.Application;import org.apache.wicket.core.request.mapper.StalePageException;import org.apache.wicket.protocol.http.PageExpiredException;import org.apache.wicket.protocol.http.WicketFilter;import org.apache.wicket.protocol.http.WicketServlet;import org.eclipse.jetty.servlet.ServletContextHandler;import org.eclipse.jetty.websocket.api.WebSocketPolicy;import org.glassfish.jersey.server.ResourceConfig;import org.glassfish.jersey.servlet.ServletContainer;import org.hibernate.CallbackException;import org.hibernate.Interceptor;import org.hibernate.ObjectNotFoundException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.StaleStateException;import org.hibernate.boot.model.naming.PhysicalNamingStrategy;import org.hibernate.collection.internal.PersistentBag;import org.hibernate.exception.ConstraintViolationException;import org.hibernate.type.Type;import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Lists;import com.google.common.collect.Sets;import com.google.inject.Provider;import com.google.inject.matcher.AbstractMatcher;import com.google.inject.matcher.Matchers;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.annotations.XStreamOmitField;import com.thoughtworks.xstream.converters.basic.NullConverter;import com.thoughtworks.xstream.converters.extended.ISO8601DateConverter;import com.thoughtworks.xstream.converters.extended.ISO8601SqlTimestampConverter;import com.thoughtworks.xstream.converters.reflection.ReflectionProvider;import com.thoughtworks.xstream.core.JVM;import com.thoughtworks.xstream.mapper.MapperWrapper;import com.vladsch.flexmark.Extension;import io.onedev.commons.launcher.bootstrap.Bootstrap;import io.onedev.commons.launcher.loader.AbstractPlugin;import io.onedev.commons.launcher.loader.AbstractPluginModule;import io.onedev.commons.launcher.loader.ImplementationProvider;import io.onedev.commons.utils.ExceptionUtils;import io.onedev.commons.utils.StringUtils;import io.onedev.server.buildspec.job.DefaultJobManager;import io.onedev.server.buildspec.job.JobManager;import io.onedev.server.buildspec.job.log.DefaultLogManager;import io.onedev.server.buildspec.job.log.LogManager;import io.onedev.server.buildspec.job.log.instruction.LogInstruction;import io.onedev.server.entitymanager.BuildDependenceManager;import io.onedev.server.entitymanager.BuildManager;import io.onedev.server.entitymanager.BuildParamManager;import io.onedev.server.entitymanager.BuildQuerySettingManager;import io.onedev.server.entitymanager.CodeCommentManager;import io.onedev.server.entitymanager.CodeCommentQuerySettingManager;import io.onedev.server.entitymanager.CodeCommentReplyManager;import io.onedev.server.entitymanager.CommitQuerySettingManager;import io.onedev.server.entitymanager.GroupAuthorizationManager;import io.onedev.server.entitymanager.GroupManager;import io.onedev.server.entitymanager.IssueChangeManager;import io.onedev.server.entitymanager.IssueCommentManager;import io.onedev.server.entitymanager.IssueFieldManager;import io.onedev.server.entitymanager.IssueManager;import io.onedev.server.entitymanager.IssueQuerySettingManager;import io.onedev.server.entitymanager.IssueVoteManager;import io.onedev.server.entitymanager.IssueWatchManager;import io.onedev.server.entitymanager.MembershipManager;import io.onedev.server.entitymanager.MilestoneManager;import io.onedev.server.entitymanager.ProjectManager;import io.onedev.server.entitymanager.PullRequestAssignmentManager;import io.onedev.server.entitymanager.PullRequestChangeManager;import io.onedev.server.entitymanager.PullRequestCommentManager;import io.onedev.server.entitymanager.PullRequestManager;import io.onedev.server.entitymanager.PullRequestQuerySettingManager;import io.onedev.server.entitymanager.PullRequestReviewManager;import io.onedev.server.entitymanager.PullRequestUpdateManager;import io.onedev.server.entitymanager.PullRequestVerificationManager;import io.onedev.server.entitymanager.PullRequestWatchManager;import io.onedev.server.entitymanager.RoleManager;import io.onedev.server.entitymanager.SettingManager;import io.onedev.server.entitymanager.SshKeyManager;import io.onedev.server.entitymanager.UrlManager;import io.onedev.server.entitymanager.UserAuthorizationManager;import io.onedev.server.entitymanager.UserManager;import io.onedev.server.entitymanager.impl.DefaultBuildDependenceManager;import io.onedev.server.entitymanager.impl.DefaultBuildManager;import io.onedev.server.entitymanager.impl.DefaultBuildParamManager;import io.onedev.server.entitymanager.impl.DefaultBuildQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultCodeCommentManager;import io.onedev.server.entitymanager.impl.DefaultCodeCommentQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultCodeCommentReplyManager;import io.onedev.server.entitymanager.impl.DefaultCommitQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultGroupAuthorizationManager;import io.onedev.server.entitymanager.impl.DefaultGroupManager;import io.onedev.server.entitymanager.impl.DefaultIssueChangeManager;import io.onedev.server.entitymanager.impl.DefaultIssueCommentManager;import io.onedev.server.entitymanager.impl.DefaultIssueFieldManager;import io.onedev.server.entitymanager.impl.DefaultIssueManager;import io.onedev.server.entitymanager.impl.DefaultIssueQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultIssueVoteManager;import io.onedev.server.entitymanager.impl.DefaultIssueWatchManager;import io.onedev.server.entitymanager.impl.DefaultMembershipManager;import io.onedev.server.entitymanager.impl.DefaultMilestoneManager;import io.onedev.server.entitymanager.impl.DefaultProjectManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestAssignmentManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestChangeManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestCommentManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestReviewManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestUpdateManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestVerificationManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestWatchManager;import io.onedev.server.entitymanager.impl.DefaultRoleManager;import io.onedev.server.entitymanager.impl.DefaultSettingManager;import io.onedev.server.entitymanager.impl.DefaultSshKeyManager;import io.onedev.server.entitymanager.impl.DefaultUserAuthorizationManager;import io.onedev.server.entitymanager.impl.DefaultUserManager;import io.onedev.server.git.GitFilter;import io.onedev.server.git.GitSshCommandCreator;import io.onedev.server.git.config.GitConfig;import io.onedev.server.git.hookcallback.GitPostReceiveCallback;import io.onedev.server.git.hookcallback.GitPreReceiveCallback;import io.onedev.server.infomanager.CommitInfoManager;import io.onedev.server.infomanager.DefaultCommitInfoManager;import io.onedev.server.infomanager.DefaultPullRequestInfoManager;import io.onedev.server.infomanager.DefaultUserInfoManager;import io.onedev.server.infomanager.PullRequestInfoManager;import io.onedev.server.infomanager.UserInfoManager;import io.onedev.server.maintenance.ApplyDatabaseConstraints;import io.onedev.server.maintenance.BackupDatabase;import io.onedev.server.maintenance.CheckDataVersion;import io.onedev.server.maintenance.CleanDatabase;import io.onedev.server.maintenance.DataManager;import io.onedev.server.maintenance.DefaultDataManager;import io.onedev.server.maintenance.ResetAdminPassword;import io.onedev.server.maintenance.RestoreDatabase;import io.onedev.server.maintenance.Upgrade;import io.onedev.server.model.support.administration.GroovyScript;import io.onedev.server.model.support.administration.authenticator.Authenticator;import io.onedev.server.model.support.administration.jobexecutor.AutoDiscoveredJobExecutor;import io.onedev.server.model.support.administration.jobexecutor.JobExecutor;import io.onedev.server.notification.BuildNotificationManager;import io.onedev.server.notification.CodeCommentNotificationManager;import io.onedev.server.notification.CommitNotificationManager;import io.onedev.server.notification.DefaultMailManager;import io.onedev.server.notification.IssueNotificationManager;import io.onedev.server.notification.MailManager;import io.onedev.server.notification.PullRequestNotificationManager;import io.onedev.server.notification.WebHookManager;import io.onedev.server.persistence.DefaultIdManager;import io.onedev.server.persistence.DefaultPersistManager;import io.onedev.server.persistence.DefaultSessionManager;import io.onedev.server.persistence.DefaultTransactionManager;import io.onedev.server.persistence.HibernateInterceptor;import io.onedev.server.persistence.IdManager;import io.onedev.server.persistence.PersistListener;import io.onedev.server.persistence.PersistManager;import io.onedev.server.persistence.PrefixedNamingStrategy;import io.onedev.server.persistence.SessionFactoryProvider;import io.onedev.server.persistence.SessionInterceptor;import io.onedev.server.persistence.SessionManager;import io.onedev.server.persistence.SessionProvider;import io.onedev.server.persistence.TransactionInterceptor;import io.onedev.server.persistence.TransactionManager;import io.onedev.server.persistence.annotation.Sessional;import io.onedev.server.persistence.annotation.Transactional;import io.onedev.server.persistence.dao.Dao;import io.onedev.server.persistence.dao.DefaultDao;import io.onedev.server.rest.RestConstants;import io.onedev.server.rest.jersey.DefaultServletContainer;import io.onedev.server.rest.jersey.JerseyConfigurator;import io.onedev.server.rest.jersey.ResourceConfigProvider;import io.onedev.server.search.code.DefaultIndexManager;import io.onedev.server.search.code.DefaultSearchManager;import io.onedev.server.search.code.IndexManager;import io.onedev.server.search.code.SearchManager;import io.onedev.server.security.BasicAuthenticationFilter;import io.onedev.server.security.BearerAuthenticationFilter;import io.onedev.server.security.CodePullAuthorizationSource;import io.onedev.server.security.DefaultFilterChainResolver;import io.onedev.server.security.DefaultPasswordService;import io.onedev.server.security.DefaultRememberMeManager;import io.onedev.server.security.DefaultWebSecurityManager;import io.onedev.server.security.FilterChainConfigurator;import io.onedev.server.security.SecurityUtils;import io.onedev.server.security.realm.AbstractAuthorizingRealm;import io.onedev.server.ssh.DefaultKeyPairProvider;import io.onedev.server.ssh.DefaultSshAuthenticator;import io.onedev.server.ssh.SshAuthenticator;import io.onedev.server.ssh.SshCommandCreator;import io.onedev.server.ssh.SshServerLauncher;import io.onedev.server.storage.AttachmentStorageManager;import io.onedev.server.storage.DefaultAttachmentStorageManager;import io.onedev.server.storage.DefaultStorageManager;import io.onedev.server.storage.StorageManager;import io.onedev.server.util.jackson.ObjectMapperConfigurator;import io.onedev.server.util.jackson.ObjectMapperProvider;import io.onedev.server.util.jackson.git.GitObjectMapperConfigurator;import io.onedev.server.util.jackson.hibernate.HibernateObjectMapperConfigurator;import io.onedev.server.util.jetty.DefaultJettyLauncher;import io.onedev.server.util.jetty.JettyLauncher;import io.onedev.server.util.markdown.DefaultMarkdownManager;import io.onedev.server.util.markdown.EntityReferenceManager;import io.onedev.server.util.markdown.MarkdownManager;import io.onedev.server.util.markdown.MarkdownProcessor;import io.onedev.server.util.schedule.DefaultTaskScheduler;import io.onedev.server.util.schedule.TaskScheduler;import io.onedev.server.util.script.ScriptContribution;import io.onedev.server.util.validation.DefaultEntityValidator;import io.onedev.server.util.validation.EntityValidator;import io.onedev.server.util.validation.ValidatorProvider;import io.onedev.server.util.work.BatchWorkManager;import io.onedev.server.util.work.DefaultBatchWorkManager;import io.onedev.server.util.work.DefaultWorkExecutor;import io.onedev.server.util.work.WorkExecutor;import io.onedev.server.util.xstream.CollectionConverter;import io.onedev.server.util.xstream.HibernateProxyConverter;import io.onedev.server.util.xstream.MapConverter;import io.onedev.server.util.xstream.ReflectionConverter;import io.onedev.server.util.xstream.StringConverter;import io.onedev.server.util.xstream.VersionedDocumentConverter;import io.onedev.server.web.DefaultUrlManager;import io.onedev.server.web.DefaultWicketFilter;import io.onedev.server.web.DefaultWicketServlet;import io.onedev.server.web.ExpectedExceptionContribution;import io.onedev.server.web.ResourcePackScopeContribution;import io.onedev.server.web.WebApplication;import io.onedev.server.web.WebApplicationConfigurator;import io.onedev.server.web.avatar.AvatarManager;import io.onedev.server.web.avatar.DefaultAvatarManager;import io.onedev.server.web.component.diff.DiffRenderer;import io.onedev.server.web.component.markdown.SourcePositionTrackExtension;import io.onedev.server.web.component.markdown.emoji.EmojiExtension;import io.onedev.server.web.component.taskbutton.TaskButton;import io.onedev.server.web.editable.DefaultEditSupportRegistry;import io.onedev.server.web.editable.EditSupport;import io.onedev.server.web.editable.EditSupportLocator;import io.onedev.server.web.editable.EditSupportRegistry;import io.onedev.server.web.mapper.DynamicPathPageMapper;import io.onedev.server.web.page.layout.DefaultUICustomization;import io.onedev.server.web.page.layout.UICustomization;import io.onedev.server.web.page.project.blob.render.BlobRendererContribution;import io.onedev.server.web.page.test.TestPage;import io.onedev.server.web.websocket.BuildEventBroadcaster;import io.onedev.server.web.websocket.CodeCommentEventBroadcaster;import io.onedev.server.web.websocket.CommitIndexedBroadcaster;import io.onedev.server.web.websocket.DefaultWebSocketManager;import io.onedev.server.web.websocket.IssueEventBroadcaster;import io.onedev.server.web.websocket.PullRequestEventBroadcaster;import io.onedev.server.web.websocket.WebSocketManager;import io.onedev.server.web.websocket.WebSocketPolicyProvider;public class CoreModule extends AbstractPluginModule {@Overrideprotected void configure() {super.configure();bind(JettyLauncher.class).to(DefaultJettyLauncher.class);bind(ServletContextHandler.class).toProvider(DefaultJettyLauncher.class);bind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);bind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {@Overridepublic ValidatorFactory get() {Configuration<?> configuration = Validation.byDefaultProvider().configure().messageInterpolator(new ParameterMessageInterpolator());return configuration.buildValidatorFactory();}}).in(Singleton.class);bind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);configurePersistence();configureSecurity();configureRestServices();configureWeb();configureSsh();configureGit();configureBuild();bind(MarkdownManager.class).to(DefaultMarkdownManager.class);bind(StorageManager.class).to(DefaultStorageManager.class);bind(SettingManager.class).to(DefaultSettingManager.class);bind(DataManager.class).to(DefaultDataManager.class);bind(TaskScheduler.class).to(DefaultTaskScheduler.class);bind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);bind(PullRequestManager.class).to(DefaultPullRequestManager.class);bind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);bind(ProjectManager.class).to(DefaultProjectManager.class);bind(UserManager.class).to(DefaultUserManager.class);bind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);bind(BuildManager.class).to(DefaultBuildManager.class);bind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);bind(JobManager.class).to(DefaultJobManager.class);bind(LogManager.class).to(DefaultLogManager.class);bind(PullRequestVerificationManager.class).to(DefaultPullRequestVerificationManager.class);bind(MailManager.class).to(DefaultMailManager.class);bind(IssueManager.class).to(DefaultIssueManager.class);bind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);bind(BuildParamManager.class).to(DefaultBuildParamManager.class);bind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);bind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);bind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);bind(RoleManager.class).to(DefaultRoleManager.class);bind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);bind(UserInfoManager.class).to(DefaultUserInfoManager.class);bind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);bind(GroupManager.class).to(DefaultGroupManager.class);bind(MembershipManager.class).to(DefaultMembershipManager.class);bind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);bind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);bind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);bind(PullRequestInfoManager.class).to(DefaultPullRequestInfoManager.class);bind(WorkExecutor.class).to(DefaultWorkExecutor.class);bind(PullRequestNotificationManager.class);bind(CommitNotificationManager.class);bind(BuildNotificationManager.class);bind(IssueNotificationManager.class);bind(EntityReferenceManager.class);bind(CodeCommentNotificationManager.class);bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);bind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);bind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);bind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);bind(MilestoneManager.class).to(DefaultMilestoneManager.class);bind(Session.class).toProvider(SessionProvider.class);bind(EntityManager.class).toProvider(SessionProvider.class);bind(SessionFactory.class).toProvider(SessionFactoryProvider.class);bind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);bind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);bind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);bind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);bind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);bind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);bind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);bind(PullRequestAssignmentManager.class).to(DefaultPullRequestAssignmentManager.class);bind(SshKeyManager.class).to(DefaultSshKeyManager.class);bind(WebHookManager.class);contribute(ImplementationProvider.class, new ImplementationProvider() {@Overridepublic Class<?> getAbstractClass() {return JobExecutor.class;}@Overridepublic Collection<Class<?>> getImplementations() {return Sets.newHashSet(AutoDiscoveredJobExecutor.class);}});contribute(CodePullAuthorizationSource.class, DefaultJobManager.class);bind(IndexManager.class).to(DefaultIndexManager.class);bind(SearchManager.class).to(DefaultSearchManager.class);bind(EntityValidator.class).to(DefaultEntityValidator.class);    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {@Overridepublic ExecutorService get() {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,         new SynchronousQueue<Runnable>()) {@Overridepublic void execute(Runnable command) {try {super.execute(SecurityUtils.inheritSubject(command));} catch (RejectedExecutionException e) {if (!isShutdown())throw ExceptionUtils.unchecked(e);}}        };}    }).in(Singleton.class);    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {@Overridepublic ForkJoinTask<?> submit(Runnable task) {return super.submit(SecurityUtils.inheritSubject(task));}@Overridepublic void execute(Runnable task) {super.execute(SecurityUtils.inheritSubject(task));}@Overridepublic <T> ForkJoinTask<T> submit(Callable<T> task) {return super.submit(SecurityUtils.inheritSubject(task));}@Overridepublic <T> ForkJoinTask<T> submit(Runnable task, T result) {return super.submit(SecurityUtils.inheritSubject(task), result);}@Overridepublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)throws InterruptedException, ExecutionException {return super.invokeAny(SecurityUtils.inheritSubject(tasks));}@Overridepublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException {return super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);}@Overridepublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {return super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);}@Overridepublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {return super.invokeAll(SecurityUtils.inheritSubject(tasks));}    });}private void configureSsh() {bind(KeyPairProvider.class).to(DefaultKeyPairProvider.class);bind(SshAuthenticator.class).to(DefaultSshAuthenticator.class);bind(SshServerLauncher.class);}private void configureSecurity() {contributeFromPackage(Realm.class, AbstractAuthorizingRealm.class);bind(RememberMeManager.class).to(DefaultRememberMeManager.class);bind(WebSecurityManager.class).to(DefaultWebSecurityManager.class);bind(FilterChainResolver.class).to(DefaultFilterChainResolver.class);bind(BasicAuthenticationFilter.class);bind(BearerAuthenticationFilter.class);bind(PasswordService.class).to(DefaultPasswordService.class);bind(ShiroFilter.class);install(new ShiroAopModule());        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {            @Override            public void configure(FilterChainManager filterChainManager) {                filterChainManager.createChain(\"info/refs\", \"noSessionCreation, authcBasic, authcBearer\");                filterChainManager.createChain(\"git-upload-pack\", \"noSessionCreation, authcBasic, authcBearer\");                filterChainManager.createChain(\"git-receive-pack\", \"noSessionCreation, authcBasic, authcBearer\");            }        });        contributeFromPackage(Authenticator.class, Authenticator.class);}private void configureGit() {contribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);bind(GitConfig.class).toProvider(GitConfigProvider.class);bind(GitFilter.class);bind(GitPreReceiveCallback.class);bind(GitPostReceiveCallback.class);contribute(SshCommandCreator.class, GitSshCommandCreator.class);}private void configureRestServices() {bind(ResourceConfig.class).toProvider(ResourceConfigProvider.class).in(Singleton.class);bind(ServletContainer.class).to(DefaultServletContainer.class);contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {@Overridepublic void configure(FilterChainManager filterChainManager) {filterChainManager.createChain(\"/rest/**\", \"noSessionCreation, authcBasic\");}});contribute(JerseyConfigurator.class, new JerseyConfigurator() {@Overridepublic void configure(ResourceConfig resourceConfig) {resourceConfig.packages(RestConstants.class.getPackage().getName());}});}private void configureWeb() {bind(WicketServlet.class).to(DefaultWicketServlet.class);bind(WicketFilter.class).to(DefaultWicketFilter.class);bind(WebSocketPolicy.class).toProvider(WebSocketPolicyProvider.class);bind(EditSupportRegistry.class).to(DefaultEditSupportRegistry.class);bind(WebSocketManager.class).to(DefaultWebSocketManager.class);contributeFromPackage(EditSupport.class, EditSupport.class);bind(org.apache.wicket.protocol.http.WebApplication.class).to(WebApplication.class);bind(Application.class).to(WebApplication.class);bind(AvatarManager.class).to(DefaultAvatarManager.class);bind(WebSocketManager.class).to(DefaultWebSocketManager.class);contributeFromPackage(EditSupport.class, EditSupportLocator.class);contribute(WebApplicationConfigurator.class, new WebApplicationConfigurator() {@Overridepublic void configure(org.apache.wicket.protocol.http.WebApplication application) {application.mount(new DynamicPathPageMapper(\"/test\", TestPage.class));}});bind(CommitIndexedBroadcaster.class);contributeFromPackage(DiffRenderer.class, DiffRenderer.class);contributeFromPackage(BlobRendererContribution.class, BlobRendererContribution.class);contribute(Extension.class, new EmojiExtension());contribute(Extension.class, new SourcePositionTrackExtension());contributeFromPackage(MarkdownProcessor.class, MarkdownProcessor.class);contribute(ResourcePackScopeContribution.class, new ResourcePackScopeContribution() {@Overridepublic Collection<Class<?>> getResourcePackScopes() {return Lists.newArrayList(WebApplication.class);}});contribute(ExpectedExceptionContribution.class, new ExpectedExceptionContribution() {@SuppressWarnings(\"unchecked\")@Overridepublic Collection<Class<? extends Exception>> getExpectedExceptionClasses() {return Sets.newHashSet(ConstraintViolationException.class, EntityNotFoundException.class, ObjectNotFoundException.class, StaleStateException.class, UnauthorizedException.class, GeneralException.class, PageExpiredException.class, StalePageException.class);}});bind(UrlManager.class).to(DefaultUrlManager.class);bind(CodeCommentEventBroadcaster.class);bind(PullRequestEventBroadcaster.class);bind(IssueEventBroadcaster.class);bind(BuildEventBroadcaster.class);bind(TaskButton.TaskFutureManager.class);bind(UICustomization.class).toInstance(new DefaultUICustomization());}private void configureBuild() {contribute(ScriptContribution.class, new ScriptContribution() {@Overridepublic GroovyScript getScript() {GroovyScript script = new GroovyScript();script.setName(\"determine-build-failure-investigator\");script.setContent(Lists.newArrayList(\"io.onedev.server.util.script.ScriptContribution.determineBuildFailureInvestigator()\"));return script;}});contribute(ScriptContribution.class, new ScriptContribution() {@Overridepublic GroovyScript getScript() {GroovyScript script = new GroovyScript();script.setName(\"get-build-number\");script.setContent(Lists.newArrayList(\"io.onedev.server.util.script.ScriptContribution.getBuildNumber()\"));return script;}});}private void configurePersistence() {    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);bind(Interceptor.class).to(HibernateInterceptor.class);bind(PhysicalNamingStrategy.class).toInstance(new PrefixedNamingStrategy(\"o_\"));bind(SessionManager.class).to(DefaultSessionManager.class);bind(TransactionManager.class).to(DefaultTransactionManager.class);bind(IdManager.class).to(DefaultIdManager.class);bind(Dao.class).to(DefaultDao.class);    TransactionInterceptor transactionInterceptor = new TransactionInterceptor();    requestInjection(transactionInterceptor);    bindInterceptor(Matchers.any(), new AbstractMatcher<AnnotatedElement>() {@Overridepublic boolean matches(AnnotatedElement element) {return element.isAnnotationPresent(Transactional.class) && !((Method) element).isSynthetic();}    }, transactionInterceptor);    SessionInterceptor sessionInterceptor = new SessionInterceptor();    requestInjection(sessionInterceptor);    bindInterceptor(Matchers.any(), new AbstractMatcher<AnnotatedElement>() {@Overridepublic boolean matches(AnnotatedElement element) {return element.isAnnotationPresent(Sessional.class) && !((Method) element).isSynthetic();}    }, sessionInterceptor);    contributeFromPackage(LogInstruction.class, LogInstruction.class);    contribute(PersistListener.class, new PersistListener() {@Overridepublic boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)throws CallbackException {return false;}@Overridepublic boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)throws CallbackException {return false;}@Overridepublic boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState,String[] propertyNames, Type[] types) throws CallbackException {return false;}@Overridepublic void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)throws CallbackException {}});bind(XStream.class).toProvider(new com.google.inject.Provider<XStream>() {@SuppressWarnings(\"rawtypes\")@Overridepublic XStream get() {ReflectionProvider reflectionProvider = JVM.newReflectionProvider();XStream xstream = new XStream(reflectionProvider) {@Overrideprotected MapperWrapper wrapMapper(MapperWrapper next) {return new MapperWrapper(next) {@Ov", "nl": "import java.io.Serializable;import java.lang.reflect.AnnotatedElement;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Collection;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.Future;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;import javax.inject.Singleton;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityNotFoundException;import javax.persistence.OneToMany;import javax.persistence.Transient;import javax.persistence.Version;import javax.validation.Configuration;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.ValidatorFactory;import org.apache.shiro.authc.credential.PasswordService;import org.apache.shiro.authz.UnauthorizedException;import org.apache.shiro.guice.aop.ShiroAopModule;import org.apache.shiro.mgt.RememberMeManager;import org.apache.shiro.realm.Realm;import org.apache.shiro.web.filter.mgt.FilterChainManager;import org.apache.shiro.web.filter.mgt.FilterChainResolver;import org.apache.shiro.web.mgt.WebSecurityManager;import org.apache.shiro.web.servlet.ShiroFilter;import org.apache.sshd.common.keyprovider.KeyPairProvider;import org.apache.wicket.Application;import org.apache.wicket.core.request.mapper.StalePageException;import org.apache.wicket.protocol.http.PageExpiredException;import org.apache.wicket.protocol.http.WicketFilter;import org.apache.wicket.protocol.http.WicketServlet;import org.eclipse.jetty.servlet.ServletContextHandler;import org.eclipse.jetty.websocket.api.WebSocketPolicy;import org.glassfish.jersey.server.ResourceConfig;import org.glassfish.jersey.servlet.ServletContainer;import org.hibernate.CallbackException;import org.hibernate.Interceptor;import org.hibernate.ObjectNotFoundException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.StaleStateException;import org.hibernate.boot.model.naming.PhysicalNamingStrategy;import org.hibernate.collection.internal.PersistentBag;import org.hibernate.exception.ConstraintViolationException;import org.hibernate.type.Type;import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.collect.Lists;import com.google.common.collect.Sets;import com.google.inject.Provider;import com.google.inject.matcher.AbstractMatcher;import com.google.inject.matcher.Matchers;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.annotations.XStreamOmitField;import com.thoughtworks.xstream.converters.basic.NullConverter;import com.thoughtworks.xstream.converters.extended.ISO8601DateConverter;import com.thoughtworks.xstream.converters.extended.ISO8601SqlTimestampConverter;import com.thoughtworks.xstream.converters.reflection.ReflectionProvider;import com.thoughtworks.xstream.core.JVM;import com.thoughtworks.xstream.mapper.MapperWrapper;import com.vladsch.flexmark.Extension;import io.onedev.commons.launcher.bootstrap.Bootstrap;import io.onedev.commons.launcher.loader.AbstractPlugin;import io.onedev.commons.launcher.loader.AbstractPluginModule;import io.onedev.commons.launcher.loader.ImplementationProvider;import io.onedev.commons.utils.ExceptionUtils;import io.onedev.commons.utils.StringUtils;import io.onedev.server.buildspec.job.DefaultJobManager;import io.onedev.server.buildspec.job.JobManager;import io.onedev.server.buildspec.job.log.DefaultLogManager;import io.onedev.server.buildspec.job.log.LogManager;import io.onedev.server.buildspec.job.log.instruction.LogInstruction;import io.onedev.server.entitymanager.BuildDependenceManager;import io.onedev.server.entitymanager.BuildManager;import io.onedev.server.entitymanager.BuildParamManager;import io.onedev.server.entitymanager.BuildQuerySettingManager;import io.onedev.server.entitymanager.CodeCommentManager;import io.onedev.server.entitymanager.CodeCommentQuerySettingManager;import io.onedev.server.entitymanager.CodeCommentReplyManager;import io.onedev.server.entitymanager.CommitQuerySettingManager;import io.onedev.server.entitymanager.GroupAuthorizationManager;import io.onedev.server.entitymanager.GroupManager;import io.onedev.server.entitymanager.IssueChangeManager;import io.onedev.server.entitymanager.IssueCommentManager;import io.onedev.server.entitymanager.IssueFieldManager;import io.onedev.server.entitymanager.IssueManager;import io.onedev.server.entitymanager.IssueQuerySettingManager;import io.onedev.server.entitymanager.IssueVoteManager;import io.onedev.server.entitymanager.IssueWatchManager;import io.onedev.server.entitymanager.MembershipManager;import io.onedev.server.entitymanager.MilestoneManager;import io.onedev.server.entitymanager.ProjectManager;import io.onedev.server.entitymanager.PullRequestAssignmentManager;import io.onedev.server.entitymanager.PullRequestChangeManager;import io.onedev.server.entitymanager.PullRequestCommentManager;import io.onedev.server.entitymanager.PullRequestManager;import io.onedev.server.entitymanager.PullRequestQuerySettingManager;import io.onedev.server.entitymanager.PullRequestReviewManager;import io.onedev.server.entitymanager.PullRequestUpdateManager;import io.onedev.server.entitymanager.PullRequestVerificationManager;import io.onedev.server.entitymanager.PullRequestWatchManager;import io.onedev.server.entitymanager.RoleManager;import io.onedev.server.entitymanager.SettingManager;import io.onedev.server.entitymanager.SshKeyManager;import io.onedev.server.entitymanager.UrlManager;import io.onedev.server.entitymanager.UserAuthorizationManager;import io.onedev.server.entitymanager.UserManager;import io.onedev.server.entitymanager.impl.DefaultBuildDependenceManager;import io.onedev.server.entitymanager.impl.DefaultBuildManager;import io.onedev.server.entitymanager.impl.DefaultBuildParamManager;import io.onedev.server.entitymanager.impl.DefaultBuildQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultCodeCommentManager;import io.onedev.server.entitymanager.impl.DefaultCodeCommentQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultCodeCommentReplyManager;import io.onedev.server.entitymanager.impl.DefaultCommitQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultGroupAuthorizationManager;import io.onedev.server.entitymanager.impl.DefaultGroupManager;import io.onedev.server.entitymanager.impl.DefaultIssueChangeManager;import io.onedev.server.entitymanager.impl.DefaultIssueCommentManager;import io.onedev.server.entitymanager.impl.DefaultIssueFieldManager;import io.onedev.server.entitymanager.impl.DefaultIssueManager;import io.onedev.server.entitymanager.impl.DefaultIssueQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultIssueVoteManager;import io.onedev.server.entitymanager.impl.DefaultIssueWatchManager;import io.onedev.server.entitymanager.impl.DefaultMembershipManager;import io.onedev.server.entitymanager.impl.DefaultMilestoneManager;import io.onedev.server.entitymanager.impl.DefaultProjectManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestAssignmentManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestChangeManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestCommentManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestQuerySettingManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestReviewManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestUpdateManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestVerificationManager;import io.onedev.server.entitymanager.impl.DefaultPullRequestWatchManager;import io.onedev.server.entitymanager.impl.DefaultRoleManager;import io.onedev.server.entitymanager.impl.DefaultSettingManager;import io.onedev.server.entitymanager.impl.DefaultSshKeyManager;import io.onedev.server.entitymanager.impl.DefaultUserAuthorizationManager;import io.onedev.server.entitymanager.impl.DefaultUserManager;import io.onedev.server.git.GitFilter;import io.onedev.server.git.GitSshCommandCreator;import io.onedev.server.git.config.GitConfig;import io.onedev.server.git.hookcallback.GitPostReceiveCallback;import io.onedev.server.git.hookcallback.GitPreReceiveCallback;import io.onedev.server.infomanager.CommitInfoManager;import io.onedev.server.infomanager.DefaultCommitInfoManager;import io.onedev.server.infomanager.DefaultPullRequestInfoManager;import io.onedev.server.infomanager.DefaultUserInfoManager;import io.onedev.server.infomanager.PullRequestInfoManager;import io.onedev.server.infomanager.UserInfoManager;import io.onedev.server.maintenance.ApplyDatabaseConstraints;import io.onedev.server.maintenance.BackupDatabase;import io.onedev.server.maintenance.CheckDataVersion;import io.onedev.server.maintenance.CleanDatabase;import io.onedev.server.maintenance.DataManager;import io.onedev.server.maintenance.DefaultDataManager;import io.onedev.server.maintenance.ResetAdminPassword;import io.onedev.server.maintenance.RestoreDatabase;import io.onedev.server.maintenance.Upgrade;import io.onedev.server.model.support.administration.GroovyScript;import io.onedev.server.model.support.administration.authenticator.Authenticator;import io.onedev.server.model.support.administration.jobexecutor.AutoDiscoveredJobExecutor;import io.onedev.server.model.support.administration.jobexecutor.JobExecutor;import io.onedev.server.notification.BuildNotificationManager;import io.onedev.server.notification.CodeCommentNotificationManager;import io.onedev.server.notification.CommitNotificationManager;import io.onedev.server.notification.DefaultMailManager;import io.onedev.server.notification.IssueNotificationManager;import io.onedev.server.notification.MailManager;import io.onedev.server.notification.PullRequestNotificationManager;import io.onedev.server.notification.WebHookManager;import io.onedev.server.persistence.DefaultIdManager;import io.onedev.server.persistence.DefaultPersistManager;import io.onedev.server.persistence.DefaultSessionManager;import io.onedev.server.persistence.DefaultTransactionManager;import io.onedev.server.persistence.HibernateInterceptor;import io.onedev.server.persistence.IdManager;import io.onedev.server.persistence.PersistListener;import io.onedev.server.persistence.PersistManager;import io.onedev.server.persistence.PrefixedNamingStrategy;import io.onedev.server.persistence.SessionFactoryProvider;import io.onedev.server.persistence.SessionInterceptor;import io.onedev.server.persistence.SessionManager;import io.onedev.server.persistence.SessionProvider;import io.onedev.server.persistence.TransactionInterceptor;import io.onedev.server.persistence.TransactionManager;import io.onedev.server.persistence.annotation.Sessional;import io.onedev.server.persistence.annotation.Transactional;import io.onedev.server.persistence.dao.Dao;import io.onedev.server.persistence.dao.DefaultDao;import io.onedev.server.rest.RestConstants;import io.onedev.server.rest.jersey.DefaultServletContainer;import io.onedev.server.rest.jersey.JerseyConfigurator;import io.onedev.server.rest.jersey.ResourceConfigProvider;import io.onedev.server.search.code.DefaultIndexManager;import io.onedev.server.search.code.DefaultSearchManager;import io.onedev.server.search.code.IndexManager;import io.onedev.server.search.code.SearchManager;import io.onedev.server.security.BasicAuthenticationFilter;import io.onedev.server.security.BearerAuthenticationFilter;import io.onedev.server.security.CodePullAuthorizationSource;import io.onedev.server.security.DefaultFilterChainResolver;import io.onedev.server.security.DefaultPasswordService;import io.onedev.server.security.DefaultRememberMeManager;import io.onedev.server.security.DefaultWebSecurityManager;import io.onedev.server.security.FilterChainConfigurator;import io.onedev.server.security.SecurityUtils;import io.onedev.server.security.realm.AbstractAuthorizingRealm;import io.onedev.server.ssh.DefaultKeyPairProvider;import io.onedev.server.ssh.DefaultSshAuthenticator;import io.onedev.server.ssh.SshAuthenticator;import io.onedev.server.ssh.SshCommandCreator;import io.onedev.server.ssh.SshServerLauncher;import io.onedev.server.storage.AttachmentStorageManager;import io.onedev.server.storage.DefaultAttachmentStorageManager;import io.onedev.server.storage.DefaultStorageManager;import io.onedev.server.storage.StorageManager;import io.onedev.server.util.jackson.ObjectMapperConfigurator;import io.onedev.server.util.jackson.ObjectMapperProvider;import io.onedev.server.util.jackson.git.GitObjectMapperConfigurator;import io.onedev.server.util.jackson.hibernate.HibernateObjectMapperConfigurator;import io.onedev.server.util.jetty.DefaultJettyLauncher;import io.onedev.server.util.jetty.JettyLauncher;import io.onedev.server.util.markdown.DefaultMarkdownManager;import io.onedev.server.util.markdown.EntityReferenceManager;import io.onedev.server.util.markdown.MarkdownManager;import io.onedev.server.util.markdown.MarkdownProcessor;import io.onedev.server.util.schedule.DefaultTaskScheduler;import io.onedev.server.util.schedule.TaskScheduler;import io.onedev.server.util.script.ScriptContribution;import io.onedev.server.util.validation.DefaultEntityValidator;import io.onedev.server.util.validation.EntityValidator;import io.onedev.server.util.validation.ValidatorProvider;import io.onedev.server.util.work.BatchWorkManager;import io.onedev.server.util.work.DefaultBatchWorkManager;import io.onedev.server.util.work.DefaultWorkExecutor;import io.onedev.server.util.work.WorkExecutor;import io.onedev.server.util.xstream.CollectionConverter;import io.onedev.server.util.xstream.HibernateProxyConverter;import io.onedev.server.util.xstream.MapConverter;import io.onedev.server.util.xstream.ReflectionConverter;import io.onedev.server.util.xstream.StringConverter;import io.onedev.server.util.xstream.VersionedDocumentConverter;import io.onedev.server.web.DefaultUrlManager;import io.onedev.server.web.DefaultWicketFilter;import io.onedev.server.web.DefaultWicketServlet;import io.onedev.server.web.ExpectedExceptionContribution;import io.onedev.server.web.ResourcePackScopeContribution;import io.onedev.server.web.WebApplication;import io.onedev.server.web.WebApplicationConfigurator;import io.onedev.server.web.avatar.AvatarManager;import io.onedev.server.web.avatar.DefaultAvatarManager;import io.onedev.server.web.component.diff.DiffRenderer;import io.onedev.server.web.component.markdown.AttachmentUploadServlet;import io.onedev.server.web.component.markdown.SourcePositionTrackExtension;import io.onedev.server.web.component.markdown.emoji.EmojiExtension;import io.onedev.server.web.component.taskbutton.TaskButton;import io.onedev.server.web.editable.DefaultEditSupportRegistry;import io.onedev.server.web.editable.EditSupport;import io.onedev.server.web.editable.EditSupportLocator;import io.onedev.server.web.editable.EditSupportRegistry;import io.onedev.server.web.mapper.DynamicPathPageMapper;import io.onedev.server.web.page.layout.DefaultUICustomization;import io.onedev.server.web.page.layout.UICustomization;import io.onedev.server.web.page.project.blob.render.BlobRendererContribution;import io.onedev.server.web.page.test.TestPage;import io.onedev.server.web.websocket.BuildEventBroadcaster;import io.onedev.server.web.websocket.CodeCommentEventBroadcaster;import io.onedev.server.web.websocket.CommitIndexedBroadcaster;import io.onedev.server.web.websocket.DefaultWebSocketManager;import io.onedev.server.web.websocket.IssueEventBroadcaster;import io.onedev.server.web.websocket.PullRequestEventBroadcaster;import io.onedev.server.web.websocket.WebSocketManager;import io.onedev.server.web.websocket.WebSocketPolicyProvider;public class CoreModule extends AbstractPluginModule {@Overrideprotected void configure() {super.configure();bind(JettyLauncher.class).to(DefaultJettyLauncher.class);bind(ServletContextHandler.class).toProvider(DefaultJettyLauncher.class);bind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);bind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {@Overridepublic ValidatorFactory get() {Configuration<?> configuration = Validation.byDefaultProvider().configure().messageInterpolator(new ParameterMessageInterpolator());return configuration.buildValidatorFactory();}}).in(Singleton.class);bind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);configurePersistence();configureSecurity();configureRestServices();configureWeb();configureSsh();configureGit();configureBuild();bind(MarkdownManager.class).to(DefaultMarkdownManager.class);bind(StorageManager.class).to(DefaultStorageManager.class);bind(SettingManager.class).to(DefaultSettingManager.class);bind(DataManager.class).to(DefaultDataManager.class);bind(TaskScheduler.class).to(DefaultTaskScheduler.class);bind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);bind(PullRequestManager.class).to(DefaultPullRequestManager.class);bind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);bind(ProjectManager.class).to(DefaultProjectManager.class);bind(UserManager.class).to(DefaultUserManager.class);bind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);bind(BuildManager.class).to(DefaultBuildManager.class);bind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);bind(JobManager.class).to(DefaultJobManager.class);bind(LogManager.class).to(DefaultLogManager.class);bind(PullRequestVerificationManager.class).to(DefaultPullRequestVerificationManager.class);bind(MailManager.class).to(DefaultMailManager.class);bind(IssueManager.class).to(DefaultIssueManager.class);bind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);bind(BuildParamManager.class).to(DefaultBuildParamManager.class);bind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);bind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);bind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);bind(RoleManager.class).to(DefaultRoleManager.class);bind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);bind(UserInfoManager.class).to(DefaultUserInfoManager.class);bind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);bind(GroupManager.class).to(DefaultGroupManager.class);bind(MembershipManager.class).to(DefaultMembershipManager.class);bind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);bind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);bind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);bind(PullRequestInfoManager.class).to(DefaultPullRequestInfoManager.class);bind(WorkExecutor.class).to(DefaultWorkExecutor.class);bind(PullRequestNotificationManager.class);bind(CommitNotificationManager.class);bind(BuildNotificationManager.class);bind(IssueNotificationManager.class);bind(EntityReferenceManager.class);bind(CodeCommentNotificationManager.class);bind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);bind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);bind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);bind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);bind(MilestoneManager.class).to(DefaultMilestoneManager.class);bind(Session.class).toProvider(SessionProvider.class);bind(EntityManager.class).toProvider(SessionProvider.class);bind(SessionFactory.class).toProvider(SessionFactoryProvider.class);bind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);bind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);bind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);bind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);bind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);bind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);bind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);bind(PullRequestAssignmentManager.class).to(DefaultPullRequestAssignmentManager.class);bind(SshKeyManager.class).to(DefaultSshKeyManager.class);bind(WebHookManager.class);contribute(ImplementationProvider.class, new ImplementationProvider() {@Overridepublic Class<?> getAbstractClass() {return JobExecutor.class;}@Overridepublic Collection<Class<?>> getImplementations() {return Sets.newHashSet(AutoDiscoveredJobExecutor.class);}});contribute(CodePullAuthorizationSource.class, DefaultJobManager.class);bind(IndexManager.class).to(DefaultIndexManager.class);bind(SearchManager.class).to(DefaultSearchManager.class);bind(EntityValidator.class).to(DefaultEntityValidator.class);    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {@Overridepublic ExecutorService get() {        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,         new SynchronousQueue<Runnable>()) {@Overridepublic void execute(Runnable command) {try {super.execute(SecurityUtils.inheritSubject(command));} catch (RejectedExecutionException e) {if (!isShutdown())throw ExceptionUtils.unchecked(e);}}        };}    }).in(Singleton.class);    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {@Overridepublic ForkJoinTask<?> submit(Runnable task) {return super.submit(SecurityUtils.inheritSubject(task));}@Overridepublic void execute(Runnable task) {super.execute(SecurityUtils.inheritSubject(task));}@Overridepublic <T> ForkJoinTask<T> submit(Callable<T> task) {return super.submit(SecurityUtils.inheritSubject(task));}@Overridepublic <T> ForkJoinTask<T> submit(Runnable task, T result) {return super.submit(SecurityUtils.inheritSubject(task), result);}@Overridepublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)throws InterruptedException, ExecutionException {return super.invokeAny(SecurityUtils.inheritSubject(tasks));}@Overridepublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException {return super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);}@Overridepublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {return super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);}@Overridepublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {return super.invokeAll(SecurityUtils.inheritSubject(tasks));}    });}private void configureSsh() {bind(KeyPairProvider.class).to(DefaultKeyPairProvider.class);bind(SshAuthenticator.class).to(DefaultSshAuthenticator.class);bind(SshServerLauncher.class);}private void configureSecurity() {contributeFromPackage(Realm.class, AbstractAuthorizingRealm.class);bind(RememberMeManager.class).to(DefaultRememberMeManager.class);bind(WebSecurityManager.class).to(DefaultWebSecurityManager.class);bind(FilterChainResolver.class).to(DefaultFilterChainResolver.class);bind(BasicAuthenticationFilter.class);bind(BearerAuthenticationFilter.class);bind(PasswordService.class).to(DefaultPasswordService.class);bind(ShiroFilter.class);install(new ShiroAopModule());        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {            @Override            public void configure(FilterChainManager filterChainManager) {                filterChainManager.createChain(\"info/refs\", \"noSessionCreation, authcBasic, authcBearer\");                filterChainManager.createChain(\"git-upload-pack\", \"noSessionCreation, authcBasic, authcBearer\");                filterChainManager.createChain(\"git-receive-pack\", \"noSessionCreation, authcBasic, authcBearer\");            }        });        contributeFromPackage(Authenticator.class, Authenticator.class);}private void configureGit() {contribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);bind(GitConfig.class).toProvider(GitConfigProvider.class);bind(GitFilter.class);bind(GitPreReceiveCallback.class);bind(GitPostReceiveCallback.class);contribute(SshCommandCreator.class, GitSshCommandCreator.class);}private void configureRestServices() {bind(ResourceConfig.class).toProvider(ResourceConfigProvider.class).in(Singleton.class);bind(ServletContainer.class).to(DefaultServletContainer.class);contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {@Overridepublic void configure(FilterChainManager filterChainManager) {filterChainManager.createChain(\"/rest/**\", \"noSessionCreation, authcBasic\");}});contribute(JerseyConfigurator.class, new JerseyConfigurator() {@Overridepublic void configure(ResourceConfig resourceConfig) {resourceConfig.packages(RestConstants.class.getPackage().getName());}});}private void configureWeb() {bind(WicketServlet.class).to(DefaultWicketServlet.class);bind(WicketFilter.class).to(DefaultWicketFilter.class);bind(WebSocketPolicy.class).toProvider(WebSocketPolicyProvider.class);bind(EditSupportRegistry.class).to(DefaultEditSupportRegistry.class);bind(WebSocketManager.class).to(DefaultWebSocketManager.class);bind(AttachmentUploadServlet.class);contributeFromPackage(EditSupport.class, EditSupport.class);bind(org.apache.wicket.protocol.http.WebApplication.class).to(WebApplication.class);bind(Application.class).to(WebApplication.class);bind(AvatarManager.class).to(DefaultAvatarManager.class);bind(WebSocketManager.class).to(DefaultWebSocketManager.class);contributeFromPackage(EditSupport.class, EditSupportLocator.class);contribute(WebApplicationConfigurator.class, new WebApplicationConfigurator() {@Overridepublic void configure(org.apache.wicket.protocol.http.WebApplication application) {application.mount(new DynamicPathPageMapper(\"/test\", TestPage.class));}});bind(CommitIndexedBroadcaster.class);contributeFromPackage(DiffRenderer.class, DiffRenderer.class);contributeFromPackage(BlobRendererContribution.class, BlobRendererContribution.class);contribute(Extension.class, new EmojiExtension());contribute(Extension.class, new SourcePositionTrackExtension());contributeFromPackage(MarkdownProcessor.class, MarkdownProcessor.class);contribute(ResourcePackScopeContribution.class, new ResourcePackScopeContribution() {@Overridepublic Collection<Class<?>> getResourcePackScopes() {return Lists.newArrayList(WebApplication.class);}});contribute(ExpectedExceptionContribution.class, new ExpectedExceptionContribution() {@SuppressWarnings(\"unchecked\")@Overridepublic Collection<Class<? extends Exception>> getExpectedExceptionClasses() {return Sets.newHashSet(ConstraintViolationException.class, EntityNotFoundException.class, ObjectNotFoundException.class, StaleStateException.class, UnauthorizedException.class, GeneralException.class, PageExpiredException.class, StalePageException.class);}});bind(UrlManager.class).to(DefaultUrlManager.class);bind(CodeCommentEventBroadcaster.class);bind(PullRequestEventBroadcaster.class);bind(IssueEventBroadcaster.class);bind(BuildEventBroadcaster.class);bind(TaskButton.TaskFutureManager.class);bind(UICustomization.class).toInstance(new DefaultUICustomization());}private void configureBuild() {contribute(ScriptContribution.class, new ScriptContribution() {@Overridepublic GroovyScript getScript() {GroovyScript script = new GroovyScript();script.setName(\"determine-build-failure-investigator\");script.setContent(Lists.newArrayList(\"io.onedev.server.util.script.ScriptContribution.determineBuildFailureInvestigator()\"));return script;}});contribute(ScriptContribution.class, new ScriptContribution() {@Overridepublic GroovyScript getScript() {GroovyScript script = new GroovyScript();script.setName(\"get-build-number\");script.setContent(Lists.newArrayList(\"io.onedev.server.util.script.ScriptContribution.getBuildNumber()\"));return script;}});}private void configurePersistence() {    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);bind(Interceptor.class).to(HibernateInterceptor.class);bind(PhysicalNamingStrategy.class).toInstance(new PrefixedNamingStrategy(\"o_\"));bind(SessionManager.class).to(DefaultSessionManager.class);bind(TransactionManager.class).to(DefaultTransactionManager.class);bind(IdManager.class).to(DefaultIdManager.class);bind(Dao.class).to(DefaultDao.class);    TransactionInterceptor transactionInterceptor = new TransactionInterceptor();    requestInjection(transactionInterceptor);    bindInterceptor(Matchers.any(), new AbstractMatcher<AnnotatedElement>() {@Overridepublic boolean matches(AnnotatedElement element) {return element.isAnnotationPresent(Transactional.class) && !((Method) element).isSynthetic();}    }, transactionInterceptor);    SessionInterceptor sessionInterceptor = new SessionInterceptor();    requestInjection(sessionInterceptor);    bindInterceptor(Matchers.any(), new AbstractMatcher<AnnotatedElement>() {@Overridepublic boolean matches(AnnotatedElement element) {return element.isAnnotationPresent(Sessional.class) && !((Method) element).isSynthetic();}    }, sessionInterceptor);    contributeFromPackage(LogInstruction.class, LogInstruction.class);    contribute(PersistListener.class, new PersistListener() {@Overridepublic boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)throws CallbackException {return false;}@Overridepublic boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)throws CallbackException {return false;}@Overridepublic boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState,String[] propertyNames, Type[] types) throws CallbackException {return false;}@Overridepublic void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)throws CallbackException {}});bind(XStream.class).toProvider(new com.google.inject.Provider<XStream>() {@SuppressWarnings(\"rawtypes\")@Overridepublic XStream get() {ReflectionProvider reflectionProvider = JVM.newReflectionProvider();XStream xstream = new XStream(reflectionProvider) {@Override"}
{"code": "import org.apache.wicket.core.request.mapper.ResourceMapper;import org.apache.wicket.markup.html.pages.BrowserInfoPage;import org.apache.wicket.protocol.http.WebApplication;import org.apache.wicket.request.IRequestMapper;import org.apache.wicket.request.mapper.CompoundRequestMapper;import io.onedev.server.GeneralException;import io.onedev.server.web.asset.icon.IconScope;import io.onedev.server.web.mapper.BaseResourceMapper;import io.onedev.server.web.mapper.DynamicPathPageMapper;import io.onedev.server.web.mapper.DynamicPathResourceMapper;import io.onedev.server.web.page.admin.authenticator.AuthenticatorPage;import io.onedev.server.web.page.admin.databasebackup.DatabaseBackupPage;import io.onedev.server.web.page.admin.generalsecuritysetting.GeneralSecuritySettingPage;import io.onedev.server.web.page.admin.groovyscript.GroovyScriptListPage;import io.onedev.server.web.page.admin.group.GroupListPage;import io.onedev.server.web.page.admin.group.authorization.GroupAuthorizationsPage;import io.onedev.server.web.page.admin.group.create.NewGroupPage;import io.onedev.server.web.page.admin.group.membership.GroupMembershipsPage;import io.onedev.server.web.page.admin.group.profile.GroupProfilePage;import io.onedev.server.web.page.admin.issuesetting.defaultboard.DefaultBoardListPage;import io.onedev.server.web.page.admin.issuesetting.fieldspec.IssueFieldListPage;import io.onedev.server.web.page.admin.issuesetting.issuetemplate.IssueTemplateListPage;import io.onedev.server.web.page.admin.issuesetting.statespec.IssueStateListPage;import io.onedev.server.web.page.admin.issuesetting.transitionspec.StateTransitionListPage;import io.onedev.server.web.page.admin.jobexecutor.JobExecutorsPage;import io.onedev.server.web.page.admin.mailsetting.MailSettingPage;import io.onedev.server.web.page.admin.role.NewRolePage;import io.onedev.server.web.page.admin.role.RoleDetailPage;import io.onedev.server.web.page.admin.role.RoleListPage;import io.onedev.server.web.page.admin.serverinformation.ServerInformationPage;import io.onedev.server.web.page.admin.serverlog.ServerLogPage;import io.onedev.server.web.page.admin.ssh.SshSettingPage;import io.onedev.server.web.page.admin.sso.SsoConnectorListPage;import io.onedev.server.web.page.admin.sso.SsoProcessPage;import io.onedev.server.web.page.admin.systemsetting.SystemSettingPage;import io.onedev.server.web.page.admin.user.UserListPage;import io.onedev.server.web.page.admin.user.accesstoken.UserAccessTokenPage;import io.onedev.server.web.page.admin.user.authorization.UserAuthorizationsPage;import io.onedev.server.web.page.admin.user.avatar.UserAvatarPage;import io.onedev.server.web.page.admin.user.create.NewUserPage;import io.onedev.server.web.page.admin.user.membership.UserMembershipsPage;import io.onedev.server.web.page.admin.user.password.UserPasswordPage;import io.onedev.server.web.page.admin.user.profile.UserProfilePage;import io.onedev.server.web.page.admin.user.ssh.UserSshKeysPage;import io.onedev.server.web.page.builds.BuildListPage;import io.onedev.server.web.page.issues.IssueListPage;import io.onedev.server.web.page.my.accesstoken.MyAccessTokenPage;import io.onedev.server.web.page.my.avatar.MyAvatarPage;import io.onedev.server.web.page.my.password.MyPasswordPage;import io.onedev.server.web.page.my.profile.MyProfilePage;import io.onedev.server.web.page.my.sshkeys.MySshKeysPage;import io.onedev.server.web.page.project.NewProjectPage;import io.onedev.server.web.page.project.ProjectListPage;import io.onedev.server.web.page.project.blob.ProjectBlobPage;import io.onedev.server.web.page.project.branches.ProjectBranchesPage;import io.onedev.server.web.page.project.builds.ProjectBuildsPage;import io.onedev.server.web.page.project.builds.detail.InvalidBuildPage;import io.onedev.server.web.page.project.builds.detail.artifacts.BuildArtifactsPage;import io.onedev.server.web.page.project.builds.detail.changes.BuildChangesPage;import io.onedev.server.web.page.project.builds.detail.dashboard.BuildDashboardPage;import io.onedev.server.web.page.project.builds.detail.issues.FixedIssuesPage;import io.onedev.server.web.page.project.builds.detail.log.BuildLogPage;import io.onedev.server.web.page.project.codecomments.InvalidCodeCommentPage;import io.onedev.server.web.page.project.codecomments.ProjectCodeCommentsPage;import io.onedev.server.web.page.project.commits.CommitDetailPage;import io.onedev.server.web.page.project.commits.ProjectCommitsPage;import io.onedev.server.web.page.project.compare.RevisionComparePage;import io.onedev.server.web.page.project.dashboard.ProjectDashboardPage;import io.onedev.server.web.page.project.issues.boards.IssueBoardsPage;import io.onedev.server.web.page.project.issues.create.NewIssuePage;import io.onedev.server.web.page.project.issues.detail.IssueActivitiesPage;import io.onedev.server.web.page.project.issues.detail.IssueBuildsPage;import io.onedev.server.web.page.project.issues.detail.IssueCommitsPage;import io.onedev.server.web.page.project.issues.detail.IssuePullRequestsPage;import io.onedev.server.web.page.project.issues.list.ProjectIssueListPage;import io.onedev.server.web.page.project.issues.milestones.MilestoneDetailPage;import io.onedev.server.web.page.project.issues.milestones.MilestoneEditPage;import io.onedev.server.web.page.project.issues.milestones.MilestoneListPage;import io.onedev.server.web.page.project.issues.milestones.NewMilestonePage;import io.onedev.server.web.page.project.pullrequests.InvalidPullRequestPage;import io.onedev.server.web.page.project.pullrequests.ProjectPullRequestsPage;import io.onedev.server.web.page.project.pullrequests.create.NewPullRequestPage;import io.onedev.server.web.page.project.pullrequests.detail.activities.PullRequestActivitiesPage;import io.onedev.server.web.page.project.pullrequests.detail.changes.PullRequestChangesPage;import io.onedev.server.web.page.project.pullrequests.detail.codecomments.PullRequestCodeCommentsPage;import io.onedev.server.web.page.project.pullrequests.detail.mergepreview.MergePreviewPage;import io.onedev.server.web.page.project.setting.authorization.ProjectAuthorizationsPage;import io.onedev.server.web.page.project.setting.avatar.AvatarEditPage;import io.onedev.server.web.page.project.setting.branchprotection.BranchProtectionsPage;import io.onedev.server.web.page.project.setting.build.ActionAuthorizationsPage;import io.onedev.server.web.page.project.setting.build.BuildPreservationsPage;import io.onedev.server.web.page.project.setting.build.JobSecretsPage;import io.onedev.server.web.page.project.setting.general.GeneralProjectSettingPage;import io.onedev.server.web.page.project.setting.tagprotection.TagProtectionsPage;import io.onedev.server.web.page.project.setting.webhook.WebHooksPage;import io.onedev.server.web.page.project.stats.ProjectContribsPage;import io.onedev.server.web.page.project.stats.SourceLinesPage;import io.onedev.server.web.page.project.tags.ProjectTagsPage;import io.onedev.server.web.page.pullrequests.PullRequestListPage;import io.onedev.server.web.page.simple.error.PageNotFoundErrorPage;import io.onedev.server.web.page.simple.security.LoginPage;import io.onedev.server.web.page.simple.security.LogoutPage;import io.onedev.server.web.page.simple.security.PasswordResetPage;import io.onedev.server.web.page.simple.security.SignUpPage;import io.onedev.server.web.page.simple.serverinit.ServerInitPage;import io.onedev.server.web.resource.ArchiveResourceReference;import io.onedev.server.web.resource.ArtifactResourceReference;import io.onedev.server.web.resource.AttachmentResourceReference;import io.onedev.server.web.resource.BuildLogResourceReference;import io.onedev.server.web.resource.RawBlobResourceReference;import io.onedev.server.web.resource.ServerLogResourceReference;import io.onedev.server.web.resource.SvgSpriteResourceReference;public class BaseUrlMapper extends CompoundRequestMapper {@Overridepublic CompoundRequestMapper add(IRequestMapper mapper) {if (mapper instanceof ResourceMapper && !(mapper instanceof BaseResourceMapper))throw new GeneralException(\"Base resource mapper should be used\");return super.add(mapper);}public BaseUrlMapper(WebApplication app) {add(new DynamicPathPageMapper(\"init\", ServerInitPage.class));add(new DynamicPathPageMapper(\"loading\", BrowserInfoPage.class));add(new DynamicPathPageMapper(\"issues\", IssueListPage.class));add(new DynamicPathPageMapper(\"pull-requests\", PullRequestListPage.class));add(new DynamicPathPageMapper(\"builds\", BuildListPage.class));addProjectPages();addMyPages();addAdministrationPages();addSecurityPages();addResources();addErrorPages();}private void addMyPages() {add(new DynamicPathPageMapper(\"my/profile\", MyProfilePage.class));add(new DynamicPathPageMapper(\"my/avatar\", MyAvatarPage.class));add(new DynamicPathPageMapper(\"my/password\", MyPasswordPage.class));add(new DynamicPathPageMapper(\"my/ssh-keys\", MySshKeysPage.class));add(new DynamicPathPageMapper(\"my/access-token\", MyAccessTokenPage.class));}private void addResources() {add(new BaseResourceMapper(\"downloads/server-log\", new ServerLogResourceReference()));add(new BaseResourceMapper(\"downloads/projects/${project}/builds/${build}/log\", new BuildLogResourceReference()));add(new BaseResourceMapper(\"projects/${project}/archive/${revision}\", new ArchiveResourceReference()));add(new DynamicPathResourceMapper(\"projects/${project}/raw/${revision}/${path}\", new RawBlobResourceReference()));add(new BaseResourceMapper(\"projects/${project}/attachment/${uuid}/${attachment}\", new AttachmentResourceReference()));add(new DynamicPathResourceMapper(\"downloads/projects/${project}/builds/${build}/artifacts/${path}\", new ArtifactResourceReference()));add(new BaseResourceMapper(SvgSpriteResourceReference.DEFAULT_MOUNT_PATH, new SvgSpriteResourceReference(IconScope.class)));}private void addErrorPages() {add(new DynamicPathPageMapper(\"/errors/404\", PageNotFoundErrorPage.class));}private void addSecurityPages() {add(new DynamicPathPageMapper(\"login\", LoginPage.class));add(new DynamicPathPageMapper(\"logout\", LogoutPage.class));add(new DynamicPathPageMapper(\"signup\", SignUpPage.class));add(new DynamicPathPageMapper(\"reset-password\", PasswordResetPage.class));add(new DynamicPathPageMapper(SsoProcessPage.MOUNT_PATH + \"/${stage}/${connector}\", SsoProcessPage.class));}private void addAdministrationPages() {add(new DynamicPathPageMapper(\"administration\", UserListPage.class));add(new DynamicPathPageMapper(\"administration/users\", UserListPage.class));add(new DynamicPathPageMapper(\"administration/users/new\", NewUserPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/profile\", UserProfilePage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/groups\", UserMembershipsPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/authorizations\", UserAuthorizationsPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/avatar\", UserAvatarPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/password\", UserPasswordPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/ssh-keys\", UserSshKeysPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/access-token\", UserAccessTokenPage.class));add(new DynamicPathPageMapper(\"administration/roles\", RoleListPage.class));add(new DynamicPathPageMapper(\"administration/roles/new\", NewRolePage.class));add(new DynamicPathPageMapper(\"administration/roles/${role}\", RoleDetailPage.class));add(new DynamicPathPageMapper(\"administration/groups\", GroupListPage.class));add(new DynamicPathPageMapper(\"administration/groups/new\", NewGroupPage.class));add(new DynamicPathPageMapper(\"administration/groups/${group}/profile\", GroupProfilePage.class));add(new DynamicPathPageMapper(\"administration/groups/${group}/members\", GroupMembershipsPage.class));add(new DynamicPathPageMapper(\"administration/groups/${group}/authorizations\", GroupAuthorizationsPage.class));add(new DynamicPathPageMapper(\"administration/settings/system\", SystemSettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/mail\", MailSettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/backup\", DatabaseBackupPage.class));add(new DynamicPathPageMapper(\"administration/settings/security\", GeneralSecuritySettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/authenticator\", AuthenticatorPage.class));add(new DynamicPathPageMapper(\"administration/settings/sso-connectors\", SsoConnectorListPage.class));add(new DynamicPathPageMapper(\"administration/settings/ssh\", SshSettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/job-executors\", JobExecutorsPage.class));add(new DynamicPathPageMapper(\"administration/settings/groovy-scripts\", GroovyScriptListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-fields\", IssueFieldListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-states\", IssueStateListPage.class));add(new DynamicPathPageMapper(\"administration/settings/state-transitions\", StateTransitionListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-boards\", DefaultBoardListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-templates\", IssueTemplateListPage.class));add(new DynamicPathPageMapper(\"administration/server-log\", ServerLogPage.class));add(new DynamicPathPageMapper(\"administration/server-information\", ServerInformationPage.class));}private void addProjectPages() {add(new DynamicPathPageMapper(\"projects\", ProjectListPage.class));add(new DynamicPathPageMapper(\"projects/new\", NewProjectPage.class));add(new DynamicPathPageMapper(\"projects/${project}\", ProjectDashboardPage.class));add(new DynamicPathPageMapper(\"projects/${project}/blob/#{revision}/#{path}\", ProjectBlobPage.class));add(new DynamicPathPageMapper(\"projects/${project}/commits\", ProjectCommitsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/commits/${revision}\", CommitDetailPage.class));add(new DynamicPathPageMapper(\"projects/${project}/compare\", RevisionComparePage.class));add(new DynamicPathPageMapper(\"projects/${project}/stats/contribs\", ProjectContribsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/stats/lines\", SourceLinesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/branches\", ProjectBranchesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/tags\", ProjectTagsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/code-comments\", ProjectCodeCommentsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/code-comments/${code-comment}/invalid\", InvalidCodeCommentPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls\", ProjectPullRequestsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/new\", NewPullRequestPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}\", PullRequestActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/activities\", PullRequestActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/code-comments\", PullRequestCodeCommentsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/changes\", PullRequestChangesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/merge-preview\", MergePreviewPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/invalid\", InvalidPullRequestPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/boards\", IssueBoardsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/boards/${board}\", IssueBoardsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/list\", ProjectIssueListPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}\", IssueActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/activities\", IssueActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/commits\", IssueCommitsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/pull-requests\", IssuePullRequestsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/builds\", IssueBuildsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/new\", NewIssuePage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones\", MilestoneListPage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones/${milestone}\", MilestoneDetailPage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones/${milestone}/edit\", MilestoneEditPage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones/new\", NewMilestonePage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds\", ProjectBuildsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}\", BuildDashboardPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/log\", BuildLogPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/changes\", BuildChangesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/fixed-issues\", FixedIssuesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/artifacts\", BuildArtifactsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/invalid\", InvalidBuildPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/general\", GeneralProjectSettingPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/authorizations\", ProjectAuthorizationsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/avatar-edit\", AvatarEditPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/branch-protection\", BranchProtectionsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/tag-protection\", TagProtectionsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/build/job-secrets\", JobSecretsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/build/action-authorizations\", ActionAuthorizationsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/build/build-preserve-rules\", BuildPreservationsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/web-hooks\", WebHooksPage.class));}}", "nl": "import org.apache.wicket.core.request.mapper.ResourceMapper;import org.apache.wicket.markup.html.pages.BrowserInfoPage;import org.apache.wicket.protocol.http.WebApplication;import org.apache.wicket.request.IRequestMapper;import org.apache.wicket.request.mapper.CompoundRequestMapper;import io.onedev.server.GeneralException;import io.onedev.server.web.asset.icon.IconScope;import io.onedev.server.web.mapper.BaseResourceMapper;import io.onedev.server.web.mapper.DynamicPathPageMapper;import io.onedev.server.web.mapper.DynamicPathResourceMapper;import io.onedev.server.web.page.admin.authenticator.AuthenticatorPage;import io.onedev.server.web.page.admin.databasebackup.DatabaseBackupPage;import io.onedev.server.web.page.admin.generalsecuritysetting.GeneralSecuritySettingPage;import io.onedev.server.web.page.admin.groovyscript.GroovyScriptListPage;import io.onedev.server.web.page.admin.group.GroupListPage;import io.onedev.server.web.page.admin.group.authorization.GroupAuthorizationsPage;import io.onedev.server.web.page.admin.group.create.NewGroupPage;import io.onedev.server.web.page.admin.group.membership.GroupMembershipsPage;import io.onedev.server.web.page.admin.group.profile.GroupProfilePage;import io.onedev.server.web.page.admin.issuesetting.defaultboard.DefaultBoardListPage;import io.onedev.server.web.page.admin.issuesetting.fieldspec.IssueFieldListPage;import io.onedev.server.web.page.admin.issuesetting.issuetemplate.IssueTemplateListPage;import io.onedev.server.web.page.admin.issuesetting.statespec.IssueStateListPage;import io.onedev.server.web.page.admin.issuesetting.transitionspec.StateTransitionListPage;import io.onedev.server.web.page.admin.jobexecutor.JobExecutorsPage;import io.onedev.server.web.page.admin.mailsetting.MailSettingPage;import io.onedev.server.web.page.admin.role.NewRolePage;import io.onedev.server.web.page.admin.role.RoleDetailPage;import io.onedev.server.web.page.admin.role.RoleListPage;import io.onedev.server.web.page.admin.serverinformation.ServerInformationPage;import io.onedev.server.web.page.admin.serverlog.ServerLogPage;import io.onedev.server.web.page.admin.ssh.SshSettingPage;import io.onedev.server.web.page.admin.sso.SsoConnectorListPage;import io.onedev.server.web.page.admin.sso.SsoProcessPage;import io.onedev.server.web.page.admin.systemsetting.SystemSettingPage;import io.onedev.server.web.page.admin.user.UserListPage;import io.onedev.server.web.page.admin.user.accesstoken.UserAccessTokenPage;import io.onedev.server.web.page.admin.user.authorization.UserAuthorizationsPage;import io.onedev.server.web.page.admin.user.avatar.UserAvatarPage;import io.onedev.server.web.page.admin.user.create.NewUserPage;import io.onedev.server.web.page.admin.user.membership.UserMembershipsPage;import io.onedev.server.web.page.admin.user.password.UserPasswordPage;import io.onedev.server.web.page.admin.user.profile.UserProfilePage;import io.onedev.server.web.page.admin.user.ssh.UserSshKeysPage;import io.onedev.server.web.page.builds.BuildListPage;import io.onedev.server.web.page.issues.IssueListPage;import io.onedev.server.web.page.my.accesstoken.MyAccessTokenPage;import io.onedev.server.web.page.my.avatar.MyAvatarPage;import io.onedev.server.web.page.my.password.MyPasswordPage;import io.onedev.server.web.page.my.profile.MyProfilePage;import io.onedev.server.web.page.my.sshkeys.MySshKeysPage;import io.onedev.server.web.page.project.NewProjectPage;import io.onedev.server.web.page.project.ProjectListPage;import io.onedev.server.web.page.project.blob.ProjectBlobPage;import io.onedev.server.web.page.project.branches.ProjectBranchesPage;import io.onedev.server.web.page.project.builds.ProjectBuildsPage;import io.onedev.server.web.page.project.builds.detail.InvalidBuildPage;import io.onedev.server.web.page.project.builds.detail.artifacts.BuildArtifactsPage;import io.onedev.server.web.page.project.builds.detail.changes.BuildChangesPage;import io.onedev.server.web.page.project.builds.detail.dashboard.BuildDashboardPage;import io.onedev.server.web.page.project.builds.detail.issues.FixedIssuesPage;import io.onedev.server.web.page.project.builds.detail.log.BuildLogPage;import io.onedev.server.web.page.project.codecomments.InvalidCodeCommentPage;import io.onedev.server.web.page.project.codecomments.ProjectCodeCommentsPage;import io.onedev.server.web.page.project.commits.CommitDetailPage;import io.onedev.server.web.page.project.commits.ProjectCommitsPage;import io.onedev.server.web.page.project.compare.RevisionComparePage;import io.onedev.server.web.page.project.dashboard.ProjectDashboardPage;import io.onedev.server.web.page.project.issues.boards.IssueBoardsPage;import io.onedev.server.web.page.project.issues.create.NewIssuePage;import io.onedev.server.web.page.project.issues.detail.IssueActivitiesPage;import io.onedev.server.web.page.project.issues.detail.IssueBuildsPage;import io.onedev.server.web.page.project.issues.detail.IssueCommitsPage;import io.onedev.server.web.page.project.issues.detail.IssuePullRequestsPage;import io.onedev.server.web.page.project.issues.list.ProjectIssueListPage;import io.onedev.server.web.page.project.issues.milestones.MilestoneDetailPage;import io.onedev.server.web.page.project.issues.milestones.MilestoneEditPage;import io.onedev.server.web.page.project.issues.milestones.MilestoneListPage;import io.onedev.server.web.page.project.issues.milestones.NewMilestonePage;import io.onedev.server.web.page.project.pullrequests.InvalidPullRequestPage;import io.onedev.server.web.page.project.pullrequests.ProjectPullRequestsPage;import io.onedev.server.web.page.project.pullrequests.create.NewPullRequestPage;import io.onedev.server.web.page.project.pullrequests.detail.activities.PullRequestActivitiesPage;import io.onedev.server.web.page.project.pullrequests.detail.changes.PullRequestChangesPage;import io.onedev.server.web.page.project.pullrequests.detail.codecomments.PullRequestCodeCommentsPage;import io.onedev.server.web.page.project.pullrequests.detail.mergepreview.MergePreviewPage;import io.onedev.server.web.page.project.setting.authorization.ProjectAuthorizationsPage;import io.onedev.server.web.page.project.setting.avatar.AvatarEditPage;import io.onedev.server.web.page.project.setting.branchprotection.BranchProtectionsPage;import io.onedev.server.web.page.project.setting.build.ActionAuthorizationsPage;import io.onedev.server.web.page.project.setting.build.BuildPreservationsPage;import io.onedev.server.web.page.project.setting.build.JobSecretsPage;import io.onedev.server.web.page.project.setting.tagprotection.TagProtectionsPage;import io.onedev.server.web.page.project.setting.webhook.WebHooksPage;import io.onedev.server.web.page.project.stats.ProjectContribsPage;import io.onedev.server.web.page.project.stats.SourceLinesPage;import io.onedev.server.web.page.project.tags.ProjectTagsPage;import io.onedev.server.web.page.pullrequests.PullRequestListPage;import io.onedev.server.web.page.simple.error.PageNotFoundErrorPage;import io.onedev.server.web.page.simple.security.LoginPage;import io.onedev.server.web.page.simple.security.LogoutPage;import io.onedev.server.web.page.simple.security.PasswordResetPage;import io.onedev.server.web.page.simple.security.SignUpPage;import io.onedev.server.web.page.simple.serverinit.ServerInitPage;import io.onedev.server.web.resource.ArchiveResourceReference;import io.onedev.server.web.resource.ArtifactResourceReference;import io.onedev.server.web.resource.AttachmentResourceReference;import io.onedev.server.web.resource.BuildLogResourceReference;import io.onedev.server.web.resource.RawBlobResourceReference;import io.onedev.server.web.resource.ServerLogResourceReference;import io.onedev.server.web.resource.SvgSpriteResourceReference;public class BaseUrlMapper extends CompoundRequestMapper {@Overridepublic CompoundRequestMapper add(IRequestMapper mapper) {if (mapper instanceof ResourceMapper && !(mapper instanceof BaseResourceMapper))throw new GeneralException(\"Base resource mapper should be used\");return super.add(mapper);}public BaseUrlMapper(WebApplication app) {add(new DynamicPathPageMapper(\"init\", ServerInitPage.class));add(new DynamicPathPageMapper(\"loading\", BrowserInfoPage.class));add(new DynamicPathPageMapper(\"issues\", IssueListPage.class));add(new DynamicPathPageMapper(\"pull-requests\", PullRequestListPage.class));add(new DynamicPathPageMapper(\"builds\", BuildListPage.class));addProjectPages();addMyPages();addAdministrationPages();addSecurityPages();addResources();addErrorPages();}private void addMyPages() {add(new DynamicPathPageMapper(\"my/profile\", MyProfilePage.class));add(new DynamicPathPageMapper(\"my/avatar\", MyAvatarPage.class));add(new DynamicPathPageMapper(\"my/password\", MyPasswordPage.class));add(new DynamicPathPageMapper(\"my/ssh-keys\", MySshKeysPage.class));add(new DynamicPathPageMapper(\"my/access-token\", MyAccessTokenPage.class));}private void addResources() {add(new BaseResourceMapper(\"downloads/server-log\", new ServerLogResourceReference()));add(new BaseResourceMapper(\"downloads/projects/${project}/builds/${build}/log\", new BuildLogResourceReference()));add(new BaseResourceMapper(\"projects/${project}/archive/${revision}\", new ArchiveResourceReference()));add(new DynamicPathResourceMapper(\"projects/${project}/raw/${revision}/${path}\", new RawBlobResourceReference()));add(new BaseResourceMapper(\"projects/${project}/attachment/${uuid}/${attachment}\", new AttachmentResourceReference()));add(new DynamicPathResourceMapper(\"downloads/projects/${project}/builds/${build}/artifacts/${path}\", new ArtifactResourceReference()));add(new BaseResourceMapper(SvgSpriteResourceReference.DEFAULT_MOUNT_PATH, new SvgSpriteResourceReference(IconScope.class)));}private void addErrorPages() {add(new DynamicPathPageMapper(\"/errors/404\", PageNotFoundErrorPage.class));}private void addSecurityPages() {add(new DynamicPathPageMapper(\"login\", LoginPage.class));add(new DynamicPathPageMapper(\"logout\", LogoutPage.class));add(new DynamicPathPageMapper(\"signup\", SignUpPage.class));add(new DynamicPathPageMapper(\"reset-password\", PasswordResetPage.class));add(new DynamicPathPageMapper(SsoProcessPage.MOUNT_PATH + \"/${stage}/${connector}\", SsoProcessPage.class));}private void addAdministrationPages() {add(new DynamicPathPageMapper(\"administration\", UserListPage.class));add(new DynamicPathPageMapper(\"administration/users\", UserListPage.class));add(new DynamicPathPageMapper(\"administration/users/new\", NewUserPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/profile\", UserProfilePage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/groups\", UserMembershipsPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/authorizations\", UserAuthorizationsPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/avatar\", UserAvatarPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/password\", UserPasswordPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/ssh-keys\", UserSshKeysPage.class));add(new DynamicPathPageMapper(\"administration/users/${user}/access-token\", UserAccessTokenPage.class));add(new DynamicPathPageMapper(\"administration/roles\", RoleListPage.class));add(new DynamicPathPageMapper(\"administration/roles/new\", NewRolePage.class));add(new DynamicPathPageMapper(\"administration/roles/${role}\", RoleDetailPage.class));add(new DynamicPathPageMapper(\"administration/groups\", GroupListPage.class));add(new DynamicPathPageMapper(\"administration/groups/new\", NewGroupPage.class));add(new DynamicPathPageMapper(\"administration/groups/${group}/profile\", GroupProfilePage.class));add(new DynamicPathPageMapper(\"administration/groups/${group}/members\", GroupMembershipsPage.class));add(new DynamicPathPageMapper(\"administration/groups/${group}/authorizations\", GroupAuthorizationsPage.class));add(new DynamicPathPageMapper(\"administration/settings/system\", SystemSettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/mail\", MailSettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/backup\", DatabaseBackupPage.class));add(new DynamicPathPageMapper(\"administration/settings/security\", GeneralSecuritySettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/authenticator\", AuthenticatorPage.class));add(new DynamicPathPageMapper(\"administration/settings/sso-connectors\", SsoConnectorListPage.class));add(new DynamicPathPageMapper(\"administration/settings/ssh\", SshSettingPage.class));add(new DynamicPathPageMapper(\"administration/settings/job-executors\", JobExecutorsPage.class));add(new DynamicPathPageMapper(\"administration/settings/groovy-scripts\", GroovyScriptListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-fields\", IssueFieldListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-states\", IssueStateListPage.class));add(new DynamicPathPageMapper(\"administration/settings/state-transitions\", StateTransitionListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-boards\", DefaultBoardListPage.class));add(new DynamicPathPageMapper(\"administration/settings/issue-templates\", IssueTemplateListPage.class));add(new DynamicPathPageMapper(\"administration/server-log\", ServerLogPage.class));add(new DynamicPathPageMapper(\"administration/server-information\", ServerInformationPage.class));}private void addProjectPages() {add(new DynamicPathPageMapper(\"projects\", ProjectListPage.class));add(new DynamicPathPageMapper(\"projects/new\", NewProjectPage.class));add(new DynamicPathPageMapper(\"projects/${project}\", ProjectDashboardPage.class));add(new DynamicPathPageMapper(\"projects/${project}/blob/#{revision}/#{path}\", ProjectBlobPage.class));add(new DynamicPathPageMapper(\"projects/${project}/commits\", ProjectCommitsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/commits/${revision}\", CommitDetailPage.class));add(new DynamicPathPageMapper(\"projects/${project}/compare\", RevisionComparePage.class));add(new DynamicPathPageMapper(\"projects/${project}/stats/contribs\", ProjectContribsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/stats/lines\", SourceLinesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/branches\", ProjectBranchesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/tags\", ProjectTagsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/code-comments\", ProjectCodeCommentsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/code-comments/${code-comment}/invalid\", InvalidCodeCommentPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls\", ProjectPullRequestsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/new\", NewPullRequestPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}\", PullRequestActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/activities\", PullRequestActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/code-comments\", PullRequestCodeCommentsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/changes\", PullRequestChangesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/merge-preview\", MergePreviewPage.class));add(new DynamicPathPageMapper(\"projects/${project}/pulls/${request}/invalid\", InvalidPullRequestPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/boards\", IssueBoardsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/boards/${board}\", IssueBoardsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/list\", ProjectIssueListPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}\", IssueActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/activities\", IssueActivitiesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/commits\", IssueCommitsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/pull-requests\", IssuePullRequestsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/${issue}/builds\", IssueBuildsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/issues/new\", NewIssuePage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones\", MilestoneListPage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones/${milestone}\", MilestoneDetailPage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones/${milestone}/edit\", MilestoneEditPage.class));add(new DynamicPathPageMapper(\"projects/${project}/milestones/new\", NewMilestonePage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds\", ProjectBuildsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}\", BuildDashboardPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/log\", BuildLogPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/changes\", BuildChangesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/fixed-issues\", FixedIssuesPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/artifacts\", BuildArtifactsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/builds/${build}/invalid\", InvalidBuildPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/general\", GeneralSecuritySettingPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/authorizations\", ProjectAuthorizationsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/avatar-edit\", AvatarEditPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/branch-protection\", BranchProtectionsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/tag-protection\", TagProtectionsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/build/job-secrets\", JobSecretsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/build/action-authorizations\", ActionAuthorizationsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/build/build-preserve-rules\", BuildPreservationsPage.class));add(new DynamicPathPageMapper(\"projects/${project}/settings/web-hooks\", WebHooksPage.class));}}"}
{"code": "None", "nl": "import java.io.IOException;import java.net.URLDecoder;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import javax.inject.Singleton;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.SerializationUtils;import org.apache.wicket.util.crypt.Base64;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import io.onedev.server.persistence.annotation.Sessional;@SuppressWarnings(\"serial\")@Singletonpublic class AttachmentUploadServlet extends HttpServlet {private static final Logger logger = LoggerFactory.getLogger(AttachmentUploadServlet.class);@Sessional@Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {String fileName = URLDecoder.decode(request.getHeader(\"File-Name\"), StandardCharsets.UTF_8.name());AttachmentSupport attachmentSuppport = (AttachmentSupport) SerializationUtils.deserialize(Base64.decodeBase64(request.getHeader(\"Attachment-Support\")));try {String attachmentName = attachmentSuppport.saveAttachment(fileName, request.getInputStream());response.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));response.setStatus(HttpServletResponse.SC_OK);} catch (Exception e) {logger.error(\"Error uploading attachment.\", e);if (e.getMessage() != null)response.getWriter().print(e.getMessage());elseresponse.getWriter().print(\"Internal server error\");response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);}}}"}
{"code": "import static org.apache.wicket.ajax.attributes.CallbackParameter.explicit;import java.io.IOException;import java.io.Serializable;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.annotation.Nullable;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.text.StringEscapeUtils;import org.apache.wicket.AttributeModifier;import org.apache.wicket.Component;import org.apache.wicket.ajax.AjaxChannel;import org.apache.wicket.ajax.AjaxRequestTarget;import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;import org.apache.wicket.behavior.AttributeAppender;import org.apache.wicket.markup.ComponentTag;import org.apache.wicket.markup.head.IHeaderResponse;import org.apache.wicket.markup.head.JavaScriptHeaderItem;import org.apache.wicket.markup.head.OnDomReadyHeaderItem;import org.apache.wicket.markup.head.OnLoadHeaderItem;import org.apache.wicket.markup.html.WebMarkupContainer;import org.apache.wicket.markup.html.basic.Label;import org.apache.wicket.markup.html.form.FormComponentPanel;import org.apache.wicket.markup.html.form.TextArea;import org.apache.wicket.markup.html.panel.Fragment;import org.apache.wicket.model.IModel;import org.apache.wicket.model.LoadableDetachableModel;import org.apache.wicket.model.Model;import org.apache.wicket.request.IRequestParameters;import org.apache.wicket.request.cycle.RequestCycle;import org.apache.wicket.request.http.WebRequest;import org.apache.wicket.request.mapper.parameter.PageParameters;import org.apache.wicket.request.resource.PackageResourceReference;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.unbescape.javascript.JavaScriptEscape;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.base.Preconditions;import io.onedev.commons.launcher.loader.AppLoader;import io.onedev.server.OneDev;import io.onedev.server.entitymanager.ProjectManager;import io.onedev.server.model.Build;import io.onedev.server.model.Issue;import io.onedev.server.model.Project;import io.onedev.server.model.PullRequest;import io.onedev.server.model.User;import io.onedev.server.util.markdown.MarkdownManager;import io.onedev.server.util.validation.ProjectNameValidator;import io.onedev.server.web.avatar.AvatarManager;import io.onedev.server.web.behavior.AbstractPostAjaxBehavior;import io.onedev.server.web.component.floating.FloatingPanel;import io.onedev.server.web.component.link.DropdownLink;import io.onedev.server.web.component.markdown.emoji.EmojiOnes;import io.onedev.server.web.component.modal.ModalPanel;import io.onedev.server.web.page.project.ProjectPage;import io.onedev.server.web.page.project.blob.render.BlobRenderContext;@SuppressWarnings(\"serial\")public class MarkdownEditor extends FormComponentPanel<String> {protected static final int ATWHO_LIMIT = 10;private static final Logger logger = LoggerFactory.getLogger(MarkdownEditor.class);private final boolean compactMode;private final boolean initialSplit;private final BlobRenderContext blobRenderContext;private WebMarkupContainer container;private TextArea<String> input;private AbstractPostAjaxBehavior actionBehavior;private AbstractPostAjaxBehavior attachmentUploadBehavior;public MarkdownEditor(String id, IModel<String> model, boolean compactMode, @Nullable BlobRenderContext blobRenderContext) {super(id, model);this.compactMode = compactMode;String cookieKey;if (compactMode)cookieKey = \"markdownEditor.compactMode.split\";elsecookieKey = \"markdownEditor.normalMode.split\";WebRequest request = (WebRequest) RequestCycle.get().getRequest();Cookie cookie = request.getCookie(cookieKey);initialSplit = cookie!=null && \"true\".equals(cookie.getValue());this.blobRenderContext = blobRenderContext;}@Overrideprotected void onModelChanged() {super.onModelChanged();input.setModelObject(getModelObject());}public void clearMarkdown() {setModelObject(\"\");input.setConvertedInput(null);}private String renderInput(String input) {if (StringUtils.isNotBlank(input)) {input = StringUtils.replace(input, \"\\r\\n\", \"\\n\");return renderMarkdown(input);} else {return \"<div class='message'>Nothing to preview</div>\";}}protected String renderMarkdown(String markdown) {Project project ;if (getPage() instanceof ProjectPage)project = ((ProjectPage) getPage()).getProject();elseproject = null;MarkdownManager manager = OneDev.getInstance(MarkdownManager.class);return manager.process(manager.render(markdown), project, blobRenderContext);}@Overrideprotected void onInitialize() {super.onInitialize();container = new WebMarkupContainer(\"container\");container.setOutputMarkupId(true);add(container);WebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");WebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");WebMarkupContainer preview = new WebMarkupContainer(\"preview\");WebMarkupContainer edit = new WebMarkupContainer(\"edit\");container.add(editLink);container.add(splitLink);container.add(preview);container.add(edit);container.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));container.add(new DropdownLink(\"doReference\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}}.setVisible(getReferenceSupport() != null));container.add(new DropdownLink(\"actionMenuTrigger\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {@Overrideprotected void onInitialize() {super.onInitialize();add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));if (getReferenceSupport() != null) add(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));else add(new WebMarkupContainer(\"doReference\").setVisible(false));}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}});container.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));edit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));for (AttributeModifier modifier: getInputModifiers()) input.add(modifier);if (initialSplit) {container.add(AttributeAppender.append(\"class\", \"split-mode\"));preview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {@Overrideprotected String load() {return renderInput(input.getConvertedInput());}}) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", container.getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setEscapeModelStrings(false));splitLink.add(AttributeAppender.append(\"class\", \"active\"));} else {container.add(AttributeAppender.append(\"class\", \"edit-mode\"));preview.add(new WebMarkupContainer(\"rendered\"));editLink.add(AttributeAppender.append(\"class\", \"active\"));}container.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));container.add(actionBehavior = new AbstractPostAjaxBehavior() {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));}@Overrideprotected void respond(AjaxRequestTarget target) {IRequestParameters params = RequestCycle.get().getRequest().getPostParameters();String action = params.getParameterValue(\"action\").toString(\"\");switch (action) {case \"render\":String markdown = params.getParameterValue(\"param1\").toString();String rendered = renderInput(markdown);String script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", container.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));target.appendJavaScript(script);break;case \"emojiQuery\":List<String> emojiNames = new ArrayList<>();String emojiQuery = params.getParameterValue(\"param1\").toOptionalString();if (StringUtils.isNotBlank(emojiQuery)) {emojiQuery = emojiQuery.toLowerCase();for (String emojiName: EmojiOnes.getInstance().all().keySet()) {if (emojiName.toLowerCase().contains(emojiQuery))emojiNames.add(emojiName);}emojiNames.sort((name1, name2) -> name1.length() - name2.length());} else {emojiNames.add(\"smile\");emojiNames.add(\"worried\");emojiNames.add(\"blush\");emojiNames.add(\"+1\");emojiNames.add(\"-1\");}List<Map<String, String>> emojis = new ArrayList<>();for (String emojiName: emojiNames) {if (emojis.size() < ATWHO_LIMIT) {String emojiCode = EmojiOnes.getInstance().all().get(emojiName);CharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", emojiName);emoji.put(\"url\", url.toString());emojis.add(emoji);}}String json;try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"loadEmojis\":emojis = new ArrayList<>();String urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,        \"icon/FILENAME.png\"), new PageParameters()).toString();for (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", entry.getKey());emoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));emojis.add(emoji);}try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"userQuery\":String userQuery = params.getParameterValue(\"param1\").toOptionalString();AvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);List<Map<String, String>> userList = new ArrayList<>();for (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {Map<String, String> userMap = new HashMap<>();userMap.put(\"name\", user.getName());if (user.getFullName() != null)userMap.put(\"fullName\", user.getFullName());String noSpaceName = StringUtils.deleteWhitespace(user.getName());if (user.getFullName() != null) {String noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());userMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);} else {userMap.put(\"searchKey\", noSpaceName);}String avatarUrl = avatarManager.getAvatarUrl(user);userMap.put(\"avatarUrl\", avatarUrl);userList.add(userMap);}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"referenceQuery\":String referenceQuery = params.getParameterValue(\"param1\").toOptionalString();String referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();String referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();List<Map<String, String>> referenceList = new ArrayList<>();Project referenceProject;if (StringUtils.isNotBlank(referenceProjectName)) referenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);elsereferenceProject = null;if (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {if (\"issue\".equals(referenceQueryType)) {for (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"issue\");referenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));referenceMap.put(\"referenceTitle\", issue.getTitle());referenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));referenceList.add(referenceMap);}} else if (\"pullrequest\".equals(referenceQueryType)) {for (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"pull request\");referenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));referenceMap.put(\"referenceTitle\", request.getTitle());referenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));referenceList.add(referenceMap);}} else if (\"build\".equals(referenceQueryType)) {for (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"build\");referenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));String title;if (build.getVersion() != null) title = \"(\" + build.getVersion() + \") \" + build.getJobName();elsetitle = build.getJobName();referenceMap.put(\"referenceTitle\", title);referenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));referenceList.add(referenceMap);}}}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"selectImage\":case \"selectLink\":new ModalPanel(target) {@Overrideprotected Component newContent(String id) {return new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {@Overrideprotected void onClose(AjaxRequestTarget target) {close();}};}@Overrideprotected void onClosed() {super.onClosed();AjaxRequestTarget target = Preconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));target.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));}};break;case \"insertUrl\":String name;try {name = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());} catch (UnsupportedEncodingException e) {throw new RuntimeException(e);}String replaceMessage = params.getParameterValue(\"param2\").toString();String url = getAttachmentSupport().getAttachmentUrl(name);insertUrl(target, isWebSafeImage(name), url, name, replaceMessage);break;default:throw new IllegalStateException(\"Unknown action: \" + action);}}});container.add(attachmentUploadBehavior = new AbstractPostAjaxBehavior() {@Overrideprotected void respond(AjaxRequestTarget target) {Preconditions.checkNotNull(getAttachmentSupport(), \"Unexpected attachment upload request\");HttpServletRequest request = (HttpServletRequest) RequestCycle.get().getRequest().getContainerRequest();HttpServletResponse response = (HttpServletResponse) RequestCycle.get().getResponse().getContainerResponse();try {String fileName = URLDecoder.decode(request.getHeader(\"File-Name\"), StandardCharsets.UTF_8.name());String attachmentName = getAttachmentSupport().saveAttachment(fileName, request.getInputStream());response.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));response.setStatus(HttpServletResponse.SC_OK);} catch (Exception e) {logger.error(\"Error uploading attachment.\", e);try {if (e.getMessage() != null)response.getWriter().print(e.getMessage());elseresponse.getWriter().print(\"Internal server error\");} catch (IOException e2) {throw new RuntimeException(e2);}response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);}}});}@Overrideprotected void onComponentTag(ComponentTag tag) {super.onComponentTag(tag);}@Overridepublic void convertInput() {setConvertedInput(input.getConvertedInput());}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);response.render(JavaScriptHeaderItem.forReference(new MarkdownResourceReference()));String actionCallback = actionBehavior.getCallbackFunction(explicit(\"action\"), explicit(\"param1\"), explicit(\"param2\"), explicit(\"param3\")).toString();String attachmentUploadUrl = attachmentUploadBehavior.getCallbackUrl().toString();String autosaveKey = getAutosaveKey();if (autosaveKey != null)autosaveKey = \"'\" + JavaScriptEscape.escapeJavaScript(autosaveKey) + \"'\";elseautosaveKey = \"undefined\";String script = String.format(\"onedev.server.markdown.onDomReady('%s', %s, %d, %s, %d, %b, %b, '%s', %s);\", container.getMarkupId(), actionCallback, ATWHO_LIMIT, getAttachmentSupport()!=null? \"'\" + attachmentUploadUrl + \"'\": \"undefined\", getAttachmentSupport()!=null? getAttachmentSupport().getAttachmentMaxSize(): 0,getUserMentionSupport() != null,getReferenceSupport() != null, JavaScriptEscape.escapeJavaScript(ProjectNameValidator.PATTERN.pattern()),autosaveKey);response.render(OnDomReadyHeaderItem.forScript(script));script = String.format(\"onedev.server.markdown.onLoad('%s');\", container.getMarkupId());response.render(OnLoadHeaderItem.forScript(script));}public void insertUrl(AjaxRequestTarget target, boolean isImage, String url, String name, @Nullable String replaceMessage) {String script = String.format(\"onedev.server.markdown.insertUrl('%s', %s, '%s', '%s', %s);\",container.getMarkupId(), isImage, StringEscapeUtils.escapeEcmaScript(url), StringEscapeUtils.escapeEcmaScript(name), replaceMessage!=null?\"'\"+replaceMessage+\"'\":\"undefined\");target.appendJavaScript(script);}public boolean isWebSafeImage(String fileName) {fileName = fileName.toLowerCase();return fileName.endsWith(\".jpg\") || fileName.endsWith(\".jpeg\") || fileName.endsWith(\".gif\") || fileName.endsWith(\".png\");}@Nullableprotected AttachmentSupport getAttachmentSupport() {return null;}@Nullableprotected UserMentionSupport getUserMentionSupport() {return null;}@Nullableprotected AtWhoReferenceSupport getReferenceSupport() {return null;}protected List<AttributeModifier> getInputModifiers() {return new ArrayList<>();}@Nullableprotected String getAutosaveKey() {return null;}@Nullablepublic BlobRenderContext getBlobRenderContext() {return blobRenderContext;}static class ReferencedEntity implements Serializable {String entityType;String entityTitle;String entityNumber;String searchKey;}}", "nl": "import static org.apache.wicket.ajax.attributes.CallbackParameter.explicit;import java.io.Serializable;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.annotation.Nullable;import javax.servlet.http.Cookie;import org.apache.commons.lang3.SerializationUtils;import org.apache.commons.lang3.StringUtils;import org.apache.commons.text.StringEscapeUtils;import org.apache.wicket.AttributeModifier;import org.apache.wicket.Component;import org.apache.wicket.ajax.AjaxChannel;import org.apache.wicket.ajax.AjaxRequestTarget;import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;import org.apache.wicket.behavior.AttributeAppender;import org.apache.wicket.markup.ComponentTag;import org.apache.wicket.markup.head.IHeaderResponse;import org.apache.wicket.markup.head.JavaScriptHeaderItem;import org.apache.wicket.markup.head.OnDomReadyHeaderItem;import org.apache.wicket.markup.head.OnLoadHeaderItem;import org.apache.wicket.markup.html.WebMarkupContainer;import org.apache.wicket.markup.html.basic.Label;import org.apache.wicket.markup.html.form.FormComponentPanel;import org.apache.wicket.markup.html.form.TextArea;import org.apache.wicket.markup.html.panel.Fragment;import org.apache.wicket.model.IModel;import org.apache.wicket.model.LoadableDetachableModel;import org.apache.wicket.model.Model;import org.apache.wicket.request.IRequestParameters;import org.apache.wicket.request.cycle.RequestCycle;import org.apache.wicket.request.http.WebRequest;import org.apache.wicket.request.mapper.parameter.PageParameters;import org.apache.wicket.request.resource.PackageResourceReference;import org.apache.wicket.util.crypt.Base64;import org.unbescape.javascript.JavaScriptEscape;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.base.Preconditions;import io.onedev.commons.launcher.loader.AppLoader;import io.onedev.server.OneDev;import io.onedev.server.entitymanager.ProjectManager;import io.onedev.server.model.Build;import io.onedev.server.model.Issue;import io.onedev.server.model.Project;import io.onedev.server.model.PullRequest;import io.onedev.server.model.User;import io.onedev.server.util.markdown.MarkdownManager;import io.onedev.server.util.validation.ProjectNameValidator;import io.onedev.server.web.avatar.AvatarManager;import io.onedev.server.web.behavior.AbstractPostAjaxBehavior;import io.onedev.server.web.component.floating.FloatingPanel;import io.onedev.server.web.component.link.DropdownLink;import io.onedev.server.web.component.markdown.emoji.EmojiOnes;import io.onedev.server.web.component.modal.ModalPanel;import io.onedev.server.web.page.project.ProjectPage;import io.onedev.server.web.page.project.blob.render.BlobRenderContext;@SuppressWarnings(\"serial\")public class MarkdownEditor extends FormComponentPanel<String> {protected static final int ATWHO_LIMIT = 10;private final boolean compactMode;private final boolean initialSplit;private final BlobRenderContext blobRenderContext;private WebMarkupContainer container;private TextArea<String> input;private AbstractPostAjaxBehavior ajaxBehavior;public MarkdownEditor(String id, IModel<String> model, boolean compactMode, @Nullable BlobRenderContext blobRenderContext) {super(id, model);this.compactMode = compactMode;String cookieKey;if (compactMode)cookieKey = \"markdownEditor.compactMode.split\";elsecookieKey = \"markdownEditor.normalMode.split\";WebRequest request = (WebRequest) RequestCycle.get().getRequest();Cookie cookie = request.getCookie(cookieKey);initialSplit = cookie!=null && \"true\".equals(cookie.getValue());this.blobRenderContext = blobRenderContext;}@Overrideprotected void onModelChanged() {super.onModelChanged();input.setModelObject(getModelObject());}public void clearMarkdown() {setModelObject(\"\");input.setConvertedInput(null);}private String renderInput(String input) {if (StringUtils.isNotBlank(input)) {input = StringUtils.replace(input, \"\\r\\n\", \"\\n\");return renderMarkdown(input);} else {return \"<div class='message'>Nothing to preview</div>\";}}protected String renderMarkdown(String markdown) {Project project ;if (getPage() instanceof ProjectPage)project = ((ProjectPage) getPage()).getProject();elseproject = null;MarkdownManager manager = OneDev.getInstance(MarkdownManager.class);return manager.process(manager.render(markdown), project, blobRenderContext);}@Overrideprotected void onInitialize() {super.onInitialize();container = new WebMarkupContainer(\"container\");container.setOutputMarkupId(true);add(container);WebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");WebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");WebMarkupContainer preview = new WebMarkupContainer(\"preview\");WebMarkupContainer edit = new WebMarkupContainer(\"edit\");container.add(editLink);container.add(splitLink);container.add(preview);container.add(edit);container.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));container.add(new DropdownLink(\"doReference\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}}.setVisible(getReferenceSupport() != null));container.add(new DropdownLink(\"actionMenuTrigger\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {@Overrideprotected void onInitialize() {super.onInitialize();add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));if (getReferenceSupport() != null) add(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));else add(new WebMarkupContainer(\"doReference\").setVisible(false));}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}});container.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));edit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));for (AttributeModifier modifier: getInputModifiers()) input.add(modifier);if (initialSplit) {container.add(AttributeAppender.append(\"class\", \"split-mode\"));preview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {@Overrideprotected String load() {return renderInput(input.getConvertedInput());}}) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", container.getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setEscapeModelStrings(false));splitLink.add(AttributeAppender.append(\"class\", \"active\"));} else {container.add(AttributeAppender.append(\"class\", \"edit-mode\"));preview.add(new WebMarkupContainer(\"rendered\"));editLink.add(AttributeAppender.append(\"class\", \"active\"));}container.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));container.add(ajaxBehavior = new AbstractPostAjaxBehavior() {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));}@Overrideprotected void respond(AjaxRequestTarget target) {IRequestParameters params = RequestCycle.get().getRequest().getPostParameters();String action = params.getParameterValue(\"action\").toString(\"\");switch (action) {case \"render\":String markdown = params.getParameterValue(\"param1\").toString();String rendered = renderInput(markdown);String script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", container.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));target.appendJavaScript(script);break;case \"emojiQuery\":List<String> emojiNames = new ArrayList<>();String emojiQuery = params.getParameterValue(\"param1\").toOptionalString();if (StringUtils.isNotBlank(emojiQuery)) {emojiQuery = emojiQuery.toLowerCase();for (String emojiName: EmojiOnes.getInstance().all().keySet()) {if (emojiName.toLowerCase().contains(emojiQuery))emojiNames.add(emojiName);}emojiNames.sort((name1, name2) -> name1.length() - name2.length());} else {emojiNames.add(\"smile\");emojiNames.add(\"worried\");emojiNames.add(\"blush\");emojiNames.add(\"+1\");emojiNames.add(\"-1\");}List<Map<String, String>> emojis = new ArrayList<>();for (String emojiName: emojiNames) {if (emojis.size() < ATWHO_LIMIT) {String emojiCode = EmojiOnes.getInstance().all().get(emojiName);CharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", emojiName);emoji.put(\"url\", url.toString());emojis.add(emoji);}}String json;try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"loadEmojis\":emojis = new ArrayList<>();String urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,        \"icon/FILENAME.png\"), new PageParameters()).toString();for (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", entry.getKey());emoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));emojis.add(emoji);}try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"userQuery\":String userQuery = params.getParameterValue(\"param1\").toOptionalString();AvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);List<Map<String, String>> userList = new ArrayList<>();for (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {Map<String, String> userMap = new HashMap<>();userMap.put(\"name\", user.getName());if (user.getFullName() != null)userMap.put(\"fullName\", user.getFullName());String noSpaceName = StringUtils.deleteWhitespace(user.getName());if (user.getFullName() != null) {String noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());userMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);} else {userMap.put(\"searchKey\", noSpaceName);}String avatarUrl = avatarManager.getAvatarUrl(user);userMap.put(\"avatarUrl\", avatarUrl);userList.add(userMap);}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"referenceQuery\":String referenceQuery = params.getParameterValue(\"param1\").toOptionalString();String referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();String referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();List<Map<String, String>> referenceList = new ArrayList<>();Project referenceProject;if (StringUtils.isNotBlank(referenceProjectName)) referenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);elsereferenceProject = null;if (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {if (\"issue\".equals(referenceQueryType)) {for (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"issue\");referenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));referenceMap.put(\"referenceTitle\", issue.getTitle());referenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));referenceList.add(referenceMap);}} else if (\"pullrequest\".equals(referenceQueryType)) {for (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"pull request\");referenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));referenceMap.put(\"referenceTitle\", request.getTitle());referenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));referenceList.add(referenceMap);}} else if (\"build\".equals(referenceQueryType)) {for (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"build\");referenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));String title;if (build.getVersion() != null) title = \"(\" + build.getVersion() + \") \" + build.getJobName();elsetitle = build.getJobName();referenceMap.put(\"referenceTitle\", title);referenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));referenceList.add(referenceMap);}}}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"selectImage\":case \"selectLink\":new ModalPanel(target) {@Overrideprotected Component newContent(String id) {return new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {@Overrideprotected void onClose(AjaxRequestTarget target) {close();}};}@Overrideprotected void onClosed() {super.onClosed();AjaxRequestTarget target = Preconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));target.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));}};break;case \"insertUrl\":String name;try {name = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());} catch (UnsupportedEncodingException e) {throw new RuntimeException(e);}String replaceMessage = params.getParameterValue(\"param2\").toString();String url = getAttachmentSupport().getAttachmentUrl(name);insertUrl(target, isWebSafeImage(name), url, name, replaceMessage);break;default:throw new IllegalStateException(\"Unknown action: \" + action);}}});}@Overrideprotected void onComponentTag(ComponentTag tag) {super.onComponentTag(tag);}@Overridepublic void convertInput() {setConvertedInput(input.getConvertedInput());}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);response.render(JavaScriptHeaderItem.forReference(new MarkdownResourceReference()));String encodedAttachmentSupport;if (getAttachmentSupport() != null) {encodedAttachmentSupport = Base64.encodeBase64String(SerializationUtils.serialize(getAttachmentSupport()));encodedAttachmentSupport = StringUtils.deleteWhitespace(encodedAttachmentSupport);encodedAttachmentSupport = StringEscapeUtils.escapeEcmaScript(encodedAttachmentSupport);encodedAttachmentSupport = \"'\" + encodedAttachmentSupport + \"'\";} else {encodedAttachmentSupport = \"undefined\";}String callback = ajaxBehavior.getCallbackFunction(explicit(\"action\"), explicit(\"param1\"), explicit(\"param2\"), explicit(\"param3\")).toString();String autosaveKey = getAutosaveKey();if (autosaveKey != null)autosaveKey = \"'\" + JavaScriptEscape.escapeJavaScript(autosaveKey) + \"'\";elseautosaveKey = \"undefined\";String script = String.format(\"onedev.server.markdown.onDomReady('%s', %s, %d, %s, %d, %b, %b, '%s', %s);\", container.getMarkupId(), callback, ATWHO_LIMIT, encodedAttachmentSupport, getAttachmentSupport()!=null?getAttachmentSupport().getAttachmentMaxSize():0,getUserMentionSupport() != null,getReferenceSupport() != null, JavaScriptEscape.escapeJavaScript(ProjectNameValidator.PATTERN.pattern()),autosaveKey);response.render(OnDomReadyHeaderItem.forScript(script));script = String.format(\"onedev.server.markdown.onLoad('%s');\", container.getMarkupId());response.render(OnLoadHeaderItem.forScript(script));}public void insertUrl(AjaxRequestTarget target, boolean isImage, String url, String name, @Nullable String replaceMessage) {String script = String.format(\"onedev.server.markdown.insertUrl('%s', %s, '%s', '%s', %s);\",container.getMarkupId(), isImage, StringEscapeUtils.escapeEcmaScript(url), StringEscapeUtils.escapeEcmaScript(name), replaceMessage!=null?\"'\"+replaceMessage+\"'\":\"undefined\");target.appendJavaScript(script);}public boolean isWebSafeImage(String fileName) {fileName = fileName.toLowerCase();return fileName.endsWith(\".jpg\") || fileName.endsWith(\".jpeg\") || fileName.endsWith(\".gif\") || fileName.endsWith(\".png\");}@Nullableprotected AttachmentSupport getAttachmentSupport() {return null;}@Nullableprotected UserMentionSupport getUserMentionSupport() {return null;}@Nullableprotected AtWhoReferenceSupport getReferenceSupport() {return null;}protected List<AttributeModifier> getInputModifiers() {return new ArrayList<>();}@Nullableprotected String getAutosaveKey() {return null;}@Nullablepublic BlobRenderContext getBlobRenderContext() {return blobRenderContext;}static class ReferencedEntity implements Serializable {String entityType;String entityTitle;String entityNumber;String searchKey;}}"}
{"code": "import java.util.EnumSet;import javax.inject.Inject;import javax.servlet.DispatcherType;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import org.apache.shiro.web.env.EnvironmentLoader;import org.apache.shiro.web.env.EnvironmentLoaderListener;import org.apache.shiro.web.servlet.ShiroFilter;import org.apache.wicket.protocol.http.WicketServlet;import org.eclipse.jetty.servlet.FilterHolder;import org.eclipse.jetty.servlet.ServletContextHandler;import org.eclipse.jetty.servlet.ServletHolder;import org.glassfish.jersey.servlet.ServletContainer;import io.onedev.commons.launcher.bootstrap.Bootstrap;import io.onedev.server.git.GitFilter;import io.onedev.server.git.hookcallback.GitPostReceiveCallback;import io.onedev.server.git.hookcallback.GitPreReceiveCallback;import io.onedev.server.security.DefaultWebEnvironment;import io.onedev.server.util.ServerConfig;import io.onedev.server.util.jetty.ClasspathAssetServlet;import io.onedev.server.util.jetty.FileAssetServlet;import io.onedev.server.util.jetty.ServletConfigurator;import io.onedev.server.web.asset.icon.IconScope;import io.onedev.server.web.img.ImageScope;import io.onedev.server.web.websocket.WebSocketManager;public class ProductServletConfigurator implements ServletConfigurator {private final ServerConfig serverConfig;private final ShiroFilter shiroFilter;    private final GitFilter gitFilter;private final GitPreReceiveCallback preReceiveServlet;private final GitPostReceiveCallback postReceiveServlet;private final WicketServlet wicketServlet;private final ServletContainer jerseyServlet;private final WebSocketManager webSocketManager;@Injectpublic ProductServletConfigurator(ServerConfig serverConfig, ShiroFilter shiroFilter, GitFilter gitFilter, GitPreReceiveCallback preReceiveServlet, GitPostReceiveCallback postReceiveServlet, WicketServlet wicketServlet, WebSocketManager webSocketManager, ServletContainer jerseyServlet) {this.serverConfig = serverConfig;this.shiroFilter = shiroFilter;        this.gitFilter = gitFilter;this.preReceiveServlet = preReceiveServlet;this.postReceiveServlet = postReceiveServlet;this.wicketServlet = wicketServlet;this.webSocketManager = webSocketManager;this.jerseyServlet = jerseyServlet;}@Overridepublic void configure(ServletContextHandler context) {context.setContextPath(\"/\");context.getSessionHandler().setMaxInactiveInterval(serverConfig.getSessionTimeout());context.setInitParameter(EnvironmentLoader.ENVIRONMENT_CLASS_PARAM, DefaultWebEnvironment.class.getName());context.addEventListener(new EnvironmentLoaderListener());context.addFilter(new FilterHolder(shiroFilter), \"context.addServlet(new ServletHolder(wicketServlet), \"/\");context.addServlet(new ServletHolder(new ClasspathAssetServlet(ImageScope.class)), \"/imgServletHolder fileServletHolder = new ServletHolder(new FileAssetServlet(Bootstrap.getSiteDir()));context.addServlet(fileServletHolder, \"/site/*\");context.addServlet(fileServletHolder, \"/robots.txt\");context.addServlet(new ServletHolder(jerseyServlet), \"/rest/*\");}}", "nl": "import java.util.EnumSet;import javax.inject.Inject;import javax.servlet.DispatcherType;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import org.apache.shiro.web.env.EnvironmentLoader;import org.apache.shiro.web.env.EnvironmentLoaderListener;import org.apache.shiro.web.servlet.ShiroFilter;import org.apache.wicket.protocol.http.WicketServlet;import org.eclipse.jetty.servlet.FilterHolder;import org.eclipse.jetty.servlet.ServletContextHandler;import org.eclipse.jetty.servlet.ServletHolder;import org.glassfish.jersey.servlet.ServletContainer;import io.onedev.commons.launcher.bootstrap.Bootstrap;import io.onedev.server.git.GitFilter;import io.onedev.server.git.hookcallback.GitPostReceiveCallback;import io.onedev.server.git.hookcallback.GitPreReceiveCallback;import io.onedev.server.security.DefaultWebEnvironment;import io.onedev.server.util.ServerConfig;import io.onedev.server.util.jetty.ClasspathAssetServlet;import io.onedev.server.util.jetty.FileAssetServlet;import io.onedev.server.util.jetty.ServletConfigurator;import io.onedev.server.web.asset.icon.IconScope;import io.onedev.server.web.component.markdown.AttachmentUploadServlet;import io.onedev.server.web.img.ImageScope;import io.onedev.server.web.websocket.WebSocketManager;public class ProductServletConfigurator implements ServletConfigurator {private final ServerConfig serverConfig;private final ShiroFilter shiroFilter;    private final GitFilter gitFilter;private final GitPreReceiveCallback preReceiveServlet;private final GitPostReceiveCallback postReceiveServlet;private final WicketServlet wicketServlet;private final AttachmentUploadServlet attachmentUploadServlet;private final ServletContainer jerseyServlet;private final WebSocketManager webSocketManager;@Injectpublic ProductServletConfigurator(ServerConfig serverConfig, ShiroFilter shiroFilter, GitFilter gitFilter, GitPreReceiveCallback preReceiveServlet, GitPostReceiveCallback postReceiveServlet, WicketServlet wicketServlet, WebSocketManager webSocketManager, AttachmentUploadServlet attachmentUploadServlet, ServletContainer jerseyServlet) {this.serverConfig = serverConfig;this.shiroFilter = shiroFilter;        this.gitFilter = gitFilter;this.preReceiveServlet = preReceiveServlet;this.postReceiveServlet = postReceiveServlet;this.wicketServlet = wicketServlet;this.webSocketManager = webSocketManager;this.jerseyServlet = jerseyServlet;this.attachmentUploadServlet = attachmentUploadServlet;}@Overridepublic void configure(ServletContextHandler context) {context.setContextPath(\"/\");context.getSessionHandler().setMaxInactiveInterval(serverConfig.getSessionTimeout());context.setInitParameter(EnvironmentLoader.ENVIRONMENT_CLASS_PARAM, DefaultWebEnvironment.class.getName());context.addEventListener(new EnvironmentLoaderListener());context.addFilter(new FilterHolder(shiroFilter), \"context.addServlet(new ServletHolder(wicketServlet), \"/\");context.addServlet(new ServletHolder(attachmentUploadServlet), \"/attachment_upload\");context.addServlet(new ServletHolder(new ClasspathAssetServlet(ImageScope.class)), \"/imgServletHolder fileServletHolder = new ServletHolder(new FileAssetServlet(Bootstrap.getSiteDir()));context.addServlet(fileServletHolder, \"/site/*\");context.addServlet(fileServletHolder, \"/robots.txt\");context.addServlet(new ServletHolder(jerseyServlet), \"/rest/*\");}}"}
{"code": "import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.Serializable;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.UUID;import javax.inject.Inject;import javax.inject.Singleton;import javax.servlet.http.HttpServletRequest;import javax.ws.rs.Consumes;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.Produces;import javax.ws.rs.core.Context;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import javax.ws.rs.core.StreamingOutput;import org.apache.commons.lang.SerializationUtils;import com.google.common.base.Splitter;import com.google.common.collect.Lists;import io.onedev.commons.utils.TarUtils;import io.onedev.k8shelper.CacheAllocationRequest;import io.onedev.k8shelper.CacheInstance;import io.onedev.server.GeneralException;import io.onedev.server.buildspec.job.Job;import io.onedev.server.buildspec.job.JobContext;import io.onedev.server.buildspec.job.JobManager;@Path(\"/k8s\")@Consumes(MediaType.WILDCARD)@Singletonpublic class KubernetesResource {public static final String TEST_JOB_TOKEN = UUID.randomUUID().toString();private final JobManager jobManager;    @Context    private HttpServletRequest request;    @Inject    public KubernetesResource(JobManager jobManager) {    this.jobManager = jobManager;}@Path(\"/job-context\")@Produces(MediaType.APPLICATION_OCTET_STREAM)    @GET    public byte[] getJobContext() {JobContext context = jobManager.getJobContext(getJobToken(), true);Map<String, Object> contextMap = new HashMap<>();contextMap.put(\"commands\", context.getCommands());contextMap.put(\"retrieveSource\", context.isRetrieveSource());contextMap.put(\"cloneDepth\", context.getCloneDepth());contextMap.put(\"projectName\", context.getProjectName());contextMap.put(\"cloneInfo\", context.getCloneInfo());contextMap.put(\"commitHash\", context.getCommitId().name());contextMap.put(\"collectFiles.includes\", context.getCollectFiles().getIncludes());contextMap.put(\"collectFiles.excludes\", context.getCollectFiles().getExcludes());return SerializationUtils.serialize((Serializable) contextMap);    }@Path(\"/allocate-job-caches\")@Consumes(MediaType.APPLICATION_OCTET_STREAM)@Produces(MediaType.APPLICATION_OCTET_STREAM)    @POST    public byte[] allocateJobCaches(String cacheAllocationRequestString) {CacheAllocationRequest cacheAllocationRequest = CacheAllocationRequest.fromString(cacheAllocationRequestString);return SerializationUtils.serialize((Serializable) jobManager.allocateJobCaches(getJobToken(), cacheAllocationRequest.getCurrentTime(), cacheAllocationRequest.getInstances()));    }@Path(\"/report-job-caches\")@Consumes(MediaType.APPLICATION_OCTET_STREAM)@POSTpublic void reportJobCaches(String cacheInstancesString) {Collection<CacheInstance> cacheInstances = new ArrayList<>();for (String field: Splitter.on(';').omitEmptyStrings().split(cacheInstancesString))cacheInstances.add(CacheInstance.fromString(field));jobManager.reportJobCaches(getJobToken(), cacheInstances);}@Path(\"/download-dependencies\")@Produces(MediaType.APPLICATION_OCTET_STREAM)@GETpublic Response downloadDependencies() {StreamingOutput os = new StreamingOutput() {@Override   public void write(OutputStream output) throws IOException {JobContext context = jobManager.getJobContext(getJobToken(), true);TarUtils.tar(context.getServerWorkspace(), Lists.newArrayList(\"**\"), new ArrayList<>(), output);output.flush();   }   };return Response.ok(os).build();}@POST@Path(\"/upload-outcomes\")@Consumes(MediaType.APPLICATION_OCTET_STREAM)public Response uploadOutcomes(InputStream is) {JobContext context = jobManager.getJobContext(getJobToken(), true);TarUtils.untar(is, context.getServerWorkspace());return Response.ok().build();}@GET@Path(\"/test\")public Response test() {String jobToken = Job.getToken(request);if (TEST_JOB_TOKEN.equals(jobToken))return Response.ok().build();else return Response.status(400).entity(\"Invalid or missing job token\").build();}private String getJobToken() {String jobToken = Job.getToken(request);if (jobToken != null)return jobToken;elsethrow new GeneralException(\"Job token is expected\");}}", "nl": "import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.Serializable;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.UUID;import javax.inject.Inject;import javax.inject.Singleton;import javax.servlet.http.HttpServletRequest;import javax.ws.rs.Consumes;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.Produces;import javax.ws.rs.core.Context;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import javax.ws.rs.core.StreamingOutput;import org.apache.commons.lang.SerializationUtils;import com.google.common.collect.Lists;import io.onedev.commons.utils.TarUtils;import io.onedev.k8shelper.CacheAllocationRequest;import io.onedev.k8shelper.CacheInstance;import io.onedev.server.GeneralException;import io.onedev.server.buildspec.job.Job;import io.onedev.server.buildspec.job.JobContext;import io.onedev.server.buildspec.job.JobManager;@Path(\"/k8s\")@Consumes(MediaType.WILDCARD)@Singletonpublic class KubernetesResource {public static final String TEST_JOB_TOKEN = UUID.randomUUID().toString();private final JobManager jobManager;    @Context    private HttpServletRequest request;    @Inject    public KubernetesResource(JobManager jobManager) {    this.jobManager = jobManager;}@Path(\"/job-context\")@Produces(MediaType.APPLICATION_OCTET_STREAM)    @GET    public byte[] getJobContext() {JobContext context = jobManager.getJobContext(getJobToken(), true);Map<String, Object> contextMap = new HashMap<>();contextMap.put(\"commands\", context.getCommands());contextMap.put(\"retrieveSource\", context.isRetrieveSource());contextMap.put(\"cloneDepth\", context.getCloneDepth());contextMap.put(\"projectName\", context.getProjectName());contextMap.put(\"cloneInfo\", context.getCloneInfo());contextMap.put(\"commitHash\", context.getCommitId().name());contextMap.put(\"collectFiles.includes\", context.getCollectFiles().getIncludes());contextMap.put(\"collectFiles.excludes\", context.getCollectFiles().getExcludes());return SerializationUtils.serialize((Serializable) contextMap);    }@Path(\"/allocate-job-caches\")@Consumes(MediaType.APPLICATION_OCTET_STREAM)@Produces(MediaType.APPLICATION_OCTET_STREAM)    @POST    public byte[] allocateJobCaches(byte[] cacheAllocationRequestBytes) {CacheAllocationRequest allocationRequest = (CacheAllocationRequest) SerializationUtils.deserialize(cacheAllocationRequestBytes);return SerializationUtils.serialize((Serializable) jobManager.allocateJobCaches(getJobToken(), allocationRequest.getCurrentTime(), allocationRequest.getInstances()));    }@Path(\"/report-job-caches\")@Consumes(MediaType.APPLICATION_OCTET_STREAM)@POSTpublic void reportJobCaches(byte[] cacheInstanceBytes) {@SuppressWarnings(\"unchecked\")Collection<CacheInstance> cacheInstances = (Collection<CacheInstance>) SerializationUtils.deserialize(cacheInstanceBytes);jobManager.reportJobCaches(getJobToken(), cacheInstances);}@Path(\"/download-dependencies\")@Produces(MediaType.APPLICATION_OCTET_STREAM)@GETpublic Response downloadDependencies() {StreamingOutput os = new StreamingOutput() {@Override   public void write(OutputStream output) throws IOException {JobContext context = jobManager.getJobContext(getJobToken(), true);TarUtils.tar(context.getServerWorkspace(), Lists.newArrayList(\"**\"), new ArrayList<>(), output);output.flush();   }   };return Response.ok(os).build();}@POST@Path(\"/upload-outcomes\")@Consumes(MediaType.APPLICATION_OCTET_STREAM)public Response uploadOutcomes(InputStream is) {JobContext context = jobManager.getJobContext(getJobToken(), true);TarUtils.untar(is, context.getServerWorkspace());return Response.ok().build();}@GET@Path(\"/test\")public Response test() {String jobToken = Job.getToken(request);if (TEST_JOB_TOKEN.equals(jobToken))return Response.ok().build();else return Response.status(400).entity(\"Invalid or missing job token\").build();}private String getJobToken() {String jobToken = Job.getToken(request);if (jobToken != null)return jobToken;elsethrow new GeneralException(\"Job token is expected\");}}"}
{"code": "public class FilenameUtils extends org.apache.commons.io.FilenameUtils {public static String sanitizeFilename(String fileName) {return fileName.replace(\"..\", \"_\").replace('/', '_').replace('\\\\', '_');}}", "nl": ""}
{"code": "import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;import javax.activation.MimetypesFileTypeMap;import javax.annotation.Nullable;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.text.StringEscapeUtils;import org.apache.wicket.Component;import org.apache.wicket.MetaDataKey;import org.apache.wicket.ajax.AjaxRequestTarget;import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;import org.apache.wicket.ajax.markup.html.AjaxLink;import org.apache.wicket.ajax.markup.html.form.AjaxButton;import org.apache.wicket.feedback.FencedFeedbackPanel;import org.apache.wicket.markup.head.IHeaderResponse;import org.apache.wicket.markup.head.OnDomReadyHeaderItem;import org.apache.wicket.markup.html.basic.Label;import org.apache.wicket.markup.html.form.Form;import org.apache.wicket.markup.html.form.TextArea;import org.apache.wicket.markup.html.form.TextField;import org.apache.wicket.markup.html.form.upload.FileUpload;import org.apache.wicket.markup.html.image.ExternalImage;import org.apache.wicket.markup.html.list.ListItem;import org.apache.wicket.markup.html.list.ListView;import org.apache.wicket.markup.html.panel.Fragment;import org.apache.wicket.markup.html.panel.Panel;import org.apache.wicket.model.IModel;import org.apache.wicket.model.LoadableDetachableModel;import org.apache.wicket.model.Model;import org.apache.wicket.model.PropertyModel;import org.apache.wicket.protocol.http.WebSession;import org.apache.wicket.request.cycle.RequestCycle;import org.apache.wicket.util.lang.Bytes;import org.eclipse.jgit.lib.FileMode;import org.eclipse.jgit.lib.ObjectId;import org.unbescape.javascript.JavaScriptEscape;import com.google.common.base.Preconditions;import io.onedev.commons.utils.PathUtils;import io.onedev.commons.utils.StringUtils;import io.onedev.server.git.BlobIdent;import io.onedev.server.git.BlobIdentFilter;import io.onedev.server.git.exception.GitException;import io.onedev.server.model.Project;import io.onedev.server.util.FilenameUtils;import io.onedev.server.util.UrlUtils;import io.onedev.server.web.ajaxlistener.ConfirmClickListener;import io.onedev.server.web.behavior.ReferenceInputBehavior;import io.onedev.server.web.component.blob.folderpicker.BlobFolderPicker;import io.onedev.server.web.component.blob.picker.BlobPicker;import io.onedev.server.web.component.dropzonefield.DropzoneField;import io.onedev.server.web.component.floating.FloatingPanel;import io.onedev.server.web.component.link.DropdownLink;import io.onedev.server.web.component.tabbable.AjaxActionTab;import io.onedev.server.web.component.tabbable.Tab;import io.onedev.server.web.component.tabbable.Tabbable;import io.onedev.server.web.page.project.blob.ProjectBlobPage;import io.onedev.server.web.page.project.blob.render.BlobRenderContext;@SuppressWarnings(\"serial\")abstract class InsertUrlPanel extends Panel {private static final MimetypesFileTypeMap MIME_TYPES = new MimetypesFileTypeMap();private static final MetaDataKey<String> ACTIVE_TAB = new MetaDataKey<String>(){};private static final MetaDataKey<String> UPLOAD_DIRECTORY = new MetaDataKey<String>(){};private static final MetaDataKey<HashSet<String>> FILE_PICKER_STATE = new MetaDataKey<HashSet<String>>(){};private static final MetaDataKey<HashSet<String>> FOLDER_PICKER_STATE = new MetaDataKey<HashSet<String>>(){};static final String TAB_INPUT_URL = \"Input URL\";static final String TAB_PICK_EXISTING = \"Pick Existing\";static final String TAB_UPLOAD = \"Upload\";private static final String CONTENT_ID = \"content\";private Collection<FileUpload> uploads;private String url;private String text;private String summaryCommitMessage;private String detailCommitMessage;private final MarkdownEditor markdownEditor;private final boolean isImage;public InsertUrlPanel(String id, MarkdownEditor markdownEditor, boolean isImage) {super(id);this.markdownEditor = markdownEditor;this.isImage = isImage;}private Component newInputUrlPanel() {Fragment fragment = new Fragment(CONTENT_ID, \"inputUrlFrag\", this) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.onInputUrlDomReady('%s');\", getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}};Form<?> form = new Form<Void>(\"form\");form.add(new FencedFeedbackPanel(\"feedback\", form));form.add(new Label(\"urlLabel\", isImage?\"Image URL\":\"Link URL\"));form.add(new Label(\"urlHelp\", isImage?\"Absolute or relative url of the image\":\"Absolute or relative url of the link\"));form.add(new TextField<String>(\"url\", new PropertyModel<String>(this, \"url\")));form.add(new Label(\"textLabel\", isImage?\"Image Text\": \"Link Text\"));form.add(new TextField<String>(\"text\", new PropertyModel<String>(this, \"text\")));form.add(new AjaxButton(\"insert\", form) {@Overrideprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {super.onSubmit(target, form);if (StringUtils.isBlank(url)) {if (isImage)error(\"Image URL should be specified\");elseerror(\"Link URL should be specified\");target.add(fragment);} else {if (text == null)text = UrlUtils.describe(url);markdownEditor.insertUrl(target, isImage, url, text, null);onClose(target);}}});fragment.add(form);fragment.setOutputMarkupId(true);return fragment;}private ObjectId resolveCommitId(BlobRenderContext context) {String revision = context.getBlobIdent().revision;if (revision == null)revision = \"master\";try {return context.getProject().getRepository().resolve(revision);} catch (IOException e) {throw new RuntimeException(e);}}private Set<BlobIdent> getPickerState(@Nullable ObjectId commitId, BlobIdent currentBlobIdent, @Nullable Set<String> expandedPaths) {Set<BlobIdent> pickerState = new HashSet<>();if (commitId != null) {if (expandedPaths != null) {for (String path: expandedPaths)pickerState.add(new BlobIdent(commitId.name(), path, FileMode.TREE.getBits()));} String parentPath;if (currentBlobIdent.isTree())parentPath = currentBlobIdent.path;else if (currentBlobIdent.path.contains(\"/\"))parentPath = StringUtils.substringBeforeLast(currentBlobIdent.path, \"/\");elseparentPath = null;while (parentPath != null) {pickerState.add(new BlobIdent(commitId.name(), parentPath, FileMode.TYPE_TREE));if (parentPath.contains(\"/\"))parentPath = StringUtils.substringBeforeLast(parentPath, \"/\");elseparentPath = null;}}return pickerState;}private Component newPickExistingPanel() {Fragment fragment;BlobRenderContext context = markdownEditor.getBlobRenderContext();if (context != null) {fragment = new Fragment(CONTENT_ID, \"pickBlobFrag\", this);BlobIdentFilter blobIdentFilter = new BlobIdentFilter() {@Overridepublic boolean filter(BlobIdent blobIdent) {if (isImage) {if (blobIdent.isTree()) {return true;} else {        String mimetype= MIME_TYPES.getContentType(new File(blobIdent.path));        return mimetype.split(\"/\")[0].equals(\"image\");}} else {return true;}}};ObjectId commitId = resolveCommitId(context);Set<BlobIdent> filePickerState = getPickerState(commitId, context.getBlobIdent(), WebSession.get().getMetaData(FILE_PICKER_STATE));fragment.add(new BlobPicker(\"files\", commitId) {@Overrideprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {blobIdent = new BlobIdent(context.getBlobIdent().revision, blobIdent.path, blobIdent.mode);String baseUrl = context.getDirectoryUrl();String referenceUrl = urlFor(ProjectBlobPage.class, ProjectBlobPage.paramsOf(context.getProject(), blobIdent)).toString();String relativized = PathUtils.relativize(baseUrl, referenceUrl);markdownEditor.insertUrl(target, isImage, relativized, UrlUtils.describe(blobIdent.getName()), null);onClose(target);}@Overrideprotected BlobIdentFilter getBlobIdentFilter() {return blobIdentFilter;}@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}@Overrideprotected void onStateChange() {HashSet<String> expandedPaths = new HashSet<>();for (BlobIdent blobIdent: filePickerState)expandedPaths.add(blobIdent.path);WebSession.get().setMetaData(FILE_PICKER_STATE, expandedPaths);}@Overrideprotected Set<BlobIdent> getState() {return filePickerState;}});} else {AttachmentSupport attachmentSupport = Preconditions.checkNotNull(markdownEditor.getAttachmentSupport());if (isImage) {fragment = new Fragment(CONTENT_ID, \"pickAttachedImageFrag\", this);fragment.add(new ListView<String>(\"attachments\", new LoadableDetachableModel<List<String>>() {@Overrideprotected List<String> load() {List<String> attachmentNames = new ArrayList<>();for (String attachmentName: attachmentSupport.getAttachments()) {if (markdownEditor.isWebSafeImage(attachmentName))attachmentNames.add(attachmentName);}return attachmentNames;}}) {@Overrideprotected void populateItem(final ListItem<String> item) {String attachmentName = item.getModelObject();String attachmentUrl = attachmentSupport.getAttachmentUrl(attachmentName);AjaxLink<Void> selectLink = new AjaxLink<Void>(\"select\") {@Overridepublic void onClick(AjaxRequestTarget target) {String displayName = UrlUtils.describe(attachmentName);markdownEditor.insertUrl(target, true, attachmentUrl, displayName, null);onClose(target);}};selectLink.add(new ExternalImage(\"image\", StringEscapeUtils.escapeHtml4(attachmentUrl)));item.add(selectLink);item.add(new AjaxLink<Void>(\"delete\") {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.getAjaxCallListeners().add(new ConfirmClickListener(\"Do you really want to delete '\" + attachmentName + \"'?\"));}@Overrideprotected void onConfigure() {super.onConfigure();setVisible(attachmentSupport.canDeleteAttachment());}@Overridepublic void onClick(AjaxRequestTarget target) {attachmentSupport.deleteAttachemnt(attachmentName);target.add(fragment);}});}});} else {fragment = new Fragment(CONTENT_ID, \"pickAttachedFileFrag\", this);fragment.add(new ListView<String>(\"attachments\", new LoadableDetachableModel<List<String>>() {@Overrideprotected List<String> load() {return attachmentSupport.getAttachments();}}) {@Overrideprotected void populateItem(final ListItem<String> item) {String attachmentName = item.getModelObject();String attachmentUrl = attachmentSupport.getAttachmentUrl(attachmentName);AjaxLink<Void> selectLink = new AjaxLink<Void>(\"select\") {@Overridepublic void onClick(AjaxRequestTarget target) {String displayName = UrlUtils.describe(attachmentName);markdownEditor.insertUrl(target, false, attachmentUrl, displayName, null);onClose(target);}};selectLink.add(new Label(\"file\", StringEscapeUtils.escapeHtml4(attachmentName)));item.add(selectLink);item.add(new AjaxLink<Void>(\"delete\") {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.getAjaxCallListeners().add(new ConfirmClickListener(\"Do you really want to delete '\" + attachmentName + \"'?\"));}@Overridepublic void onClick(AjaxRequestTarget target) {attachmentSupport.deleteAttachemnt(attachmentName);target.add(fragment);}});}});}}fragment.setOutputMarkupId(true);return fragment;}private Component newUploadPanel() {Fragment fragment;IModel<Collection<FileUpload>> model = new PropertyModel<Collection<FileUpload>>(this, \"uploads\");String acceptedFiles;if (isImage)acceptedFiles = \"image/*\";elseacceptedFiles = null;AttachmentSupport attachmentSupport = markdownEditor.getAttachmentSupport();if (attachmentSupport != null) {fragment = new Fragment(CONTENT_ID, \"uploadAttachmentFrag\", this);Form<?> form = new Form<Void>(\"form\") {@Overrideprotected void onSubmit() {super.onSubmit();AjaxRequestTarget target = RequestCycle.get().find(AjaxRequestTarget.class);String attachmentName;FileUpload upload = uploads.iterator().next();try (InputStream is = upload.getInputStream()) {attachmentName = attachmentSupport.saveAttachment(FilenameUtils.sanitizeFilename(upload.getClientFileName()), is);} catch (IOException e) {throw new RuntimeException(e);}markdownEditor.insertUrl(target, isImage, attachmentSupport.getAttachmentUrl(attachmentName), UrlUtils.describe(attachmentName), null);onClose(target);}@Overrideprotected void onFileUploadException(FileUploadException e, Map<String, Object> model) {throw new RuntimeException(e);}};form.setMaxSize(Bytes.bytes(attachmentSupport.getAttachmentMaxSize()));form.setMultiPart(true);form.add(new FencedFeedbackPanel(\"feedback\", form));int maxFilesize = (int) (attachmentSupport.getAttachmentMaxSize()/1024/1024);if (maxFilesize <= 0)maxFilesize = 1;form.add(new DropzoneField(\"file\", model, acceptedFiles, 1, maxFilesize).setRequired(true).setLabel(Model.of(\"Attachment\")));form.add(new AjaxButton(\"insert\"){});fragment.add(form);} else {fragment = new Fragment(CONTENT_ID, \"uploadBlobFrag\", this);Form<?> form = new Form<Void>(\"form\");form.setMultiPart(true);form.setFileMaxSize(Bytes.megabytes(Project.MAX_UPLOAD_SIZE));add(form);FencedFeedbackPanel feedback = new FencedFeedbackPanel(\"feedback\", form);feedback.setOutputMarkupPlaceholderTag(true);form.add(feedback);form.add(new DropzoneField(\"file\", model, acceptedFiles, 1, Project.MAX_UPLOAD_SIZE).setRequired(true).setLabel(Model.of(\"Attachment\")));form.add(new TextField<String>(\"directory\", new IModel<String>() {@Overridepublic void detach() {}@Overridepublic String getObject() {return WebSession.get().getMetaData(UPLOAD_DIRECTORY);}@Overridepublic void setObject(String object) {WebSession.get().setMetaData(UPLOAD_DIRECTORY, object);}})); BlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());ObjectId commitId = resolveCommitId(context);Set<BlobIdent> folderPickerState = getPickerState(commitId, context.getBlobIdent(), WebSession.get().getMetaData(FOLDER_PICKER_STATE));form.add(new DropdownLink(\"select\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new BlobFolderPicker(id, commitId) {@Overrideprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {dropdown.close();String relativePath = PathUtils.relativize(context.getDirectory(), blobIdent.path);String script = String.format(\"$('form.upload-blob .directory input').val('%s');\", JavaScriptEscape.escapeJavaScript(relativePath));target.appendJavaScript(script);}@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}@Overrideprotected void onStateChange() {HashSet<String> expandedPaths = new HashSet<>();for (BlobIdent blobIdent: folderPickerState)expandedPaths.add(blobIdent.path);WebSession.get().setMetaData(FOLDER_PICKER_STATE, expandedPaths);}@Overrideprotected Set<BlobIdent> getState() {return folderPickerState;}};}});ReferenceInputBehavior behavior = new ReferenceInputBehavior(true) {@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}};form.add(new TextField<String>(\"summaryCommitMessage\", new PropertyModel<String>(this, \"summaryCommitMessage\")).add(behavior));behavior = new ReferenceInputBehavior(true) {@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}};form.add(new TextArea<String>(\"detailCommitMessage\", new PropertyModel<String>(this, \"detailCommitMessage\")).add(behavior));form.add(new AjaxButton(\"insert\") {@Overrideprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {super.onSubmit(target, form);BlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());String commitMessage = summaryCommitMessage;if (StringUtils.isBlank(commitMessage))commitMessage = \"Add files via upload\";if (StringUtils.isNotBlank(detailCommitMessage))commitMessage += \"\\n\\n\" + detailCommitMessage;try {String directory = WebSession.get().getMetaData(UPLOAD_DIRECTORY);context.onCommitted(null, context.uploadFiles(uploads, directory, commitMessage), null);String fileName = uploads.iterator().next().getClientFileName();String url;if (directory != null) url = directory + \"/\" + UrlUtils.encodePath(fileName);else url = UrlUtils.encodePath(fileName);markdownEditor.insertUrl(target, isImage, url, UrlUtils.describe(fileName), null);onClose(target);} catch (GitException e) {form.error(e.getMessage());target.add(feedback);}}@Overrideprotected void onError(AjaxRequestTarget target, Form<?> form) {super.onError(target, form);target.add(feedback);}});fragment.add(form);}fragment.setOutputMarkupId(true);return fragment;}@Overrideprotected void onInitialize() {super.onInitialize();add(new Label(\"title\", isImage?\"Insert Image\":\"Insert Link\"));if (markdownEditor.getBlobRenderContext() == null && markdownEditor.getAttachmentSupport() == null) {add(newInputUrlPanel());} else {Fragment fragment = new Fragment(CONTENT_ID, \"tabbedFrag\", this);List<Tab> tabs = new ArrayList<>();AjaxActionTab inputUrlTab = new AjaxActionTab(Model.of(TAB_INPUT_URL)) {@Overrideprotected void onSelect(AjaxRequestTarget target, Component tabLink) {Component content = newInputUrlPanel();target.add(content);fragment.replace(content);WebSession.get().setMetaData(ACTIVE_TAB, TAB_INPUT_URL);}};tabs.add(inputUrlTab);AjaxActionTab pickExistingTab = new AjaxActionTab(Model.of(TAB_PICK_EXISTING)) {@Overrideprotected void onSelect(AjaxRequestTarget target, Component tabLink) {Component content = newPickExistingPanel();target.add(content);fragment.replace(content);WebSession.get().setMetaData(ACTIVE_TAB, TAB_PICK_EXISTING);}};tabs.add(pickExistingTab);AjaxActionTab uploadTab = new AjaxActionTab(Model.of(TAB_UPLOAD)) {@Overrideprotected void onSelect(AjaxRequestTarget target, Component tabLink) {Component content = newUploadPanel();target.add(content);fragment.replace(content);WebSession.get().setMetaData(ACTIVE_TAB, TAB_UPLOAD);}};tabs.add(uploadTab);fragment.add(new Tabbable(\"tabs\", tabs));inputUrlTab.setSelected(false);String activeTab = WebSession.get().getMetaData(ACTIVE_TAB);if (TAB_PICK_EXISTING.equals(activeTab)) {pickExistingTab.setSelected(true);fragment.add(newPickExistingPanel());} else if (TAB_UPLOAD.equals(activeTab)) {uploadTab.setSelected(true);fragment.add(newUploadPanel());} else {inputUrlTab.setSelected(true);fragment.add(newInputUrlPanel());}add(fragment);}add(new AjaxLink<Void>(\"close\") {@Overridepublic void onClick(AjaxRequestTarget target) {onClose(target);}});}protected abstract void onClose(AjaxRequestTarget target);}", "nl": "import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;import javax.activation.MimetypesFileTypeMap;import javax.annotation.Nullable;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.text.StringEscapeUtils;import org.apache.wicket.Component;import org.apache.wicket.MetaDataKey;import org.apache.wicket.ajax.AjaxRequestTarget;import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;import org.apache.wicket.ajax.markup.html.AjaxLink;import org.apache.wicket.ajax.markup.html.form.AjaxButton;import org.apache.wicket.feedback.FencedFeedbackPanel;import org.apache.wicket.markup.head.IHeaderResponse;import org.apache.wicket.markup.head.OnDomReadyHeaderItem;import org.apache.wicket.markup.html.basic.Label;import org.apache.wicket.markup.html.form.Form;import org.apache.wicket.markup.html.form.TextArea;import org.apache.wicket.markup.html.form.TextField;import org.apache.wicket.markup.html.form.upload.FileUpload;import org.apache.wicket.markup.html.image.ExternalImage;import org.apache.wicket.markup.html.list.ListItem;import org.apache.wicket.markup.html.list.ListView;import org.apache.wicket.markup.html.panel.Fragment;import org.apache.wicket.markup.html.panel.Panel;import org.apache.wicket.model.IModel;import org.apache.wicket.model.LoadableDetachableModel;import org.apache.wicket.model.Model;import org.apache.wicket.model.PropertyModel;import org.apache.wicket.protocol.http.WebSession;import org.apache.wicket.request.cycle.RequestCycle;import org.apache.wicket.util.lang.Bytes;import org.eclipse.jgit.lib.FileMode;import org.eclipse.jgit.lib.ObjectId;import org.unbescape.javascript.JavaScriptEscape;import com.google.common.base.Preconditions;import io.onedev.commons.utils.PathUtils;import io.onedev.commons.utils.StringUtils;import io.onedev.server.git.BlobIdent;import io.onedev.server.git.BlobIdentFilter;import io.onedev.server.git.exception.GitException;import io.onedev.server.model.Project;import io.onedev.server.util.UrlUtils;import io.onedev.server.web.ajaxlistener.ConfirmClickListener;import io.onedev.server.web.behavior.ReferenceInputBehavior;import io.onedev.server.web.component.blob.folderpicker.BlobFolderPicker;import io.onedev.server.web.component.blob.picker.BlobPicker;import io.onedev.server.web.component.dropzonefield.DropzoneField;import io.onedev.server.web.component.floating.FloatingPanel;import io.onedev.server.web.component.link.DropdownLink;import io.onedev.server.web.component.tabbable.AjaxActionTab;import io.onedev.server.web.component.tabbable.Tab;import io.onedev.server.web.component.tabbable.Tabbable;import io.onedev.server.web.page.project.blob.ProjectBlobPage;import io.onedev.server.web.page.project.blob.render.BlobRenderContext;@SuppressWarnings(\"serial\")abstract class InsertUrlPanel extends Panel {private static final MimetypesFileTypeMap MIME_TYPES = new MimetypesFileTypeMap();private static final MetaDataKey<String> ACTIVE_TAB = new MetaDataKey<String>(){};private static final MetaDataKey<String> UPLOAD_DIRECTORY = new MetaDataKey<String>(){};private static final MetaDataKey<HashSet<String>> FILE_PICKER_STATE = new MetaDataKey<HashSet<String>>(){};private static final MetaDataKey<HashSet<String>> FOLDER_PICKER_STATE = new MetaDataKey<HashSet<String>>(){};static final String TAB_INPUT_URL = \"Input URL\";static final String TAB_PICK_EXISTING = \"Pick Existing\";static final String TAB_UPLOAD = \"Upload\";private static final String CONTENT_ID = \"content\";private Collection<FileUpload> uploads;private String url;private String text;private String summaryCommitMessage;private String detailCommitMessage;private final MarkdownEditor markdownEditor;private final boolean isImage;public InsertUrlPanel(String id, MarkdownEditor markdownEditor, boolean isImage) {super(id);this.markdownEditor = markdownEditor;this.isImage = isImage;}private Component newInputUrlPanel() {Fragment fragment = new Fragment(CONTENT_ID, \"inputUrlFrag\", this) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.onInputUrlDomReady('%s');\", getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}};Form<?> form = new Form<Void>(\"form\");form.add(new FencedFeedbackPanel(\"feedback\", form));form.add(new Label(\"urlLabel\", isImage?\"Image URL\":\"Link URL\"));form.add(new Label(\"urlHelp\", isImage?\"Absolute or relative url of the image\":\"Absolute or relative url of the link\"));form.add(new TextField<String>(\"url\", new PropertyModel<String>(this, \"url\")));form.add(new Label(\"textLabel\", isImage?\"Image Text\": \"Link Text\"));form.add(new TextField<String>(\"text\", new PropertyModel<String>(this, \"text\")));form.add(new AjaxButton(\"insert\", form) {@Overrideprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {super.onSubmit(target, form);if (StringUtils.isBlank(url)) {if (isImage)error(\"Image URL should be specified\");elseerror(\"Link URL should be specified\");target.add(fragment);} else {if (text == null)text = UrlUtils.describe(url);markdownEditor.insertUrl(target, isImage, url, text, null);onClose(target);}}});fragment.add(form);fragment.setOutputMarkupId(true);return fragment;}private ObjectId resolveCommitId(BlobRenderContext context) {String revision = context.getBlobIdent().revision;if (revision == null)revision = \"master\";try {return context.getProject().getRepository().resolve(revision);} catch (IOException e) {throw new RuntimeException(e);}}private Set<BlobIdent> getPickerState(@Nullable ObjectId commitId, BlobIdent currentBlobIdent, @Nullable Set<String> expandedPaths) {Set<BlobIdent> pickerState = new HashSet<>();if (commitId != null) {if (expandedPaths != null) {for (String path: expandedPaths)pickerState.add(new BlobIdent(commitId.name(), path, FileMode.TREE.getBits()));} String parentPath;if (currentBlobIdent.isTree())parentPath = currentBlobIdent.path;else if (currentBlobIdent.path.contains(\"/\"))parentPath = StringUtils.substringBeforeLast(currentBlobIdent.path, \"/\");elseparentPath = null;while (parentPath != null) {pickerState.add(new BlobIdent(commitId.name(), parentPath, FileMode.TYPE_TREE));if (parentPath.contains(\"/\"))parentPath = StringUtils.substringBeforeLast(parentPath, \"/\");elseparentPath = null;}}return pickerState;}private Component newPickExistingPanel() {Fragment fragment;BlobRenderContext context = markdownEditor.getBlobRenderContext();if (context != null) {fragment = new Fragment(CONTENT_ID, \"pickBlobFrag\", this);BlobIdentFilter blobIdentFilter = new BlobIdentFilter() {@Overridepublic boolean filter(BlobIdent blobIdent) {if (isImage) {if (blobIdent.isTree()) {return true;} else {        String mimetype= MIME_TYPES.getContentType(new File(blobIdent.path));        return mimetype.split(\"/\")[0].equals(\"image\");}} else {return true;}}};ObjectId commitId = resolveCommitId(context);Set<BlobIdent> filePickerState = getPickerState(commitId, context.getBlobIdent(), WebSession.get().getMetaData(FILE_PICKER_STATE));fragment.add(new BlobPicker(\"files\", commitId) {@Overrideprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {blobIdent = new BlobIdent(context.getBlobIdent().revision, blobIdent.path, blobIdent.mode);String baseUrl = context.getDirectoryUrl();String referenceUrl = urlFor(ProjectBlobPage.class, ProjectBlobPage.paramsOf(context.getProject(), blobIdent)).toString();String relativized = PathUtils.relativize(baseUrl, referenceUrl);markdownEditor.insertUrl(target, isImage, relativized, UrlUtils.describe(blobIdent.getName()), null);onClose(target);}@Overrideprotected BlobIdentFilter getBlobIdentFilter() {return blobIdentFilter;}@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}@Overrideprotected void onStateChange() {HashSet<String> expandedPaths = new HashSet<>();for (BlobIdent blobIdent: filePickerState)expandedPaths.add(blobIdent.path);WebSession.get().setMetaData(FILE_PICKER_STATE, expandedPaths);}@Overrideprotected Set<BlobIdent> getState() {return filePickerState;}});} else {AttachmentSupport attachmentSupport = Preconditions.checkNotNull(markdownEditor.getAttachmentSupport());if (isImage) {fragment = new Fragment(CONTENT_ID, \"pickAttachedImageFrag\", this);fragment.add(new ListView<String>(\"attachments\", new LoadableDetachableModel<List<String>>() {@Overrideprotected List<String> load() {List<String> attachmentNames = new ArrayList<>();for (String attachmentName: attachmentSupport.getAttachments()) {if (markdownEditor.isWebSafeImage(attachmentName))attachmentNames.add(attachmentName);}return attachmentNames;}}) {@Overrideprotected void populateItem(final ListItem<String> item) {String attachmentName = item.getModelObject();String attachmentUrl = attachmentSupport.getAttachmentUrl(attachmentName);AjaxLink<Void> selectLink = new AjaxLink<Void>(\"select\") {@Overridepublic void onClick(AjaxRequestTarget target) {String displayName = UrlUtils.describe(attachmentName);markdownEditor.insertUrl(target, true, attachmentUrl, displayName, null);onClose(target);}};selectLink.add(new ExternalImage(\"image\", StringEscapeUtils.escapeHtml4(attachmentUrl)));item.add(selectLink);item.add(new AjaxLink<Void>(\"delete\") {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.getAjaxCallListeners().add(new ConfirmClickListener(\"Do you really want to delete '\" + attachmentName + \"'?\"));}@Overrideprotected void onConfigure() {super.onConfigure();setVisible(attachmentSupport.canDeleteAttachment());}@Overridepublic void onClick(AjaxRequestTarget target) {attachmentSupport.deleteAttachemnt(attachmentName);target.add(fragment);}});}});} else {fragment = new Fragment(CONTENT_ID, \"pickAttachedFileFrag\", this);fragment.add(new ListView<String>(\"attachments\", new LoadableDetachableModel<List<String>>() {@Overrideprotected List<String> load() {return attachmentSupport.getAttachments();}}) {@Overrideprotected void populateItem(final ListItem<String> item) {String attachmentName = item.getModelObject();String attachmentUrl = attachmentSupport.getAttachmentUrl(attachmentName);AjaxLink<Void> selectLink = new AjaxLink<Void>(\"select\") {@Overridepublic void onClick(AjaxRequestTarget target) {String displayName = UrlUtils.describe(attachmentName);markdownEditor.insertUrl(target, false, attachmentUrl, displayName, null);onClose(target);}};selectLink.add(new Label(\"file\", StringEscapeUtils.escapeHtml4(attachmentName)));item.add(selectLink);item.add(new AjaxLink<Void>(\"delete\") {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.getAjaxCallListeners().add(new ConfirmClickListener(\"Do you really want to delete '\" + attachmentName + \"'?\"));}@Overridepublic void onClick(AjaxRequestTarget target) {attachmentSupport.deleteAttachemnt(attachmentName);target.add(fragment);}});}});}}fragment.setOutputMarkupId(true);return fragment;}private Component newUploadPanel() {Fragment fragment;IModel<Collection<FileUpload>> model = new PropertyModel<Collection<FileUpload>>(this, \"uploads\");String acceptedFiles;if (isImage)acceptedFiles = \"image/*\";elseacceptedFiles = null;AttachmentSupport attachmentSupport = markdownEditor.getAttachmentSupport();if (attachmentSupport != null) {fragment = new Fragment(CONTENT_ID, \"uploadAttachmentFrag\", this);Form<?> form = new Form<Void>(\"form\") {@Overrideprotected void onSubmit() {super.onSubmit();AjaxRequestTarget target = RequestCycle.get().find(AjaxRequestTarget.class);String attachmentName;FileUpload upload = uploads.iterator().next();try (InputStream is = upload.getInputStream()) {attachmentName = attachmentSupport.saveAttachment(upload.getClientFileName(), is);} catch (IOException e) {throw new RuntimeException(e);}markdownEditor.insertUrl(target, isImage, attachmentSupport.getAttachmentUrl(attachmentName), UrlUtils.describe(attachmentName), null);onClose(target);}@Overrideprotected void onFileUploadException(FileUploadException e, Map<String, Object> model) {throw new RuntimeException(e);}};form.setMaxSize(Bytes.bytes(attachmentSupport.getAttachmentMaxSize()));form.setMultiPart(true);form.add(new FencedFeedbackPanel(\"feedback\", form));int maxFilesize = (int) (attachmentSupport.getAttachmentMaxSize()/1024/1024);if (maxFilesize <= 0)maxFilesize = 1;form.add(new DropzoneField(\"file\", model, acceptedFiles, 1, maxFilesize).setRequired(true).setLabel(Model.of(\"Attachment\")));form.add(new AjaxButton(\"insert\"){});fragment.add(form);} else {fragment = new Fragment(CONTENT_ID, \"uploadBlobFrag\", this);Form<?> form = new Form<Void>(\"form\");form.setMultiPart(true);form.setFileMaxSize(Bytes.megabytes(Project.MAX_UPLOAD_SIZE));add(form);FencedFeedbackPanel feedback = new FencedFeedbackPanel(\"feedback\", form);feedback.setOutputMarkupPlaceholderTag(true);form.add(feedback);form.add(new DropzoneField(\"file\", model, acceptedFiles, 1, Project.MAX_UPLOAD_SIZE).setRequired(true).setLabel(Model.of(\"Attachment\")));form.add(new TextField<String>(\"directory\", new IModel<String>() {@Overridepublic void detach() {}@Overridepublic String getObject() {return WebSession.get().getMetaData(UPLOAD_DIRECTORY);}@Overridepublic void setObject(String object) {WebSession.get().setMetaData(UPLOAD_DIRECTORY, object);}})); BlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());ObjectId commitId = resolveCommitId(context);Set<BlobIdent> folderPickerState = getPickerState(commitId, context.getBlobIdent(), WebSession.get().getMetaData(FOLDER_PICKER_STATE));form.add(new DropdownLink(\"select\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new BlobFolderPicker(id, commitId) {@Overrideprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {dropdown.close();String relativePath = PathUtils.relativize(context.getDirectory(), blobIdent.path);String script = String.format(\"$('form.upload-blob .directory input').val('%s');\", JavaScriptEscape.escapeJavaScript(relativePath));target.appendJavaScript(script);}@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}@Overrideprotected void onStateChange() {HashSet<String> expandedPaths = new HashSet<>();for (BlobIdent blobIdent: folderPickerState)expandedPaths.add(blobIdent.path);WebSession.get().setMetaData(FOLDER_PICKER_STATE, expandedPaths);}@Overrideprotected Set<BlobIdent> getState() {return folderPickerState;}};}});ReferenceInputBehavior behavior = new ReferenceInputBehavior(true) {@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}};form.add(new TextField<String>(\"summaryCommitMessage\", new PropertyModel<String>(this, \"summaryCommitMessage\")).add(behavior));behavior = new ReferenceInputBehavior(true) {@Overrideprotected Project getProject() {return markdownEditor.getBlobRenderContext().getProject();}};form.add(new TextArea<String>(\"detailCommitMessage\", new PropertyModel<String>(this, \"detailCommitMessage\")).add(behavior));form.add(new AjaxButton(\"insert\") {@Overrideprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {super.onSubmit(target, form);BlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());String commitMessage = summaryCommitMessage;if (StringUtils.isBlank(commitMessage))commitMessage = \"Add files via upload\";if (StringUtils.isNotBlank(detailCommitMessage))commitMessage += \"\\n\\n\" + detailCommitMessage;try {String directory = WebSession.get().getMetaData(UPLOAD_DIRECTORY);context.onCommitted(null, context.uploadFiles(uploads, directory, commitMessage), null);String fileName = uploads.iterator().next().getClientFileName();String url;if (directory != null) url = directory + \"/\" + UrlUtils.encodePath(fileName);else url = UrlUtils.encodePath(fileName);markdownEditor.insertUrl(target, isImage, url, UrlUtils.describe(fileName), null);onClose(target);} catch (GitException e) {form.error(e.getMessage());target.add(feedback);}}@Overrideprotected void onError(AjaxRequestTarget target, Form<?> form) {super.onError(target, form);target.add(feedback);}});fragment.add(form);}fragment.setOutputMarkupId(true);return fragment;}@Overrideprotected void onInitialize() {super.onInitialize();add(new Label(\"title\", isImage?\"Insert Image\":\"Insert Link\"));if (markdownEditor.getBlobRenderContext() == null && markdownEditor.getAttachmentSupport() == null) {add(newInputUrlPanel());} else {Fragment fragment = new Fragment(CONTENT_ID, \"tabbedFrag\", this);List<Tab> tabs = new ArrayList<>();AjaxActionTab inputUrlTab = new AjaxActionTab(Model.of(TAB_INPUT_URL)) {@Overrideprotected void onSelect(AjaxRequestTarget target, Component tabLink) {Component content = newInputUrlPanel();target.add(content);fragment.replace(content);WebSession.get().setMetaData(ACTIVE_TAB, TAB_INPUT_URL);}};tabs.add(inputUrlTab);AjaxActionTab pickExistingTab = new AjaxActionTab(Model.of(TAB_PICK_EXISTING)) {@Overrideprotected void onSelect(AjaxRequestTarget target, Component tabLink) {Component content = newPickExistingPanel();target.add(content);fragment.replace(content);WebSession.get().setMetaData(ACTIVE_TAB, TAB_PICK_EXISTING);}};tabs.add(pickExistingTab);AjaxActionTab uploadTab = new AjaxActionTab(Model.of(TAB_UPLOAD)) {@Overrideprotected void onSelect(AjaxRequestTarget target, Component tabLink) {Component content = newUploadPanel();target.add(content);fragment.replace(content);WebSession.get().setMetaData(ACTIVE_TAB, TAB_UPLOAD);}};tabs.add(uploadTab);fragment.add(new Tabbable(\"tabs\", tabs));inputUrlTab.setSelected(false);String activeTab = WebSession.get().getMetaData(ACTIVE_TAB);if (TAB_PICK_EXISTING.equals(activeTab)) {pickExistingTab.setSelected(true);fragment.add(newPickExistingPanel());} else if (TAB_UPLOAD.equals(activeTab)) {uploadTab.setSelected(true);fragment.add(newUploadPanel());} else {inputUrlTab.setSelected(true);fragment.add(newInputUrlPanel());}add(fragment);}add(new AjaxLink<Void>(\"close\") {@Overridepublic void onClick(AjaxRequestTarget target) {onClose(target);}});}protected abstract void onClose(AjaxRequestTarget target);}"}
{"code": "import static org.apache.wicket.ajax.attributes.CallbackParameter.explicit;import java.io.IOException;import java.io.Serializable;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.annotation.Nullable;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.text.StringEscapeUtils;import org.apache.wicket.AttributeModifier;import org.apache.wicket.Component;import org.apache.wicket.ajax.AjaxChannel;import org.apache.wicket.ajax.AjaxRequestTarget;import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;import org.apache.wicket.behavior.AttributeAppender;import org.apache.wicket.markup.ComponentTag;import org.apache.wicket.markup.head.IHeaderResponse;import org.apache.wicket.markup.head.JavaScriptHeaderItem;import org.apache.wicket.markup.head.OnDomReadyHeaderItem;import org.apache.wicket.markup.head.OnLoadHeaderItem;import org.apache.wicket.markup.html.WebMarkupContainer;import org.apache.wicket.markup.html.basic.Label;import org.apache.wicket.markup.html.form.FormComponentPanel;import org.apache.wicket.markup.html.form.TextArea;import org.apache.wicket.markup.html.panel.Fragment;import org.apache.wicket.model.IModel;import org.apache.wicket.model.LoadableDetachableModel;import org.apache.wicket.model.Model;import org.apache.wicket.request.IRequestParameters;import org.apache.wicket.request.cycle.RequestCycle;import org.apache.wicket.request.http.WebRequest;import org.apache.wicket.request.mapper.parameter.PageParameters;import org.apache.wicket.request.resource.PackageResourceReference;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.unbescape.javascript.JavaScriptEscape;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.base.Preconditions;import io.onedev.commons.launcher.loader.AppLoader;import io.onedev.server.OneDev;import io.onedev.server.entitymanager.ProjectManager;import io.onedev.server.model.Build;import io.onedev.server.model.Issue;import io.onedev.server.model.Project;import io.onedev.server.model.PullRequest;import io.onedev.server.model.User;import io.onedev.server.util.FilenameUtils;import io.onedev.server.util.markdown.MarkdownManager;import io.onedev.server.util.validation.ProjectNameValidator;import io.onedev.server.web.avatar.AvatarManager;import io.onedev.server.web.behavior.AbstractPostAjaxBehavior;import io.onedev.server.web.component.floating.FloatingPanel;import io.onedev.server.web.component.link.DropdownLink;import io.onedev.server.web.component.markdown.emoji.EmojiOnes;import io.onedev.server.web.component.modal.ModalPanel;import io.onedev.server.web.page.project.ProjectPage;import io.onedev.server.web.page.project.blob.render.BlobRenderContext;@SuppressWarnings(\"serial\")public class MarkdownEditor extends FormComponentPanel<String> {protected static final int ATWHO_LIMIT = 10;private static final Logger logger = LoggerFactory.getLogger(MarkdownEditor.class);private final boolean compactMode;private final boolean initialSplit;private final BlobRenderContext blobRenderContext;private WebMarkupContainer container;private TextArea<String> input;private AbstractPostAjaxBehavior actionBehavior;private AbstractPostAjaxBehavior attachmentUploadBehavior;public MarkdownEditor(String id, IModel<String> model, boolean compactMode, @Nullable BlobRenderContext blobRenderContext) {super(id, model);this.compactMode = compactMode;String cookieKey;if (compactMode)cookieKey = \"markdownEditor.compactMode.split\";elsecookieKey = \"markdownEditor.normalMode.split\";WebRequest request = (WebRequest) RequestCycle.get().getRequest();Cookie cookie = request.getCookie(cookieKey);initialSplit = cookie!=null && \"true\".equals(cookie.getValue());this.blobRenderContext = blobRenderContext;}@Overrideprotected void onModelChanged() {super.onModelChanged();input.setModelObject(getModelObject());}public void clearMarkdown() {setModelObject(\"\");input.setConvertedInput(null);}private String renderInput(String input) {if (StringUtils.isNotBlank(input)) {input = StringUtils.replace(input, \"\\r\\n\", \"\\n\");return renderMarkdown(input);} else {return \"<div class='message'>Nothing to preview</div>\";}}protected String renderMarkdown(String markdown) {Project project ;if (getPage() instanceof ProjectPage)project = ((ProjectPage) getPage()).getProject();elseproject = null;MarkdownManager manager = OneDev.getInstance(MarkdownManager.class);return manager.process(manager.render(markdown), project, blobRenderContext);}@Overrideprotected void onInitialize() {super.onInitialize();container = new WebMarkupContainer(\"container\");container.setOutputMarkupId(true);add(container);WebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");WebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");WebMarkupContainer preview = new WebMarkupContainer(\"preview\");WebMarkupContainer edit = new WebMarkupContainer(\"edit\");container.add(editLink);container.add(splitLink);container.add(preview);container.add(edit);container.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));container.add(new DropdownLink(\"doReference\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}}.setVisible(getReferenceSupport() != null));container.add(new DropdownLink(\"actionMenuTrigger\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {@Overrideprotected void onInitialize() {super.onInitialize();add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));if (getReferenceSupport() != null) add(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));else add(new WebMarkupContainer(\"doReference\").setVisible(false));}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}});container.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));edit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));for (AttributeModifier modifier: getInputModifiers()) input.add(modifier);if (initialSplit) {container.add(AttributeAppender.append(\"class\", \"split-mode\"));preview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {@Overrideprotected String load() {return renderInput(input.getConvertedInput());}}) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", container.getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setEscapeModelStrings(false));splitLink.add(AttributeAppender.append(\"class\", \"active\"));} else {container.add(AttributeAppender.append(\"class\", \"edit-mode\"));preview.add(new WebMarkupContainer(\"rendered\"));editLink.add(AttributeAppender.append(\"class\", \"active\"));}container.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));container.add(actionBehavior = new AbstractPostAjaxBehavior() {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));}@Overrideprotected void respond(AjaxRequestTarget target) {IRequestParameters params = RequestCycle.get().getRequest().getPostParameters();String action = params.getParameterValue(\"action\").toString(\"\");switch (action) {case \"render\":String markdown = params.getParameterValue(\"param1\").toString();String rendered = renderInput(markdown);String script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", container.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));target.appendJavaScript(script);break;case \"emojiQuery\":List<String> emojiNames = new ArrayList<>();String emojiQuery = params.getParameterValue(\"param1\").toOptionalString();if (StringUtils.isNotBlank(emojiQuery)) {emojiQuery = emojiQuery.toLowerCase();for (String emojiName: EmojiOnes.getInstance().all().keySet()) {if (emojiName.toLowerCase().contains(emojiQuery))emojiNames.add(emojiName);}emojiNames.sort((name1, name2) -> name1.length() - name2.length());} else {emojiNames.add(\"smile\");emojiNames.add(\"worried\");emojiNames.add(\"blush\");emojiNames.add(\"+1\");emojiNames.add(\"-1\");}List<Map<String, String>> emojis = new ArrayList<>();for (String emojiName: emojiNames) {if (emojis.size() < ATWHO_LIMIT) {String emojiCode = EmojiOnes.getInstance().all().get(emojiName);CharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", emojiName);emoji.put(\"url\", url.toString());emojis.add(emoji);}}String json;try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"loadEmojis\":emojis = new ArrayList<>();String urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,        \"icon/FILENAME.png\"), new PageParameters()).toString();for (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", entry.getKey());emoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));emojis.add(emoji);}try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"userQuery\":String userQuery = params.getParameterValue(\"param1\").toOptionalString();AvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);List<Map<String, String>> userList = new ArrayList<>();for (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {Map<String, String> userMap = new HashMap<>();userMap.put(\"name\", user.getName());if (user.getFullName() != null)userMap.put(\"fullName\", user.getFullName());String noSpaceName = StringUtils.deleteWhitespace(user.getName());if (user.getFullName() != null) {String noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());userMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);} else {userMap.put(\"searchKey\", noSpaceName);}String avatarUrl = avatarManager.getAvatarUrl(user);userMap.put(\"avatarUrl\", avatarUrl);userList.add(userMap);}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"referenceQuery\":String referenceQuery = params.getParameterValue(\"param1\").toOptionalString();String referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();String referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();List<Map<String, String>> referenceList = new ArrayList<>();Project referenceProject;if (StringUtils.isNotBlank(referenceProjectName)) referenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);elsereferenceProject = null;if (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {if (\"issue\".equals(referenceQueryType)) {for (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"issue\");referenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));referenceMap.put(\"referenceTitle\", issue.getTitle());referenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));referenceList.add(referenceMap);}} else if (\"pullrequest\".equals(referenceQueryType)) {for (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"pull request\");referenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));referenceMap.put(\"referenceTitle\", request.getTitle());referenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));referenceList.add(referenceMap);}} else if (\"build\".equals(referenceQueryType)) {for (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"build\");referenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));String title;if (build.getVersion() != null) title = \"(\" + build.getVersion() + \") \" + build.getJobName();elsetitle = build.getJobName();referenceMap.put(\"referenceTitle\", title);referenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));referenceList.add(referenceMap);}}}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"selectImage\":case \"selectLink\":new ModalPanel(target) {@Overrideprotected Component newContent(String id) {return new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {@Overrideprotected void onClose(AjaxRequestTarget target) {close();}};}@Overrideprotected void onClosed() {super.onClosed();AjaxRequestTarget target = Preconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));target.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));}};break;case \"insertUrl\":String name;try {name = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());} catch (UnsupportedEncodingException e) {throw new RuntimeException(e);}String replaceMessage = params.getParameterValue(\"param2\").toString();String url = getAttachmentSupport().getAttachmentUrl(name);insertUrl(target, isWebSafeImage(name), url, name, replaceMessage);break;default:throw new IllegalStateException(\"Unknown action: \" + action);}}});container.add(attachmentUploadBehavior = new AbstractPostAjaxBehavior() {@Overrideprotected void respond(AjaxRequestTarget target) {Preconditions.checkNotNull(getAttachmentSupport(), \"Unexpected attachment upload request\");HttpServletRequest request = (HttpServletRequest) RequestCycle.get().getRequest().getContainerRequest();HttpServletResponse response = (HttpServletResponse) RequestCycle.get().getResponse().getContainerResponse();try {String fileName = FilenameUtils.sanitizeFilename(URLDecoder.decode(request.getHeader(\"File-Name\"), StandardCharsets.UTF_8.name()));String attachmentName = getAttachmentSupport().saveAttachment(fileName, request.getInputStream());response.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));response.setStatus(HttpServletResponse.SC_OK);} catch (Exception e) {logger.error(\"Error uploading attachment.\", e);try {if (e.getMessage() != null)response.getWriter().print(e.getMessage());elseresponse.getWriter().print(\"Internal server error\");} catch (IOException e2) {throw new RuntimeException(e2);}response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);}}});}@Overrideprotected void onComponentTag(ComponentTag tag) {super.onComponentTag(tag);}@Overridepublic void convertInput() {setConvertedInput(input.getConvertedInput());}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);response.render(JavaScriptHeaderItem.forReference(new MarkdownResourceReference()));String actionCallback = actionBehavior.getCallbackFunction(explicit(\"action\"), explicit(\"param1\"), explicit(\"param2\"), explicit(\"param3\")).toString();String attachmentUploadUrl = attachmentUploadBehavior.getCallbackUrl().toString();String autosaveKey = getAutosaveKey();if (autosaveKey != null)autosaveKey = \"'\" + JavaScriptEscape.escapeJavaScript(autosaveKey) + \"'\";elseautosaveKey = \"undefined\";String script = String.format(\"onedev.server.markdown.onDomReady('%s', %s, %d, %s, %d, %b, %b, '%s', %s);\", container.getMarkupId(), actionCallback, ATWHO_LIMIT, getAttachmentSupport()!=null? \"'\" + attachmentUploadUrl + \"'\": \"undefined\", getAttachmentSupport()!=null? getAttachmentSupport().getAttachmentMaxSize(): 0,getUserMentionSupport() != null,getReferenceSupport() != null, JavaScriptEscape.escapeJavaScript(ProjectNameValidator.PATTERN.pattern()),autosaveKey);response.render(OnDomReadyHeaderItem.forScript(script));script = String.format(\"onedev.server.markdown.onLoad('%s');\", container.getMarkupId());response.render(OnLoadHeaderItem.forScript(script));}public void insertUrl(AjaxRequestTarget target, boolean isImage, String url, String name, @Nullable String replaceMessage) {String script = String.format(\"onedev.server.markdown.insertUrl('%s', %s, '%s', '%s', %s);\",container.getMarkupId(), isImage, StringEscapeUtils.escapeEcmaScript(url), StringEscapeUtils.escapeEcmaScript(name), replaceMessage!=null?\"'\"+replaceMessage+\"'\":\"undefined\");target.appendJavaScript(script);}public boolean isWebSafeImage(String fileName) {fileName = fileName.toLowerCase();return fileName.endsWith(\".jpg\") || fileName.endsWith(\".jpeg\") || fileName.endsWith(\".gif\") || fileName.endsWith(\".png\");}@Nullableprotected AttachmentSupport getAttachmentSupport() {return null;}@Nullableprotected UserMentionSupport getUserMentionSupport() {return null;}@Nullableprotected AtWhoReferenceSupport getReferenceSupport() {return null;}protected List<AttributeModifier> getInputModifiers() {return new ArrayList<>();}@Nullableprotected String getAutosaveKey() {return null;}@Nullablepublic BlobRenderContext getBlobRenderContext() {return blobRenderContext;}static class ReferencedEntity implements Serializable {String entityType;String entityTitle;String entityNumber;String searchKey;}}", "nl": "import static org.apache.wicket.ajax.attributes.CallbackParameter.explicit;import java.io.IOException;import java.io.Serializable;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.annotation.Nullable;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.text.StringEscapeUtils;import org.apache.wicket.AttributeModifier;import org.apache.wicket.Component;import org.apache.wicket.ajax.AjaxChannel;import org.apache.wicket.ajax.AjaxRequestTarget;import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;import org.apache.wicket.behavior.AttributeAppender;import org.apache.wicket.markup.ComponentTag;import org.apache.wicket.markup.head.IHeaderResponse;import org.apache.wicket.markup.head.JavaScriptHeaderItem;import org.apache.wicket.markup.head.OnDomReadyHeaderItem;import org.apache.wicket.markup.head.OnLoadHeaderItem;import org.apache.wicket.markup.html.WebMarkupContainer;import org.apache.wicket.markup.html.basic.Label;import org.apache.wicket.markup.html.form.FormComponentPanel;import org.apache.wicket.markup.html.form.TextArea;import org.apache.wicket.markup.html.panel.Fragment;import org.apache.wicket.model.IModel;import org.apache.wicket.model.LoadableDetachableModel;import org.apache.wicket.model.Model;import org.apache.wicket.request.IRequestParameters;import org.apache.wicket.request.cycle.RequestCycle;import org.apache.wicket.request.http.WebRequest;import org.apache.wicket.request.mapper.parameter.PageParameters;import org.apache.wicket.request.resource.PackageResourceReference;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.unbescape.javascript.JavaScriptEscape;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.common.base.Preconditions;import io.onedev.commons.launcher.loader.AppLoader;import io.onedev.server.OneDev;import io.onedev.server.entitymanager.ProjectManager;import io.onedev.server.model.Build;import io.onedev.server.model.Issue;import io.onedev.server.model.Project;import io.onedev.server.model.PullRequest;import io.onedev.server.model.User;import io.onedev.server.util.markdown.MarkdownManager;import io.onedev.server.util.validation.ProjectNameValidator;import io.onedev.server.web.avatar.AvatarManager;import io.onedev.server.web.behavior.AbstractPostAjaxBehavior;import io.onedev.server.web.component.floating.FloatingPanel;import io.onedev.server.web.component.link.DropdownLink;import io.onedev.server.web.component.markdown.emoji.EmojiOnes;import io.onedev.server.web.component.modal.ModalPanel;import io.onedev.server.web.page.project.ProjectPage;import io.onedev.server.web.page.project.blob.render.BlobRenderContext;@SuppressWarnings(\"serial\")public class MarkdownEditor extends FormComponentPanel<String> {protected static final int ATWHO_LIMIT = 10;private static final Logger logger = LoggerFactory.getLogger(MarkdownEditor.class);private final boolean compactMode;private final boolean initialSplit;private final BlobRenderContext blobRenderContext;private WebMarkupContainer container;private TextArea<String> input;private AbstractPostAjaxBehavior actionBehavior;private AbstractPostAjaxBehavior attachmentUploadBehavior;public MarkdownEditor(String id, IModel<String> model, boolean compactMode, @Nullable BlobRenderContext blobRenderContext) {super(id, model);this.compactMode = compactMode;String cookieKey;if (compactMode)cookieKey = \"markdownEditor.compactMode.split\";elsecookieKey = \"markdownEditor.normalMode.split\";WebRequest request = (WebRequest) RequestCycle.get().getRequest();Cookie cookie = request.getCookie(cookieKey);initialSplit = cookie!=null && \"true\".equals(cookie.getValue());this.blobRenderContext = blobRenderContext;}@Overrideprotected void onModelChanged() {super.onModelChanged();input.setModelObject(getModelObject());}public void clearMarkdown() {setModelObject(\"\");input.setConvertedInput(null);}private String renderInput(String input) {if (StringUtils.isNotBlank(input)) {input = StringUtils.replace(input, \"\\r\\n\", \"\\n\");return renderMarkdown(input);} else {return \"<div class='message'>Nothing to preview</div>\";}}protected String renderMarkdown(String markdown) {Project project ;if (getPage() instanceof ProjectPage)project = ((ProjectPage) getPage()).getProject();elseproject = null;MarkdownManager manager = OneDev.getInstance(MarkdownManager.class);return manager.process(manager.render(markdown), project, blobRenderContext);}@Overrideprotected void onInitialize() {super.onInitialize();container = new WebMarkupContainer(\"container\");container.setOutputMarkupId(true);add(container);WebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");WebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");WebMarkupContainer preview = new WebMarkupContainer(\"preview\");WebMarkupContainer edit = new WebMarkupContainer(\"edit\");container.add(editLink);container.add(splitLink);container.add(preview);container.add(edit);container.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));container.add(new DropdownLink(\"doReference\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}}.setVisible(getReferenceSupport() != null));container.add(new DropdownLink(\"actionMenuTrigger\") {@Overrideprotected Component newContent(String id, FloatingPanel dropdown) {return new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {@Overrideprotected void onInitialize() {super.onInitialize();add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));if (getReferenceSupport() != null) add(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));else add(new WebMarkupContainer(\"doReference\").setVisible(false));}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", container.getMarkupId(), getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setOutputMarkupId(true);}});container.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));edit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));for (AttributeModifier modifier: getInputModifiers()) input.add(modifier);if (initialSplit) {container.add(AttributeAppender.append(\"class\", \"split-mode\"));preview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {@Overrideprotected String load() {return renderInput(input.getConvertedInput());}}) {@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);String script = String.format(\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", container.getMarkupId());response.render(OnDomReadyHeaderItem.forScript(script));}}.setEscapeModelStrings(false));splitLink.add(AttributeAppender.append(\"class\", \"active\"));} else {container.add(AttributeAppender.append(\"class\", \"edit-mode\"));preview.add(new WebMarkupContainer(\"rendered\"));editLink.add(AttributeAppender.append(\"class\", \"active\"));}container.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));container.add(actionBehavior = new AbstractPostAjaxBehavior() {@Overrideprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {super.updateAjaxAttributes(attributes);attributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));}@Overrideprotected void respond(AjaxRequestTarget target) {IRequestParameters params = RequestCycle.get().getRequest().getPostParameters();String action = params.getParameterValue(\"action\").toString(\"\");switch (action) {case \"render\":String markdown = params.getParameterValue(\"param1\").toString();String rendered = renderInput(markdown);String script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", container.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));target.appendJavaScript(script);break;case \"emojiQuery\":List<String> emojiNames = new ArrayList<>();String emojiQuery = params.getParameterValue(\"param1\").toOptionalString();if (StringUtils.isNotBlank(emojiQuery)) {emojiQuery = emojiQuery.toLowerCase();for (String emojiName: EmojiOnes.getInstance().all().keySet()) {if (emojiName.toLowerCase().contains(emojiQuery))emojiNames.add(emojiName);}emojiNames.sort((name1, name2) -> name1.length() - name2.length());} else {emojiNames.add(\"smile\");emojiNames.add(\"worried\");emojiNames.add(\"blush\");emojiNames.add(\"+1\");emojiNames.add(\"-1\");}List<Map<String, String>> emojis = new ArrayList<>();for (String emojiName: emojiNames) {if (emojis.size() < ATWHO_LIMIT) {String emojiCode = EmojiOnes.getInstance().all().get(emojiName);CharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", emojiName);emoji.put(\"url\", url.toString());emojis.add(emoji);}}String json;try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"loadEmojis\":emojis = new ArrayList<>();String urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,        \"icon/FILENAME.png\"), new PageParameters()).toString();for (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {Map<String, String> emoji = new HashMap<>();emoji.put(\"name\", entry.getKey());emoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));emojis.add(emoji);}try {json = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"userQuery\":String userQuery = params.getParameterValue(\"param1\").toOptionalString();AvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);List<Map<String, String>> userList = new ArrayList<>();for (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {Map<String, String> userMap = new HashMap<>();userMap.put(\"name\", user.getName());if (user.getFullName() != null)userMap.put(\"fullName\", user.getFullName());String noSpaceName = StringUtils.deleteWhitespace(user.getName());if (user.getFullName() != null) {String noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());userMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);} else {userMap.put(\"searchKey\", noSpaceName);}String avatarUrl = avatarManager.getAvatarUrl(user);userMap.put(\"avatarUrl\", avatarUrl);userList.add(userMap);}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"referenceQuery\":String referenceQuery = params.getParameterValue(\"param1\").toOptionalString();String referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();String referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();List<Map<String, String>> referenceList = new ArrayList<>();Project referenceProject;if (StringUtils.isNotBlank(referenceProjectName)) referenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);elsereferenceProject = null;if (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {if (\"issue\".equals(referenceQueryType)) {for (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"issue\");referenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));referenceMap.put(\"referenceTitle\", issue.getTitle());referenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));referenceList.add(referenceMap);}} else if (\"pullrequest\".equals(referenceQueryType)) {for (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"pull request\");referenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));referenceMap.put(\"referenceTitle\", request.getTitle());referenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));referenceList.add(referenceMap);}} else if (\"build\".equals(referenceQueryType)) {for (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {Map<String, String> referenceMap = new HashMap<>();referenceMap.put(\"referenceType\", \"build\");referenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));String title;if (build.getVersion() != null) title = \"(\" + build.getVersion() + \") \" + build.getJobName();elsetitle = build.getJobName();referenceMap.put(\"referenceTitle\", title);referenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));referenceList.add(referenceMap);}}}try {json = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);} catch (JsonProcessingException e) {throw new RuntimeException(e);}script = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);target.appendJavaScript(script);break;case \"selectImage\":case \"selectLink\":new ModalPanel(target) {@Overrideprotected Component newContent(String id) {return new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {@Overrideprotected void onClose(AjaxRequestTarget target) {close();}};}@Overrideprotected void onClosed() {super.onClosed();AjaxRequestTarget target = Preconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));target.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));}};break;case \"insertUrl\":String name;try {name = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());} catch (UnsupportedEncodingException e) {throw new RuntimeException(e);}String replaceMessage = params.getParameterValue(\"param2\").toString();String url = getAttachmentSupport().getAttachmentUrl(name);insertUrl(target, isWebSafeImage(name), url, name, replaceMessage);break;default:throw new IllegalStateException(\"Unknown action: \" + action);}}});container.add(attachmentUploadBehavior = new AbstractPostAjaxBehavior() {@Overrideprotected void respond(AjaxRequestTarget target) {Preconditions.checkNotNull(getAttachmentSupport(), \"Unexpected attachment upload request\");HttpServletRequest request = (HttpServletRequest) RequestCycle.get().getRequest().getContainerRequest();HttpServletResponse response = (HttpServletResponse) RequestCycle.get().getResponse().getContainerResponse();try {String fileName = URLDecoder.decode(request.getHeader(\"File-Name\"), StandardCharsets.UTF_8.name());String attachmentName = getAttachmentSupport().saveAttachment(fileName, request.getInputStream());response.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));response.setStatus(HttpServletResponse.SC_OK);} catch (Exception e) {logger.error(\"Error uploading attachment.\", e);try {if (e.getMessage() != null)response.getWriter().print(e.getMessage());elseresponse.getWriter().print(\"Internal server error\");} catch (IOException e2) {throw new RuntimeException(e2);}response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);}}});}@Overrideprotected void onComponentTag(ComponentTag tag) {super.onComponentTag(tag);}@Overridepublic void convertInput() {setConvertedInput(input.getConvertedInput());}@Overridepublic void renderHead(IHeaderResponse response) {super.renderHead(response);response.render(JavaScriptHeaderItem.forReference(new MarkdownResourceReference()));String actionCallback = actionBehavior.getCallbackFunction(explicit(\"action\"), explicit(\"param1\"), explicit(\"param2\"), explicit(\"param3\")).toString();String attachmentUploadUrl = attachmentUploadBehavior.getCallbackUrl().toString();String autosaveKey = getAutosaveKey();if (autosaveKey != null)autosaveKey = \"'\" + JavaScriptEscape.escapeJavaScript(autosaveKey) + \"'\";elseautosaveKey = \"undefined\";String script = String.format(\"onedev.server.markdown.onDomReady('%s', %s, %d, %s, %d, %b, %b, '%s', %s);\", container.getMarkupId(), actionCallback, ATWHO_LIMIT, getAttachmentSupport()!=null? \"'\" + attachmentUploadUrl + \"'\": \"undefined\", getAttachmentSupport()!=null? getAttachmentSupport().getAttachmentMaxSize(): 0,getUserMentionSupport() != null,getReferenceSupport() != null, JavaScriptEscape.escapeJavaScript(ProjectNameValidator.PATTERN.pattern()),autosaveKey);response.render(OnDomReadyHeaderItem.forScript(script));script = String.format(\"onedev.server.markdown.onLoad('%s');\", container.getMarkupId());response.render(OnLoadHeaderItem.forScript(script));}public void insertUrl(AjaxRequestTarget target, boolean isImage, String url, String name, @Nullable String replaceMessage) {String script = String.format(\"onedev.server.markdown.insertUrl('%s', %s, '%s', '%s', %s);\",container.getMarkupId(), isImage, StringEscapeUtils.escapeEcmaScript(url), StringEscapeUtils.escapeEcmaScript(name), replaceMessage!=null?\"'\"+replaceMessage+\"'\":\"undefined\");target.appendJavaScript(script);}public boolean isWebSafeImage(String fileName) {fileName = fileName.toLowerCase();return fileName.endsWith(\".jpg\") || fileName.endsWith(\".jpeg\") || fileName.endsWith(\".gif\") || fileName.endsWith(\".png\");}@Nullableprotected AttachmentSupport getAttachmentSupport() {return null;}@Nullableprotected UserMentionSupport getUserMentionSupport() {return null;}@Nullableprotected AtWhoReferenceSupport getReferenceSupport() {return null;}protected List<AttributeModifier> getInputModifiers() {return new ArrayList<>();}@Nullableprotected String getAutosaveKey() {return null;}@Nullablepublic BlobRenderContext getBlobRenderContext() {return blobRenderContext;}static class ReferencedEntity implements Serializable {String entityType;String entityTitle;String entityNumber;String searchKey;}}"}
{"code": "  import static org.apache.wicket.ajax.attributes.CallbackParameter.explicit;  import java.io.IOException; import java.io.Serializable; import java.net.URISyntaxException; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.atomic.AtomicBoolean;  import javax.annotation.Nullable;  import org.apache.commons.lang3.SerializationUtils; import org.apache.commons.lang3.StringUtils; import org.apache.http.NameValuePair; import org.apache.http.client.utils.URIBuilder; import org.apache.wicket.Component; import org.apache.wicket.ajax.AjaxRequestTarget; import org.apache.wicket.behavior.AttributeAppender; import org.apache.wicket.core.request.handler.IPartialPageRequestHandler; import org.apache.wicket.event.IEvent; import org.apache.wicket.markup.ComponentTag; import org.apache.wicket.markup.head.IHeaderResponse; import org.apache.wicket.markup.head.JavaScriptHeaderItem; import org.apache.wicket.markup.head.OnDomReadyHeaderItem; import org.apache.wicket.markup.html.WebMarkupContainer; import org.apache.wicket.markup.html.basic.Label; import org.apache.wicket.markup.html.form.upload.FileUpload; import org.apache.wicket.model.AbstractReadOnlyModel; import org.apache.wicket.model.IModel; import org.apache.wicket.model.Model; import org.apache.wicket.request.IRequestParameters; import org.apache.wicket.request.cycle.RequestCycle; import org.apache.wicket.request.flow.RedirectToUrlException; import org.apache.wicket.request.handler.resource.ResourceReferenceRequestHandler; import org.apache.wicket.request.mapper.parameter.PageParameters; import org.apache.wicket.util.visit.IVisit; import org.apache.wicket.util.visit.IVisitor; import org.eclipse.jgit.lib.FileMode; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevTree; import org.eclipse.jgit.revwalk.RevWalk; import org.eclipse.jgit.treewalk.TreeWalk; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Sets;  import io.onedev.commons.launcher.loader.ListenerRegistry; import io.onedev.commons.utils.PlanarRange; import io.onedev.server.OneDev; import io.onedev.server.buildspec.BuildSpec; import io.onedev.server.entitymanager.CodeCommentManager; import io.onedev.server.entitymanager.ProjectManager; import io.onedev.server.entitymanager.PullRequestManager; import io.onedev.server.entitymanager.PullRequestUpdateManager; import io.onedev.server.event.RefUpdated; import io.onedev.server.git.BlobContent; import io.onedev.server.git.BlobEdits; import io.onedev.server.git.BlobIdent; import io.onedev.server.git.GitUtils; import io.onedev.server.git.exception.BlobEditException; import io.onedev.server.git.exception.NotTreeException; import io.onedev.server.git.exception.ObjectAlreadyExistsException; import io.onedev.server.git.exception.ObsoleteCommitException; import io.onedev.server.model.CodeComment; import io.onedev.server.model.Project; import io.onedev.server.model.PullRequest; import io.onedev.server.model.User; import io.onedev.server.persistence.SessionManager; import io.onedev.server.persistence.TransactionManager; import io.onedev.server.search.code.CommitIndexed; import io.onedev.server.search.code.IndexManager; import io.onedev.server.search.code.SearchManager; import io.onedev.server.search.code.hit.QueryHit; import io.onedev.server.search.code.query.BlobQuery; import io.onedev.server.search.code.query.TextQuery; import io.onedev.server.security.SecurityUtils; import io.onedev.server.util.FilenameUtils; import io.onedev.server.util.script.identity.JobIdentity; import io.onedev.server.util.script.identity.ScriptIdentity; import io.onedev.server.util.script.identity.ScriptIdentityAware; import io.onedev.server.web.PrioritizedComponentRenderer; import io.onedev.server.web.behavior.AbstractPostAjaxBehavior; import io.onedev.server.web.behavior.WebSocketObserver; import io.onedev.server.web.component.commit.status.CommitStatusPanel; import io.onedev.server.web.component.floating.FloatingPanel; import io.onedev.server.web.component.link.DropdownLink; import io.onedev.server.web.component.link.ViewStateAwareAjaxLink; import io.onedev.server.web.component.link.ViewStateAwarePageLink; import io.onedev.server.web.component.menu.MenuItem; import io.onedev.server.web.component.menu.MenuLink; import io.onedev.server.web.component.modal.ModalLink; import io.onedev.server.web.component.modal.ModalPanel; import io.onedev.server.web.component.revisionpicker.RevisionPicker; import io.onedev.server.web.page.project.ProjectPage; import io.onedev.server.web.page.project.blob.navigator.BlobNavigator; import io.onedev.server.web.page.project.blob.render.BlobRenderContext; import io.onedev.server.web.page.project.blob.render.BlobRendererContribution; import io.onedev.server.web.page.project.blob.render.renderers.source.SourceRendererProvider; import io.onedev.server.web.page.project.blob.render.view.Positionable; import io.onedev.server.web.page.project.blob.search.SearchMenuContributor; import io.onedev.server.web.page.project.blob.search.advanced.AdvancedSearchPanel; import io.onedev.server.web.page.project.blob.search.quick.QuickSearchPanel; import io.onedev.server.web.page.project.blob.search.result.SearchResultPanel; import io.onedev.server.web.page.project.commits.ProjectCommitsPage; import io.onedev.server.web.resource.RawBlobResourceReference; import io.onedev.server.web.util.EditParamsAware; import io.onedev.server.web.websocket.WebSocketManager;  @SuppressWarnings(\"serial\") public class ProjectBlobPage extends ProjectPage implements BlobRenderContext, ScriptIdentityAware, EditParamsAware {  private static final String PARAM_REVISION = \"revision\";  private static final String PARAM_PATH = \"path\";  private static final String PARAM_INITIAL_NEW_PATH = \"initial-new-path\";  private static final String PARAM_REQUEST = \"request\";  private static final String PARAM_COMMENT = \"comment\";  private static final String PARAM_MODE = \"mode\";  private static final String PARAM_VIEW_PLAIN = \"view-plain\";  private static final String PARAM_URL_BEFORE_EDIT = \"url-before-edit\";  private static final String PARAM_URL_AFTER_EDIT = \"url-after-edit\";  private static final String PARAM_QUERY = \"query\";  private static final String PARAM_POSITION = \"position\";  private static final String PARAM_RAW = \"raw\";  private static final String REVISION_PICKER_ID = \"revisionPicker\";  private static final String BLOB_NAVIGATOR_ID = \"blobNavigator\";  private static final String BLOB_CONTENT_ID = \"blobContent\";  private static final Logger logger = LoggerFactory.getLogger(ProjectBlobPage.class);  private State state = new State();  private ObjectId resolvedRevision;  private Component revisionIndexing;  private WebMarkupContainer searchResult;  private AbstractPostAjaxBehavior ajaxBehavior;  public ProjectBlobPage(PageParameters params) { super(params);  List<String> revisionAndPathSegments = new ArrayList<>(); String segment = params.get(PARAM_REVISION).toString(); if (segment != null && segment.length() != 0) revisionAndPathSegments.add(segment); segment = params.get(PARAM_PATH).toString(); if (segment != null && segment.length() != 0) revisionAndPathSegments.add(segment);  for (int i=0; i<params.getIndexedCount(); i++) { segment = params.get(i).toString(); if (segment.length() != 0) revisionAndPathSegments.add(segment); }  BlobIdent blobIdent = new BlobIdent(getProject(), revisionAndPathSegments);  state = new State(blobIdent);  String modeStr = params.get(PARAM_MODE).toString(); if (modeStr != null) state.mode = Mode.valueOf(modeStr.toUpperCase());  String viewPlain = params.get(PARAM_VIEW_PLAIN).toString(); state.viewPlain = \"true\".equals(viewPlain);  state.urlBeforeEdit = params.get(PARAM_URL_BEFORE_EDIT).toString(); state.urlAfterEdit = params.get(PARAM_URL_AFTER_EDIT).toString();  if (state.blobIdent.revision != null) resolvedRevision = getProject().getRevCommit(state.blobIdent.revision, true).copy();  state.position = params.get(PARAM_POSITION).toString();  state.requestId = params.get(PARAM_REQUEST).toOptionalLong();  state.commentId = params.get(PARAM_COMMENT).toOptionalLong();  state.query = params.get(PARAM_QUERY).toString();  state.initialNewPath = params.get(PARAM_INITIAL_NEW_PATH).toString();  if (state.mode == Mode.ADD || state.mode == Mode.EDIT || state.mode == Mode.DELETE) { if (!isOnBranch())  throw new IllegalArgumentException(\"Files can only be edited on branch\");  String path = state.blobIdent.path; if (path != null && state.blobIdent.isTree()) path += \"/\"; if (!SecurityUtils.canModify(getProject(), state.blobIdent.revision, path)) unauthorized(); }  if (params.get(PARAM_RAW).toBoolean(false)) { RequestCycle.get().scheduleRequestHandlerAfterCurrent( new ResourceReferenceRequestHandler(new RawBlobResourceReference(), getPageParameters())); } }  @Override protected void onInitialize() { super.onInitialize();  newRevisionPicker(null); newCommitStatus(null); newBlobNavigator(null); newBlobOperations(null);  add(revisionIndexing = new WebMarkupContainer(\"revisionIndexing\") {  @Override protected void onConfigure() { super.onConfigure();  if (resolvedRevision != null) { RevCommit commit = getProject().getRevCommit(resolvedRevision, true); IndexManager indexManager = OneDev.getInstance(IndexManager.class); if (!indexManager.isIndexed(getProject(), commit)) { OneDev.getInstance(IndexManager.class).indexAsync(getProject(), commit); setVisible(true); } else { setVisible(false); } } else { setVisible(false); } }  }.setOutputMarkupPlaceholderTag(true));  revisionIndexing.add(new WebSocketObserver() {  @Override public void onObservableChanged(IPartialPageRequestHandler handler) { handler.add(revisionIndexing); resizeWindow(handler); }  @Override public Collection<String> getObservables() { Set<String> observables = new HashSet<>(); if (resolvedRevision != null)  observables.add(CommitIndexed.getWebSocketObservable(getProject().getRevCommit(resolvedRevision, true).name())); return observables; }  });  newBuildSupportNote(null); newBlobContent(null);  add(searchResult = new WebMarkupContainer(\"searchResult\"));  List<QueryHit> queryHits; if (state.query != null) { BlobQuery query = new TextQuery.Builder() .term(state.query) .wholeWord(true) .caseSensitive(true)  .count(SearchResultPanel.MAX_QUERY_ENTRIES) .build(); try { SearchManager searchManager = OneDev.getInstance(SearchManager.class); queryHits = searchManager.search(projectModel.getObject(), getProject().getRevCommit(resolvedRevision, true),  query); } catch (InterruptedException e) { throw new RuntimeException(e); } } else { queryHits = null; }  newSearchResult(null, queryHits);  add(ajaxBehavior = new AbstractPostAjaxBehavior() {  @Override protected void respond(AjaxRequestTarget target) { IRequestParameters params = RequestCycle.get().getRequest().getPostParameters();  String action = params.getParameterValue(\"action\").toString(\"\"); switch (action) { case \"quickSearch\":  new ModalPanel(target) {  @Override protected Component newContent(String id) { return newQuickSearchPanel(id, this); }  }; break; case \"advancedSearch\": new ModalPanel(target) {  @Override protected Component newContent(String id) { return newAdvancedSearchPanel(id, this); }  }; break; case \"permalink\": if (isOnBranch()) { BlobIdent newBlobIdent = new BlobIdent(state.blobIdent); newBlobIdent.revision = resolvedRevision.name(); ProjectBlobPage.this.onSelect(target, newBlobIdent, null); } break; default: throw new IllegalStateException(\"Unexpected action: \" + action); } }  }); }   @Override protected Map<String, ObjectId> getObjectIdCache() { Map<String, ObjectId> objectIdCache = new HashMap<>(); if (resolvedRevision != null) objectIdCache.put(state.blobIdent.revision, resolvedRevision); return objectIdCache; }  @Override public CodeComment getOpenComment() { if (state.commentId != null) return OneDev.getInstance(CodeCommentManager.class).load(state.commentId); else return null; }  @Override public PullRequest getPullRequest() { if (state.requestId != null) return OneDev.getInstance(PullRequestManager.class).load(state.requestId); else return null; }  private void newBlobNavigator(@Nullable AjaxRequestTarget target) { Component blobNavigator = new BlobNavigator(BLOB_NAVIGATOR_ID, this); if (target != null) { replace(blobNavigator); target.add(blobNavigator); } else { add(blobNavigator); } }  private void newBlobOperations(@Nullable AjaxRequestTarget target) { WebMarkupContainer blobOperations = new WebMarkupContainer(\"blobOperations\"); blobOperations.setOutputMarkupId(true);  String revision = state.blobIdent.revision;  AtomicBoolean reviewRequired = new AtomicBoolean(true); try { reviewRequired.set(revision!=null && getProject().isReviewRequiredForModification(getLoginUser(), revision, null));  } catch (Exception e) { logger.error(\"Error checking review requirement\", e); }  AtomicBoolean buildRequired = new AtomicBoolean(true); try { buildRequired.set(revision!=null && getProject().isBuildRequiredForModification(getLoginUser(), revision, null)); } catch (Exception e) { logger.error(\"Error checking build requirement\", e); }  blobOperations.add(new MenuLink(\"add\") {  @Override protected List<MenuItem> getMenuItems(FloatingPanel dropdown) { List<MenuItem> menuItems = new ArrayList<>(); menuItems.add(new MenuItem() {  @Override public String getLabel() { return \"Create New File\"; }  @Override public WebMarkupContainer newLink(String id) { return new ViewStateAwareAjaxLink<Void>(id) {  @Override public void onClick(AjaxRequestTarget target) { onModeChange(target, Mode.ADD, null); dropdown.close(); }  }; }  });  menuItems.add(new MenuItem() {  @Override public String getLabel() { return \"Upload Files\"; }  @Override public WebMarkupContainer newLink(String id) { return new ModalLink(id) {  @Override public void onClick(AjaxRequestTarget target) { super.onClick(target); dropdown.close(); }  @Override protected Component newContent(String id, ModalPanel modal) { return new BlobUploadPanel(id, ProjectBlobPage.this) {  @Override public void onCancel(AjaxRequestTarget target) { modal.close(); }  @Override public void onCommitted(AjaxRequestTarget target, RefUpdated refUpdated) { ProjectBlobPage.this.onCommitted(target, refUpdated, null); modal.close(); }  }; }  }; }  }); return menuItems; }  @Override protected void onComponentTag(ComponentTag tag) { super.onComponentTag(tag);  if (reviewRequired.get()) { tag.append(\"class\", \"disabled\", \" \"); tag.put(\"title\", \"Review required for this change. Submit pull request instead\"); } else if (buildRequired.get()) { tag.append(\"class\", \"disabled\", \" \"); tag.put(\"title\", \"Build required for this change. Submit pull request instead\"); } else { tag.put(\"title\", \"Add on branch \" + state.blobIdent.revision); } }  @Override protected void onConfigure() { super.onConfigure();  Project project = getProject(); if ((state.mode == Mode.VIEW || state.mode == Mode.BLAME)  && isOnBranch() && state.blobIdent.isTree()  && SecurityUtils.canWriteCode(project)) { setVisible(true); setEnabled(!reviewRequired.get() && !buildRequired.get()); } else { setVisible(false); } }  });  blobOperations.add(new MenuLink(\"search\") {  @Override protected List<MenuItem> getMenuItems(FloatingPanel dropdown) { List<MenuItem> menuItems = new ArrayList<>(); menuItems.add(new MenuItem() {  @Override public String getShortcut() { return \"T\"; }  @Override public String getLabel() { return \"Quick Search\"; }  @Override public WebMarkupContainer newLink(String id) { return new ModalLink(id) {  @Override public void onClick(AjaxRequestTarget target) { super.onClick(target); dropdown.close(); }  @Override protected Component newContent(String id, ModalPanel modal) { return newQuickSearchPanel(id, modal); }  }; }  }); menuItems.add(new MenuItem() {  @Override public String getShortcut() { return \"V\"; }  @Override public String getLabel() { return \"Advanced Search\"; }  @Override public WebMarkupContainer newLink(String id) { return new ModalLink(id) {  @Override public void onClick(AjaxRequestTarget target) { super.onClick(target); dropdown.close(); }  @Override protected Component newContent(String id, ModalPanel modal) { return newAdvancedSearchPanel(id, modal); }  }; }  });  IVisitor<Component, Component> visitor = new IVisitor<Component, Component>() {  @Override public void component(Component object, IVisit<Component> visit) { visit.stop(object); }  }; SearchMenuContributor contributor = (SearchMenuContributor) getPage().visitChildren( SearchMenuContributor.class, visitor); if (contributor != null) menuItems.addAll(contributor.getMenuItems(dropdown));  return menuItems; }  });  String compareWith = resolvedRevision!=null?resolvedRevision.name():null; String query; if (state.blobIdent.path != null) query = String.format(\"path(%s)\", state.blobIdent.path); else query = null; blobOperations.add(new ViewStateAwarePageLink<Void>(\"history\", ProjectCommitsPage.class,  ProjectCommitsPage.paramsOf(getProject(), query, compareWith)));  blobOperations.add(new DropdownLink(\"getCode\") {  @Override protected void onConfigure() { super.onConfigure(); setVisible(state.blobIdent.revision != null && state.blobIdent.path == null); }  @Override protected void onInitialize(FloatingPanel dropdown) { super.onInitialize(dropdown); dropdown.add(AttributeAppender.append(\"class\", \"get-code\")); }  @Override protected Component newContent(String id, FloatingPanel dropdown) { return new GetCodePanel(id, this) {  @Override protected Project getProject() { return ProjectBlobPage.this.getProject(); }  @Override protected String getRevision() { return state.blobIdent.revision; }  }; }  });  if (target != null) { replace(blobOperations); target.add(blobOperations); } else { add(blobOperations); } }  private QuickSearchPanel newQuickSearchPanel(String id, ModalPanel modal) { return new QuickSearchPanel(id, projectModel, new AbstractReadOnlyModel<String>() {  @Override public String getObject() { return state.blobIdent.revision; }  }) {  @Override protected void onSelect(AjaxRequestTarget target, QueryHit hit) { BlobIdent selected = new BlobIdent(state.blobIdent.revision, hit.getBlobPath(),  FileMode.REGULAR_FILE.getBits());  ProjectBlobPage.this.onSelect(target, selected, SourceRendererProvider.getPosition(hit.getTokenPos())); modal.close(); }  @Override protected void onMoreQueried(AjaxRequestTarget target, List<QueryHit> hits) { newSearchResult(target, hits); resizeWindow(target); modal.close(); }  @Override protected void onCancel(AjaxRequestTarget target) { modal.close(); }  }; }  private AdvancedSearchPanel advancedSearchPanel;  private ModalPanel advancedSearchPanelModal;  private AdvancedSearchPanel newAdvancedSearchPanel(String id, ModalPanel modal) {  advancedSearchPanelModal = modal; if (advancedSearchPanel == null) { advancedSearchPanel = new AdvancedSearchPanel(id, projectModel, new AbstractReadOnlyModel<String>() {  @Override public String getObject() { return state.blobIdent.revision; }  }) {  @Override protected void onSearchComplete(AjaxRequestTarget target, List<QueryHit> hits) { newSearchResult(target, hits); resizeWindow(target); advancedSearchPanelModal.close(); }  @Override protected void onCancel(AjaxRequestTarget target) { advancedSearchPanelModal.close(); }  @Override protected BlobIdent getCurrentBlob() { return state.blobIdent; }  }; }  return advancedSearchPanel; }  private void newBlobContent(@Nullable AjaxRequestTarget target) { PrioritizedComponentRenderer mostPrioritizedRenderer = null; for (BlobRendererContribution contribution: OneDev.getExtensions(BlobRendererContribution.class)) { PrioritizedComponentRenderer renderer = contribution.getRenderer(this); if (renderer != null) { if (mostPrioritizedRenderer == null || mostPrioritizedRenderer.getPriority() > renderer.getPriority()) mostPrioritizedRenderer = renderer; } } Component blobContent = Preconditions.checkNotNull(mostPrioritizedRenderer).render(BLOB_CONTENT_ID); if (target != null) { replace(blobContent); target.add(blobContent); } else { add(blobContent); } }  private void pushState(AjaxRequestTarget target) { PageParameters params = paramsOf(getProject(), state); CharSequence url = RequestCycle.get().urlFor(ProjectBlobPage.class, params); pushState(target, url.toString(), state); }  private void newCommitStatus(@Nullable AjaxRequestTarget target) { Component commitStatus; if (resolvedRevision != null) { commitStatus = new CommitStatusPanel(\"buildStatus\", resolvedRevision) {  @Override protected Project getProject() { return ProjectBlobPage.this.getProject(); }  }; } else { commitStatus = new WebMarkupContainer(\"buildStatus\").add(AttributeAppender.append(\"class\", \"d-none\")); }  commitStatus.setOutputMarkupPlaceholderTag(true);  if (target != null) { replace(commitStatus); target.add(commitStatus); } else { add(commitStatus); } }  private void newBuildSupportNote(@Nullable AjaxRequestTarget target) { Component buildSupportNote = new WebMarkupContainer(\"buildSupportNote\") {  @Override protected void onInitialize() { super.onInitialize();  String branch = state.blobIdent.revision; if (branch == null) branch = \"master\"; if (SecurityUtils.canModify(getProject(), branch, BuildSpec.BLOB_PATH)) { add(new ViewStateAwareAjaxLink<Void>(\"addFile\") {  @Override public void onClick(AjaxRequestTarget target) { onModeChange(target, Mode.ADD, BuildSpec.BLOB_PATH); }  @Override public IModel<?> getBody() { return Model.of(\"adding \" + BuildSpec.BLOB_PATH); }  }); } else { add(new Label(\"addFile\", \"adding \" + BuildSpec.BLOB_PATH) {  @Override protected void onComponentTag(ComponentTag tag) { super.onComponentTag(tag); tag.setName(\"span\"); }  }); } setOutputMarkupPlaceholderTag(true); }  @Override protected void onConfigure() { super.onConfigure(); if (resolvedRevision != null && isOnBranch() && state.blobIdent.path == null && state.mode == Mode.VIEW) { BlobIdent oldBlobIdent = new BlobIdent(resolvedRevision.name(), \".onedev-buildspec\", FileMode.TYPE_FILE); BlobIdent blobIdent = new BlobIdent(resolvedRevision.name(), BuildSpec.BLOB_PATH, FileMode.TYPE_FILE); setVisible(getProject().getBlob(blobIdent, false) == null && getProject().getBlob(oldBlobIdent, false) == null); } else { setVisible(false); } }  };  if (target != null) { replace(buildSupportNote); target.add(buildSupportNote); } else { add(buildSupportNote); } }  private void newRevisionPicker(@Nullable AjaxRequestTarget target) { String revision = state.blobIdent.revision; boolean canCreateRef; if (revision == null) { revision = \"master\"; canCreateRef = false; } else { canCreateRef = true; }  Component revisionPicker = new RevisionPicker(REVISION_PICKER_ID, projectModel, revision, canCreateRef) {  @Override protected void onComponentTag(ComponentTag tag) { super.onComponentTag(tag); if (isOnBranch()) tag.put(\"title\", \"Press 'y' to get permalink\"); }  @Override protected String getRevisionUrl(String revision) { BlobIdent blobIdent = new BlobIdent(revision, null, FileMode.TREE.getBits()); State state = new State(blobIdent); PageParameters params = ProjectBlobPage.paramsOf(projectModel.getObject(), state); return urlFor(ProjectBlobPage.class, params).toString(); }  @Override protected void onSelect(AjaxRequestTarget target, String revision) { BlobIdent newBlobIdent = new BlobIdent(state.blobIdent); newBlobIdent.revision = revision; if (newBlobIdent.path != null) { try (RevWalk revWalk = new RevWalk(getProject().getRepository())) { RevTree revTree = getProject().getRevCommit(revision, true).getTree(); TreeWalk treeWalk = TreeWalk.forPath(getProject().getRepository(), newBlobIdent.path, revTree); if (treeWalk != null) { newBlobIdent.mode = treeWalk.getRawMode(0); } else { newBlobIdent.path = null; newBlobIdent.mode = FileMode.TREE.getBits(); } } catch (IOException e) { throw new RuntimeException(e); } }  ProjectBlobPage.this.onSelect(target, newBlobIdent, null); }  };  if (target != null) { replace(revisionPicker); target.add(revisionPicker); } else { add(revisionPicker); } }_x0", "nl": "  import static org.apache.wicket.ajax.attributes.CallbackParameter.explicit;  import java.io.IOException; import java.io.Serializable; import java.net.URISyntaxException; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.atomic.AtomicBoolean;  import javax.annotation.Nullable;  import org.apache.commons.lang3.SerializationUtils; import org.apache.commons.lang3.StringUtils; import org.apache.http.NameValuePair; import org.apache.http.client.utils.URIBuilder; import org.apache.wicket.Component; import org.apache.wicket.ajax.AjaxRequestTarget; import org.apache.wicket.behavior.AttributeAppender; import org.apache.wicket.core.request.handler.IPartialPageRequestHandler; import org.apache.wicket.event.IEvent; import org.apache.wicket.markup.ComponentTag; import org.apache.wicket.markup.head.IHeaderResponse; import org.apache.wicket.markup.head.JavaScriptHeaderItem; import org.apache.wicket.markup.head.OnDomReadyHeaderItem; import org.apache.wicket.markup.html.WebMarkupContainer; import org.apache.wicket.markup.html.basic.Label; import org.apache.wicket.markup.html.form.upload.FileUpload; import org.apache.wicket.model.AbstractReadOnlyModel; import org.apache.wicket.model.IModel; import org.apache.wicket.model.Model; import org.apache.wicket.request.IRequestParameters; import org.apache.wicket.request.cycle.RequestCycle; import org.apache.wicket.request.flow.RedirectToUrlException; import org.apache.wicket.request.handler.resource.ResourceReferenceRequestHandler; import org.apache.wicket.request.mapper.parameter.PageParameters; import org.apache.wicket.util.visit.IVisit; import org.apache.wicket.util.visit.IVisitor; import org.eclipse.jgit.lib.FileMode; import org.eclipse.jgit.lib.ObjectId; import org.eclipse.jgit.revwalk.RevCommit; import org.eclipse.jgit.revwalk.RevTree; import org.eclipse.jgit.revwalk.RevWalk; import org.eclipse.jgit.treewalk.TreeWalk; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import com.google.common.base.Objects; import com.google.common.base.Preconditions; import com.google.common.collect.Sets;  import io.onedev.commons.launcher.loader.ListenerRegistry; import io.onedev.commons.utils.PlanarRange; import io.onedev.server.OneDev; import io.onedev.server.buildspec.BuildSpec; import io.onedev.server.entitymanager.CodeCommentManager; import io.onedev.server.entitymanager.ProjectManager; import io.onedev.server.entitymanager.PullRequestManager; import io.onedev.server.entitymanager.PullRequestUpdateManager; import io.onedev.server.event.RefUpdated; import io.onedev.server.git.BlobContent; import io.onedev.server.git.BlobEdits; import io.onedev.server.git.BlobIdent; import io.onedev.server.git.GitUtils; import io.onedev.server.git.exception.BlobEditException; import io.onedev.server.git.exception.NotTreeException; import io.onedev.server.git.exception.ObjectAlreadyExistsException; import io.onedev.server.git.exception.ObsoleteCommitException; import io.onedev.server.model.CodeComment; import io.onedev.server.model.Project; import io.onedev.server.model.PullRequest; import io.onedev.server.model.User; import io.onedev.server.persistence.SessionManager; import io.onedev.server.persistence.TransactionManager; import io.onedev.server.search.code.CommitIndexed; import io.onedev.server.search.code.IndexManager; import io.onedev.server.search.code.SearchManager; import io.onedev.server.search.code.hit.QueryHit; import io.onedev.server.search.code.query.BlobQuery; import io.onedev.server.search.code.query.TextQuery; import io.onedev.server.security.SecurityUtils; import io.onedev.server.util.script.identity.JobIdentity; import io.onedev.server.util.script.identity.ScriptIdentity; import io.onedev.server.util.script.identity.ScriptIdentityAware; import io.onedev.server.web.PrioritizedComponentRenderer; import io.onedev.server.web.behavior.AbstractPostAjaxBehavior; import io.onedev.server.web.behavior.WebSocketObserver; import io.onedev.server.web.component.commit.status.CommitStatusPanel; import io.onedev.server.web.component.floating.FloatingPanel; import io.onedev.server.web.component.link.DropdownLink; import io.onedev.server.web.component.link.ViewStateAwareAjaxLink; import io.onedev.server.web.component.link.ViewStateAwarePageLink; import io.onedev.server.web.component.menu.MenuItem; import io.onedev.server.web.component.menu.MenuLink; import io.onedev.server.web.component.modal.ModalLink; import io.onedev.server.web.component.modal.ModalPanel; import io.onedev.server.web.component.revisionpicker.RevisionPicker; import io.onedev.server.web.page.project.ProjectPage; import io.onedev.server.web.page.project.blob.navigator.BlobNavigator; import io.onedev.server.web.page.project.blob.render.BlobRenderContext; import io.onedev.server.web.page.project.blob.render.BlobRendererContribution; import io.onedev.server.web.page.project.blob.render.renderers.source.SourceRendererProvider; import io.onedev.server.web.page.project.blob.render.view.Positionable; import io.onedev.server.web.page.project.blob.search.SearchMenuContributor; import io.onedev.server.web.page.project.blob.search.advanced.AdvancedSearchPanel; import io.onedev.server.web.page.project.blob.search.quick.QuickSearchPanel; import io.onedev.server.web.page.project.blob.search.result.SearchResultPanel; import io.onedev.server.web.page.project.commits.ProjectCommitsPage; import io.onedev.server.web.resource.RawBlobResourceReference; import io.onedev.server.web.util.EditParamsAware; import io.onedev.server.web.websocket.WebSocketManager;  @SuppressWarnings(\"serial\") public class ProjectBlobPage extends ProjectPage implements BlobRenderContext, ScriptIdentityAware, EditParamsAware {  private static final String PARAM_REVISION = \"revision\";  private static final String PARAM_PATH = \"path\";  private static final String PARAM_INITIAL_NEW_PATH = \"initial-new-path\";  private static final String PARAM_REQUEST = \"request\";  private static final String PARAM_COMMENT = \"comment\";  private static final String PARAM_MODE = \"mode\";  private static final String PARAM_VIEW_PLAIN = \"view-plain\";  private static final String PARAM_URL_BEFORE_EDIT = \"url-before-edit\";  private static final String PARAM_URL_AFTER_EDIT = \"url-after-edit\";  private static final String PARAM_QUERY = \"query\";  private static final String PARAM_POSITION = \"position\";  private static final String PARAM_RAW = \"raw\";  private static final String REVISION_PICKER_ID = \"revisionPicker\";  private static final String BLOB_NAVIGATOR_ID = \"blobNavigator\";  private static final String BLOB_CONTENT_ID = \"blobContent\";  private static final Logger logger = LoggerFactory.getLogger(ProjectBlobPage.class);  private State state = new State();  private ObjectId resolvedRevision;  private Component revisionIndexing;  private WebMarkupContainer searchResult;  private AbstractPostAjaxBehavior ajaxBehavior;  public ProjectBlobPage(PageParameters params) { super(params);  List<String> revisionAndPathSegments = new ArrayList<>(); String segment = params.get(PARAM_REVISION).toString(); if (segment != null && segment.length() != 0) revisionAndPathSegments.add(segment); segment = params.get(PARAM_PATH).toString(); if (segment != null && segment.length() != 0) revisionAndPathSegments.add(segment);  for (int i=0; i<params.getIndexedCount(); i++) { segment = params.get(i).toString(); if (segment.length() != 0) revisionAndPathSegments.add(segment); }  BlobIdent blobIdent = new BlobIdent(getProject(), revisionAndPathSegments);  state = new State(blobIdent);  String modeStr = params.get(PARAM_MODE).toString(); if (modeStr != null) state.mode = Mode.valueOf(modeStr.toUpperCase());  String viewPlain = params.get(PARAM_VIEW_PLAIN).toString(); state.viewPlain = \"true\".equals(viewPlain);  state.urlBeforeEdit = params.get(PARAM_URL_BEFORE_EDIT).toString(); state.urlAfterEdit = params.get(PARAM_URL_AFTER_EDIT).toString();  if (state.blobIdent.revision != null) resolvedRevision = getProject().getRevCommit(state.blobIdent.revision, true).copy();  state.position = params.get(PARAM_POSITION).toString();  state.requestId = params.get(PARAM_REQUEST).toOptionalLong();  state.commentId = params.get(PARAM_COMMENT).toOptionalLong();  state.query = params.get(PARAM_QUERY).toString();  state.initialNewPath = params.get(PARAM_INITIAL_NEW_PATH).toString();  if (state.mode == Mode.ADD || state.mode == Mode.EDIT || state.mode == Mode.DELETE) { if (!isOnBranch())  throw new IllegalArgumentException(\"Files can only be edited on branch\");  String path = state.blobIdent.path; if (path != null && state.blobIdent.isTree()) path += \"/\"; if (!SecurityUtils.canModify(getProject(), state.blobIdent.revision, path)) unauthorized(); }  if (params.get(PARAM_RAW).toBoolean(false)) { RequestCycle.get().scheduleRequestHandlerAfterCurrent( new ResourceReferenceRequestHandler(new RawBlobResourceReference(), getPageParameters())); } }  @Override protected void onInitialize() { super.onInitialize();  newRevisionPicker(null); newCommitStatus(null); newBlobNavigator(null); newBlobOperations(null);  add(revisionIndexing = new WebMarkupContainer(\"revisionIndexing\") {  @Override protected void onConfigure() { super.onConfigure();  if (resolvedRevision != null) { RevCommit commit = getProject().getRevCommit(resolvedRevision, true); IndexManager indexManager = OneDev.getInstance(IndexManager.class); if (!indexManager.isIndexed(getProject(), commit)) { OneDev.getInstance(IndexManager.class).indexAsync(getProject(), commit); setVisible(true); } else { setVisible(false); } } else { setVisible(false); } }  }.setOutputMarkupPlaceholderTag(true));  revisionIndexing.add(new WebSocketObserver() {  @Override public void onObservableChanged(IPartialPageRequestHandler handler) { handler.add(revisionIndexing); resizeWindow(handler); }  @Override public Collection<String> getObservables() { Set<String> observables = new HashSet<>(); if (resolvedRevision != null)  observables.add(CommitIndexed.getWebSocketObservable(getProject().getRevCommit(resolvedRevision, true).name())); return observables; }  });  newBuildSupportNote(null); newBlobContent(null);  add(searchResult = new WebMarkupContainer(\"searchResult\"));  List<QueryHit> queryHits; if (state.query != null) { BlobQuery query = new TextQuery.Builder() .term(state.query) .wholeWord(true) .caseSensitive(true)  .count(SearchResultPanel.MAX_QUERY_ENTRIES) .build(); try { SearchManager searchManager = OneDev.getInstance(SearchManager.class); queryHits = searchManager.search(projectModel.getObject(), getProject().getRevCommit(resolvedRevision, true),  query); } catch (InterruptedException e) { throw new RuntimeException(e); } } else { queryHits = null; }  newSearchResult(null, queryHits);  add(ajaxBehavior = new AbstractPostAjaxBehavior() {  @Override protected void respond(AjaxRequestTarget target) { IRequestParameters params = RequestCycle.get().getRequest().getPostParameters();  String action = params.getParameterValue(\"action\").toString(\"\"); switch (action) { case \"quickSearch\":  new ModalPanel(target) {  @Override protected Component newContent(String id) { return newQuickSearchPanel(id, this); }  }; break; case \"advancedSearch\": new ModalPanel(target) {  @Override protected Component newContent(String id) { return newAdvancedSearchPanel(id, this); }  }; break; case \"permalink\": if (isOnBranch()) { BlobIdent newBlobIdent = new BlobIdent(state.blobIdent); newBlobIdent.revision = resolvedRevision.name(); ProjectBlobPage.this.onSelect(target, newBlobIdent, null); } break; default: throw new IllegalStateException(\"Unexpected action: \" + action); } }  }); }   @Override protected Map<String, ObjectId> getObjectIdCache() { Map<String, ObjectId> objectIdCache = new HashMap<>(); if (resolvedRevision != null) objectIdCache.put(state.blobIdent.revision, resolvedRevision); return objectIdCache; }  @Override public CodeComment getOpenComment() { if (state.commentId != null) return OneDev.getInstance(CodeCommentManager.class).load(state.commentId); else return null; }  @Override public PullRequest getPullRequest() { if (state.requestId != null) return OneDev.getInstance(PullRequestManager.class).load(state.requestId); else return null; }  private void newBlobNavigator(@Nullable AjaxRequestTarget target) { Component blobNavigator = new BlobNavigator(BLOB_NAVIGATOR_ID, this); if (target != null) { replace(blobNavigator); target.add(blobNavigator); } else { add(blobNavigator); } }  private void newBlobOperations(@Nullable AjaxRequestTarget target) { WebMarkupContainer blobOperations = new WebMarkupContainer(\"blobOperations\"); blobOperations.setOutputMarkupId(true);  String revision = state.blobIdent.revision;  AtomicBoolean reviewRequired = new AtomicBoolean(true); try { reviewRequired.set(revision!=null && getProject().isReviewRequiredForModification(getLoginUser(), revision, null));  } catch (Exception e) { logger.error(\"Error checking review requirement\", e); }  AtomicBoolean buildRequired = new AtomicBoolean(true); try { buildRequired.set(revision!=null && getProject().isBuildRequiredForModification(getLoginUser(), revision, null)); } catch (Exception e) { logger.error(\"Error checking build requirement\", e); }  blobOperations.add(new MenuLink(\"add\") {  @Override protected List<MenuItem> getMenuItems(FloatingPanel dropdown) { List<MenuItem> menuItems = new ArrayList<>(); menuItems.add(new MenuItem() {  @Override public String getLabel() { return \"Create New File\"; }  @Override public WebMarkupContainer newLink(String id) { return new ViewStateAwareAjaxLink<Void>(id) {  @Override public void onClick(AjaxRequestTarget target) { onModeChange(target, Mode.ADD, null); dropdown.close(); }  }; }  });  menuItems.add(new MenuItem() {  @Override public String getLabel() { return \"Upload Files\"; }  @Override public WebMarkupContainer newLink(String id) { return new ModalLink(id) {  @Override public void onClick(AjaxRequestTarget target) { super.onClick(target); dropdown.close(); }  @Override protected Component newContent(String id, ModalPanel modal) { return new BlobUploadPanel(id, ProjectBlobPage.this) {  @Override public void onCancel(AjaxRequestTarget target) { modal.close(); }  @Override public void onCommitted(AjaxRequestTarget target, RefUpdated refUpdated) { ProjectBlobPage.this.onCommitted(target, refUpdated, null); modal.close(); }  }; }  }; }  }); return menuItems; }  @Override protected void onComponentTag(ComponentTag tag) { super.onComponentTag(tag);  if (reviewRequired.get()) { tag.append(\"class\", \"disabled\", \" \"); tag.put(\"title\", \"Review required for this change. Submit pull request instead\"); } else if (buildRequired.get()) { tag.append(\"class\", \"disabled\", \" \"); tag.put(\"title\", \"Build required for this change. Submit pull request instead\"); } else { tag.put(\"title\", \"Add on branch \" + state.blobIdent.revision); } }  @Override protected void onConfigure() { super.onConfigure();  Project project = getProject(); if ((state.mode == Mode.VIEW || state.mode == Mode.BLAME)  && isOnBranch() && state.blobIdent.isTree()  && SecurityUtils.canWriteCode(project)) { setVisible(true); setEnabled(!reviewRequired.get() && !buildRequired.get()); } else { setVisible(false); } }  });  blobOperations.add(new MenuLink(\"search\") {  @Override protected List<MenuItem> getMenuItems(FloatingPanel dropdown) { List<MenuItem> menuItems = new ArrayList<>(); menuItems.add(new MenuItem() {  @Override public String getShortcut() { return \"T\"; }  @Override public String getLabel() { return \"Quick Search\"; }  @Override public WebMarkupContainer newLink(String id) { return new ModalLink(id) {  @Override public void onClick(AjaxRequestTarget target) { super.onClick(target); dropdown.close(); }  @Override protected Component newContent(String id, ModalPanel modal) { return newQuickSearchPanel(id, modal); }  }; }  }); menuItems.add(new MenuItem() {  @Override public String getShortcut() { return \"V\"; }  @Override public String getLabel() { return \"Advanced Search\"; }  @Override public WebMarkupContainer newLink(String id) { return new ModalLink(id) {  @Override public void onClick(AjaxRequestTarget target) { super.onClick(target); dropdown.close(); }  @Override protected Component newContent(String id, ModalPanel modal) { return newAdvancedSearchPanel(id, modal); }  }; }  });  IVisitor<Component, Component> visitor = new IVisitor<Component, Component>() {  @Override public void component(Component object, IVisit<Component> visit) { visit.stop(object); }  }; SearchMenuContributor contributor = (SearchMenuContributor) getPage().visitChildren( SearchMenuContributor.class, visitor); if (contributor != null) menuItems.addAll(contributor.getMenuItems(dropdown));  return menuItems; }  });  String compareWith = resolvedRevision!=null?resolvedRevision.name():null; String query; if (state.blobIdent.path != null) query = String.format(\"path(%s)\", state.blobIdent.path); else query = null; blobOperations.add(new ViewStateAwarePageLink<Void>(\"history\", ProjectCommitsPage.class,  ProjectCommitsPage.paramsOf(getProject(), query, compareWith)));  blobOperations.add(new DropdownLink(\"getCode\") {  @Override protected void onConfigure() { super.onConfigure(); setVisible(state.blobIdent.revision != null && state.blobIdent.path == null); }  @Override protected void onInitialize(FloatingPanel dropdown) { super.onInitialize(dropdown); dropdown.add(AttributeAppender.append(\"class\", \"get-code\")); }  @Override protected Component newContent(String id, FloatingPanel dropdown) { return new GetCodePanel(id, this) {  @Override protected Project getProject() { return ProjectBlobPage.this.getProject(); }  @Override protected String getRevision() { return state.blobIdent.revision; }  }; }  });  if (target != null) { replace(blobOperations); target.add(blobOperations); } else { add(blobOperations); } }  private QuickSearchPanel newQuickSearchPanel(String id, ModalPanel modal) { return new QuickSearchPanel(id, projectModel, new AbstractReadOnlyModel<String>() {  @Override public String getObject() { return state.blobIdent.revision; }  }) {  @Override protected void onSelect(AjaxRequestTarget target, QueryHit hit) { BlobIdent selected = new BlobIdent(state.blobIdent.revision, hit.getBlobPath(),  FileMode.REGULAR_FILE.getBits());  ProjectBlobPage.this.onSelect(target, selected, SourceRendererProvider.getPosition(hit.getTokenPos())); modal.close(); }  @Override protected void onMoreQueried(AjaxRequestTarget target, List<QueryHit> hits) { newSearchResult(target, hits); resizeWindow(target); modal.close(); }  @Override protected void onCancel(AjaxRequestTarget target) { modal.close(); }  }; }  private AdvancedSearchPanel advancedSearchPanel;  private ModalPanel advancedSearchPanelModal;  private AdvancedSearchPanel newAdvancedSearchPanel(String id, ModalPanel modal) {  advancedSearchPanelModal = modal; if (advancedSearchPanel == null) { advancedSearchPanel = new AdvancedSearchPanel(id, projectModel, new AbstractReadOnlyModel<String>() {  @Override public String getObject() { return state.blobIdent.revision; }  }) {  @Override protected void onSearchComplete(AjaxRequestTarget target, List<QueryHit> hits) { newSearchResult(target, hits); resizeWindow(target); advancedSearchPanelModal.close(); }  @Override protected void onCancel(AjaxRequestTarget target) { advancedSearchPanelModal.close(); }  @Override protected BlobIdent getCurrentBlob() { return state.blobIdent; }  }; }  return advancedSearchPanel; }  private void newBlobContent(@Nullable AjaxRequestTarget target) { PrioritizedComponentRenderer mostPrioritizedRenderer = null; for (BlobRendererContribution contribution: OneDev.getExtensions(BlobRendererContribution.class)) { PrioritizedComponentRenderer renderer = contribution.getRenderer(this); if (renderer != null) { if (mostPrioritizedRenderer == null || mostPrioritizedRenderer.getPriority() > renderer.getPriority()) mostPrioritizedRenderer = renderer; } } Component blobContent = Preconditions.checkNotNull(mostPrioritizedRenderer).render(BLOB_CONTENT_ID); if (target != null) { replace(blobContent); target.add(blobContent); } else { add(blobContent); } }  private void pushState(AjaxRequestTarget target) { PageParameters params = paramsOf(getProject(), state); CharSequence url = RequestCycle.get().urlFor(ProjectBlobPage.class, params); pushState(target, url.toString(), state); }  private void newCommitStatus(@Nullable AjaxRequestTarget target) { Component commitStatus; if (resolvedRevision != null) { commitStatus = new CommitStatusPanel(\"buildStatus\", resolvedRevision) {  @Override protected Project getProject() { return ProjectBlobPage.this.getProject(); }  }; } else { commitStatus = new WebMarkupContainer(\"buildStatus\").add(AttributeAppender.append(\"class\", \"d-none\")); }  commitStatus.setOutputMarkupPlaceholderTag(true);  if (target != null) { replace(commitStatus); target.add(commitStatus); } else { add(commitStatus); } }  private void newBuildSupportNote(@Nullable AjaxRequestTarget target) { Component buildSupportNote = new WebMarkupContainer(\"buildSupportNote\") {  @Override protected void onInitialize() { super.onInitialize();  String branch = state.blobIdent.revision; if (branch == null) branch = \"master\"; if (SecurityUtils.canModify(getProject(), branch, BuildSpec.BLOB_PATH)) { add(new ViewStateAwareAjaxLink<Void>(\"addFile\") {  @Override public void onClick(AjaxRequestTarget target) { onModeChange(target, Mode.ADD, BuildSpec.BLOB_PATH); }  @Override public IModel<?> getBody() { return Model.of(\"adding \" + BuildSpec.BLOB_PATH); }  }); } else { add(new Label(\"addFile\", \"adding \" + BuildSpec.BLOB_PATH) {  @Override protected void onComponentTag(ComponentTag tag) { super.onComponentTag(tag); tag.setName(\"span\"); }  }); } setOutputMarkupPlaceholderTag(true); }  @Override protected void onConfigure() { super.onConfigure(); if (resolvedRevision != null && isOnBranch() && state.blobIdent.path == null && state.mode == Mode.VIEW) { BlobIdent oldBlobIdent = new BlobIdent(resolvedRevision.name(), \".onedev-buildspec\", FileMode.TYPE_FILE); BlobIdent blobIdent = new BlobIdent(resolvedRevision.name(), BuildSpec.BLOB_PATH, FileMode.TYPE_FILE); setVisible(getProject().getBlob(blobIdent, false) == null && getProject().getBlob(oldBlobIdent, false) == null); } else { setVisible(false); } }  };  if (target != null) { replace(buildSupportNote); target.add(buildSupportNote); } else { add(buildSupportNote); } }  private void newRevisionPicker(@Nullable AjaxRequestTarget target) { String revision = state.blobIdent.revision; boolean canCreateRef; if (revision == null) { revision = \"master\"; canCreateRef = false; } else { canCreateRef = true; }  Component revisionPicker = new RevisionPicker(REVISION_PICKER_ID, projectModel, revision, canCreateRef) {  @Override protected void onComponentTag(ComponentTag tag) { super.onComponentTag(tag); if (isOnBranch()) tag.put(\"title\", \"Press 'y' to get permalink\"); }  @Override protected String getRevisionUrl(String revision) { BlobIdent blobIdent = new BlobIdent(revision, null, FileMode.TREE.getBits()); State state = new State(blobIdent); PageParameters params = ProjectBlobPage.paramsOf(projectModel.getObject(), state); return urlFor(ProjectBlobPage.class, params).toString(); }  @Override protected void onSelect(AjaxRequestTarget target, String revision) { BlobIdent newBlobIdent = new BlobIdent(state.blobIdent); newBlobIdent.revision = revision; if (newBlobIdent.path != null) { try (RevWalk revWalk = new RevWalk(getProject().getRepository())) { RevTree revTree = getProject().getRevCommit(revision, true).getTree(); TreeWalk treeWalk = TreeWalk.forPath(getProject().getRepository(), newBlobIdent.path, revTree); if (treeWalk != null) { newBlobIdent.mode = treeWalk.getRawMode(0); } else { newBlobIdent.path = null; newBlobIdent.mode = FileMode.TREE.getBits(); } } catch (IOException e) { throw new RuntimeException(e); } }  ProjectBlobPage.this.onSelect(target, newBlobIdent, null); }  };  if (target != null) { replace(revisionPicker); target.add(revisionPicker); } else { add(revisionPicker); } }   private void onResolvedRevi"}
{"code": "import static io.onedev.server.model.User.PROP_EMAIL;import static io.onedev.server.model.User.PROP_FULL_NAME;import static io.onedev.server.model.User.PROP_NAME;import static io.onedev.server.model.User.PROP_ACCESS_TOKEN;import java.util.ArrayList;import java.util.Collection;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.Stack;import java.util.stream.Collectors;import javax.annotation.Nullable;import javax.persistence.CascadeType;import javax.persistence.Column;import javax.persistence.Embedded;import javax.persistence.Entity;import javax.persistence.Index;import javax.persistence.Lob;import javax.persistence.OneToMany;import javax.persistence.Table;import javax.persistence.UniqueConstraint;import org.apache.commons.lang3.RandomStringUtils;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.SimplePrincipalCollection;import org.apache.shiro.subject.Subject;import org.eclipse.jgit.lib.PersonIdent;import org.hibernate.annotations.Cache;import org.hibernate.annotations.CacheConcurrencyStrategy;import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.NotEmpty;import com.fasterxml.jackson.annotation.JsonView;import com.google.common.base.MoreObjects;import io.onedev.server.OneDev;import io.onedev.server.entitymanager.SettingManager;import io.onedev.server.model.support.NamedProjectQuery;import io.onedev.server.model.support.QuerySetting;import io.onedev.server.model.support.SsoInfo;import io.onedev.server.model.support.administration.authenticator.Authenticator;import io.onedev.server.model.support.administration.sso.SsoConnector;import io.onedev.server.model.support.build.NamedBuildQuery;import io.onedev.server.model.support.issue.NamedIssueQuery;import io.onedev.server.model.support.pullrequest.NamedPullRequestQuery;import io.onedev.server.security.SecurityUtils;import io.onedev.server.util.jackson.DefaultView;import io.onedev.server.util.match.MatchScoreUtils;import io.onedev.server.util.validation.annotation.UserName;import io.onedev.server.util.watch.QuerySubscriptionSupport;import io.onedev.server.util.watch.QueryWatchSupport;import io.onedev.server.web.editable.annotation.Editable;import io.onedev.server.web.editable.annotation.Password;@Entity@Table(indexes={@Index(columnList=PROP_NAME), @Index(columnList=PROP_EMAIL), @Index(columnList=PROP_FULL_NAME), @Index(columnList=SsoInfo.COLUMN_CONNECTOR), @Index(columnList=SsoInfo.COLUMN_SUBJECT), @Index(columnList=PROP_ACCESS_TOKEN)}, uniqueConstraints={@UniqueConstraint(columnNames={SsoInfo.COLUMN_CONNECTOR, SsoInfo.COLUMN_SUBJECT})})@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)@Editablepublic class User extends AbstractEntity implements AuthenticationInfo {private static final long serialVersionUID = 1L;public static final int ACCESS_TOKEN_LEN = 40;public static final Long SYSTEM_ID = -1L;public static final Long ROOT_ID = 1L;public static final String EXTERNAL_MANAGED = \"external_managed\";public static final String PROP_NAME = \"name\";public static final String PROP_EMAIL = \"email\";public static final String PROP_PASSWORD = \"password\";public static final String PROP_FULL_NAME = \"fullName\";public static final String PROP_SSO_INFO = \"ssoInfo\";public static final String PROP_ACCESS_TOKEN = \"accessToken\";public static final String AUTH_SOURCE_BUILTIN_USER_STORE = \"Builtin User Store\";public static final String AUTH_SOURCE_EXTERNAL_AUTHENTICATOR = \"External Authenticator\";public static final String AUTH_SOURCE_SSO_PROVIDER = \"SSO Provider: \";private static ThreadLocal<Stack<User>> stack =  new ThreadLocal<Stack<User>>() {@Overrideprotected Stack<User> initialValue() {return new Stack<User>();}};@Column(unique=true, nullable=false)    private String name;    @Column(length=1024, nullable=false)@JsonView(DefaultView.class)    private String password;private String fullName;@JsonView(DefaultView.class)@Embeddedprivate SsoInfo ssoInfo = new SsoInfo();@Column(unique=true, nullable=false)private String email;@Column(unique=true, nullable=false)@JsonView(DefaultView.class)private String accessToken = RandomStringUtils.randomAlphanumeric(ACCESS_TOKEN_LEN);@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)private Collection<UserAuthorization> authorizations = new ArrayList<>();@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)private Collection<Membership> memberships = new ArrayList<>();@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)private Collection<PullRequestReview> pullRequestReviews = new ArrayList<>();@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)private Collection<PullRequestAssignment> pullRequestAssignments = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<PullRequestWatch> pullRequestWatches = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<IssueWatch> issueWatches = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<IssueVote> issueVotes = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<IssueQuerySetting> projectIssueQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<BuildQuerySetting> projectBuildQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<PullRequestQuerySetting> projectPullRequestQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<CommitQuerySetting> projectCommitQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<CodeCommentQuerySetting> projectCodeCommentQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"owner\", cascade=CascadeType.REMOVE)@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)    private Collection<SshKey> sshKeys = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedProjectQuery> userProjectQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedIssueQuery> userIssueQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> userIssueQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> issueQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedPullRequestQuery> userPullRequestQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> userPullRequestQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> pullRequestQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedBuildQuery> userBuildQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private LinkedHashSet<String> userBuildQuerySubscriptions = new LinkedHashSet<>();@Lob@Column(nullable=false, length=65535)private LinkedHashSet<String> buildQuerySubscriptions = new LinkedHashSet<>();    private transient Collection<Group> groups;public QuerySetting<NamedProjectQuery> getProjectQuerySetting() {return new QuerySetting<NamedProjectQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedProjectQuery> getUserQueries() {return userProjectQueries;}@Overridepublic void setUserQueries(ArrayList<NamedProjectQuery> userQueries) {userProjectQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedProjectQuery> getQueryWatchSupport() {return null;}@Overridepublic QuerySubscriptionSupport<NamedProjectQuery> getQuerySubscriptionSupport() {return null;}};}public QuerySetting<NamedIssueQuery> getIssueQuerySetting() {return new QuerySetting<NamedIssueQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedIssueQuery> getUserQueries() {return userIssueQueries;}@Overridepublic void setUserQueries(ArrayList<NamedIssueQuery> userQueries) {userIssueQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedIssueQuery> getQueryWatchSupport() {return new QueryWatchSupport<NamedIssueQuery>() {@Overridepublic LinkedHashMap<String, Boolean> getUserQueryWatches() {return userIssueQueryWatches;}@Overridepublic LinkedHashMap<String, Boolean> getQueryWatches() {return issueQueryWatches;}};}@Overridepublic QuerySubscriptionSupport<NamedIssueQuery> getQuerySubscriptionSupport() {return null;}};}public QuerySetting<NamedPullRequestQuery> getPullRequestQuerySetting() {return new QuerySetting<NamedPullRequestQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedPullRequestQuery> getUserQueries() {return userPullRequestQueries;}@Overridepublic void setUserQueries(ArrayList<NamedPullRequestQuery> userQueries) {userPullRequestQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedPullRequestQuery> getQueryWatchSupport() {return new QueryWatchSupport<NamedPullRequestQuery>() {@Overridepublic LinkedHashMap<String, Boolean> getUserQueryWatches() {return userPullRequestQueryWatches;}@Overridepublic LinkedHashMap<String, Boolean> getQueryWatches() {return pullRequestQueryWatches;}};}@Overridepublic QuerySubscriptionSupport<NamedPullRequestQuery> getQuerySubscriptionSupport() {return null;}};}public QuerySetting<NamedBuildQuery> getBuildQuerySetting() {return new QuerySetting<NamedBuildQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedBuildQuery> getUserQueries() {return userBuildQueries;}@Overridepublic void setUserQueries(ArrayList<NamedBuildQuery> userQueries) {userBuildQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedBuildQuery> getQueryWatchSupport() {return null;}@Overridepublic QuerySubscriptionSupport<NamedBuildQuery> getQuerySubscriptionSupport() {return new QuerySubscriptionSupport<NamedBuildQuery>() {@Overridepublic LinkedHashSet<String> getUserQuerySubscriptions() {return userBuildQuerySubscriptions;}@Overridepublic LinkedHashSet<String> getQuerySubscriptions() {return buildQuerySubscriptions;}};}};}@Override    public PrincipalCollection getPrincipals() {        return new SimplePrincipalCollection(getId(), \"\");    }    @Override    public Object getCredentials() {    return password;    }    public Subject asSubject() {    return SecurityUtils.asSubject(getId());    }@Editable(name=\"Login Name\", order=100)@UserName@NotEmptypublic String getName() {return name;}    public void setName(String name) {    this.name = name;    }@Editable(order=150)@Password(confirmative=true, autoComplete=\"new-password\")@NotEmptypublic String getPassword() {return password;}    public void setPassword(String password) {    this.password = password;    }    public boolean isExternalManaged() {    return getPassword().equals(EXTERNAL_MANAGED);    }@Editable(order=200)public String getFullName() {return fullName;}public void setFullName(String fullName) {this.fullName = fullName;}public SsoInfo getSsoInfo() {return ssoInfo;}public void setSsoInfo(SsoInfo ssoInfo) {this.ssoInfo = ssoInfo;}public String getAccessToken() {return accessToken;}public void setAccessToken(String accessToken) {this.accessToken = accessToken;}@Editable(order=300)@NotEmpty@Emailpublic String getEmail() {return email;}public void setEmail(String email) {this.email = email;}public Collection<Membership> getMemberships() {return memberships;}public void setMemberships(Collection<Membership> memberships) {this.memberships = memberships;}@Overridepublic String toString() {return MoreObjects.toStringHelper(this).add(\"name\", getName()).toString();}public PersonIdent asPerson() {if (isSystem())return new PersonIdent(getDisplayName(), \"\");elsereturn new PersonIdent(getDisplayName(), getEmail());}public String getDisplayName() {if (getFullName() != null)return getFullName();elsereturn getName();}public boolean isRoot() {return ROOT_ID.equals(getId());}public boolean isSystem() {return SYSTEM_ID.equals(getId());}public Collection<UserAuthorization> getAuthorizations() {return authorizations;}public void setAuthorizations(Collection<UserAuthorization> authorizations) {this.authorizations = authorizations;}@Overridepublic int compareTo(AbstractEntity entity) {User user = (User) entity;if (getDisplayName().equals(user.getDisplayName())) {return getId().compareTo(entity.getId());} else {return getDisplayName().compareTo(user.getDisplayName());}}public double getMatchScore(@Nullable String queryTerm) {double scoreOfName = MatchScoreUtils.getMatchScore(name, queryTerm);double scoreOfFullName = MatchScoreUtils.getMatchScore(fullName, queryTerm);return Math.max(scoreOfName, scoreOfFullName);}public Collection<Group> getGroups() {if (groups == null)  groups = getMemberships().stream().map(it->it.getGroup()).collect(Collectors.toList());return groups;}public static User from(@Nullable User user, @Nullable String displayName) {if (user == null) {user = new User();if (displayName != null)user.setName(displayName);elseuser.setName(\"Unknown\");}return user;}public static void push(User user) {stack.get().push(user);}public static void pop() {stack.get().pop();}@Nullablepublic static User get() {if (!stack.get().isEmpty())return stack.get().peek();else return SecurityUtils.getUser();}    public Collection<SshKey> getSshKeys() {        return sshKeys;    }    public void setSshKeys(Collection<SshKey> sshKeys) {        this.sshKeys = sshKeys;    }    public boolean isSshKeyExternalManaged() {    if (isExternalManaged()) {    if (getSsoInfo().getConnector() != null) {    return false;    } else {    Authenticator authenticator = OneDev.getInstance(SettingManager.class).getAuthenticator();    return authenticator != null && authenticator.isManagingSshKeys();    }    } else {    return false;    }    }    public boolean isMembershipExternalManaged() {    if (isExternalManaged()) {    SettingManager settingManager = OneDev.getInstance(SettingManager.class);    if (getSsoInfo().getConnector() != null) {    SsoConnector ssoConnector = settingManager.getSsoConnectors().stream()    .filter(it->it.getName().equals(getSsoInfo().getConnector()))    .findFirst().orElse(null);    return ssoConnector != null && ssoConnector.isManagingMemberships();    } else {    Authenticator authenticator = settingManager.getAuthenticator();    return authenticator != null && authenticator.isManagingMemberships();    }    } else {    return false;    }    }    public String getAuthSource() {if (isExternalManaged()) {if (getSsoInfo().getConnector() != null)return AUTH_SOURCE_SSO_PROVIDER + getSsoInfo().getConnector();elsereturn AUTH_SOURCE_EXTERNAL_AUTHENTICATOR;} else {return AUTH_SOURCE_BUILTIN_USER_STORE;}    }}", "nl": "import static io.onedev.server.model.User.PROP_EMAIL;import static io.onedev.server.model.User.PROP_FULL_NAME;import static io.onedev.server.model.User.PROP_NAME;import static io.onedev.server.model.User.PROP_ACCESS_TOKEN;import java.util.ArrayList;import java.util.Collection;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.Stack;import java.util.stream.Collectors;import javax.annotation.Nullable;import javax.persistence.CascadeType;import javax.persistence.Column;import javax.persistence.Embedded;import javax.persistence.Entity;import javax.persistence.Index;import javax.persistence.Lob;import javax.persistence.OneToMany;import javax.persistence.Table;import javax.persistence.UniqueConstraint;import org.apache.commons.lang3.RandomStringUtils;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.subject.SimplePrincipalCollection;import org.apache.shiro.subject.Subject;import org.eclipse.jgit.lib.PersonIdent;import org.hibernate.annotations.Cache;import org.hibernate.annotations.CacheConcurrencyStrategy;import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.NotEmpty;import com.fasterxml.jackson.annotation.JsonView;import com.google.common.base.MoreObjects;import io.onedev.server.OneDev;import io.onedev.server.entitymanager.SettingManager;import io.onedev.server.model.support.NamedProjectQuery;import io.onedev.server.model.support.QuerySetting;import io.onedev.server.model.support.SsoInfo;import io.onedev.server.model.support.administration.authenticator.Authenticator;import io.onedev.server.model.support.administration.sso.SsoConnector;import io.onedev.server.model.support.build.NamedBuildQuery;import io.onedev.server.model.support.issue.NamedIssueQuery;import io.onedev.server.model.support.pullrequest.NamedPullRequestQuery;import io.onedev.server.security.SecurityUtils;import io.onedev.server.util.jackson.DefaultView;import io.onedev.server.util.match.MatchScoreUtils;import io.onedev.server.util.validation.annotation.UserName;import io.onedev.server.util.watch.QuerySubscriptionSupport;import io.onedev.server.util.watch.QueryWatchSupport;import io.onedev.server.web.editable.annotation.Editable;import io.onedev.server.web.editable.annotation.Password;@Entity@Table(indexes={@Index(columnList=PROP_NAME), @Index(columnList=PROP_EMAIL), @Index(columnList=PROP_FULL_NAME), @Index(columnList=SsoInfo.COLUMN_CONNECTOR), @Index(columnList=SsoInfo.COLUMN_SUBJECT), @Index(columnList=PROP_ACCESS_TOKEN)}, uniqueConstraints={@UniqueConstraint(columnNames={SsoInfo.COLUMN_CONNECTOR, SsoInfo.COLUMN_SUBJECT})})@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)@Editablepublic class User extends AbstractEntity implements AuthenticationInfo {private static final long serialVersionUID = 1L;public static final int ACCESS_TOKEN_LEN = 40;public static final Long SYSTEM_ID = -1L;public static final Long ROOT_ID = 1L;public static final String EXTERNAL_MANAGED = \"external_managed\";public static final String PROP_NAME = \"name\";public static final String PROP_EMAIL = \"email\";public static final String PROP_PASSWORD = \"password\";public static final String PROP_FULL_NAME = \"fullName\";public static final String PROP_SSO_INFO = \"ssoInfo\";public static final String PROP_ACCESS_TOKEN = \"accessToken\";public static final String AUTH_SOURCE_BUILTIN_USER_STORE = \"Builtin User Store\";public static final String AUTH_SOURCE_EXTERNAL_AUTHENTICATOR = \"External Authenticator\";public static final String AUTH_SOURCE_SSO_PROVIDER = \"SSO Provider: \";private static ThreadLocal<Stack<User>> stack =  new ThreadLocal<Stack<User>>() {@Overrideprotected Stack<User> initialValue() {return new Stack<User>();}};@Column(unique=true, nullable=false)    private String name;    @Column(length=1024, nullable=false)@JsonView(DefaultView.class)    private String password;private String fullName;@Embeddedprivate SsoInfo ssoInfo = new SsoInfo();@Column(unique=true, nullable=false)private String email;@Column(unique=true, nullable=false)private String accessToken = RandomStringUtils.randomAlphanumeric(ACCESS_TOKEN_LEN);@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)private Collection<UserAuthorization> authorizations = new ArrayList<>();@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)private Collection<Membership> memberships = new ArrayList<>();@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)private Collection<PullRequestReview> pullRequestReviews = new ArrayList<>();@OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)private Collection<PullRequestAssignment> pullRequestAssignments = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<PullRequestWatch> pullRequestWatches = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<IssueWatch> issueWatches = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<IssueVote> issueVotes = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<IssueQuerySetting> projectIssueQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<BuildQuerySetting> projectBuildQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<PullRequestQuerySetting> projectPullRequestQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<CommitQuerySetting> projectCommitQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"user\", cascade=CascadeType.REMOVE)    private Collection<CodeCommentQuerySetting> projectCodeCommentQuerySettings = new ArrayList<>();    @OneToMany(mappedBy=\"owner\", cascade=CascadeType.REMOVE)@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)    private Collection<SshKey> sshKeys = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedProjectQuery> userProjectQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedIssueQuery> userIssueQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> userIssueQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> issueQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedPullRequestQuery> userPullRequestQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> userPullRequestQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private LinkedHashMap<String, Boolean> pullRequestQueryWatches = new LinkedHashMap<>();@Lob@Column(nullable=false, length=65535)private ArrayList<NamedBuildQuery> userBuildQueries = new ArrayList<>();@Lob@Column(nullable=false, length=65535)private LinkedHashSet<String> userBuildQuerySubscriptions = new LinkedHashSet<>();@Lob@Column(nullable=false, length=65535)private LinkedHashSet<String> buildQuerySubscriptions = new LinkedHashSet<>();    private transient Collection<Group> groups;public QuerySetting<NamedProjectQuery> getProjectQuerySetting() {return new QuerySetting<NamedProjectQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedProjectQuery> getUserQueries() {return userProjectQueries;}@Overridepublic void setUserQueries(ArrayList<NamedProjectQuery> userQueries) {userProjectQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedProjectQuery> getQueryWatchSupport() {return null;}@Overridepublic QuerySubscriptionSupport<NamedProjectQuery> getQuerySubscriptionSupport() {return null;}};}public QuerySetting<NamedIssueQuery> getIssueQuerySetting() {return new QuerySetting<NamedIssueQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedIssueQuery> getUserQueries() {return userIssueQueries;}@Overridepublic void setUserQueries(ArrayList<NamedIssueQuery> userQueries) {userIssueQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedIssueQuery> getQueryWatchSupport() {return new QueryWatchSupport<NamedIssueQuery>() {@Overridepublic LinkedHashMap<String, Boolean> getUserQueryWatches() {return userIssueQueryWatches;}@Overridepublic LinkedHashMap<String, Boolean> getQueryWatches() {return issueQueryWatches;}};}@Overridepublic QuerySubscriptionSupport<NamedIssueQuery> getQuerySubscriptionSupport() {return null;}};}public QuerySetting<NamedPullRequestQuery> getPullRequestQuerySetting() {return new QuerySetting<NamedPullRequestQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedPullRequestQuery> getUserQueries() {return userPullRequestQueries;}@Overridepublic void setUserQueries(ArrayList<NamedPullRequestQuery> userQueries) {userPullRequestQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedPullRequestQuery> getQueryWatchSupport() {return new QueryWatchSupport<NamedPullRequestQuery>() {@Overridepublic LinkedHashMap<String, Boolean> getUserQueryWatches() {return userPullRequestQueryWatches;}@Overridepublic LinkedHashMap<String, Boolean> getQueryWatches() {return pullRequestQueryWatches;}};}@Overridepublic QuerySubscriptionSupport<NamedPullRequestQuery> getQuerySubscriptionSupport() {return null;}};}public QuerySetting<NamedBuildQuery> getBuildQuerySetting() {return new QuerySetting<NamedBuildQuery>() {@Overridepublic Project getProject() {return null;}@Overridepublic User getUser() {return User.this;}@Overridepublic ArrayList<NamedBuildQuery> getUserQueries() {return userBuildQueries;}@Overridepublic void setUserQueries(ArrayList<NamedBuildQuery> userQueries) {userBuildQueries = userQueries;}@Overridepublic QueryWatchSupport<NamedBuildQuery> getQueryWatchSupport() {return null;}@Overridepublic QuerySubscriptionSupport<NamedBuildQuery> getQuerySubscriptionSupport() {return new QuerySubscriptionSupport<NamedBuildQuery>() {@Overridepublic LinkedHashSet<String> getUserQuerySubscriptions() {return userBuildQuerySubscriptions;}@Overridepublic LinkedHashSet<String> getQuerySubscriptions() {return buildQuerySubscriptions;}};}};}@Override    public PrincipalCollection getPrincipals() {        return new SimplePrincipalCollection(getId(), \"\");    }    @Override    public Object getCredentials() {    return password;    }    public Subject asSubject() {    return SecurityUtils.asSubject(getId());    }@Editable(name=\"Login Name\", order=100)@UserName@NotEmptypublic String getName() {return name;}    public void setName(String name) {    this.name = name;    }@Editable(order=150)@Password(confirmative=true, autoComplete=\"new-password\")@NotEmptypublic String getPassword() {return password;}    public void setPassword(String password) {    this.password = password;    }    public boolean isExternalManaged() {    return getPassword().equals(EXTERNAL_MANAGED);    }@Editable(order=200)public String getFullName() {return fullName;}public void setFullName(String fullName) {this.fullName = fullName;}public SsoInfo getSsoInfo() {return ssoInfo;}public void setSsoInfo(SsoInfo ssoInfo) {this.ssoInfo = ssoInfo;}public String getAccessToken() {return accessToken;}public void setAccessToken(String accessToken) {this.accessToken = accessToken;}@Editable(order=300)@NotEmpty@Emailpublic String getEmail() {return email;}public void setEmail(String email) {this.email = email;}public Collection<Membership> getMemberships() {return memberships;}public void setMemberships(Collection<Membership> memberships) {this.memberships = memberships;}@Overridepublic String toString() {return MoreObjects.toStringHelper(this).add(\"name\", getName()).toString();}public PersonIdent asPerson() {if (isSystem())return new PersonIdent(getDisplayName(), \"\");elsereturn new PersonIdent(getDisplayName(), getEmail());}public String getDisplayName() {if (getFullName() != null)return getFullName();elsereturn getName();}public boolean isRoot() {return ROOT_ID.equals(getId());}public boolean isSystem() {return SYSTEM_ID.equals(getId());}public Collection<UserAuthorization> getAuthorizations() {return authorizations;}public void setAuthorizations(Collection<UserAuthorization> authorizations) {this.authorizations = authorizations;}@Overridepublic int compareTo(AbstractEntity entity) {User user = (User) entity;if (getDisplayName().equals(user.getDisplayName())) {return getId().compareTo(entity.getId());} else {return getDisplayName().compareTo(user.getDisplayName());}}public double getMatchScore(@Nullable String queryTerm) {double scoreOfName = MatchScoreUtils.getMatchScore(name, queryTerm);double scoreOfFullName = MatchScoreUtils.getMatchScore(fullName, queryTerm);return Math.max(scoreOfName, scoreOfFullName);}public Collection<Group> getGroups() {if (groups == null)  groups = getMemberships().stream().map(it->it.getGroup()).collect(Collectors.toList());return groups;}public static User from(@Nullable User user, @Nullable String displayName) {if (user == null) {user = new User();if (displayName != null)user.setName(displayName);elseuser.setName(\"Unknown\");}return user;}public static void push(User user) {stack.get().push(user);}public static void pop() {stack.get().pop();}@Nullablepublic static User get() {if (!stack.get().isEmpty())return stack.get().peek();else return SecurityUtils.getUser();}    public Collection<SshKey> getSshKeys() {        return sshKeys;    }    public void setSshKeys(Collection<SshKey> sshKeys) {        this.sshKeys = sshKeys;    }    public boolean isSshKeyExternalManaged() {    if (isExternalManaged()) {    if (getSsoInfo().getConnector() != null) {    return false;    } else {    Authenticator authenticator = OneDev.getInstance(SettingManager.class).getAuthenticator();    return authenticator != null && authenticator.isManagingSshKeys();    }    } else {    return false;    }    }    public boolean isMembershipExternalManaged() {    if (isExternalManaged()) {    SettingManager settingManager = OneDev.getInstance(SettingManager.class);    if (getSsoInfo().getConnector() != null) {    SsoConnector ssoConnector = settingManager.getSsoConnectors().stream()    .filter(it->it.getName().equals(getSsoInfo().getConnector()))    .findFirst().orElse(null);    return ssoConnector != null && ssoConnector.isManagingMemberships();    } else {    Authenticator authenticator = settingManager.getAuthenticator();    return authenticator != null && authenticator.isManagingMemberships();    }    } else {    return false;    }    }    public String getAuthSource() {if (isExternalManaged()) {if (getSsoInfo().getConnector() != null)return AUTH_SOURCE_SSO_PROVIDER + getSsoInfo().getConnector();elsereturn AUTH_SOURCE_EXTERNAL_AUTHENTICATOR;} else {return AUTH_SOURCE_BUILTIN_USER_STORE;}    }}"}
{"code": "None", "nl": "import java.util.Collection;import javax.inject.Inject;import javax.inject.Singleton;import javax.ws.rs.Consumes;import javax.ws.rs.GET;import javax.ws.rs.Path;import javax.ws.rs.PathParam;import javax.ws.rs.Produces;import javax.ws.rs.QueryParam;import javax.ws.rs.core.Context;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import javax.ws.rs.core.UriInfo;import org.apache.shiro.authz.UnauthorizedException;import org.hibernate.criterion.Restrictions;import org.hibernate.validator.constraints.Email;import io.onedev.server.entitymanager.UserManager;import io.onedev.server.model.User;import io.onedev.server.persistence.dao.EntityCriteria;import io.onedev.server.rest.jersey.ValidQueryParams;import io.onedev.server.security.SecurityUtils;@Path(\"/users\")@Consumes(MediaType.WILDCARD)@Produces(MediaType.APPLICATION_JSON)@Singletonpublic class UserResource {private final UserManager userManager;@Injectpublic UserResource(UserManager userManager) {this.userManager = userManager;}@ValidQueryParams@GETpublic Response query(@QueryParam(\"name\") String name, @Email @QueryParam(\"email\") String email, @QueryParam(\"offset\") Integer offset, @QueryParam(\"count\") Integer count, @Context UriInfo uriInfo) {    if (!SecurityUtils.isAdministrator())    throw new UnauthorizedException(\"Unauthorized access to user profiles\");    EntityCriteria<User> criteria = EntityCriteria.of(User.class);    if (name != null)    criteria.add(Restrictions.eq(\"name\", name));if (email != null)criteria.add(Restrictions.eq(\"email\", email));    if (offset == null)    offset = 0;    if (count == null || count > RestConstants.PAGE_SIZE)     count = RestConstants.PAGE_SIZE;    Collection<User> users = userManager.query(criteria, offset, count);return Response.ok(users, RestConstants.JSON_UTF8).build();}    @GET    @Path(\"/{userId}\")    public User get(@PathParam(\"userId\") Long userId) {    return userManager.load(userId);    }}"}
{"code": "  import java.io.Serializable; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map;  import javax.annotation.Nullable;  import org.apache.commons.lang.SerializationUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.unbescape.java.JavaEscape;  import com.google.common.collect.Lists;  import io.onedev.server.model.support.inputspec.showcondition.ShowCondition; import io.onedev.server.util.GroovyUtils; import io.onedev.server.web.editable.EditableUtils; import io.onedev.server.web.editable.annotation.Editable;  @Editable public abstract class InputSpec implements Serializable {  private static final long serialVersionUID = 1L;  private static final Logger logger = LoggerFactory.getLogger(InputSpec.class);  public static final String BOOLEAN = \"Checkbox\";  public static final String TEXT = \"Text\";  public static final String DATE = \"Date\";  public static final String SECRET = \"Secret\";  public static final String NUMBER = \"Number\";  public static final String COMMIT = \"Commit\";  public static final String ENUMERATION = \"Enumeration\";  public static final String USER = \"User\";  public static final String GROUP = \"Group\";  public static final String ISSUE = \"Issue\";  public static final String BUILD = \"Build\";  public static final String PULLREQUEST = \"Pull request\";  private String name;  private String description;  private boolean allowMultiple;  private boolean allowEmpty;  private ShowCondition showCondition;  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public boolean isAllowMultiple() { return allowMultiple; }  public void setAllowMultiple(boolean allowMultiple) { this.allowMultiple = allowMultiple; }  public ShowCondition getShowCondition() { return showCondition; }  public void setShowCondition(ShowCondition showCondition) { this.showCondition = showCondition; }  public boolean isAllowEmpty() { return allowEmpty; }  public void setAllowEmpty(boolean allowEmpty) { this.allowEmpty = allowEmpty; }  public List<String> getPossibleValues() { return Lists.newArrayList(); }  public static String escape(String string) { String escaped = JavaEscape.escapeJava(string); escaped = escaped.replace(\"$\", \"\\\\$\");  return escaped; }  public abstract String getPropertyDef(Map<String, Integer> indexes);  protected String getLiteral(byte[] bytes) { StringBuffer buffer = new StringBuffer(\"[\"); for (byte eachByte: bytes) { buffer.append(String.format(\"%d\", eachByte)).append(\",\"); } buffer.append(\"] as byte[]\"); return buffer.toString(); }  public void appendField(StringBuffer buffer, int index, String type) { buffer.append(\"    private Optional<\" + type + \"> input\" + index + \";\\n\"); buffer.append(\"\\n\"); }  public void appendChoiceProvider(StringBuffer buffer, int index, String annotation) { buffer.append(\"    \" + annotation + \"(\\\"getInput\" + index + \"Choices\\\")\\n\"); }  public void appendCommonAnnotations(StringBuffer buffer, int index) { if (description != null) { buffer.append(\"    @Editable(name=\\\"\" + escape(name) + \"\\\", description=\\\"\" +  escape(description) + \"\\\", order=\" + index + \")\\n\"); } else { buffer.append(\"    @Editable(name=\\\"\" + escape(name) +  \"\\\", order=\" + index + \")\\n\"); } if (showCondition != null)  buffer.append(\"    @ShowCondition(\\\"isInput\" + index + \"Visible\\\")\\n\"); }  private void wrapWithChildContext(StringBuffer buffer, int index, String statement) { buffer.append(\"            ComponentContext context = ComponentContext.get();\\n\"); buffer.append(\"            if (context != null) {\\n\"); buffer.append(\"                ComponentContext childContext = context.getChildContext(\\\"input\" + index + \"\\\");\\n\"); buffer.append(\"                if (childContext != null) {\\n\"); buffer.append(\"                    ComponentContext.push(childContext);\\n\"); buffer.append(\"                    try {\\n\"); buffer.append(\"                        \" + statement + \"\\n\"); buffer.append(\"                    } finally {\\n\"); buffer.append(\"                        ComponentContext.pop();\\n\"); buffer.append(\"                    }\\n\"); buffer.append(\"                } else {\\n\"); buffer.append(\"                    \" + statement + \"\\n\"); buffer.append(\"                }\\n\"); buffer.append(\"            } else {\\n\"); buffer.append(\"                \" + statement + \"\\n\"); buffer.append(\"            }\\n\"); }  public void appendMethods(StringBuffer buffer, int index, String type,  @Nullable Serializable choiceProvider, @Nullable Serializable defaultValueProvider) { String literalBytes = getLiteral(SerializationUtils.serialize(defaultValueProvider)); buffer.append(\"    public \" + type + \" getInput\" + index + \"() {\\n\"); buffer.append(\"        if (input\" + index + \"!=null) {\\n\"); buffer.append(\"            return input\" + index + \".orNull();\\n\"); buffer.append(\"        } else {\\n\"); if (defaultValueProvider != null) { wrapWithChildContext(buffer, index, \"return SerializationUtils.deserialize(\" + literalBytes + \").getDefaultValue();\"); } else { buffer.append(\"        return null;\\n\"); } buffer.append(\"        }\\n\"); buffer.append(\"    }\\n\"); buffer.append(\"\\n\");  buffer.append(\"    public void setInput\" + index + \"(\" + type + \" value) {\\n\"); buffer.append(\"        this.input\" + index + \"=Optional.fromNullable(value);\\n\"); buffer.append(\"    }\\n\"); buffer.append(\"\\n\");  if (showCondition != null) { buffer.append(\"    private static boolean isInput\" + index + \"Visible() {\\n\"); literalBytes = getLiteral(SerializationUtils.serialize(showCondition)); buffer.append(\"        return SerializationUtils.deserialize(\" + literalBytes + \").isVisible();\\n\"); buffer.append(\"    }\\n\"); buffer.append(\"\\n\"); }   if (choiceProvider != null) { buffer.append(\"    private static List getInput\" + index + \"Choices() {\\n\"); literalBytes = getLiteral(SerializationUtils.serialize(choiceProvider)); if (choiceProvider instanceof io.onedev.server.model.support.inputspec.choiceinput.choiceprovider.ChoiceProvider) { buffer.append(\"        return new ArrayList(SerializationUtils.deserialize(\" + literalBytes + \").getChoices(false).keySet());\\n\"); } else { buffer.append(\"        return SerializationUtils.deserialize(\" + literalBytes + \").getChoices(false);\\n\"); } buffer.append(\"    }\\n\"); buffer.append(\"\\n\"); } }  public static Class<?> defineClass(String className, String description, Collection<? extends InputSpec> inputs) { StringBuffer buffer = new StringBuffer(); buffer.append(\"import org.apache.commons.lang3.SerializationUtils;\\n\"); buffer.append(\"import com.google.common.base.Optional;\\n\"); buffer.append(\"import io.onedev.server.web.editable.annotation.*;\\n\"); buffer.append(\"import io.onedev.server.util.validation.annotation.*;\\n\"); buffer.append(\"import io.onedev.util.*;\\n\"); buffer.append(\"import io.onedev.server.util.*;\\n\"); buffer.append(\"import io.onedev.server.util.facade.*;\\n\"); buffer.append(\"import java.util.*;\\n\"); buffer.append(\"import javax.validation.constraints.*;\\n\"); buffer.append(\"import org.hibernate.validator.constraints.*;\\n\"); buffer.append(\"\\n\"); buffer.append(\"@Editable(name=\").append(\"\\\"\").append(description).append(\"\\\")\\n\"); buffer.append(\"class \" + className + \" implements java.io.Serializable {\\n\"); buffer.append(\"\\n\"); buffer.append(\"    private static final long serialVersionUID = 1L;\\n\"); buffer.append(\"\\n\"); Map<String, Integer> indexes = new HashMap<>(); int index = 1; for (InputSpec input: inputs) indexes.put(input.getName(), index++); for (InputSpec input: inputs) buffer.append(input.getPropertyDef(indexes));  buffer.append(\"}\\n\"); buffer.append(\"return \" + className + \";\\n\");  logger.trace(\"Class definition script:\\n\" + buffer.toString());  return (Class<?>) GroovyUtils.evalScript(buffer.toString(), new HashMap<>()); }  public abstract List<String> convertToStrings(@Nullable Object object);   @Nullable public abstract Object convertToObject(List<String> strings);  public long getOrdinal(String fieldValue) { return -1; }  public String getType() { return EditableUtils.getDisplayName(getClass()); }  public boolean checkListElements(Object value, Class<?> elementClass) { if (value instanceof List) { for (Object element: (List<?>)value) { if (element == null || element.getClass() != elementClass) return false; } return true; } else { return false; } }  } ", "nl": "  import java.io.Serializable; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map;  import javax.annotation.Nullable;  import org.apache.commons.lang.SerializationUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.unbescape.java.JavaEscape;  import com.google.common.collect.Lists;  import io.onedev.server.model.support.inputspec.showcondition.ShowCondition; import io.onedev.server.util.GroovyUtils; import io.onedev.server.web.editable.EditableUtils; import io.onedev.server.web.editable.annotation.Editable;  @Editable public abstract class InputSpec implements Serializable {  private static final long serialVersionUID = 1L;  private static final Logger logger = LoggerFactory.getLogger(InputSpec.class);  public static final String BOOLEAN = \"Checkbox\";  public static final String TEXT = \"Text\";  public static final String DATE = \"Date\";  public static final String SECRET = \"Secret\";  public static final String NUMBER = \"Number\";  public static final String COMMIT = \"Commit\";  public static final String ENUMERATION = \"Enumeration\";  public static final String USER = \"User\";  public static final String GROUP = \"Group\";  public static final String ISSUE = \"Issue\";  public static final String BUILD = \"Build\";  public static final String PULLREQUEST = \"Pull request\";  private String name;  private String description;  private boolean allowMultiple;  private boolean allowEmpty;  private ShowCondition showCondition;  public String getName() { return name; }  public void setName(String name) { this.name = name; }  public String getDescription() { return description; }  public void setDescription(String description) { this.description = description; }  public boolean isAllowMultiple() { return allowMultiple; }  public void setAllowMultiple(boolean allowMultiple) { this.allowMultiple = allowMultiple; }  public ShowCondition getShowCondition() { return showCondition; }  public void setShowCondition(ShowCondition showCondition) { this.showCondition = showCondition; }  public boolean isAllowEmpty() { return allowEmpty; }  public void setAllowEmpty(boolean allowEmpty) { this.allowEmpty = allowEmpty; }  public List<String> getPossibleValues() { return Lists.newArrayList(); }  protected String escape(String string) { String escaped = JavaEscape.escapeJava(string); escaped = escaped.replace(\"$\", \"\\\\$\");  return escaped; }  public abstract String getPropertyDef(Map<String, Integer> indexes);  protected String getLiteral(byte[] bytes) { StringBuffer buffer = new StringBuffer(\"[\"); for (byte eachByte: bytes) { buffer.append(String.format(\"%d\", eachByte)).append(\",\"); } buffer.append(\"] as byte[]\"); return buffer.toString(); }  public void appendField(StringBuffer buffer, int index, String type) { buffer.append(\"    private Optional<\" + type + \"> input\" + index + \";\\n\"); buffer.append(\"\\n\"); }  public void appendChoiceProvider(StringBuffer buffer, int index, String annotation) { buffer.append(\"    \" + annotation + \"(\\\"getInput\" + index + \"Choices\\\")\\n\"); }  public void appendCommonAnnotations(StringBuffer buffer, int index) { if (description != null) { buffer.append(\"    @Editable(name=\\\"\" + escape(name) + \"\\\", description=\\\"\" +  escape(description) + \"\\\", order=\" + index + \")\\n\"); } else { buffer.append(\"    @Editable(name=\\\"\" + escape(name) +  \"\\\", order=\" + index + \")\\n\"); } if (showCondition != null)  buffer.append(\"    @ShowCondition(\\\"isInput\" + index + \"Visible\\\")\\n\"); }  private void wrapWithChildContext(StringBuffer buffer, int index, String statement) { buffer.append(\"            ComponentContext context = ComponentContext.get();\\n\"); buffer.append(\"            if (context != null) {\\n\"); buffer.append(\"                ComponentContext childContext = context.getChildContext(\\\"input\" + index + \"\\\");\\n\"); buffer.append(\"                if (childContext != null) {\\n\"); buffer.append(\"                    ComponentContext.push(childContext);\\n\"); buffer.append(\"                    try {\\n\"); buffer.append(\"                        \" + statement + \"\\n\"); buffer.append(\"                    } finally {\\n\"); buffer.append(\"                        ComponentContext.pop();\\n\"); buffer.append(\"                    }\\n\"); buffer.append(\"                } else {\\n\"); buffer.append(\"                    \" + statement + \"\\n\"); buffer.append(\"                }\\n\"); buffer.append(\"            } else {\\n\"); buffer.append(\"                \" + statement + \"\\n\"); buffer.append(\"            }\\n\"); }  public void appendMethods(StringBuffer buffer, int index, String type,  @Nullable Serializable choiceProvider, @Nullable Serializable defaultValueProvider) { String literalBytes = getLiteral(SerializationUtils.serialize(defaultValueProvider)); buffer.append(\"    public \" + type + \" getInput\" + index + \"() {\\n\"); buffer.append(\"        if (input\" + index + \"!=null) {\\n\"); buffer.append(\"            return input\" + index + \".orNull();\\n\"); buffer.append(\"        } else {\\n\"); if (defaultValueProvider != null) { wrapWithChildContext(buffer, index, \"return SerializationUtils.deserialize(\" + literalBytes + \").getDefaultValue();\"); } else { buffer.append(\"        return null;\\n\"); } buffer.append(\"        }\\n\"); buffer.append(\"    }\\n\"); buffer.append(\"\\n\");  buffer.append(\"    public void setInput\" + index + \"(\" + type + \" value) {\\n\"); buffer.append(\"        this.input\" + index + \"=Optional.fromNullable(value);\\n\"); buffer.append(\"    }\\n\"); buffer.append(\"\\n\");  if (showCondition != null) { buffer.append(\"    private static boolean isInput\" + index + \"Visible() {\\n\"); literalBytes = getLiteral(SerializationUtils.serialize(showCondition)); buffer.append(\"        return SerializationUtils.deserialize(\" + literalBytes + \").isVisible();\\n\"); buffer.append(\"    }\\n\"); buffer.append(\"\\n\"); }   if (choiceProvider != null) { buffer.append(\"    private static List getInput\" + index + \"Choices() {\\n\"); literalBytes = getLiteral(SerializationUtils.serialize(choiceProvider)); if (choiceProvider instanceof io.onedev.server.model.support.inputspec.choiceinput.choiceprovider.ChoiceProvider) { buffer.append(\"        return new ArrayList(SerializationUtils.deserialize(\" + literalBytes + \").getChoices(false).keySet());\\n\"); } else { buffer.append(\"        return SerializationUtils.deserialize(\" + literalBytes + \").getChoices(false);\\n\"); } buffer.append(\"    }\\n\"); buffer.append(\"\\n\"); } }  public static Class<?> defineClass(String className, String description, Collection<? extends InputSpec> inputs) { StringBuffer buffer = new StringBuffer(); buffer.append(\"import org.apache.commons.lang3.SerializationUtils;\\n\"); buffer.append(\"import com.google.common.base.Optional;\\n\"); buffer.append(\"import io.onedev.server.web.editable.annotation.*;\\n\"); buffer.append(\"import io.onedev.server.util.validation.annotation.*;\\n\"); buffer.append(\"import io.onedev.util.*;\\n\"); buffer.append(\"import io.onedev.server.util.*;\\n\"); buffer.append(\"import io.onedev.server.util.facade.*;\\n\"); buffer.append(\"import java.util.*;\\n\"); buffer.append(\"import javax.validation.constraints.*;\\n\"); buffer.append(\"import org.hibernate.validator.constraints.*;\\n\"); buffer.append(\"\\n\"); buffer.append(\"@Editable(name=\").append(\"\\\"\").append(description).append(\"\\\")\\n\"); buffer.append(\"class \" + className + \" implements java.io.Serializable {\\n\"); buffer.append(\"\\n\"); buffer.append(\"    private static final long serialVersionUID = 1L;\\n\"); buffer.append(\"\\n\"); Map<String, Integer> indexes = new HashMap<>(); int index = 1; for (InputSpec input: inputs) indexes.put(input.getName(), index++); for (InputSpec input: inputs) buffer.append(input.getPropertyDef(indexes));  buffer.append(\"}\\n\"); buffer.append(\"return \" + className + \";\\n\");  logger.trace(\"Class definition script:\\n\" + buffer.toString());  return (Class<?>) GroovyUtils.evalScript(buffer.toString(), new HashMap<>()); }  public abstract List<String> convertToStrings(@Nullable Object object);   @Nullable public abstract Object convertToObject(List<String> strings);  public long getOrdinal(String fieldValue) { return -1; }  public String getType() { return EditableUtils.getDisplayName(getClass()); }  public boolean checkListElements(Object value, Class<?> elementClass) { if (value instanceof List) { for (Object element: (List<?>)value) { if (element == null || element.getClass() != elementClass) return false; } return true; } else { return false; } }  } "}
{"code": "import java.util.ArrayList;import java.util.List;import java.util.Map;import javax.validation.ValidationException;import com.google.common.collect.Lists;import io.onedev.server.model.support.inputspec.InputSpec;import io.onedev.server.model.support.inputspec.textinput.defaultvalueprovider.DefaultValueProvider;public class TextInput {public static String getPropertyDef(InputSpec inputSpec, Map<String, Integer> indexes, String pattern, DefaultValueProvider defaultValueProvider) {pattern = InputSpec.escape(pattern);int index = indexes.get(inputSpec.getName());StringBuffer buffer = new StringBuffer();inputSpec.appendField(buffer, index, \"String\");inputSpec.appendCommonAnnotations(buffer, index);if (!inputSpec.isAllowEmpty())buffer.append(\"    @NotEmpty\\n\");if (pattern != null)buffer.append(\"    @Pattern(regexp=\\\"\" + pattern + \"\\\", message=\\\"Should match regular expression: \" + pattern + \"\\\")\\n\");inputSpec.appendMethods(buffer, index, \"String\", null, defaultValueProvider);return buffer.toString();}public static Object convertToObject(List<String> strings) {if (strings.size() == 0)return null;else if (strings.size() == 1)return strings.iterator().next();elsethrow new ValidationException(\"Not eligible for multi-value\");}public static List<String> convertToStrings(Object value) {if (value instanceof String)return Lists.newArrayList((String)value);elsereturn new ArrayList<>();}}", "nl": "import java.util.ArrayList;import java.util.List;import java.util.Map;import javax.validation.ValidationException;import com.google.common.collect.Lists;import io.onedev.server.model.support.inputspec.InputSpec;import io.onedev.server.model.support.inputspec.textinput.defaultvalueprovider.DefaultValueProvider;public class TextInput {public static String getPropertyDef(InputSpec inputSpec, Map<String, Integer> indexes, String pattern, DefaultValueProvider defaultValueProvider) {int index = indexes.get(inputSpec.getName());StringBuffer buffer = new StringBuffer();inputSpec.appendField(buffer, index, \"String\");inputSpec.appendCommonAnnotations(buffer, index);if (!inputSpec.isAllowEmpty())buffer.append(\"    @NotEmpty\\n\");if (pattern != null)buffer.append(\"    @Pattern(regexp=\\\"\" + pattern + \"\\\", message=\\\"Should match regular expression: \" + pattern + \"\\\")\\n\");inputSpec.appendMethods(buffer, index, \"String\", null, defaultValueProvider);return buffer.toString();}public static Object convertToObject(List<String> strings) {if (strings.size() == 0)return null;else if (strings.size() == 1)return strings.iterator().next();elsethrow new ValidationException(\"Not eligible for multi-value\");}public static List<String> convertToStrings(Object value) {if (value instanceof String)return Lists.newArrayList((String)value);elsereturn new ArrayList<>();}}"}
{"code": "  public class Test {  @org.junit.Test public void test() { }  }", "nl": "  public class Test {  @org.junit.Test public void test() { }  }"}
{"code": "  import java.beans.IntrospectionException; import java.beans.PropertyDescriptor; import java.io.IOException; import java.io.StringReader; import java.io.StringWriter; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Collection; import java.util.Comparator; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set;  import org.hibernate.proxy.HibernateProxyHelper; import org.yaml.snakeyaml.DumperOptions; import org.yaml.snakeyaml.DumperOptions.FlowStyle; import org.yaml.snakeyaml.Yaml; import org.yaml.snakeyaml.constructor.Constructor; import org.yaml.snakeyaml.emitter.Emitter; import org.yaml.snakeyaml.introspector.BeanAccess; import org.yaml.snakeyaml.introspector.MethodProperty; import org.yaml.snakeyaml.introspector.Property; import org.yaml.snakeyaml.introspector.PropertyUtils; import org.yaml.snakeyaml.nodes.MappingNode; import org.yaml.snakeyaml.nodes.Node; import org.yaml.snakeyaml.nodes.NodeTuple; import org.yaml.snakeyaml.nodes.ScalarNode; import org.yaml.snakeyaml.nodes.Tag; import org.yaml.snakeyaml.representer.Representer; import org.yaml.snakeyaml.resolver.Resolver; import org.yaml.snakeyaml.serializer.Serializer;  import edu.emory.mathcs.backport.java.util.Collections; import io.onedev.commons.launcher.loader.ImplementationRegistry; import io.onedev.commons.utils.ClassUtils; import io.onedev.server.GeneralException; import io.onedev.server.OneDev; import io.onedev.server.util.BeanUtils; import io.onedev.server.web.editable.annotation.Editable;  public class VersionedYamlDoc extends MappingNode {  public VersionedYamlDoc(MappingNode wrapped) { super(wrapped.getTag(), wrapped.getValue(), wrapped.getFlowStyle()); }  public static VersionedYamlDoc fromYaml(String yaml) { return new VersionedYamlDoc((MappingNode) new OneYaml().compose(new StringReader(yaml))); }  @SuppressWarnings(\"unchecked\") public <T> T toBean(Class<T> beanClass) {         setTag(new Tag(beanClass)); if (getVersion() != null) { try { MigrationHelper.migrate(getVersion(), beanClass.newInstance(), this); removeVersion(); } catch (InstantiationException | IllegalAccessException e) { throw new RuntimeException(e); } }          return (T) new OneYaml().construct(this); }  public static VersionedYamlDoc fromBean(Object bean) { VersionedYamlDoc doc = new VersionedYamlDoc((MappingNode) new OneYaml().represent(bean)); doc.setVersion(MigrationHelper.getVersion(HibernateProxyHelper.getClassWithoutInitializingProxy(bean))); return doc; }  private String getVersion() { for (NodeTuple tuple: getValue()) { ScalarNode keyNode = (ScalarNode) tuple.getKeyNode(); if (keyNode.getValue().equals(\"version\"))  return ((ScalarNode)tuple.getValueNode()).getValue(); } throw new GeneralException(\"Unable to find version\"); }  private void removeVersion() { for (Iterator<NodeTuple> it = getValue().iterator(); it.hasNext();) { ScalarNode keyNode = (ScalarNode) it.next().getKeyNode(); if (keyNode.getValue().equals(\"version\"))  it.remove(); } }  private void setVersion(String version) { ScalarNode versionNode = null; for (NodeTuple tuple:  getValue()) { ScalarNode keyNode = (ScalarNode) tuple.getKeyNode(); if (keyNode.getValue().equals(\"version\")) { ((ScalarNode) tuple.getValueNode()).setValue(version); break; } } if (versionNode == null) { ScalarNode keyNode = new ScalarNode(Tag.STR, \"version\", null, null, DumperOptions.ScalarStyle.PLAIN); versionNode = new ScalarNode(Tag.INT, version, null, null, DumperOptions.ScalarStyle.PLAIN); getValue().add(0, new NodeTuple(keyNode, versionNode)); } }  public String toYaml() { StringWriter writer = new StringWriter(); DumperOptions dumperOptions = new DumperOptions(); Serializer serializer = new Serializer(new Emitter(writer, dumperOptions),  new Resolver(), dumperOptions, Tag.MAP); try { serializer.open(); serializer.serialize(this); serializer.close(); return writer.toString(); } catch (IOException e) { throw new RuntimeException(e); } }  private static class OneConstructor extends Constructor {  public Object construct(Node node) { return constructDocument(node); }  @Override protected Class<?> getClassForNode(Node node) { if (node instanceof VersionedYamlDoc) { return super.getClassForNode(node); } else { Class<?> type = node.getType(); if (type.getAnnotation(Editable.class) == null) { throw new IllegalStateException(String.format(\"Unexpected yaml node (type: %s, tag: %s)\",  type, node.getTag())); } else { if (!ClassUtils.isConcrete(type)) { ImplementationRegistry registry = OneDev.getInstance(ImplementationRegistry.class); for (Class<?> implementationClass: registry.getImplementations(node.getType())) { String implementationTag = new Tag(\"!\" + implementationClass.getSimpleName()).getValue(); if (implementationTag.equals(node.getTag().getValue())) return implementationClass; } } return super.getClassForNode(node); } } }  }  private static class OneYaml extends Yaml {  OneYaml() { super(newConstructor(), newRepresenter());   setBeanAccess(BeanAccess.PROPERTY); }  private static Representer newRepresenter() { Representer representer = new Representer() {      @SuppressWarnings(\"rawtypes\") @Override     protected NodeTuple representJavaBeanProperty(Object javaBean, Property property,      Object propertyValue,Tag customTag) {         if (propertyValue == null          || propertyValue instanceof Collection && ((Collection) propertyValue).isEmpty()         || propertyValue instanceof Map && ((Map) propertyValue).isEmpty()) {          return null;         } else {         return super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);         }     }  }; representer.setDefaultFlowStyle(FlowStyle.BLOCK); representer.setPropertyUtils(new PropertyUtils() {  @Override protected Set<Property> createPropertySet(Class<? extends Object> type, BeanAccess bAccess) { List<Property> properties = new ArrayList<>(); Map<String, Integer> orders = new HashMap<>(); if (type.getAnnotation(Editable.class) != null) { for (Method getter: BeanUtils.findGetters(type)) { Editable editable = getter.getAnnotation(Editable.class); Method setter = BeanUtils.findSetter(getter); if (editable != null && setter != null) { String propertyName = BeanUtils.getPropertyName(getter); try { properties.add(new MethodProperty(new PropertyDescriptor(propertyName, getter, setter))); } catch (IntrospectionException e) { throw new RuntimeException(e); } orders.put(propertyName, editable.order()); } } } Collections.sort(properties, new Comparator<Property>() {  @Override public int compare(Property o1, Property o2) { return orders.get(o1.getName()) - orders.get(o2.getName()); }  }); return new LinkedHashSet<>(properties); }  }); return representer; }  private static OneConstructor newConstructor() { return new OneConstructor(); }  public Object construct(Node node) {         return ((OneConstructor)constructor).construct(node); }      }  } ", "nl": "  import java.beans.IntrospectionException; import java.beans.PropertyDescriptor; import java.io.IOException; import java.io.StringReader; import java.io.StringWriter; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.Collection; import java.util.Comparator; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Set;  import org.hibernate.proxy.HibernateProxyHelper; import org.yaml.snakeyaml.DumperOptions; import org.yaml.snakeyaml.DumperOptions.FlowStyle; import org.yaml.snakeyaml.Yaml; import org.yaml.snakeyaml.constructor.Constructor; import org.yaml.snakeyaml.emitter.Emitter; import org.yaml.snakeyaml.introspector.BeanAccess; import org.yaml.snakeyaml.introspector.MethodProperty; import org.yaml.snakeyaml.introspector.Property; import org.yaml.snakeyaml.introspector.PropertyUtils; import org.yaml.snakeyaml.nodes.MappingNode; import org.yaml.snakeyaml.nodes.Node; import org.yaml.snakeyaml.nodes.NodeTuple; import org.yaml.snakeyaml.nodes.ScalarNode; import org.yaml.snakeyaml.nodes.Tag; import org.yaml.snakeyaml.representer.Representer; import org.yaml.snakeyaml.resolver.Resolver; import org.yaml.snakeyaml.serializer.Serializer;  import edu.emory.mathcs.backport.java.util.Collections; import io.onedev.commons.launcher.loader.ImplementationRegistry; import io.onedev.commons.utils.ClassUtils; import io.onedev.server.OneDev; import io.onedev.server.GeneralException; import io.onedev.server.util.BeanUtils; import io.onedev.server.web.editable.annotation.Editable;  public class VersionedYamlDoc extends MappingNode {  public VersionedYamlDoc(MappingNode wrapped) { super(wrapped.getTag(), wrapped.getValue(), wrapped.getFlowStyle()); }  public static VersionedYamlDoc fromYaml(String yaml) { return new VersionedYamlDoc((MappingNode) new OneYaml().compose(new StringReader(yaml))); }  @SuppressWarnings(\"unchecked\") public <T> T toBean(Class<T> beanClass) {         setTag(new Tag(beanClass));          if (getVersion() != null) { try { MigrationHelper.migrate(getVersion(), beanClass.newInstance(), this); removeVersion(); } catch (InstantiationException | IllegalAccessException e) { throw new RuntimeException(e); } }          return (T) new OneYaml().construct(this); }  public static VersionedYamlDoc fromBean(Object bean) { VersionedYamlDoc doc = new VersionedYamlDoc((MappingNode) new OneYaml().represent(bean)); doc.setVersion(MigrationHelper.getVersion(HibernateProxyHelper.getClassWithoutInitializingProxy(bean))); return doc; }  private String getVersion() { for (NodeTuple tuple: getValue()) { ScalarNode keyNode = (ScalarNode) tuple.getKeyNode(); if (keyNode.getValue().equals(\"version\"))  return ((ScalarNode)tuple.getValueNode()).getValue(); } throw new GeneralException(\"Unable to find version\"); }  private void removeVersion() { for (Iterator<NodeTuple> it = getValue().iterator(); it.hasNext();) { ScalarNode keyNode = (ScalarNode) it.next().getKeyNode(); if (keyNode.getValue().equals(\"version\"))  it.remove(); } }  private void setVersion(String version) { ScalarNode versionNode = null; for (NodeTuple tuple:  getValue()) { ScalarNode keyNode = (ScalarNode) tuple.getKeyNode(); if (keyNode.getValue().equals(\"version\")) { ((ScalarNode) tuple.getValueNode()).setValue(version); break; } } if (versionNode == null) { ScalarNode keyNode = new ScalarNode(Tag.STR, \"version\", null, null, DumperOptions.ScalarStyle.PLAIN); versionNode = new ScalarNode(Tag.INT, version, null, null, DumperOptions.ScalarStyle.PLAIN); getValue().add(0, new NodeTuple(keyNode, versionNode)); } }  public String toYaml() { StringWriter writer = new StringWriter(); DumperOptions dumperOptions = new DumperOptions(); Serializer serializer = new Serializer(new Emitter(writer, dumperOptions),  new Resolver(), dumperOptions, Tag.MAP); try { serializer.open(); serializer.serialize(this); serializer.close(); return writer.toString(); } catch (IOException e) { throw new RuntimeException(e); } }  private static class OneConstructor extends Constructor {  public Object construct(Node node) { return constructDocument(node); }  @Override protected Class<?> getClassForNode(Node node) { Class<?> type = node.getType(); if (type.getAnnotation(Editable.class) != null && !ClassUtils.isConcrete(type)) { ImplementationRegistry registry = OneDev.getInstance(ImplementationRegistry.class); for (Class<?> implementationClass: registry.getImplementations(node.getType())) { String implementationTag = new Tag(\"!\" + implementationClass.getSimpleName()).getValue(); if (implementationTag.equals(node.getTag().getValue())) return implementationClass; } }  return super.getClassForNode(node); }  }  private static class OneYaml extends Yaml {  OneYaml() { super(newConstructor(), newRepresenter());   setBeanAccess(BeanAccess.PROPERTY); }  private static Representer newRepresenter() { Representer representer = new Representer() {      @SuppressWarnings(\"rawtypes\") @Override     protected NodeTuple representJavaBeanProperty(Object javaBean, Property property,      Object propertyValue,Tag customTag) {         if (propertyValue == null          || propertyValue instanceof Collection && ((Collection) propertyValue).isEmpty()         || propertyValue instanceof Map && ((Map) propertyValue).isEmpty()) {          return null;         } else {         return super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);         }     }  }; representer.setDefaultFlowStyle(FlowStyle.BLOCK); representer.setPropertyUtils(new PropertyUtils() {  @Override protected Set<Property> createPropertySet(Class<? extends Object> type, BeanAccess bAccess) { List<Property> properties = new ArrayList<>(); Map<String, Integer> orders = new HashMap<>(); if (type.getAnnotation(Editable.class) != null) { for (Method getter: BeanUtils.findGetters(type)) { Editable editable = getter.getAnnotation(Editable.class); Method setter = BeanUtils.findSetter(getter); if (editable != null && setter != null) { String propertyName = BeanUtils.getPropertyName(getter); try { properties.add(new MethodProperty(new PropertyDescriptor(propertyName, getter, setter))); } catch (IntrospectionException e) { throw new RuntimeException(e); } orders.put(propertyName, editable.order()); } } } Collections.sort(properties, new Comparator<Property>() {  @Override public int compare(Property o1, Property o2) { return orders.get(o1.getName()) - orders.get(o2.getName()); }  }); return new LinkedHashSet<>(properties); }  }); return representer; }  private static OneConstructor newConstructor() { return new OneConstructor(); }  public Object construct(Node node) {         return ((OneConstructor)constructor).construct(node); }      }  } "}
{"code": "import java.io.IOException;import java.io.StringReader;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.xml.sax.SAXException;import org.yaml.snakeyaml.DumperOptions;import org.yaml.snakeyaml.DumperOptions.FlowStyle;import org.yaml.snakeyaml.emitter.Emitter;import org.yaml.snakeyaml.nodes.MappingNode;import org.yaml.snakeyaml.nodes.Node;import org.yaml.snakeyaml.nodes.NodeTuple;import org.yaml.snakeyaml.nodes.ScalarNode;import org.yaml.snakeyaml.nodes.SequenceNode;import org.yaml.snakeyaml.nodes.Tag;import org.yaml.snakeyaml.resolver.Resolver;import org.yaml.snakeyaml.serializer.Serializer;import com.google.common.collect.Lists;import io.onedev.commons.utils.StringUtils;public class XmlBuildSpecMigrator {private static Node migrateParamSpec(Element paramSpecElement) {String classTag = getClassTag(paramSpecElement.getName());List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, paramSpecElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"allowEmpty\"), new ScalarNode(Tag.STR, paramSpecElement.elementText(\"allowEmpty\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"allowMultiple\"), new ScalarNode(Tag.STR, paramSpecElement.elementText(\"allowMultiple\").trim())));Element patternElement = paramSpecElement.element(\"pattern\");if (patternElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"pattern\"), new ScalarNode(Tag.STR, patternElement.getText().trim())));}Element descriptionElement = paramSpecElement.element(\"description\");if (descriptionElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"description\"), new ScalarNode(Tag.STR, descriptionElement.getText().trim())));}Element minValueElement = paramSpecElement.element(\"minValue\");if (minValueElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"minValue\"), new ScalarNode(Tag.STR, minValueElement.getText().trim())));}Element maxValueElement = paramSpecElement.element(\"maxValue\");if (maxValueElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"maxValue\"), new ScalarNode(Tag.STR, maxValueElement.getText().trim())));}Element showConditionElement = paramSpecElement.element(\"showCondition\");if (showConditionElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"showCondition\"), migrateShowCondition(showConditionElement)));}Element defaultValueProviderElement = paramSpecElement.element(\"defaultValueProvider\");if (defaultValueProviderElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"defaultValueProvider\"), migrateDefaultValueProvider(defaultValueProviderElement)));}Element defaultMultiValueProviderElement = paramSpecElement.element(\"defaultMultiValueProvider\");if (defaultMultiValueProviderElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"defaultMultiValueProvider\"), migrateDefaultMultiValueProvider(defaultMultiValueProviderElement)));}Element choiceProviderElement = paramSpecElement.element(\"choiceProvider\");if (choiceProviderElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"choiceProvider\"), migrateChoiceProvider(choiceProviderElement)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static String getClassTag(String className) {return \"!\" + StringUtils.substringAfterLast(className, \".\");}private static Node migrateChoiceProvider(Element choiceProviderElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(choiceProviderElement.attributeValue(\"class\"));Element scriptNameElement = choiceProviderElement.element(\"scriptName\");if (scriptNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element choicesElement = choiceProviderElement.element(\"choices\");if (choicesElement != null) {List<Node> choiceNodes = new ArrayList<>();for (Element choiceElement: choicesElement.elements()) {List<NodeTuple> choiceTuples = new ArrayList<>();choiceTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new ScalarNode(Tag.STR, choiceElement.elementText(\"value\").trim())));choiceTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"color\"), new ScalarNode(Tag.STR, choiceElement.elementText(\"color\").trim())));choiceNodes.add(new MappingNode(Tag.MAP, choiceTuples, FlowStyle.BLOCK));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"choices\"), new SequenceNode(Tag.SEQ, choiceNodes, FlowStyle.BLOCK)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateDefaultMultiValueProvider(Element defaultMultiValueProviderElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(defaultMultiValueProviderElement.attributeValue(\"class\"));Element scriptNameElement = defaultMultiValueProviderElement.element(\"scriptName\");if (scriptNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valueElement = defaultMultiValueProviderElement.element(\"value\");if (valueElement != null) {List<Node> valueItemNodes = new ArrayList<>();for (Element valueItemElement: valueElement.elements())valueItemNodes.add(new ScalarNode(Tag.STR, valueItemElement.getText().trim()));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new SequenceNode(Tag.SEQ, valueItemNodes, FlowStyle.BLOCK)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateDefaultValueProvider(Element defaultValueProviderElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(defaultValueProviderElement.attributeValue(\"class\"));Element scriptNameElement = defaultValueProviderElement.element(\"scriptName\");if (scriptNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valueElement = defaultValueProviderElement.element(\"value\");if (valueElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new ScalarNode(Tag.STR, valueElement.getText().trim())));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateShowCondition(Element showConditionElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"inputName\"), new ScalarNode(Tag.STR, showConditionElement.elementText(\"inputName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"valueMatcher\"), migrateValueMatcher(showConditionElement.element(\"valueMatcher\"))));return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateValueMatcher(Element valueMatcherElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(valueMatcherElement.attributeValue(\"class\"));Element valuesElement = valueMatcherElement.element(\"values\");if (valuesElement != null) {List<Node> valueNodes = new ArrayList<>();for (Element valueElement: valuesElement.elements()) valueNodes.add(new ScalarNode(Tag.STR, valueElement.getText().trim()));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"values\"), new SequenceNode(Tag.SEQ, valueNodes, FlowStyle.BLOCK)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateJob(Element jobElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, jobElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"image\"), new ScalarNode(Tag.STR, jobElement.elementText(\"image\").trim())));List<Node> commandNodes = new ArrayList<>();for (Element commandElement: jobElement.element(\"commands\").elements()) commandNodes.add(new ScalarNode(Tag.STR, commandElement.getText().trim()));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"commands\"), new SequenceNode(Tag.SEQ, commandNodes, FlowStyle.BLOCK)));List<Node> paramSpecNodes = new ArrayList<>();for (Element paramSpecElement: jobElement.element(\"paramSpecs\").elements()) paramSpecNodes.add(migrateParamSpec(paramSpecElement));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"paramSpecs\"), new SequenceNode(Tag.SEQ, paramSpecNodes, FlowStyle.BLOCK)));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"retrieveSource\"),new ScalarNode(Tag.STR, jobElement.elementText(\"retrieveSource\").trim())));Element cloneDepthElement = jobElement.element(\"cloneDepth\");if (cloneDepthElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"cloneDepth\"),new ScalarNode(Tag.STR, cloneDepthElement.getText().trim())));}List<Node> submoduleCredentialNodes = new ArrayList<>();for (Element submoduleCredentialElement: jobElement.element(\"submoduleCredentials\").elements()) {List<NodeTuple> submoduleCredentialTuples = new ArrayList<>();submoduleCredentialTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"url\"), new ScalarNode(Tag.STR, submoduleCredentialElement.elementText(\"url\").trim())));submoduleCredentialTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"userName\"), new ScalarNode(Tag.STR, submoduleCredentialElement.elementText(\"userName\").trim())));submoduleCredentialTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"passwordSecret\"), new ScalarNode(Tag.STR, submoduleCredentialElement.elementText(\"passwordSecret\").trim())));submoduleCredentialNodes.add(new MappingNode(Tag.MAP, submoduleCredentialTuples, FlowStyle.BLOCK));}if (!submoduleCredentialNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"submoduleCredentials\"), new SequenceNode(Tag.SEQ, submoduleCredentialNodes, FlowStyle.BLOCK)));}List<Node> jobDependencyNodes = new ArrayList<>();for (Element jobDependencyElement: jobElement.element(\"jobDependencies\").elements()) jobDependencyNodes.add(migrateJobDependency(jobDependencyElement));if (!jobDependencyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobDependencies\"), new SequenceNode(Tag.SEQ, jobDependencyNodes, FlowStyle.BLOCK)));}List<Node> projectDependencyNodes = new ArrayList<>();for (Element projectDependencyElement: jobElement.element(\"projectDependencies\").elements()) projectDependencyNodes.add(migrateProjectDependency(projectDependencyElement));if (!projectDependencyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"projectDependencies\"), new SequenceNode(Tag.SEQ, projectDependencyNodes, FlowStyle.BLOCK)));}List<Node> serviceNodes = new ArrayList<>();for (Element serviceElement: jobElement.element(\"services\").elements()) serviceNodes.add(migrateService(serviceElement));if (!serviceNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"services\"), new SequenceNode(Tag.SEQ, serviceNodes, FlowStyle.BLOCK)));}Element artifactsElement = jobElement.element(\"artifacts\");if (artifactsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"artifacts\"), new ScalarNode(Tag.STR, artifactsElement.getText().trim())));}List<Node> reportNodes = new ArrayList<>();for (Element reportElement: jobElement.element(\"reports\").elements()) reportNodes.add(migrateReport(reportElement));if (!reportNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"reports\"), new SequenceNode(Tag.SEQ, reportNodes, FlowStyle.BLOCK)));}List<Node> triggerNodes = new ArrayList<>();for (Element triggerElement: jobElement.element(\"triggers\").elements()) triggerNodes.add(migrateTrigger(triggerElement));if (!triggerNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"triggers\"), new SequenceNode(Tag.SEQ, triggerNodes, FlowStyle.BLOCK)));}List<Node> cacheNodes = new ArrayList<>();for (Element cacheElement: jobElement.element(\"caches\").elements()) cacheNodes.add(migrateCache(cacheElement));if (!cacheNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"caches\"), new SequenceNode(Tag.SEQ, cacheNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"cpuRequirement\"), new ScalarNode(Tag.STR, jobElement.elementText(\"cpuRequirement\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"memoryRequirement\"), new ScalarNode(Tag.STR, jobElement.elementText(\"memoryRequirement\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"timeout\"), new ScalarNode(Tag.STR, jobElement.elementText(\"timeout\").trim())));List<Node> postBuildActionNodes = new ArrayList<>();for (Element postBuildActionElement: jobElement.element(\"postBuildActions\").elements())postBuildActionNodes.add(migratePostBuildAction(postBuildActionElement));if (!postBuildActionNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"postBuildActions\"), new SequenceNode(Tag.SEQ, postBuildActionNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"retryCondition\"), new ScalarNode(Tag.STR, jobElement.elementText(\"retryCondition\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"maxRetries\"), new ScalarNode(Tag.STR, jobElement.elementText(\"maxRetries\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"retryDelay\"), new ScalarNode(Tag.STR, jobElement.elementText(\"retryDelay\").trim())));Element defaultFixedIssuesFilterElement = jobElement.element(\"defaultFixedIssuesFilter\");if (defaultFixedIssuesFilterElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"defaultFixedIssuesFilter\"), new ScalarNode(Tag.STR, defaultFixedIssuesFilterElement.getText().trim())));}MappingNode jobNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);return jobNode;}private static Node migratePostBuildAction(Element postBuildActionElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(postBuildActionElement.getName());tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"condition\"), new ScalarNode(Tag.STR, postBuildActionElement.elementText(\"condition\").trim())));Element milestoneNameElement = postBuildActionElement.element(\"milestoneName\");if (milestoneNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"milestoneName\"), new ScalarNode(Tag.STR, milestoneNameElement.getText().trim())));}Element issueTitleElement = postBuildActionElement.element(\"issueTitle\");if (issueTitleElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"issueTitle\"), new ScalarNode(Tag.STR, issueTitleElement.getText().trim())));}Element issueDescriptionElement = postBuildActionElement.element(\"issueDescription\");if (issueDescriptionElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"issueDescription\"), new ScalarNode(Tag.STR, issueDescriptionElement.getText().trim())));}Element issueFieldsElement = postBuildActionElement.element(\"issueFields\");if (issueFieldsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"issueFields\"), new SequenceNode(Tag.SEQ, migrateFieldSupplies(issueFieldsElement.elements()), FlowStyle.BLOCK)));}Element tagNameElement = postBuildActionElement.element(\"tagName\");if (tagNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"tagName\"), new ScalarNode(Tag.STR, tagNameElement.getText().trim())));}Element tagMessageElement = postBuildActionElement.element(\"tagMessage\");if (tagMessageElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"tagMessage\"), new ScalarNode(Tag.STR, tagMessageElement.getText().trim())));}Element jobNameElement = postBuildActionElement.element(\"jobName\");if (jobNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobName\"), new ScalarNode(Tag.STR, jobNameElement.getText().trim())));}Element jobParamsElement = postBuildActionElement.element(\"jobParams\");if (jobParamsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobParams\"), new SequenceNode(Tag.SEQ, migrateParamSupplies(jobParamsElement.elements()), FlowStyle.BLOCK)));}Element receiversElement = postBuildActionElement.element(\"receivers\");if (receiversElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"receivers\"), new ScalarNode(Tag.STR, receiversElement.getText().trim())));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateCache(Element cacheElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"key\"), new ScalarNode(Tag.STR, cacheElement.elementText(\"key\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"path\"), new ScalarNode(Tag.STR, cacheElement.elementText(\"path\").trim())));return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateTrigger(Element triggerElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(triggerElement.getName());List<Node> paramSupplyNodes = migrateParamSupplies(triggerElement.element(\"params\").elements());if (!paramSupplyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"params\"), new SequenceNode(Tag.SEQ, paramSupplyNodes, FlowStyle.BLOCK)));}Element branchesElement = triggerElement.element(\"branches\");if (branchesElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"branches\"), new ScalarNode(Tag.STR, branchesElement.getText().trim())));}Element pathsElement = triggerElement.element(\"paths\");if (pathsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"paths\"), new ScalarNode(Tag.STR, pathsElement.getText().trim())));}Element tagsElement = triggerElement.element(\"tags\");if (tagsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"tags\"), new ScalarNode(Tag.STR, tagsElement.getText().trim())));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateReport(Element reportElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(reportElement.getName());tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"filePatterns\"), new ScalarNode(Tag.STR, reportElement.elementText(\"filePatterns\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"reportName\"), new ScalarNode(Tag.STR, reportElement.elementText(\"reportName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"startPage\"), new ScalarNode(Tag.STR, reportElement.elementText(\"startPage\").trim())));return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateService(Element serviceElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"image\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"image\").trim())));Element argumentsElement = serviceElement.element(\"arguments\");if (argumentsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"arguments\"), new ScalarNode(Tag.STR, argumentsElement.getText().trim())));}List<Node> envVarNodes = new ArrayList<>();for (Element envVarElement: serviceElement.element(\"envVars\").elements()) {List<NodeTuple> envVarTuples = new ArrayList<>();envVarTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"),new ScalarNode(Tag.STR, envVarElement.elementText(\"name\").trim())));envVarTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"),new ScalarNode(Tag.STR, envVarElement.elementText(\"value\").trim())));envVarNodes.add(new MappingNode(Tag.MAP, envVarTuples, FlowStyle.BLOCK));}if (!envVarNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"envVars\"), new SequenceNode(Tag.SEQ, envVarNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"readinessCheckCommand\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"readinessCheckCommand\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"cpuRequirement\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"cpuRequirement\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"memoryRequirement\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"memoryRequirement\").trim())));return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateProjectDependency(Element projectDependencyElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"projectName\"), new ScalarNode(Tag.STR, projectDependencyElement.elementText(\"projectName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"buildNumber\"), new ScalarNode(Tag.STR, projectDependencyElement.elementText(\"buildNumber\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"artifacts\"), new ScalarNode(Tag.STR, projectDependencyElement.elementText(\"artifacts\").trim())));Element authenticationElement = projectDependencyElement.element(\"authentication\");if (authenticationElement != null) {List<NodeTuple> authenticationTuples = new ArrayList<>();authenticationTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"userName\"), new ScalarNode(Tag.STR, authenticationElement.elementText(\"userName\").trim())));authenticationTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"passwordSecret\"), new ScalarNode(Tag.STR, authenticationElement.elementText(\"passwordSecret\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"authentication\"), new MappingNode(Tag.MAP, authenticationTuples, FlowStyle.BLOCK)));}return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateJobDependency(Element jobDependencyElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobName\"), new ScalarNode(Tag.STR, jobDependencyElement.elementText(\"jobName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"requireSuccessful\"), new ScalarNode(Tag.STR, jobDependencyElement.elementText(\"requireSuccessful\").trim())));Element artifactsElement = jobDependencyElement.element(\"artifacts\");if (artifactsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"artifacts\"), new ScalarNode(Tag.STR, artifactsElement.getText().trim())));}List<Node> paramSupplyNodes = migrateParamSupplies(jobDependencyElement.element(\"jobParams\").elements());if (!paramSupplyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobParams\"), new SequenceNode(Tag.SEQ, paramSupplyNodes, FlowStyle.BLOCK)));}return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static List<Node> migrateParamSupplies(List<Element> paramSupplyElements) {List<Node> paramSupplyNodes = new ArrayList<>();for (Element paramSupplyElement: paramSupplyElements) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, paramSupplyElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"secret\"), new ScalarNode(Tag.STR, paramSupplyElement.elementText(\"secret\").trim())));Element valuesProviderElement = paramSupplyElement.element(\"valuesProvider\");String classTag = getClassTag(valuesProviderElement.attributeValue(\"class\"));List<NodeTuple> valuesProviderTuples = new ArrayList<>();Element scriptNameElement = valuesProviderElement.element(\"scriptName\");if (scriptNameElement != null) {valuesProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valuesElement = valuesProviderElement.element(\"values\");if (valuesElement != null) {List<Node> listNodes = new ArrayList<>();for (Element listElement: valuesElement.elements()) {List<Node> listItemNodes = new ArrayList<>();for (Element listItemElement: listElement.elements()) listItemNodes.add(new ScalarNode(Tag.STR, listItemElement.getText().trim()));listNodes.add(new SequenceNode(Tag.SEQ, listItemNodes, FlowStyle.BLOCK));}valuesProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"values\"), new SequenceNode(Tag.SEQ, listNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"valuesProvider\"), new MappingNode(new Tag(classTag), valuesProviderTuples, FlowStyle.BLOCK)));paramSupplyNodes.add(new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK));}return paramSupplyNodes;}private static List<Node> migrateFieldSupplies(List<Element> fieldSupplyElements) {List<Node> fieldSupplyNodes = new ArrayList<>();for (Element fieldSupplyElement: fieldSupplyElements) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, fieldSupplyElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"secret\"), new ScalarNode(Tag.STR, fieldSupplyElement.elementText(\"secret\").trim())));Element valueProviderElement = fieldSupplyElement.element(\"valueProvider\");String classTag = getClassTag(valueProviderElement.attributeValue(\"class\"));List<NodeTuple> valueProviderTuples = new ArrayList<>();Element scriptNameElement = valueProviderElement.element(\"scriptName\");if (scriptNameElement != null) {valueProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valueElement = valueProviderElement.element(\"value\");if (valueElement != null) {List<Node> valueItemNodes = new ArrayList<>();for (Element valueItemElement: valueElement.elements()) valueItemNodes.add(new ScalarNode(Tag.STR, valueItemElement.getText().trim()));valueProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new SequenceNode(Tag.SEQ, valueItemNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"valueProvider\"), new MappingNode(new Tag(classTag), valueProviderTuples, FlowStyle.BLOCK)));fieldSupplyNodes.add(new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK));}return fieldSupplyNodes;}public static String migrate(String xml) {Document xmlDoc;try {SAXReader reader = new SAXReader();reader.setFeature(\"http:xmlDoc = reader.read(new StringReader(xml));} catch (DocumentException | SAXException e) {throw new RuntimeException(e);}List<NodeTuple> tuples = new ArrayList<>();Node keyNode = new ScalarNode(Tag.STR, \"version\");Node valueNode = new ScalarNode(Tag.INT, \"0\");tuples.add(new NodeTuple(keyNode, valueNode));List<Node> jobNodes = new ArrayList<>();for (Element jobElement: xmlDoc.getRootElement().element(\"jobs\").elements()) jobNodes.add(migrateJob(jobElement));if (!jobNodes.isEmpty()) {keyNode = new ScalarNode(Tag.STR, \"jobs\");tuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, jobNodes, FlowStyle.BLOCK)));}List<Node> propertyNodes = new ArrayList<>();Element propertiesElement = xmlDoc.getRootElement().element(\"properties\");if (propertiesElement != null) {for (Element propertyElement: propertiesElement.elements()) {Node nameNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"name\").trim());valueNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"value\").trim());List<NodeTuple> propertyTuples = Lists.newArrayList(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), nameNode), new NodeTuple(new ScalarNode(Tag.STR, \"value\"), valueNode));propertyNodes.add(new MappingNode(Tag.MAP, propertyTuples, FlowStyle.BLOCK));}}if(!propertyNodes.isEmpty()) {keyNode = new ScalarNode(Tag.STR, \"properties\");tuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, propertyNodes, FlowStyle.BLOCK)));}MappingNode rootNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);StringWriter writer = new StringWriter();DumperOptions dumperOptions = new DumperOptions();Serializer serializer = new Serializer(new Emitter(writer, dumperOptions), new Resolver(), dumperOptions, Tag.MAP);try {serializer.open();serializer.serialize(rootNode);serializer.close();return writer.toString();} catch (IOException e) {throw new RuntimeException(e);}}}", "nl": "import java.io.IOException;import java.io.StringReader;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.yaml.snakeyaml.DumperOptions;import org.yaml.snakeyaml.DumperOptions.FlowStyle;import org.yaml.snakeyaml.emitter.Emitter;import org.yaml.snakeyaml.nodes.MappingNode;import org.yaml.snakeyaml.nodes.Node;import org.yaml.snakeyaml.nodes.NodeTuple;import org.yaml.snakeyaml.nodes.ScalarNode;import org.yaml.snakeyaml.nodes.SequenceNode;import org.yaml.snakeyaml.nodes.Tag;import org.yaml.snakeyaml.resolver.Resolver;import org.yaml.snakeyaml.serializer.Serializer;import com.google.common.collect.Lists;import io.onedev.commons.utils.StringUtils;public class XmlBuildSpecMigrator {private static Node migrateParamSpec(Element paramSpecElement) {String classTag = getClassTag(paramSpecElement.getName());List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, paramSpecElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"allowEmpty\"), new ScalarNode(Tag.STR, paramSpecElement.elementText(\"allowEmpty\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"allowMultiple\"), new ScalarNode(Tag.STR, paramSpecElement.elementText(\"allowMultiple\").trim())));Element patternElement = paramSpecElement.element(\"pattern\");if (patternElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"pattern\"), new ScalarNode(Tag.STR, patternElement.getText().trim())));}Element descriptionElement = paramSpecElement.element(\"description\");if (descriptionElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"description\"), new ScalarNode(Tag.STR, descriptionElement.getText().trim())));}Element minValueElement = paramSpecElement.element(\"minValue\");if (minValueElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"minValue\"), new ScalarNode(Tag.STR, minValueElement.getText().trim())));}Element maxValueElement = paramSpecElement.element(\"maxValue\");if (maxValueElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"maxValue\"), new ScalarNode(Tag.STR, maxValueElement.getText().trim())));}Element showConditionElement = paramSpecElement.element(\"showCondition\");if (showConditionElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"showCondition\"), migrateShowCondition(showConditionElement)));}Element defaultValueProviderElement = paramSpecElement.element(\"defaultValueProvider\");if (defaultValueProviderElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"defaultValueProvider\"), migrateDefaultValueProvider(defaultValueProviderElement)));}Element defaultMultiValueProviderElement = paramSpecElement.element(\"defaultMultiValueProvider\");if (defaultMultiValueProviderElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"defaultMultiValueProvider\"), migrateDefaultMultiValueProvider(defaultMultiValueProviderElement)));}Element choiceProviderElement = paramSpecElement.element(\"choiceProvider\");if (choiceProviderElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"choiceProvider\"), migrateChoiceProvider(choiceProviderElement)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static String getClassTag(String className) {return \"!\" + StringUtils.substringAfterLast(className, \".\");}private static Node migrateChoiceProvider(Element choiceProviderElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(choiceProviderElement.attributeValue(\"class\"));Element scriptNameElement = choiceProviderElement.element(\"scriptName\");if (scriptNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element choicesElement = choiceProviderElement.element(\"choices\");if (choicesElement != null) {List<Node> choiceNodes = new ArrayList<>();for (Element choiceElement: choicesElement.elements()) {List<NodeTuple> choiceTuples = new ArrayList<>();choiceTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new ScalarNode(Tag.STR, choiceElement.elementText(\"value\").trim())));choiceTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"color\"), new ScalarNode(Tag.STR, choiceElement.elementText(\"color\").trim())));choiceNodes.add(new MappingNode(Tag.MAP, choiceTuples, FlowStyle.BLOCK));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"choices\"), new SequenceNode(Tag.SEQ, choiceNodes, FlowStyle.BLOCK)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateDefaultMultiValueProvider(Element defaultMultiValueProviderElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(defaultMultiValueProviderElement.attributeValue(\"class\"));Element scriptNameElement = defaultMultiValueProviderElement.element(\"scriptName\");if (scriptNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valueElement = defaultMultiValueProviderElement.element(\"value\");if (valueElement != null) {List<Node> valueItemNodes = new ArrayList<>();for (Element valueItemElement: valueElement.elements())valueItemNodes.add(new ScalarNode(Tag.STR, valueItemElement.getText().trim()));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new SequenceNode(Tag.SEQ, valueItemNodes, FlowStyle.BLOCK)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateDefaultValueProvider(Element defaultValueProviderElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(defaultValueProviderElement.attributeValue(\"class\"));Element scriptNameElement = defaultValueProviderElement.element(\"scriptName\");if (scriptNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valueElement = defaultValueProviderElement.element(\"value\");if (valueElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new ScalarNode(Tag.STR, valueElement.getText().trim())));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateShowCondition(Element showConditionElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"inputName\"), new ScalarNode(Tag.STR, showConditionElement.elementText(\"inputName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"valueMatcher\"), migrateValueMatcher(showConditionElement.element(\"valueMatcher\"))));return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateValueMatcher(Element valueMatcherElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(valueMatcherElement.attributeValue(\"class\"));Element valuesElement = valueMatcherElement.element(\"values\");if (valuesElement != null) {List<Node> valueNodes = new ArrayList<>();for (Element valueElement: valuesElement.elements()) valueNodes.add(new ScalarNode(Tag.STR, valueElement.getText().trim()));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"values\"), new SequenceNode(Tag.SEQ, valueNodes, FlowStyle.BLOCK)));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateJob(Element jobElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, jobElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"image\"), new ScalarNode(Tag.STR, jobElement.elementText(\"image\").trim())));List<Node> commandNodes = new ArrayList<>();for (Element commandElement: jobElement.element(\"commands\").elements()) commandNodes.add(new ScalarNode(Tag.STR, commandElement.getText().trim()));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"commands\"), new SequenceNode(Tag.SEQ, commandNodes, FlowStyle.BLOCK)));List<Node> paramSpecNodes = new ArrayList<>();for (Element paramSpecElement: jobElement.element(\"paramSpecs\").elements()) paramSpecNodes.add(migrateParamSpec(paramSpecElement));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"paramSpecs\"), new SequenceNode(Tag.SEQ, paramSpecNodes, FlowStyle.BLOCK)));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"retrieveSource\"),new ScalarNode(Tag.STR, jobElement.elementText(\"retrieveSource\").trim())));Element cloneDepthElement = jobElement.element(\"cloneDepth\");if (cloneDepthElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"cloneDepth\"),new ScalarNode(Tag.STR, cloneDepthElement.getText().trim())));}List<Node> submoduleCredentialNodes = new ArrayList<>();for (Element submoduleCredentialElement: jobElement.element(\"submoduleCredentials\").elements()) {List<NodeTuple> submoduleCredentialTuples = new ArrayList<>();submoduleCredentialTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"url\"), new ScalarNode(Tag.STR, submoduleCredentialElement.elementText(\"url\").trim())));submoduleCredentialTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"userName\"), new ScalarNode(Tag.STR, submoduleCredentialElement.elementText(\"userName\").trim())));submoduleCredentialTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"passwordSecret\"), new ScalarNode(Tag.STR, submoduleCredentialElement.elementText(\"passwordSecret\").trim())));submoduleCredentialNodes.add(new MappingNode(Tag.MAP, submoduleCredentialTuples, FlowStyle.BLOCK));}if (!submoduleCredentialNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"submoduleCredentials\"), new SequenceNode(Tag.SEQ, submoduleCredentialNodes, FlowStyle.BLOCK)));}List<Node> jobDependencyNodes = new ArrayList<>();for (Element jobDependencyElement: jobElement.element(\"jobDependencies\").elements()) jobDependencyNodes.add(migrateJobDependency(jobDependencyElement));if (!jobDependencyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobDependencies\"), new SequenceNode(Tag.SEQ, jobDependencyNodes, FlowStyle.BLOCK)));}List<Node> projectDependencyNodes = new ArrayList<>();for (Element projectDependencyElement: jobElement.element(\"projectDependencies\").elements()) projectDependencyNodes.add(migrateProjectDependency(projectDependencyElement));if (!projectDependencyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"projectDependencies\"), new SequenceNode(Tag.SEQ, projectDependencyNodes, FlowStyle.BLOCK)));}List<Node> serviceNodes = new ArrayList<>();for (Element serviceElement: jobElement.element(\"services\").elements()) serviceNodes.add(migrateService(serviceElement));if (!serviceNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"services\"), new SequenceNode(Tag.SEQ, serviceNodes, FlowStyle.BLOCK)));}Element artifactsElement = jobElement.element(\"artifacts\");if (artifactsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"artifacts\"), new ScalarNode(Tag.STR, artifactsElement.getText().trim())));}List<Node> reportNodes = new ArrayList<>();for (Element reportElement: jobElement.element(\"reports\").elements()) reportNodes.add(migrateReport(reportElement));if (!reportNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"reports\"), new SequenceNode(Tag.SEQ, reportNodes, FlowStyle.BLOCK)));}List<Node> triggerNodes = new ArrayList<>();for (Element triggerElement: jobElement.element(\"triggers\").elements()) triggerNodes.add(migrateTrigger(triggerElement));if (!triggerNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"triggers\"), new SequenceNode(Tag.SEQ, triggerNodes, FlowStyle.BLOCK)));}List<Node> cacheNodes = new ArrayList<>();for (Element cacheElement: jobElement.element(\"caches\").elements()) cacheNodes.add(migrateCache(cacheElement));if (!cacheNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"caches\"), new SequenceNode(Tag.SEQ, cacheNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"cpuRequirement\"), new ScalarNode(Tag.STR, jobElement.elementText(\"cpuRequirement\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"memoryRequirement\"), new ScalarNode(Tag.STR, jobElement.elementText(\"memoryRequirement\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"timeout\"), new ScalarNode(Tag.STR, jobElement.elementText(\"timeout\").trim())));List<Node> postBuildActionNodes = new ArrayList<>();for (Element postBuildActionElement: jobElement.element(\"postBuildActions\").elements())postBuildActionNodes.add(migratePostBuildAction(postBuildActionElement));if (!postBuildActionNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"postBuildActions\"), new SequenceNode(Tag.SEQ, postBuildActionNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"retryCondition\"), new ScalarNode(Tag.STR, jobElement.elementText(\"retryCondition\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"maxRetries\"), new ScalarNode(Tag.STR, jobElement.elementText(\"maxRetries\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"retryDelay\"), new ScalarNode(Tag.STR, jobElement.elementText(\"retryDelay\").trim())));Element defaultFixedIssuesFilterElement = jobElement.element(\"defaultFixedIssuesFilter\");if (defaultFixedIssuesFilterElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"defaultFixedIssuesFilter\"), new ScalarNode(Tag.STR, defaultFixedIssuesFilterElement.getText().trim())));}MappingNode jobNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);return jobNode;}private static Node migratePostBuildAction(Element postBuildActionElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(postBuildActionElement.getName());tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"condition\"), new ScalarNode(Tag.STR, postBuildActionElement.elementText(\"condition\").trim())));Element milestoneNameElement = postBuildActionElement.element(\"milestoneName\");if (milestoneNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"milestoneName\"), new ScalarNode(Tag.STR, milestoneNameElement.getText().trim())));}Element issueTitleElement = postBuildActionElement.element(\"issueTitle\");if (issueTitleElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"issueTitle\"), new ScalarNode(Tag.STR, issueTitleElement.getText().trim())));}Element issueDescriptionElement = postBuildActionElement.element(\"issueDescription\");if (issueDescriptionElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"issueDescription\"), new ScalarNode(Tag.STR, issueDescriptionElement.getText().trim())));}Element issueFieldsElement = postBuildActionElement.element(\"issueFields\");if (issueFieldsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"issueFields\"), new SequenceNode(Tag.SEQ, migrateFieldSupplies(issueFieldsElement.elements()), FlowStyle.BLOCK)));}Element tagNameElement = postBuildActionElement.element(\"tagName\");if (tagNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"tagName\"), new ScalarNode(Tag.STR, tagNameElement.getText().trim())));}Element tagMessageElement = postBuildActionElement.element(\"tagMessage\");if (tagMessageElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"tagMessage\"), new ScalarNode(Tag.STR, tagMessageElement.getText().trim())));}Element jobNameElement = postBuildActionElement.element(\"jobName\");if (jobNameElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobName\"), new ScalarNode(Tag.STR, jobNameElement.getText().trim())));}Element jobParamsElement = postBuildActionElement.element(\"jobParams\");if (jobParamsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobParams\"), new SequenceNode(Tag.SEQ, migrateParamSupplies(jobParamsElement.elements()), FlowStyle.BLOCK)));}Element receiversElement = postBuildActionElement.element(\"receivers\");if (receiversElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"receivers\"), new ScalarNode(Tag.STR, receiversElement.getText().trim())));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateCache(Element cacheElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"key\"), new ScalarNode(Tag.STR, cacheElement.elementText(\"key\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"path\"), new ScalarNode(Tag.STR, cacheElement.elementText(\"path\").trim())));return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateTrigger(Element triggerElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(triggerElement.getName());List<Node> paramSupplyNodes = migrateParamSupplies(triggerElement.element(\"params\").elements());if (!paramSupplyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"params\"), new SequenceNode(Tag.SEQ, paramSupplyNodes, FlowStyle.BLOCK)));}Element branchesElement = triggerElement.element(\"branches\");if (branchesElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"branches\"), new ScalarNode(Tag.STR, branchesElement.getText().trim())));}Element pathsElement = triggerElement.element(\"paths\");if (pathsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"paths\"), new ScalarNode(Tag.STR, pathsElement.getText().trim())));}Element tagsElement = triggerElement.element(\"tags\");if (tagsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"tags\"), new ScalarNode(Tag.STR, tagsElement.getText().trim())));}return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateReport(Element reportElement) {List<NodeTuple> tuples = new ArrayList<>();String classTag = getClassTag(reportElement.getName());tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"filePatterns\"), new ScalarNode(Tag.STR, reportElement.elementText(\"filePatterns\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"reportName\"), new ScalarNode(Tag.STR, reportElement.elementText(\"reportName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"startPage\"), new ScalarNode(Tag.STR, reportElement.elementText(\"startPage\").trim())));return new MappingNode(new Tag(classTag), tuples, FlowStyle.BLOCK);}private static Node migrateService(Element serviceElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"image\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"image\").trim())));Element argumentsElement = serviceElement.element(\"arguments\");if (argumentsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"arguments\"), new ScalarNode(Tag.STR, argumentsElement.getText().trim())));}List<Node> envVarNodes = new ArrayList<>();for (Element envVarElement: serviceElement.element(\"envVars\").elements()) {List<NodeTuple> envVarTuples = new ArrayList<>();envVarTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"),new ScalarNode(Tag.STR, envVarElement.elementText(\"name\").trim())));envVarTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"),new ScalarNode(Tag.STR, envVarElement.elementText(\"value\").trim())));envVarNodes.add(new MappingNode(Tag.MAP, envVarTuples, FlowStyle.BLOCK));}if (!envVarNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"envVars\"), new SequenceNode(Tag.SEQ, envVarNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"readinessCheckCommand\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"readinessCheckCommand\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"cpuRequirement\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"cpuRequirement\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"memoryRequirement\"), new ScalarNode(Tag.STR, serviceElement.elementText(\"memoryRequirement\").trim())));return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateProjectDependency(Element projectDependencyElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"projectName\"), new ScalarNode(Tag.STR, projectDependencyElement.elementText(\"projectName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"buildNumber\"), new ScalarNode(Tag.STR, projectDependencyElement.elementText(\"buildNumber\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"artifacts\"), new ScalarNode(Tag.STR, projectDependencyElement.elementText(\"artifacts\").trim())));Element authenticationElement = projectDependencyElement.element(\"authentication\");if (authenticationElement != null) {List<NodeTuple> authenticationTuples = new ArrayList<>();authenticationTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"userName\"), new ScalarNode(Tag.STR, authenticationElement.elementText(\"userName\").trim())));authenticationTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"passwordSecret\"), new ScalarNode(Tag.STR, authenticationElement.elementText(\"passwordSecret\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"authentication\"), new MappingNode(Tag.MAP, authenticationTuples, FlowStyle.BLOCK)));}return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static Node migrateJobDependency(Element jobDependencyElement) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobName\"), new ScalarNode(Tag.STR, jobDependencyElement.elementText(\"jobName\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"requireSuccessful\"), new ScalarNode(Tag.STR, jobDependencyElement.elementText(\"requireSuccessful\").trim())));Element artifactsElement = jobDependencyElement.element(\"artifacts\");if (artifactsElement != null) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"artifacts\"), new ScalarNode(Tag.STR, artifactsElement.getText().trim())));}List<Node> paramSupplyNodes = migrateParamSupplies(jobDependencyElement.element(\"jobParams\").elements());if (!paramSupplyNodes.isEmpty()) {tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"jobParams\"), new SequenceNode(Tag.SEQ, paramSupplyNodes, FlowStyle.BLOCK)));}return new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);}private static List<Node> migrateParamSupplies(List<Element> paramSupplyElements) {List<Node> paramSupplyNodes = new ArrayList<>();for (Element paramSupplyElement: paramSupplyElements) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, paramSupplyElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"secret\"), new ScalarNode(Tag.STR, paramSupplyElement.elementText(\"secret\").trim())));Element valuesProviderElement = paramSupplyElement.element(\"valuesProvider\");String classTag = getClassTag(valuesProviderElement.attributeValue(\"class\"));List<NodeTuple> valuesProviderTuples = new ArrayList<>();Element scriptNameElement = valuesProviderElement.element(\"scriptName\");if (scriptNameElement != null) {valuesProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valuesElement = valuesProviderElement.element(\"values\");if (valuesElement != null) {List<Node> listNodes = new ArrayList<>();for (Element listElement: valuesElement.elements()) {List<Node> listItemNodes = new ArrayList<>();for (Element listItemElement: listElement.elements()) listItemNodes.add(new ScalarNode(Tag.STR, listItemElement.getText().trim()));listNodes.add(new SequenceNode(Tag.SEQ, listItemNodes, FlowStyle.BLOCK));}valuesProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"values\"), new SequenceNode(Tag.SEQ, listNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"valuesProvider\"), new MappingNode(new Tag(classTag), valuesProviderTuples, FlowStyle.BLOCK)));paramSupplyNodes.add(new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK));}return paramSupplyNodes;}private static List<Node> migrateFieldSupplies(List<Element> fieldSupplyElements) {List<Node> fieldSupplyNodes = new ArrayList<>();for (Element fieldSupplyElement: fieldSupplyElements) {List<NodeTuple> tuples = new ArrayList<>();tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), new ScalarNode(Tag.STR, fieldSupplyElement.elementText(\"name\").trim())));tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"secret\"), new ScalarNode(Tag.STR, fieldSupplyElement.elementText(\"secret\").trim())));Element valueProviderElement = fieldSupplyElement.element(\"valueProvider\");String classTag = getClassTag(valueProviderElement.attributeValue(\"class\"));List<NodeTuple> valueProviderTuples = new ArrayList<>();Element scriptNameElement = valueProviderElement.element(\"scriptName\");if (scriptNameElement != null) {valueProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"scriptName\"), new ScalarNode(Tag.STR, scriptNameElement.getText().trim())));}Element valueElement = valueProviderElement.element(\"value\");if (valueElement != null) {List<Node> valueItemNodes = new ArrayList<>();for (Element valueItemElement: valueElement.elements()) valueItemNodes.add(new ScalarNode(Tag.STR, valueItemElement.getText().trim()));valueProviderTuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"value\"), new SequenceNode(Tag.SEQ, valueItemNodes, FlowStyle.BLOCK)));}tuples.add(new NodeTuple(new ScalarNode(Tag.STR, \"valueProvider\"), new MappingNode(new Tag(classTag), valueProviderTuples, FlowStyle.BLOCK)));fieldSupplyNodes.add(new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK));}return fieldSupplyNodes;}public static String migrate(String xml) {Document xmlDoc;try {xmlDoc = new SAXReader().read(new StringReader(xml));} catch (DocumentException e) {throw new RuntimeException(e);}List<NodeTuple> tuples = new ArrayList<>();Node keyNode = new ScalarNode(Tag.STR, \"version\");Node valueNode = new ScalarNode(Tag.INT, \"0\");tuples.add(new NodeTuple(keyNode, valueNode));List<Node> jobNodes = new ArrayList<>();for (Element jobElement: xmlDoc.getRootElement().element(\"jobs\").elements()) jobNodes.add(migrateJob(jobElement));if (!jobNodes.isEmpty()) {keyNode = new ScalarNode(Tag.STR, \"jobs\");tuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, jobNodes, FlowStyle.BLOCK)));}List<Node> propertyNodes = new ArrayList<>();Element propertiesElement = xmlDoc.getRootElement().element(\"properties\");if (propertiesElement != null) {for (Element propertyElement: propertiesElement.elements()) {Node nameNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"name\").trim());valueNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"value\").trim());List<NodeTuple> propertyTuples = Lists.newArrayList(new NodeTuple(new ScalarNode(Tag.STR, \"name\"), nameNode), new NodeTuple(new ScalarNode(Tag.STR, \"value\"), valueNode));propertyNodes.add(new MappingNode(Tag.MAP, propertyTuples, FlowStyle.BLOCK));}}if(!propertyNodes.isEmpty()) {keyNode = new ScalarNode(Tag.STR, \"properties\");tuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, propertyNodes, FlowStyle.BLOCK)));}MappingNode rootNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);StringWriter writer = new StringWriter();DumperOptions dumperOptions = new DumperOptions();Serializer serializer = new Serializer(new Emitter(writer, dumperOptions), new Resolver(), dumperOptions, Tag.MAP);try {serializer.open();serializer.serialize(rootNode);serializer.close();return writer.toString();} catch (IOException e) {throw new RuntimeException(e);}}}"}
{"code": "import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Hashtable;import java.util.List;import javax.annotation.Nullable;import javax.naming.AuthenticationException;import javax.naming.CompositeName;import javax.naming.Context;import javax.naming.InvalidNameException;import javax.naming.Name;import javax.naming.NamingEnumeration;import javax.naming.NamingException;import javax.naming.PartialResultException;import javax.naming.directory.Attribute;import javax.naming.directory.Attributes;import javax.naming.directory.DirContext;import javax.naming.directory.InitialDirContext;import javax.naming.directory.SearchControls;import javax.naming.directory.SearchResult;import javax.validation.constraints.NotNull;import org.apache.shiro.authc.AccountException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.hibernate.validator.constraints.NotEmpty;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import io.onedev.commons.utils.StringUtils;import io.onedev.server.model.support.administration.authenticator.Authenticated;import io.onedev.server.model.support.administration.authenticator.Authenticator;import io.onedev.server.web.editable.annotation.Editable;import io.onedev.server.web.editable.annotation.Password;@Editable(name=\"Generic LDAP\", order=200)public class LdapAuthenticator extends Authenticator {private static final long serialVersionUID = 1L;private static final Logger logger  = LoggerFactory.getLogger(LdapAuthenticator.class);private String ldapUrl;    private String managerDN;    private String managerPassword;    private String userSearchBase;    private String userSearchFilter;    private String userFullNameAttribute = \"displayName\";    private String userEmailAttribute = \"mail\";    private String userSshKeyAttribute;    private GroupRetrieval groupRetrieval = new DoNotRetrieveGroups();    @Editable(order=100, name=\"LDAP URL\", description=        \"Specifies LDAP URL, for example: <i>ldap:    @NotEmptypublic String getLdapUrl() {return ldapUrl;}public void setLdapUrl(String ldapUrl) {this.ldapUrl = ldapUrl;}@Editable(order=300, description=\"\"+ \"To authenticate user against LDAP and retrieve associated attributes and groups, OneDev would have to \"+ \"first authenticate itself against the LDAP server and OneDev does that by sending 'manager' DN and \"+ \"password\")@NotEmptypublic String getManagerDN() {return managerDN;}public void setManagerDN(String managerDN) {this.managerDN = managerDN;}@Editable(order=400, description=\"Specifies password of above manager DN\")@NotEmpty@Passwordpublic String getManagerPassword() {return managerPassword;}public void setManagerPassword(String managerPassword) {this.managerPassword = managerPassword;}@Editable(order=500, description=\"Specifies the base node for user search. For example: <i>ou=users, dc=example, dc=com</i>\")@NotEmptypublic String getUserSearchBase() {return userSearchBase;}public void setUserSearchBase(String userSearchBase) {this.userSearchBase = userSearchBase;}@Editable(order=600, description=     \"This filter is used to determine the LDAP entry for current user. \" +      \"For example: <i>(&(uid={0})(objectclass=person))</i>. In this example, \" +     \"<i>{0}</i> represents login name of current user.\")@NotEmptypublic String getUserSearchFilter() {return userSearchFilter;}public void setUserSearchFilter(String userSearchFilter) {this.userSearchFilter = userSearchFilter;}@Editable(order=700, description=\"\"+ \"Optionally specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"+ \"full name. This field is normally set to <i>displayName</i> according to RFC 2798. If left empty, full \"+ \"name of the user will not be retrieved\")public String getUserFullNameAttribute() {return userFullNameAttribute;}public void setUserFullNameAttribute(String userFullNameAttribute) {this.userFullNameAttribute = userFullNameAttribute;}@Editable(order=800, description=\"\"+ \"Specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"+ \"email. This field is normally set to <i>mail</i> according to RFC 2798\")@NotEmptypublic String getUserEmailAttribute() {return userEmailAttribute;}public void setUserEmailAttribute(String userEmailAttribute) {this.userEmailAttribute = userEmailAttribute;}@Editable(name=\"User SSH Key Attribute\", order=850, description=\"\"+ \"Optionally specify name of the attribute inside the user LDAP entry whose values will be taken as user \"+ \"SSH keys. SSH keys will be managed by LDAP only if this field is set\")public String getUserSshKeyAttribute() {return userSshKeyAttribute;}public void setUserSshKeyAttribute(String userSshKeyAttribute) {this.userSshKeyAttribute = userSshKeyAttribute;}@Editable(order=900, description=\"Specify the strategy to retrieve group membership information. \"+ \"To give appropriate permissions to a LDAP group, a OneDev group with same name should \"+ \"be defined. Use strategy <tt>Do Not Retrieve Groups</tt> if you want to manage group \"+ \"memberships at OneDev side\")@NotNull(message=\"may not be empty\")public GroupRetrieval getGroupRetrieval() {return groupRetrieval;}public void setGroupRetrieval(GroupRetrieval groupRetrieval) {this.groupRetrieval = groupRetrieval;}@Overridepublic Authenticated authenticate(UsernamePasswordToken token) {String fullName = null;String email = null;Collection<String> groupNames = null;        Collection<String> sshKeys = null;        Name userSearchBase;try {userSearchBase = new CompositeName().add(getUserSearchBase());} catch (InvalidNameException e) {throw new RuntimeException(e);}        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\",         escape(token.getUsername()));        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);        SearchControls searchControls = new SearchControls();        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);        List<String> attributeNames = new ArrayList<String>();        if (getUserFullNameAttribute() != null)            attributeNames.add(getUserFullNameAttribute());        if (getUserSshKeyAttribute() != null)        attributeNames.add(getUserSshKeyAttribute());        attributeNames.add(getUserEmailAttribute());        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {        GetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();            attributeNames.add(groupRetrieval.getUserGroupsAttribute());        }        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));        searchControls.setReturningObjFlag(true);        Hashtable<String, String> ldapEnv = new Hashtable<>();        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));        ldapEnv.put(Context.REFERRAL, \"follow\");        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());        DirContext ctx = null;        DirContext referralCtx = null;        try {            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");            try {            ctx = new InitialDirContext(ldapEnv);            } catch (AuthenticationException e) {        throw new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());            }            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);            if (results == null || !results.hasMore())                 throw new UnknownAccountException(\"Unknown account\");            SearchResult searchResult = (SearchResult) results.next();            String userDN = searchResult.getNameInNamespace();            if (!searchResult.isRelative()) {            StringBuffer buffer = new StringBuffer();                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"                buffer.append(\"                buffer.append(StringUtils.substringBefore(                StringUtils.substringAfter(searchResult.getName(), \"                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");                referralCtx = new InitialDirContext(ldapEnv);            }            if (userDN.startsWith(\"ldap\")) {            userDN = StringUtils.substringAfter(userDN, \"            userDN = StringUtils.substringAfter(userDN, \"/\");            }            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));            DirContext userCtx = null;            try {                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");                userCtx = new InitialDirContext(ldapEnv);            } catch (AuthenticationException e) {            throw new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);            } finally {                if (userCtx != null) {                    try {                        userCtx.close();                    } catch (NamingException e) {                    }                }            }            Attributes searchResultAttributes = searchResult.getAttributes();            if (searchResultAttributes != null) {                if (getUserFullNameAttribute() != null) {                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());                    if (attribute != null && attribute.get() != null)                        fullName = (String) attribute.get();                }                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());                if (attribute != null && attribute.get() != null)                    email = (String) attribute.get();                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute)                 groupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);                if (getUserSshKeyAttribute() != null)                 sshKeys = retrieveSshKeys(searchResultAttributes);            }            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter)             groupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);            if (StringUtils.isBlank(email))            throw new AccountException(\"Email is required but not available in ldap directory\");            else            return new Authenticated(email, fullName, groupNames, sshKeys);        } catch (NamingException e) {        throw new RuntimeException(e);        } finally {            if (ctx != null) {                try {                    ctx.close();                } catch (NamingException e) {                }            }            if (referralCtx != null) {                try {                    referralCtx.close();                } catch (NamingException e) {                }            }        }}private Collection<String> retrieveGroupsByAttribute(DirContext ctx, DirContext referralCtx, Attributes searchResultAttributes) {Collection<String> groupNames = new HashSet<>();try {        GetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute) getGroupRetrieval();            Attribute attribute = searchResultAttributes.get(groupRetrieval.getUserGroupsAttribute());            if (attribute != null) {                for (NamingEnumeration<?> e = attribute.getAll(); e.hasMore();) {                    Name groupDN = new CompositeName().add((String) e.next());                    logger.debug(\"Looking up group entry '\" + groupDN + \"'...\");                    DirContext groupCtx = null;                    try {                        if (referralCtx != null)                            groupCtx = (DirContext) referralCtx.lookup(groupDN);                        else                            groupCtx = (DirContext) ctx.lookup(groupDN);                        if (groupCtx == null) {                            throw new RuntimeException(\"Can not find group entry \" +                            \"identified by '\" + groupDN + \"'.\");                        }                        String groupNameAttribute = groupRetrieval.getGroupNameAttribute();                        Attributes groupAttributes = groupCtx.getAttributes(\"\",                         new String[]{groupNameAttribute});                        if (groupAttributes == null                         || groupAttributes.get(groupNameAttribute) == null                                || groupAttributes.get(groupNameAttribute).get() == null) {                            throw new RuntimeException(\"Can not find attribute '\"                             + groupNameAttribute + \"' in returned group entry.\");                        }                        groupNames.add((String) groupAttributes.get(groupNameAttribute).get());                    } finally {                        if (groupCtx != null) {                            try {                                groupCtx.close();                            } catch (NamingException ne) {                            }                        }                    }                }            } else {                logger.warn(\"No attribute identified by '\" + groupRetrieval.getUserGroupsAttribute()                 + \"' inside fetched user LDAP entry.\");            }} catch (NamingException e) {logger.error(\"Error retrieving groups by attribute\");}return groupNames;}private Collection<String> retrieveGroupsByFilter(DirContext ctx, DirContext referralCtx, String userDN) {Collection<String> groupNames = new HashSet<>();try {    SearchGroupsUsingFilter groupRetrieval = (SearchGroupsUsingFilter) getGroupRetrieval();    String groupNameAttribute = groupRetrieval.getGroupNameAttribute();        Name groupSearchBase = new CompositeName().add(groupRetrieval.getGroupSearchBase());        String groupSearchFilter = StringUtils.replace(groupRetrieval.getGroupSearchFilter(), \"{0}\", userDN);        groupSearchFilter = StringUtils.replace(groupSearchFilter, \"\\\\\", \"\\\\\\\\\");        logger.debug(\"Evaluated group search filter: \" + groupSearchFilter);        SearchControls searchControls = new SearchControls();        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);        searchControls.setReturningAttributes(new String[]{groupNameAttribute});        searchControls.setReturningObjFlag(true);    NamingEnumeration<SearchResult> results;        if (referralCtx != null)            results = referralCtx.search(groupSearchBase, groupSearchFilter, searchControls);        else            results = ctx.search(groupSearchBase, groupSearchFilter, searchControls);        if (results != null) {            while (results.hasMore()) {            SearchResult searchResult = (SearchResult) results.next();                Attributes searchResultAttributes = searchResult.getAttributes();                if (searchResultAttributes == null                 || searchResultAttributes.get(groupNameAttribute) == null                        || searchResultAttributes.get(groupNameAttribute).get() == null) {                    throw new RuntimeException(\"Can not find attribute '\"                     + groupNameAttribute + \"' in the returned group object.\");                }                groupNames.add((String) searchResultAttributes.get(groupNameAttribute).get());            }        }        } catch (PartialResultException pre) {            logger.warn(\"Partial exception detected. You may try to set property \" +            \"'follow referrals' to true to avoid this exception.\", pre);} catch (NamingException e) {logger.error(\"Error retrieving groups by filter\", e);}return groupNames;}@Nullableprivate Collection<String> retrieveSshKeys(Attributes searchResultAttributes) {Attribute attribute = searchResultAttributes.get(getUserSshKeyAttribute());if (attribute != null) {Collection<String> sshKeys = new ArrayList<>();try {NamingEnumeration<?> ldapValues = attribute.getAll();while (ldapValues.hasMore()) {Object value = ldapValues.next();if (value instanceof String) sshKeys.add((String) value);else logger.error(\"SSH key from ldap is not a String\");}} catch (NamingException e) {logger.error(\"Error retrieving SSH keys\", e);}return sshKeys;} else {return null;}}@Overridepublic boolean isManagingMemberships() {return !(getGroupRetrieval() instanceof DoNotRetrieveGroups);}@Overridepublic boolean isManagingSshKeys() {return getUserSshKeyAttribute() != null;}    private static String[] FILTER_ESCAPE_TABLE = new String['\\\\' + 1];    static {        for (char c = 0; c < FILTER_ESCAPE_TABLE.length; c++) {            FILTER_ESCAPE_TABLE[c] = String.valueOf(c);        }        FILTER_ESCAPE_TABLE['*'] = \"\\\\2a\";        FILTER_ESCAPE_TABLE['('] = \"\\\\28\";        FILTER_ESCAPE_TABLE[')'] = \"\\\\29\";        FILTER_ESCAPE_TABLE['\\\\'] = \"\\\\5c\";        FILTER_ESCAPE_TABLE[0] = \"\\\\00\";    }    private static String escape(String value) {        StringBuilder encodedValue = new StringBuilder(value.length() * 2);        int length = value.length();        for (int i = 0; i < length; i++) {            char c = value.charAt(i);            if (c < FILTER_ESCAPE_TABLE.length) {                encodedValue.append(FILTER_ESCAPE_TABLE[c]);            } else {                encodedValue.append(c);            }        }        return encodedValue.toString();    }}", "nl": "import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Hashtable;import java.util.List;import javax.annotation.Nullable;import javax.naming.AuthenticationException;import javax.naming.CompositeName;import javax.naming.Context;import javax.naming.InvalidNameException;import javax.naming.Name;import javax.naming.NamingEnumeration;import javax.naming.NamingException;import javax.naming.PartialResultException;import javax.naming.directory.Attribute;import javax.naming.directory.Attributes;import javax.naming.directory.DirContext;import javax.naming.directory.InitialDirContext;import javax.naming.directory.SearchControls;import javax.naming.directory.SearchResult;import javax.validation.constraints.NotNull;import org.apache.shiro.authc.AccountException;import org.apache.shiro.authc.UnknownAccountException;import org.apache.shiro.authc.UsernamePasswordToken;import org.hibernate.validator.constraints.NotEmpty;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import io.onedev.commons.utils.StringUtils;import io.onedev.server.model.support.administration.authenticator.Authenticated;import io.onedev.server.model.support.administration.authenticator.Authenticator;import io.onedev.server.web.editable.annotation.Editable;import io.onedev.server.web.editable.annotation.Password;@Editable(name=\"Generic LDAP\", order=200)public class LdapAuthenticator extends Authenticator {private static final long serialVersionUID = 1L;private static final Logger logger  = LoggerFactory.getLogger(LdapAuthenticator.class);private String ldapUrl;    private String managerDN;    private String managerPassword;    private String userSearchBase;    private String userSearchFilter;    private String userFullNameAttribute = \"displayName\";    private String userEmailAttribute = \"mail\";    private String userSshKeyAttribute;    private GroupRetrieval groupRetrieval = new DoNotRetrieveGroups();    @Editable(order=100, name=\"LDAP URL\", description=        \"Specifies LDAP URL, for example: <i>ldap:    @NotEmptypublic String getLdapUrl() {return ldapUrl;}public void setLdapUrl(String ldapUrl) {this.ldapUrl = ldapUrl;}@Editable(order=300, description=\"\"+ \"To authenticate user against LDAP and retrieve associated attributes and groups, OneDev would have to \"+ \"first authenticate itself against the LDAP server and OneDev does that by sending 'manager' DN and \"+ \"password\")@NotEmptypublic String getManagerDN() {return managerDN;}public void setManagerDN(String managerDN) {this.managerDN = managerDN;}@Editable(order=400, description=\"Specifies password of above manager DN\")@NotEmpty@Passwordpublic String getManagerPassword() {return managerPassword;}public void setManagerPassword(String managerPassword) {this.managerPassword = managerPassword;}@Editable(order=500, description=\"Specifies the base node for user search. For example: <i>ou=users, dc=example, dc=com</i>\")@NotEmptypublic String getUserSearchBase() {return userSearchBase;}public void setUserSearchBase(String userSearchBase) {this.userSearchBase = userSearchBase;}@Editable(order=600, description=     \"This filter is used to determine the LDAP entry for current user. \" +      \"For example: <i>(&(uid={0})(objectclass=person))</i>. In this example, \" +     \"<i>{0}</i> represents login name of current user.\")@NotEmptypublic String getUserSearchFilter() {return userSearchFilter;}public void setUserSearchFilter(String userSearchFilter) {this.userSearchFilter = userSearchFilter;}@Editable(order=700, description=\"\"+ \"Optionally specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"+ \"full name. This field is normally set to <i>displayName</i> according to RFC 2798. If left empty, full \"+ \"name of the user will not be retrieved\")public String getUserFullNameAttribute() {return userFullNameAttribute;}public void setUserFullNameAttribute(String userFullNameAttribute) {this.userFullNameAttribute = userFullNameAttribute;}@Editable(order=800, description=\"\"+ \"Specifies name of the attribute inside the user LDAP entry whose value will be taken as user \"+ \"email. This field is normally set to <i>mail</i> according to RFC 2798\")@NotEmptypublic String getUserEmailAttribute() {return userEmailAttribute;}public void setUserEmailAttribute(String userEmailAttribute) {this.userEmailAttribute = userEmailAttribute;}@Editable(name=\"User SSH Key Attribute\", order=850, description=\"\"+ \"Optionally specify name of the attribute inside the user LDAP entry whose values will be taken as user \"+ \"SSH keys. SSH keys will be managed by LDAP only if this field is set\")public String getUserSshKeyAttribute() {return userSshKeyAttribute;}public void setUserSshKeyAttribute(String userSshKeyAttribute) {this.userSshKeyAttribute = userSshKeyAttribute;}@Editable(order=900, description=\"Specify the strategy to retrieve group membership information. \"+ \"To give appropriate permissions to a LDAP group, a OneDev group with same name should \"+ \"be defined. Use strategy <tt>Do Not Retrieve Groups</tt> if you want to manage group \"+ \"memberships at OneDev side\")@NotNull(message=\"may not be empty\")public GroupRetrieval getGroupRetrieval() {return groupRetrieval;}public void setGroupRetrieval(GroupRetrieval groupRetrieval) {this.groupRetrieval = groupRetrieval;}@Overridepublic Authenticated authenticate(UsernamePasswordToken token) {String fullName = null;String email = null;Collection<String> groupNames = null;        Collection<String> sshKeys = null;        Name userSearchBase;try {userSearchBase = new CompositeName().add(getUserSearchBase());} catch (InvalidNameException e) {throw new RuntimeException(e);}        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\", token.getUsername());        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);        SearchControls searchControls = new SearchControls();        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);        List<String> attributeNames = new ArrayList<String>();        if (getUserFullNameAttribute() != null)            attributeNames.add(getUserFullNameAttribute());        if (getUserSshKeyAttribute() != null)        attributeNames.add(getUserSshKeyAttribute());        attributeNames.add(getUserEmailAttribute());        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {        GetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();            attributeNames.add(groupRetrieval.getUserGroupsAttribute());        }        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));        searchControls.setReturningObjFlag(true);        Hashtable<String, String> ldapEnv = new Hashtable<>();        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));        ldapEnv.put(Context.REFERRAL, \"follow\");        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());        DirContext ctx = null;        DirContext referralCtx = null;        try {            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");            try {            ctx = new InitialDirContext(ldapEnv);            } catch (AuthenticationException e) {        throw new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());            }            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);            if (results == null || !results.hasMore())                 throw new UnknownAccountException(\"Unknown account\");            SearchResult searchResult = (SearchResult) results.next();            String userDN = searchResult.getNameInNamespace();            if (!searchResult.isRelative()) {            StringBuffer buffer = new StringBuffer();                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"                buffer.append(\"                buffer.append(StringUtils.substringBefore(                StringUtils.substringAfter(searchResult.getName(), \"                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");                referralCtx = new InitialDirContext(ldapEnv);            }            if (userDN.startsWith(\"ldap\")) {            userDN = StringUtils.substringAfter(userDN, \"            userDN = StringUtils.substringAfter(userDN, \"/\");            }            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));            DirContext userCtx = null;            try {                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");                userCtx = new InitialDirContext(ldapEnv);            } catch (AuthenticationException e) {            throw new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);            } finally {                if (userCtx != null) {                    try {                        userCtx.close();                    } catch (NamingException e) {                    }                }            }            Attributes searchResultAttributes = searchResult.getAttributes();            if (searchResultAttributes != null) {                if (getUserFullNameAttribute() != null) {                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());                    if (attribute != null && attribute.get() != null)                        fullName = (String) attribute.get();                }                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());                if (attribute != null && attribute.get() != null)                    email = (String) attribute.get();                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute)                 groupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);                if (getUserSshKeyAttribute() != null)                 sshKeys = retrieveSshKeys(searchResultAttributes);            }            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter)             groupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);            if (StringUtils.isBlank(email))            throw new AccountException(\"Email is required but not available in ldap directory\");            else            return new Authenticated(email, fullName, groupNames, sshKeys);        } catch (NamingException e) {        throw new RuntimeException(e);        } finally {            if (ctx != null) {                try {                    ctx.close();                } catch (NamingException e) {                }            }            if (referralCtx != null) {                try {                    referralCtx.close();                } catch (NamingException e) {                }            }        }}private Collection<String> retrieveGroupsByAttribute(DirContext ctx, DirContext referralCtx, Attributes searchResultAttributes) {Collection<String> groupNames = new HashSet<>();try {        GetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute) getGroupRetrieval();            Attribute attribute = searchResultAttributes.get(groupRetrieval.getUserGroupsAttribute());            if (attribute != null) {                for (NamingEnumeration<?> e = attribute.getAll(); e.hasMore();) {                    Name groupDN = new CompositeName().add((String) e.next());                    logger.debug(\"Looking up group entry '\" + groupDN + \"'...\");                    DirContext groupCtx = null;                    try {                        if (referralCtx != null)                            groupCtx = (DirContext) referralCtx.lookup(groupDN);                        else                            groupCtx = (DirContext) ctx.lookup(groupDN);                        if (groupCtx == null) {                            throw new RuntimeException(\"Can not find group entry \" +                            \"identified by '\" + groupDN + \"'.\");                        }                        String groupNameAttribute = groupRetrieval.getGroupNameAttribute();                        Attributes groupAttributes = groupCtx.getAttributes(\"\",                         new String[]{groupNameAttribute});                        if (groupAttributes == null                         || groupAttributes.get(groupNameAttribute) == null                                || groupAttributes.get(groupNameAttribute).get() == null) {                            throw new RuntimeException(\"Can not find attribute '\"                             + groupNameAttribute + \"' in returned group entry.\");                        }                        groupNames.add((String) groupAttributes.get(groupNameAttribute).get());                    } finally {                        if (groupCtx != null) {                            try {                                groupCtx.close();                            } catch (NamingException ne) {                            }                        }                    }                }            } else {                logger.warn(\"No attribute identified by '\" + groupRetrieval.getUserGroupsAttribute()                 + \"' inside fetched user LDAP entry.\");            }} catch (NamingException e) {logger.error(\"Error retrieving groups by attribute\");}return groupNames;}private Collection<String> retrieveGroupsByFilter(DirContext ctx, DirContext referralCtx, String userDN) {Collection<String> groupNames = new HashSet<>();try {    SearchGroupsUsingFilter groupRetrieval = (SearchGroupsUsingFilter) getGroupRetrieval();    String groupNameAttribute = groupRetrieval.getGroupNameAttribute();        Name groupSearchBase = new CompositeName().add(groupRetrieval.getGroupSearchBase());        String groupSearchFilter = StringUtils.replace(groupRetrieval.getGroupSearchFilter(), \"{0}\", userDN);        groupSearchFilter = StringUtils.replace(groupSearchFilter, \"\\\\\", \"\\\\\\\\\");        logger.debug(\"Evaluated group search filter: \" + groupSearchFilter);        SearchControls searchControls = new SearchControls();        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);        searchControls.setReturningAttributes(new String[]{groupNameAttribute});        searchControls.setReturningObjFlag(true);    NamingEnumeration<SearchResult> results;        if (referralCtx != null)            results = referralCtx.search(groupSearchBase, groupSearchFilter, searchControls);        else            results = ctx.search(groupSearchBase, groupSearchFilter, searchControls);        if (results != null) {            while (results.hasMore()) {            SearchResult searchResult = (SearchResult) results.next();                Attributes searchResultAttributes = searchResult.getAttributes();                if (searchResultAttributes == null                 || searchResultAttributes.get(groupNameAttribute) == null                        || searchResultAttributes.get(groupNameAttribute).get() == null) {                    throw new RuntimeException(\"Can not find attribute '\"                     + groupNameAttribute + \"' in the returned group object.\");                }                groupNames.add((String) searchResultAttributes.get(groupNameAttribute).get());            }        }        } catch (PartialResultException pre) {            logger.warn(\"Partial exception detected. You may try to set property \" +            \"'follow referrals' to true to avoid this exception.\", pre);} catch (NamingException e) {logger.error(\"Error retrieving groups by filter\", e);}return groupNames;}@Nullableprivate Collection<String> retrieveSshKeys(Attributes searchResultAttributes) {Attribute attribute = searchResultAttributes.get(getUserSshKeyAttribute());if (attribute != null) {Collection<String> sshKeys = new ArrayList<>();try {NamingEnumeration<?> ldapValues = attribute.getAll();while (ldapValues.hasMore()) {Object value = ldapValues.next();if (value instanceof String) sshKeys.add((String) value);else logger.error(\"SSH key from ldap is not a String\");}} catch (NamingException e) {logger.error(\"Error retrieving SSH keys\", e);}return sshKeys;} else {return null;}}@Overridepublic boolean isManagingMemberships() {return !(getGroupRetrieval() instanceof DoNotRetrieveGroups);}@Overridepublic boolean isManagingSshKeys() {return getUserSshKeyAttribute() != null;}}"}
{"code": "import java.io.IOException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.bijay.onlinevotingsystem.dao.AdminDao;import com.bijay.onlinevotingsystem.dao.AdminDaoImpl;@WebServlet(\"/aLoginController\")public class AdminLoginController extends HttpServlet {private static final long serialVersionUID = 1L;AdminDao adminDao = new AdminDaoImpl();protected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {HttpSession session = request.getSession();session.invalidate();RequestDispatcher rd = request.getRequestDispatcher(\"adminlogin.jsp\");request.setAttribute(\"loggedOutMsg\", \"Log Out Successful\");rd.include(request, response);}protected void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {String userName = request.getParameter(\"aname\");String password = request.getParameter(\"pass\");String rememberMe = request.getParameter(\"remember-me\");if (adminDao.loginValidate(userName, password)) {if (rememberMe != null) {Cookie cookie1 = new Cookie(\"uname\", userName);Cookie cookie2 = new Cookie(\"pass\", password);cookie1.setMaxAge(24 * 60 * 60);cookie2.setMaxAge(24 * 60 * 60);response.addCookie(cookie1);response.addCookie(cookie2);}HttpSession session = request.getSession();session.setAttribute(\"username\", userName);response.sendRedirect(\"AdminController?actions=admin_list\");} else {RequestDispatcher rd = request.getRequestDispatcher(\"adminlogin.jsp\");request.setAttribute(\"loginFailMsg\", \"Invalid Username or Password !!\");rd.include(request, response);}}}", "nl": "import java.io.IOException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.bijay.onlinevotingsystem.dao.AdminDao;import com.bijay.onlinevotingsystem.dao.AdminDaoImpl;@WebServlet(\"/aLoginController\")public class AdminLoginController extends HttpServlet {private static final long serialVersionUID = 1L;AdminDao adminDao = new AdminDaoImpl();SHA256 sha = new SHA256();protected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {HttpSession session = request.getSession();session.invalidate();RequestDispatcher rd = request.getRequestDispatcher(\"adminlogin.jsp\");request.setAttribute(\"loggedOutMsg\", \"Log Out Successful\");rd.include(request, response);}protected void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {String userName = request.getParameter(\"aname\");String password = sha.getSHA(request.getParameter(\"pass\"));String rememberMe = request.getParameter(\"remember-me\");if (adminDao.loginValidate(userName, password)) {if (rememberMe != null) {Cookie cookie1 = new Cookie(\"uname\", userName);Cookie cookie2 = new Cookie(\"pass\", password);cookie1.setMaxAge(24 * 60 * 60);cookie2.setMaxAge(24 * 60 * 60);response.addCookie(cookie1);response.addCookie(cookie2);}HttpSession session = request.getSession();session.setAttribute(\"username\", userName);response.sendRedirect(\"AdminController?actions=admin_list\");} else {RequestDispatcher rd = request.getRequestDispatcher(\"adminlogin.jsp\");request.setAttribute(\"loginFailMsg\", \"Invalid Username or Password !!\");rd.include(request, response);}}}"}
{"code": "import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Base64;public class SHA256 {private static final String SSHA_PREFIX = \"{SSHA}\";private static final int SSHA_256_LENGTH = 32; private static final int SALT_LENGTH = 16; public String getSHA(String password) {try {byte[] salt = getSalt();String cipher = getCipher(password, salt);return cipher;} catch (NoSuchAlgorithmException e) {e.printStackTrace();return null;}}public static boolean validatePassword(String password, String cipherText) {boolean isValid = false;try {String cipher = cipherText.substring(SSHA_PREFIX.length());byte[] cipherBytes = Base64.getDecoder().decode(cipher.getBytes());byte[] salt = new byte[SALT_LENGTH];System.arraycopy(cipherBytes, SSHA_256_LENGTH, salt, 0, SALT_LENGTH);String result = getCipher(password, salt);isValid = result.equals(cipherText);} catch (NoSuchAlgorithmException e) {e.printStackTrace();}return isValid;}private static byte[] getSalt() throws NoSuchAlgorithmException {SecureRandom random = new SecureRandom();byte[] salt = new byte[SALT_LENGTH];random.nextBytes(salt);return salt;}private static String getCipher(String password, byte[] salt) throws NoSuchAlgorithmException {MessageDigest md = MessageDigest.getInstance(\"SHA-256\");md.update(salt);byte[] passBytes = password.getBytes();byte[] allBytes = new byte[passBytes.length + SALT_LENGTH];System.arraycopy(passBytes, 0, allBytes, 0, passBytes.length);System.arraycopy(salt, 0, allBytes, passBytes.length, SALT_LENGTH);byte[] cipherBytes = new byte[SSHA_256_LENGTH + SALT_LENGTH];byte[] messageDigest = md.digest(allBytes);System.arraycopy(messageDigest, 0, cipherBytes, 0, SSHA_256_LENGTH);System.arraycopy(salt, 0, cipherBytes, SSHA_256_LENGTH, SALT_LENGTH);String result = SSHA_PREFIX + Base64.getEncoder().encodeToString(cipherBytes);return result;}}", "nl": "import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class SHA256 {public String getSHA(String password) {try {MessageDigest md = MessageDigest.getInstance(\"SHA-256\");byte[] messageDigest = md.digest(password.getBytes());BigInteger no = new BigInteger(1, messageDigest);String hashPass = no.toString(16);while (hashPass.length() < 32) {hashPass = \"0\" + hashPass;}return hashPass;} catch (NoSuchAlgorithmException e) {e.printStackTrace();return null;}}}"}
{"code": "import java.io.IOException;import java.io.PrintWriter;import java.util.Random;import javax.mail.MessagingException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.bijay.onlinevotingsystem.dao.VoterDao;import com.bijay.onlinevotingsystem.dao.VoterDaoImpl;@WebServlet(\"/vLoginController\")public class VoterLoginController extends HttpServlet {private static final long serialVersionUID = 1L;VoterDao voterDao = new VoterDaoImpl();private String host;private String port;private String user;private String pass;public String recipient;public int otp;public int giveOtp() {return this.otp;}public void init() {ServletContext context = getServletContext();host = context.getInitParameter(\"host\");port = context.getInitParameter(\"port\");user = context.getInitParameter(\"user\");pass = context.getInitParameter(\"pass\");}public VoterLoginController() {super();}protected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {HttpSession session = request.getSession();session.invalidate();RequestDispatcher rd = request.getRequestDispatcher(\"voterlogin.jsp\");request.setAttribute(\"loggedOutMsg\", \"Log Out Successful !!\");rd.include(request, response);}protected void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {PrintWriter out = response.getWriter();int min = 100000;int max = 999999;otp = 5432;Random r = new Random();otp = r.nextInt(max - min) + min;String userName = request.getParameter(\"uname\");String password = request.getParameter(\"pass\");String vemail = request.getParameter(\"vmail\");String recipient = vemail;String subject = \"otp verification\";String content = \"your otp is: \" + otp;String resultMessage = \"\";if (voterDao.loginValidate(userName, password, vemail)) {HttpSession session = request.getSession();session.setAttribute(\"username\", userName);try {EmailSend.sendEmail(host, port, user, pass, recipient, subject, content);} catch (MessagingException e) {e.printStackTrace();resultMessage = \"There were an error: \" + e.getMessage();} finally {RequestDispatcher rd = request.getRequestDispatcher(\"OTP.jsp\");rd.include(request, response);out.println(\"<script type=\\\"text/javascript\\\">\");out.println(\"alert('\" + resultMessage + \"');\");out.println(\"</script>\");}} else {RequestDispatcher rd = request.getRequestDispatcher(\"voterlogin.jsp\");request.setAttribute(\"loginFailMsg\", \"Invalid Input ! Enter again !!\");rd.include(request, response);}}}", "nl": "import java.io.IOException;import java.io.PrintWriter;import java.util.Random;import javax.mail.MessagingException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.bijay.onlinevotingsystem.dao.VoterDao;import com.bijay.onlinevotingsystem.dao.VoterDaoImpl;@WebServlet(\"/vLoginController\")public class VoterLoginController extends HttpServlet {private static final long serialVersionUID = 1L;VoterDao voterDao = new VoterDaoImpl();SHA256 sha = new SHA256();private String host;private String port;private String user;private String pass;public String recipient;public int otp;public int giveOtp() {return this.otp;}public void init() {ServletContext context = getServletContext();host = context.getInitParameter(\"host\");port = context.getInitParameter(\"port\");user = context.getInitParameter(\"user\");pass = context.getInitParameter(\"pass\");}public VoterLoginController() {super();}protected void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {HttpSession session = request.getSession();session.invalidate();RequestDispatcher rd = request.getRequestDispatcher(\"voterlogin.jsp\");request.setAttribute(\"loggedOutMsg\", \"Log Out Successful !!\");rd.include(request, response);}protected void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {PrintWriter out = response.getWriter();int min = 100000;int max = 999999;otp = 5432;Random r = new Random();otp = r.nextInt(max - min) + min;String userName = request.getParameter(\"uname\");String password = sha.getSHA(request.getParameter(\"pass\"));String vemail = request.getParameter(\"vmail\");String recipient = vemail;String subject = \"otp verification\";String content = \"your otp is: \" + otp;String resultMessage = \"\";if (voterDao.loginValidate(userName, password, vemail)) {HttpSession session = request.getSession();session.setAttribute(\"username\", userName);try {EmailSend.sendEmail(host, port, user, pass, recipient, subject, content);} catch (MessagingException e) {e.printStackTrace();resultMessage = \"There were an error: \" + e.getMessage();} finally {RequestDispatcher rd = request.getRequestDispatcher(\"OTP.jsp\");rd.include(request, response);out.println(\"<script type=\\\"text/javascript\\\">\");out.println(\"alert('\" + resultMessage + \"');\");out.println(\"</script>\");}} else {RequestDispatcher rd = request.getRequestDispatcher(\"voterlogin.jsp\");request.setAttribute(\"loginFailMsg\", \"Invalid Input ! Enter again !!\");rd.include(request, response);}}}"}
{"code": "import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import javax.crypto.Cipher;import com.bijay.onlinevotingsystem.controller.SHA256;import com.bijay.onlinevotingsystem.dto.Admin;import com.bijay.onlinevotingsystem.util.DbUtil;public class AdminDaoImpl implements AdminDao {PreparedStatement ps = null;@Overridepublic void saveAdminInfo(Admin admin) {String sql = \"insert into admin_table(admin_name, password) values(?,?)\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, admin.getAdminName());ps.setString(2, admin.getPassword());ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic List<Admin> getAllAdminInfo() {List<Admin> adminList = new ArrayList<>();String sql = \"select * from admin_table\";try {ps = DbUtil.getConnection().prepareStatement(sql);ResultSet rs = ps.executeQuery();while (rs.next()) {Admin admin = new Admin();admin.setId(rs.getInt(\"id\"));admin.setAdminName(rs.getString(\"admin_name\"));admin.setPassword(rs.getString(\"password\"));adminList.add(admin);}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return adminList;}@Overridepublic void deleteAdminInfo(int id) {String sql = \"delete from admin_table where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setInt(1, id);ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic Admin getAdminInfoById(int id) {Admin admin = new Admin();String sql = \"select * from admin_table where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setInt(1, id);ResultSet rs = ps.executeQuery();if (rs.next()) {admin.setId(rs.getInt(\"id\"));admin.setAdminName(rs.getString(\"admin_name\"));admin.setPassword(rs.getString(\"password\"));}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return admin;}@Overridepublic void updateAdminInfo(Admin admin) {String sql = \"update admin_table set admin_name=?, password=? where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, admin.getAdminName());ps.setString(2, admin.getPassword());ps.setInt(3, admin.getId());ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic boolean loginValidate(String userName, String password) {String sql = \"select * from admin_table where admin_name=?\";try {ps=DbUtil.getConnection().prepareStatement(sql);ps.setString(1, userName);ResultSet rs =ps.executeQuery();if (rs.next()) {String cipherText = rs.getString(\"password\");return SHA256.validatePassword(password, cipherText);}} catch (SQLException | ClassNotFoundException e) {e.printStackTrace();}return false;}}", "nl": "import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import com.bijay.onlinevotingsystem.dto.Admin;import com.bijay.onlinevotingsystem.util.DbUtil;public class AdminDaoImpl implements AdminDao {PreparedStatement ps = null;@Overridepublic void saveAdminInfo(Admin admin) {String sql = \"insert into admin_table(admin_name, password) values(?,?)\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, admin.getAdminName());ps.setString(2, admin.getPassword());ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic List<Admin> getAllAdminInfo() {List<Admin> adminList = new ArrayList<>();String sql = \"select * from admin_table\";try {ps = DbUtil.getConnection().prepareStatement(sql);ResultSet rs = ps.executeQuery();while (rs.next()) {Admin admin = new Admin();admin.setId(rs.getInt(\"id\"));admin.setAdminName(rs.getString(\"admin_name\"));admin.setPassword(rs.getString(\"password\"));adminList.add(admin);}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return adminList;}@Overridepublic void deleteAdminInfo(int id) {String sql = \"delete from admin_table where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setInt(1, id);ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic Admin getAdminInfoById(int id) {Admin admin = new Admin();String sql = \"select * from admin_table where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setInt(1, id);ResultSet rs = ps.executeQuery();if (rs.next()) {admin.setId(rs.getInt(\"id\"));admin.setAdminName(rs.getString(\"admin_name\"));admin.setPassword(rs.getString(\"password\"));}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return admin;}@Overridepublic void updateAdminInfo(Admin admin) {String sql = \"update admin_table set admin_name=?, password=? where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, admin.getAdminName());ps.setString(2, admin.getPassword());ps.setInt(3, admin.getId());ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic boolean loginValidate(String userName, String password) {String sql = \"select * from admin_table where admin_name=? and password=?\";try {ps=DbUtil.getConnection().prepareStatement(sql);ps.setString(1, userName);ps.setString(2,password);ResultSet rs =ps.executeQuery();if (rs.next()) {return true;}} catch (SQLException | ClassNotFoundException e) {e.printStackTrace();}return false;}}"}
{"code": "import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.sql.Date;import com.bijay.onlinevotingsystem.controller.SHA256;import com.bijay.onlinevotingsystem.dto.Voter;import com.bijay.onlinevotingsystem.util.DbUtil;public class VoterDaoImpl implements VoterDao {PreparedStatement ps = null;@Overridepublic void saveVoterInfo(Voter voter) {String sql = \"insert into voter_table(voter_name, password, gender, state_no, district, email, dob, imageurl) values(?,?,?,?,?,?,?,?)\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, voter.getVoterName());ps.setString(2, voter.getPassword());ps.setString(3, voter.getGender());ps.setInt(4, voter.getStateNo());ps.setString(5, voter.getDistrictName());ps.setString(6, voter.getEmail());ps.setDate(7, new Date(voter.getDob().getTime()));ps.setString(8, voter.getImgUrl());ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic List<Voter> getAllVoterInfo() {List<Voter> voterList = new ArrayList<>();String sql = \"select * from voter_table\";try {ps = DbUtil.getConnection().prepareStatement(sql);ResultSet rs = ps.executeQuery();while (rs.next()) {Voter voter = new Voter();voter.setId(rs.getInt(\"id\"));voter.setVoterName(rs.getString(\"voter_name\"));voter.setPassword(rs.getString(\"password\"));voter.setStateNo(rs.getInt(\"state_no\"));voter.setDistrictName(rs.getString(\"district\"));voter.setGender(rs.getString(\"gender\"));voter.setImgUrl(rs.getString(\"imageurl\"));voter.setEmail(rs.getString(\"email\"));voter.setDob(rs.getDate(\"dob\"));voterList.add(voter);}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return voterList;}@Overridepublic void updateVoterInfo(Voter voter) {}@Overridepublic void deleteVoterInfo(int id) {String sql = \"delete from voter_table where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setInt(1, id);ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic boolean loginValidate(String userName, String password, String email) {String sql = \"select * from voter_table where voter_name=? and email=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, userName);ps.setString(2, email);ResultSet rs = ps.executeQuery();if (rs.next()) {String cipherText = rs.getString(\"password\");return SHA256.validatePassword(password, cipherText);}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return false;}}", "nl": "import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.sql.Date;import com.bijay.onlinevotingsystem.dto.Voter;import com.bijay.onlinevotingsystem.util.DbUtil;public class VoterDaoImpl implements VoterDao {PreparedStatement ps = null;@Overridepublic void saveVoterInfo(Voter voter) {String sql = \"insert into voter_table(voter_name, password, gender, state_no, district, email, dob, imageurl) values(?,?,?,?,?,?,?,?)\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, voter.getVoterName());ps.setString(2, voter.getPassword());ps.setString(3, voter.getGender());ps.setInt(4, voter.getStateNo());ps.setString(5, voter.getDistrictName());ps.setString(6, voter.getEmail());ps.setDate(7, new Date(voter.getDob().getTime()));ps.setString(8, voter.getImgUrl());ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic List<Voter> getAllVoterInfo() {List<Voter> voterList = new ArrayList<>();String sql = \"select * from voter_table\";try {ps = DbUtil.getConnection().prepareStatement(sql);ResultSet rs = ps.executeQuery();while (rs.next()) {Voter voter = new Voter();voter.setId(rs.getInt(\"id\"));voter.setVoterName(rs.getString(\"voter_name\"));voter.setPassword(rs.getString(\"password\"));voter.setStateNo(rs.getInt(\"state_no\"));voter.setDistrictName(rs.getString(\"district\"));voter.setGender(rs.getString(\"gender\"));voter.setImgUrl(rs.getString(\"imageurl\"));voter.setEmail(rs.getString(\"email\"));voter.setDob(rs.getDate(\"dob\"));voterList.add(voter);}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return voterList;}@Overridepublic void updateVoterInfo(Voter voter) {}@Overridepublic void deleteVoterInfo(int id) {String sql = \"delete from voter_table where id=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setInt(1, id);ps.executeUpdate();} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}}@Overridepublic boolean loginValidate(String userName, String password, String email) {String sql = \"select * from voter_table where voter_name=? and password=? and email=?\";try {ps = DbUtil.getConnection().prepareStatement(sql);ps.setString(1, userName);ps.setString(2, password);ps.setString(3, email);ResultSet rs = ps.executeQuery();if (rs.next()) {return true;}} catch (ClassNotFoundException | SQLException e) {e.printStackTrace();}return false;}}"}
{"code": "import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;import java.util.Optional;import java.util.concurrent.atomic.AtomicBoolean;import com.google.common.annotations.VisibleForTesting;import io.vertx.core.Handler;import io.vertx.core.json.JsonObject;import io.vertx.ext.auth.User;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class AuthenticationUtils {  private static final Logger LOG = LogManager.getLogger();  @VisibleForTesting  public static boolean isPermitted(      final Optional<AuthenticationService> authenticationService,      final Optional<User> optionalUser,      final JsonRpcMethod jsonRpcMethod) {    AtomicBoolean foundMatchingPermission = new AtomicBoolean();    if (authenticationService.isEmpty()) {      return true;    }    if (optionalUser.isPresent()) {      User user = optionalUser.get();      for (String perm : jsonRpcMethod.getPermissions()) {        user.isAuthorized(            perm,            (authed) -> {              if (authed.result()) {                LOG.trace(                    \"user {} authorized : {} via permission {}\",                    user,                    jsonRpcMethod.getName(),                    perm);                foundMatchingPermission.set(true);              }            });        if (foundMatchingPermission.get()) {          return foundMatchingPermission.get();        }      }    }    if (!foundMatchingPermission.get()) {      LOG.trace(\"user NOT authorized : {}\", jsonRpcMethod.getName());    }    return foundMatchingPermission.get();  }  public static void getUser(      final Optional<AuthenticationService> authenticationService,      final String token,      final Handler<Optional<User>> handler) {    try {      if (authenticationService.isEmpty()) {        handler.handle(Optional.empty());      } else {        authenticationService            .get()            .getJwtAuthProvider()            .authenticate(                new JsonObject().put(\"jwt\", token),                (r) -> {                  if (r.succeeded()) {                    final Optional<User> user = Optional.ofNullable(r.result());                    validateExpiryExists(user);                    handler.handle(user);                  } else {                    LOG.debug(\"Invalid JWT token\", r.cause());                    handler.handle(Optional.empty());                  }                });      }    } catch (Exception e) {      handler.handle(Optional.empty());    }  }  private static void validateExpiryExists(final Optional<User> user) {    if (!user.map(User::principal).map(p -> p.containsKey(\"exp\")).orElse(false)) {      throw new IllegalStateException(\"Invalid JWT doesn't have expiry\");    }  }  public static String getJwtTokenFromAuthorizationHeaderValue(final String value) {    if (value != null) {      final String bearerSchemaName = \"Bearer \";      if (value.startsWith(bearerSchemaName)) {        return value.substring(bearerSchemaName.length());      }    }    return null;  }}", "nl": "import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;import java.util.Optional;import java.util.concurrent.atomic.AtomicBoolean;import com.google.common.annotations.VisibleForTesting;import io.vertx.core.Handler;import io.vertx.core.json.JsonObject;import io.vertx.ext.auth.User;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class AuthenticationUtils {  private static final Logger LOG = LogManager.getLogger();  @VisibleForTesting  public static boolean isPermitted(      final Optional<AuthenticationService> authenticationService,      final Optional<User> optionalUser,      final JsonRpcMethod jsonRpcMethod) {    AtomicBoolean foundMatchingPermission = new AtomicBoolean();    if (authenticationService.isPresent()) {      if (optionalUser.isPresent()) {        User user = optionalUser.get();        for (String perm : jsonRpcMethod.getPermissions()) {          user.isAuthorized(              perm,              (authed) -> {                if (authed.result()) {                  LOG.trace(                      \"user {} authorized : {} via permission {}\",                      user,                      jsonRpcMethod.getName(),                      perm);                  foundMatchingPermission.set(true);                }              });        }      }    } else {      foundMatchingPermission.set(true);    }    if (!foundMatchingPermission.get()) {      LOG.trace(\"user NOT authorized : {}\", jsonRpcMethod.getName());    }    return foundMatchingPermission.get();  }  public static void getUser(      final Optional<AuthenticationService> authenticationService,      final String token,      final Handler<Optional<User>> handler) {    try {      if (authenticationService.isEmpty()) {        handler.handle(Optional.empty());      } else {        authenticationService            .get()            .getJwtAuthProvider()            .authenticate(                new JsonObject().put(\"jwt\", token),                (r) -> {                  if (r.succeeded()) {                    final Optional<User> user = Optional.ofNullable(r.result());                    validateExpiryExists(user);                    handler.handle(user);                  } else {                    LOG.debug(\"Invalid JWT token\", r.cause());                    handler.handle(Optional.empty());                  }                });      }    } catch (Exception e) {      handler.handle(Optional.empty());    }  }  private static void validateExpiryExists(final Optional<User> user) {    if (!user.map(User::principal).map(p -> p.containsKey(\"exp\")).orElse(false)) {      throw new IllegalStateException(\"Invalid JWT doesn't have expiry\");    }  }  public static String getJwtTokenFromAuthorizationHeaderValue(final String value) {    if (value != null) {      final String bearerSchemaName = \"Bearer \";      if (value.startsWith(bearerSchemaName)) {        return value.substring(bearerSchemaName.length());      }    }    return null;  }}"}
{"code": "import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;import java.util.ArrayList;import java.util.List;public interface JsonRpcMethod {  String getName();  JsonRpcResponse response(JsonRpcRequestContext request);  default List<String> getPermissions() {    List<String> permissions = new ArrayList<>();    permissions.add(\"*:*\");    permissions.add(this.getName().substring(0, this.getName().indexOf('_')) + \":*\");    permissions.add(this.getName().replace('_', ':'));    return permissions;  };}", "nl": "import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;import java.util.ArrayList;import java.util.List;public interface JsonRpcMethod {  String getName();  JsonRpcResponse response(JsonRpcRequestContext request);  default List<String> getPermissions() {    List<String> permissions = new ArrayList<>();    permissions.add(\"*:*\");    permissions.add(this.getName().replace('_', ':'));    permissions.add(this.getName().substring(0, this.getName().indexOf('_')) + \":*\");    return permissions;  };}"}
{"code": "import static java.nio.charset.StandardCharsets.UTF_8;import static java.util.concurrent.TimeUnit.MINUTES;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.util.Lists.list;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.spy;import org.hyperledger.besu.config.StubGenesisConfigOptions;import org.hyperledger.besu.ethereum.api.jsonrpc.authentication.AuthenticationUtils;import org.hyperledger.besu.ethereum.api.jsonrpc.health.HealthService;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthAccounts;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthBlockNumber;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.NetVersion;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3ClientVersion;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3Sha3;import org.hyperledger.besu.ethereum.api.jsonrpc.methods.JsonRpcMethodsFactory;import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.WebSocketConfiguration;import org.hyperledger.besu.ethereum.api.query.BlockchainQueries;import org.hyperledger.besu.ethereum.blockcreation.EthHashMiningCoordinator;import org.hyperledger.besu.ethereum.core.PrivacyParameters;import org.hyperledger.besu.ethereum.core.Synchronizer;import org.hyperledger.besu.ethereum.eth.EthProtocol;import org.hyperledger.besu.ethereum.eth.transactions.TransactionPool;import org.hyperledger.besu.ethereum.mainnet.MainnetProtocolSchedule;import org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;import org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;import org.hyperledger.besu.metrics.prometheus.MetricsConfiguration;import org.hyperledger.besu.nat.NatService;import java.io.IOException;import java.math.BigInteger;import java.nio.file.Paths;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.util.Arrays;import java.util.Base64;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Optional;import java.util.Set;import com.google.common.base.Splitter;import io.vertx.core.Vertx;import io.vertx.core.json.Json;import io.vertx.core.json.JsonArray;import io.vertx.core.json.JsonObject;import io.vertx.ext.auth.User;import io.vertx.ext.auth.jwt.JWTAuth;import okhttp3.MediaType;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;import org.assertj.core.api.Assertions;import org.junit.AfterClass;import org.junit.BeforeClass;import org.junit.ClassRule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import org.junit.runner.RunWith;import org.mockito.junit.MockitoJUnitRunner;@RunWith(MockitoJUnitRunner.StrictStubs.class)public class JsonRpcHttpServiceLoginTest {  @ClassRule public static final TemporaryFolder folder = new TemporaryFolder();  private static final Vertx vertx = Vertx.vertx();  protected static Map<String, JsonRpcMethod> rpcMethods;  protected static JsonRpcHttpService service;  protected static OkHttpClient client;  protected static String baseUrl;  protected static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");  protected static final String CLIENT_VERSION = \"TestClientVersion/0.1.0\";  protected static final BigInteger CHAIN_ID = BigInteger.valueOf(123);  protected static P2PNetwork peerDiscoveryMock;  protected static BlockchainQueries blockchainQueries;  protected static Synchronizer synchronizer;  protected static final Collection<RpcApi> JSON_RPC_APIS =      Arrays.asList(RpcApis.ETH, RpcApis.NET, RpcApis.WEB3, RpcApis.ADMIN);  protected static JWTAuth jwtAuth;  protected static String authPermissionsConfigFilePath = \"JsonRpcHttpService/auth.toml\";  protected final JsonRpcTestHelper testHelper = new JsonRpcTestHelper();  protected static final NatService natService = new NatService(Optional.empty());  @BeforeClass  public static void initServerAndClient() throws Exception {    peerDiscoveryMock = mock(P2PNetwork.class);    blockchainQueries = mock(BlockchainQueries.class);    synchronizer = mock(Synchronizer.class);    final Set<Capability> supportedCapabilities = new HashSet<>();    supportedCapabilities.add(EthProtocol.ETH62);    supportedCapabilities.add(EthProtocol.ETH63);    final StubGenesisConfigOptions genesisConfigOptions =        new StubGenesisConfigOptions().constantinopleBlock(0).chainId(CHAIN_ID);    rpcMethods =        spy(            new JsonRpcMethodsFactory()                .methods(                    CLIENT_VERSION,                    CHAIN_ID,                    genesisConfigOptions,                    peerDiscoveryMock,                    blockchainQueries,                    synchronizer,                    MainnetProtocolSchedule.fromConfig(genesisConfigOptions),                    mock(FilterManager.class),                    mock(TransactionPool.class),                    mock(EthHashMiningCoordinator.class),                    new NoOpMetricsSystem(),                    supportedCapabilities,                    Optional.empty(),                    Optional.empty(),                    JSON_RPC_APIS,                    mock(PrivacyParameters.class),                    mock(JsonRpcConfiguration.class),                    mock(WebSocketConfiguration.class),                    mock(MetricsConfiguration.class),                    natService,                    new HashMap<>()));    service = createJsonRpcHttpService();    jwtAuth = service.authenticationService.get().getJwtAuthProvider();    service.start().join();    client = new OkHttpClient();    baseUrl = service.url();  }  private static JsonRpcHttpService createJsonRpcHttpService() throws Exception {    final String authTomlPath =        Paths.get(ClassLoader.getSystemResource(authPermissionsConfigFilePath).toURI())            .toAbsolutePath()            .toString();    final JsonRpcConfiguration config = createJsonRpcConfig();    config.setAuthenticationEnabled(true);    config.setAuthenticationCredentialsFile(authTomlPath);    return new JsonRpcHttpService(        vertx,        folder.newFolder().toPath(),        config,        new NoOpMetricsSystem(),        natService,        rpcMethods,        HealthService.ALWAYS_HEALTHY,        HealthService.ALWAYS_HEALTHY);  }  private static JsonRpcConfiguration createJsonRpcConfig() {    final JsonRpcConfiguration config = JsonRpcConfiguration.createDefault();    config.setPort(0);    config.setHostsAllowlist(Collections.singletonList(\"*\"));    return config;  }  @AfterClass  public static void shutdownServer() {    service.stop().join();  }  @Test  public void loginWithBadCredentials() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"badpass\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  @Test  public void loginWithGoodCredentials() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      jwtAuth.authenticate(          new JsonObject().put(\"jwt\", token),          (r) -> {            assertThat(r.succeeded()).isTrue();            final User user = r.result();            user.isAuthorized(                \"noauths\",                (authed) -> {                  assertThat(authed.succeeded()).isTrue();                  assertThat(authed.result()).isFalse();                });          });    }  }  @Test  public void loginWithGoodCredentialsAndPermissions() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      jwtAuth.authenticate(          new JsonObject().put(\"jwt\", token),          (r) -> {            assertThat(r.succeeded()).isTrue();            final User user = r.result();            user.isAuthorized(                \"noauths\",                (authed) -> {                  assertThat(authed.succeeded()).isTrue();                  assertThat(authed.result()).isFalse();                });            user.isAuthorized(                \"fakePermission\",                (authed) -> {                  assertThat(authed.succeeded()).isTrue();                  assertThat(authed.result()).isTrue();                });          });    }  }  @Test  public void loginDoesntPopulateJWTPayloadWithPassword()      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      final JsonObject jwtPayload = decodeJwtPayload(token);      final String jwtPayloadString = jwtPayload.encode();      assertThat(jwtPayloadString.contains(\"password\")).isFalse();      assertThat(jwtPayloadString.contains(\"pegasys\")).isFalse();    }  }  @Test  public void loginPopulatesJWTPayloadWithRequiredValues()      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      final JsonObject jwtPayload = decodeJwtPayload(token);      assertThat(jwtPayload.getString(\"username\")).isEqualTo(\"user\");      assertThat(jwtPayload.getJsonArray(\"permissions\"))          .isEqualTo(              new JsonArray(list(\"fakePermission\", \"eth:blockNumber\", \"eth:subscribe\", \"web3:*\")));      assertThat(jwtPayload.getString(\"privacyPublicKey\"))          .isEqualTo(\"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\");      assertThat(jwtPayload.containsKey(\"iat\")).isTrue();      assertThat(jwtPayload.containsKey(\"exp\")).isTrue();      final long tokenExpiry = jwtPayload.getLong(\"exp\") - jwtPayload.getLong(\"iat\");      assertThat(tokenExpiry).isEqualTo(MINUTES.toSeconds(5));    }  }  private String login(final String username, final String password) throws IOException {    final RequestBody loginBody =        RequestBody.create(            JSON, \"{\\\"username\\\":\\\"\" + username + \"\\\",\\\"password\\\":\\\"\" + password + \"\\\"}\");    final Request loginRequest =        new Request.Builder().post(loginBody).url(baseUrl + \"/login\").build();    final String token;    try (final Response loginResp = client.newCall(loginRequest).execute()) {      assertThat(loginResp.code()).isEqualTo(200);      assertThat(loginResp.message()).isEqualTo(\"OK\");      assertThat(loginResp.body().contentType()).isNotNull();      assertThat(loginResp.body().contentType().type()).isEqualTo(\"application\");      assertThat(loginResp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = loginResp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      token = respBody.getString(\"token\");      assertThat(token).isNotNull();    }    return token;  }  @Test  public void checkJsonRpcMethodsAvailableWithGoodCredentialsAndPermissions() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      final JsonRpcMethod ethAccounts = new EthAccounts();      final JsonRpcMethod netVersion = new NetVersion(Optional.of(BigInteger.valueOf(123)));      final JsonRpcMethod ethBlockNumber = new EthBlockNumber(blockchainQueries);      final JsonRpcMethod web3Sha3 = new Web3Sha3();      final JsonRpcMethod web3ClientVersion = new Web3ClientVersion(\"777\");      jwtAuth.authenticate(          new JsonObject().put(\"jwt\", token),          (r) -> {            assertThat(r.succeeded()).isTrue();            final User user = r.result();            Assertions.assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), ethBlockNumber))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), ethAccounts))                .isFalse();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), web3ClientVersion))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), web3Sha3))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), netVersion))                .isFalse();          });    }  }  @Test  public void checkJsonRpcMethodsAvailableWithGoodCredentialsAndAllPermissions()      throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"adminuser\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      final JsonRpcMethod ethAccounts = new EthAccounts();      final JsonRpcMethod netVersion = new NetVersion(Optional.of(BigInteger.valueOf(123)));      final JsonRpcMethod ethBlockNumber = new EthBlockNumber(blockchainQueries);      final JsonRpcMethod web3Sha3 = new Web3Sha3();      final JsonRpcMethod web3ClientVersion = new Web3ClientVersion(\"777\");      jwtAuth.authenticate(          new JsonObject().put(\"jwt\", token),          (r) -> {            assertThat(r.succeeded()).isTrue();            final User user = r.result();            Assertions.assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), ethBlockNumber))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), ethAccounts))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), web3ClientVersion))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), web3Sha3))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), netVersion))                .isTrue();          });    }  }  @Test  public void checkPermissionsWithEmptyUser() {    final JsonRpcMethod ethAccounts = new EthAccounts();    assertThat(            AuthenticationUtils.isPermitted(                service.authenticationService, Optional.empty(), ethAccounts))        .isFalse();  }  @Test  public void web3ClientVersionUnsuccessfulBeforeLogin() throws Exception {    final String id = \"123\";    final RequestBody body =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"                + Json.encode(id)                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");    try (final Response resp = client.newCall(buildPostRequest(body)).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  @Test  public void web3ClientVersionUnsuccessfulWithBadBearer() throws Exception {    final String id = \"123\";    final RequestBody body =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"                + Json.encode(id)                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");    try (final Response resp = client.newCall(buildPostRequest(body, \"badtoken\")).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  @Test  public void web3ClientVersionSuccessfulAfterLogin() throws Exception {    final String token = login(\"user\", \"pegasys\");    final String id = \"123\";    final RequestBody web3ClientVersionBody =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"                + Json.encode(id)                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");    try (final Response web3ClientVersionResp =        client.newCall(buildPostRequest(web3ClientVersionBody, token)).execute()) {      assertThat(web3ClientVersionResp.code()).isEqualTo(200);      final JsonObject json = new JsonObject(web3ClientVersionResp.body().string());      testHelper.assertValidJsonRpcResult(json, id);      final String result = json.getString(\"result\");      assertThat(result).isEqualTo(\"TestClientVersion/0.1.0\");    }  }  @Test  public void ethSyncingUnauthorisedWithoutPermission() throws Exception {    final String token = login(\"user\", \"pegasys\");    final String id = \"007\";    final RequestBody body =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\" + Json.encode(id) + \",\\\"method\\\":\\\"eth_syncing\\\"}\");    try (final Response resp = client.newCall(buildPostRequest(body, token)).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  private Request buildPostRequest(final RequestBody body) {    return buildPostRequest(body, Optional.empty());  }  private Request buildPostRequest(final RequestBody body, final String token) {    return buildPostRequest(body, Optional.of(token));  }  private Request buildPostRequest(final RequestBody body, final Optional<String> token) {    final Request.Builder request = new Request.Builder().post(body).url(baseUrl);    token.ifPresent(t -> request.addHeader(\"Authorization\", \"Bearer \" + t));    return request.build();  }  private JsonObject decodeJwtPayload(final String token) {    final List<String> tokenParts = Splitter.on('.').splitToList(token);    final String payload = tokenParts.get(1);    return new JsonObject(new String(Base64.getUrlDecoder().decode(payload), UTF_8));  }}", "nl": "import static java.nio.charset.StandardCharsets.UTF_8;import static java.util.concurrent.TimeUnit.MINUTES;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.util.Lists.list;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.spy;import org.hyperledger.besu.config.StubGenesisConfigOptions;import org.hyperledger.besu.ethereum.api.jsonrpc.authentication.AuthenticationUtils;import org.hyperledger.besu.ethereum.api.jsonrpc.health.HealthService;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthAccounts;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthBlockNumber;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.NetVersion;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3ClientVersion;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3Sha3;import org.hyperledger.besu.ethereum.api.jsonrpc.methods.JsonRpcMethodsFactory;import org.hyperledger.besu.ethereum.api.jsonrpc.websocket.WebSocketConfiguration;import org.hyperledger.besu.ethereum.api.query.BlockchainQueries;import org.hyperledger.besu.ethereum.blockcreation.EthHashMiningCoordinator;import org.hyperledger.besu.ethereum.core.PrivacyParameters;import org.hyperledger.besu.ethereum.core.Synchronizer;import org.hyperledger.besu.ethereum.eth.EthProtocol;import org.hyperledger.besu.ethereum.eth.transactions.TransactionPool;import org.hyperledger.besu.ethereum.mainnet.MainnetProtocolSchedule;import org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;import org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;import org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;import org.hyperledger.besu.metrics.prometheus.MetricsConfiguration;import org.hyperledger.besu.nat.NatService;import java.io.IOException;import java.math.BigInteger;import java.nio.file.Paths;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.cert.CertificateException;import java.util.Arrays;import java.util.Base64;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Optional;import java.util.Set;import com.google.common.base.Splitter;import io.vertx.core.Vertx;import io.vertx.core.json.Json;import io.vertx.core.json.JsonArray;import io.vertx.core.json.JsonObject;import io.vertx.ext.auth.User;import io.vertx.ext.auth.jwt.JWTAuth;import okhttp3.MediaType;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;import org.assertj.core.api.Assertions;import org.junit.AfterClass;import org.junit.BeforeClass;import org.junit.ClassRule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import org.junit.runner.RunWith;import org.mockito.junit.MockitoJUnitRunner;@RunWith(MockitoJUnitRunner.StrictStubs.class)public class JsonRpcHttpServiceLoginTest {  @ClassRule public static final TemporaryFolder folder = new TemporaryFolder();  private static final Vertx vertx = Vertx.vertx();  protected static Map<String, JsonRpcMethod> rpcMethods;  protected static JsonRpcHttpService service;  protected static OkHttpClient client;  protected static String baseUrl;  protected static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");  protected static final String CLIENT_VERSION = \"TestClientVersion/0.1.0\";  protected static final BigInteger CHAIN_ID = BigInteger.valueOf(123);  protected static P2PNetwork peerDiscoveryMock;  protected static BlockchainQueries blockchainQueries;  protected static Synchronizer synchronizer;  protected static final Collection<RpcApi> JSON_RPC_APIS =      Arrays.asList(RpcApis.ETH, RpcApis.NET, RpcApis.WEB3, RpcApis.ADMIN);  protected static JWTAuth jwtAuth;  protected static String authPermissionsConfigFilePath = \"JsonRpcHttpService/auth.toml\";  protected final JsonRpcTestHelper testHelper = new JsonRpcTestHelper();  protected static final NatService natService = new NatService(Optional.empty());  @BeforeClass  public static void initServerAndClient() throws Exception {    peerDiscoveryMock = mock(P2PNetwork.class);    blockchainQueries = mock(BlockchainQueries.class);    synchronizer = mock(Synchronizer.class);    final Set<Capability> supportedCapabilities = new HashSet<>();    supportedCapabilities.add(EthProtocol.ETH62);    supportedCapabilities.add(EthProtocol.ETH63);    final StubGenesisConfigOptions genesisConfigOptions =        new StubGenesisConfigOptions().constantinopleBlock(0).chainId(CHAIN_ID);    rpcMethods =        spy(            new JsonRpcMethodsFactory()                .methods(                    CLIENT_VERSION,                    CHAIN_ID,                    genesisConfigOptions,                    peerDiscoveryMock,                    blockchainQueries,                    synchronizer,                    MainnetProtocolSchedule.fromConfig(genesisConfigOptions),                    mock(FilterManager.class),                    mock(TransactionPool.class),                    mock(EthHashMiningCoordinator.class),                    new NoOpMetricsSystem(),                    supportedCapabilities,                    Optional.empty(),                    Optional.empty(),                    JSON_RPC_APIS,                    mock(PrivacyParameters.class),                    mock(JsonRpcConfiguration.class),                    mock(WebSocketConfiguration.class),                    mock(MetricsConfiguration.class),                    natService,                    new HashMap<>()));    service = createJsonRpcHttpService();    jwtAuth = service.authenticationService.get().getJwtAuthProvider();    service.start().join();    client = new OkHttpClient();    baseUrl = service.url();  }  private static JsonRpcHttpService createJsonRpcHttpService() throws Exception {    final String authTomlPath =        Paths.get(ClassLoader.getSystemResource(authPermissionsConfigFilePath).toURI())            .toAbsolutePath()            .toString();    final JsonRpcConfiguration config = createJsonRpcConfig();    config.setAuthenticationEnabled(true);    config.setAuthenticationCredentialsFile(authTomlPath);    return new JsonRpcHttpService(        vertx,        folder.newFolder().toPath(),        config,        new NoOpMetricsSystem(),        natService,        rpcMethods,        HealthService.ALWAYS_HEALTHY,        HealthService.ALWAYS_HEALTHY);  }  private static JsonRpcConfiguration createJsonRpcConfig() {    final JsonRpcConfiguration config = JsonRpcConfiguration.createDefault();    config.setPort(0);    config.setHostsAllowlist(Collections.singletonList(\"*\"));    return config;  }  @AfterClass  public static void shutdownServer() {    service.stop().join();  }  @Test  public void loginWithBadCredentials() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"badpass\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  @Test  public void loginWithGoodCredentials() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      jwtAuth.authenticate(          new JsonObject().put(\"jwt\", token),          (r) -> {            assertThat(r.succeeded()).isTrue();            final User user = r.result();            user.isAuthorized(                \"noauths\",                (authed) -> {                  assertThat(authed.succeeded()).isTrue();                  assertThat(authed.result()).isFalse();                });          });    }  }  @Test  public void loginWithGoodCredentialsAndPermissions() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      jwtAuth.authenticate(          new JsonObject().put(\"jwt\", token),          (r) -> {            assertThat(r.succeeded()).isTrue();            final User user = r.result();            user.isAuthorized(                \"noauths\",                (authed) -> {                  assertThat(authed.succeeded()).isTrue();                  assertThat(authed.result()).isFalse();                });            user.isAuthorized(                \"fakePermission\",                (authed) -> {                  assertThat(authed.succeeded()).isTrue();                  assertThat(authed.result()).isTrue();                });          });    }  }  @Test  public void loginDoesntPopulateJWTPayloadWithPassword()      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      final JsonObject jwtPayload = decodeJwtPayload(token);      final String jwtPayloadString = jwtPayload.encode();      assertThat(jwtPayloadString.contains(\"password\")).isFalse();      assertThat(jwtPayloadString.contains(\"pegasys\")).isFalse();    }  }  @Test  public void loginPopulatesJWTPayloadWithRequiredValues()      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      final JsonObject jwtPayload = decodeJwtPayload(token);      assertThat(jwtPayload.getString(\"username\")).isEqualTo(\"user\");      assertThat(jwtPayload.getJsonArray(\"permissions\"))          .isEqualTo(              new JsonArray(list(\"fakePermission\", \"eth:blockNumber\", \"eth:subscribe\", \"web3:*\")));      assertThat(jwtPayload.getString(\"privacyPublicKey\"))          .isEqualTo(\"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\");      assertThat(jwtPayload.containsKey(\"iat\")).isTrue();      assertThat(jwtPayload.containsKey(\"exp\")).isTrue();      final long tokenExpiry = jwtPayload.getLong(\"exp\") - jwtPayload.getLong(\"iat\");      assertThat(tokenExpiry).isEqualTo(MINUTES.toSeconds(5));    }  }  private String login(final String username, final String password) throws IOException {    final RequestBody loginBody =        RequestBody.create(            JSON, \"{\\\"username\\\":\\\"\" + username + \"\\\",\\\"password\\\":\\\"\" + password + \"\\\"}\");    final Request loginRequest =        new Request.Builder().post(loginBody).url(baseUrl + \"/login\").build();    final String token;    try (final Response loginResp = client.newCall(loginRequest).execute()) {      assertThat(loginResp.code()).isEqualTo(200);      assertThat(loginResp.message()).isEqualTo(\"OK\");      assertThat(loginResp.body().contentType()).isNotNull();      assertThat(loginResp.body().contentType().type()).isEqualTo(\"application\");      assertThat(loginResp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = loginResp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      token = respBody.getString(\"token\");      assertThat(token).isNotNull();    }    return token;  }  @Test  public void checkJsonRpcMethodsAvailableWithGoodCredentialsAndPermissions() throws IOException {    final RequestBody body =        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();    try (final Response resp = client.newCall(request).execute()) {      assertThat(resp.code()).isEqualTo(200);      assertThat(resp.message()).isEqualTo(\"OK\");      assertThat(resp.body().contentType()).isNotNull();      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");      final String bodyString = resp.body().string();      assertThat(bodyString).isNotNull();      assertThat(bodyString).isNotBlank();      final JsonObject respBody = new JsonObject(bodyString);      final String token = respBody.getString(\"token\");      assertThat(token).isNotNull();      final JsonRpcMethod ethAccounts = new EthAccounts();      final JsonRpcMethod netVersion = new NetVersion(Optional.of(BigInteger.valueOf(123)));      final JsonRpcMethod ethBlockNumber = new EthBlockNumber(blockchainQueries);      final JsonRpcMethod web3Sha3 = new Web3Sha3();      final JsonRpcMethod web3ClientVersion = new Web3ClientVersion(\"777\");      jwtAuth.authenticate(          new JsonObject().put(\"jwt\", token),          (r) -> {            assertThat(r.succeeded()).isTrue();            final User user = r.result();            Assertions.assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), ethBlockNumber))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), ethAccounts))                .isFalse();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), web3ClientVersion))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), web3Sha3))                .isTrue();            assertThat(                    AuthenticationUtils.isPermitted(                        service.authenticationService, Optional.of(user), netVersion))                .isFalse();          });    }  }  @Test  public void checkPermissionsWithEmptyUser() {    final JsonRpcMethod ethAccounts = new EthAccounts();    assertThat(            AuthenticationUtils.isPermitted(                service.authenticationService, Optional.empty(), ethAccounts))        .isFalse();  }  @Test  public void web3ClientVersionUnsuccessfulBeforeLogin() throws Exception {    final String id = \"123\";    final RequestBody body =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"                + Json.encode(id)                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");    try (final Response resp = client.newCall(buildPostRequest(body)).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  @Test  public void web3ClientVersionUnsuccessfulWithBadBearer() throws Exception {    final String id = \"123\";    final RequestBody body =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"                + Json.encode(id)                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");    try (final Response resp = client.newCall(buildPostRequest(body, \"badtoken\")).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  @Test  public void web3ClientVersionSuccessfulAfterLogin() throws Exception {    final String token = login(\"user\", \"pegasys\");    final String id = \"123\";    final RequestBody web3ClientVersionBody =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"                + Json.encode(id)                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");    try (final Response web3ClientVersionResp =        client.newCall(buildPostRequest(web3ClientVersionBody, token)).execute()) {      assertThat(web3ClientVersionResp.code()).isEqualTo(200);      final JsonObject json = new JsonObject(web3ClientVersionResp.body().string());      testHelper.assertValidJsonRpcResult(json, id);      final String result = json.getString(\"result\");      assertThat(result).isEqualTo(\"TestClientVersion/0.1.0\");    }  }  @Test  public void ethSyncingUnauthorisedWithoutPermission() throws Exception {    final String token = login(\"user\", \"pegasys\");    final String id = \"007\";    final RequestBody body =        RequestBody.create(            JSON,            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\" + Json.encode(id) + \",\\\"method\\\":\\\"eth_syncing\\\"}\");    try (final Response resp = client.newCall(buildPostRequest(body, token)).execute()) {      assertThat(resp.code()).isEqualTo(401);      assertThat(resp.message()).isEqualTo(\"Unauthorized\");    }  }  private Request buildPostRequest(final RequestBody body) {    return buildPostRequest(body, Optional.empty());  }  private Request buildPostRequest(final RequestBody body, final String token) {    return buildPostRequest(body, Optional.of(token));  }  private Request buildPostRequest(final RequestBody body, final Optional<String> token) {    final Request.Builder request = new Request.Builder().post(body).url(baseUrl);    token.ifPresent(t -> request.addHeader(\"Authorization\", \"Bearer \" + t));    return request.build();  }  private JsonObject decodeJwtPayload(final String token) {    final List<String> tokenParts = Splitter.on('.').splitToList(token);    final String payload = tokenParts.get(1);    return new JsonObject(new String(Base64.getUrlDecoder().decode(payload), UTF_8));  }}"}
{"code": "import static org.assertj.core.api.Assertions.assertThat;import static org.mockito.Mockito.when;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;import org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;import java.util.List;import org.assertj.core.api.Assertions;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.Mock;import org.mockito.junit.MockitoJUnitRunner;@RunWith(MockitoJUnitRunner.class)public class NetListeningTest {  private NetListening method;  @Mock private P2PNetwork p2PNetwork;  @Before  public void before() {    this.method = new NetListening(p2PNetwork);  }  @Test  public void shouldReturnTrueWhenNetworkIsListening() {    when(p2PNetwork.isListening()).thenReturn(true);    final JsonRpcRequestContext request = netListeningRequest();    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, true);    Assertions.assertThat(method.response(request))        .isEqualToComparingFieldByField(expectedResponse);  }  @Test  public void shouldReturnFalseWhenNetworkIsNotListening() {    when(p2PNetwork.isListening()).thenReturn(false);    final JsonRpcRequestContext request = netListeningRequest();    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, false);    Assertions.assertThat(method.response(request))        .isEqualToComparingFieldByField(expectedResponse);  }  @Test  public void getPermissions() {    List<String> permissions = method.getPermissions();    assertThat(permissions).containsExactly(\"*:*\", \"net:*\", \"net:listening\");  }  private JsonRpcRequestContext netListeningRequest() {    return new JsonRpcRequestContext(new JsonRpcRequest(\"2.0\", \"net_listening\", new Object[] {}));  }}", "nl": "import static org.assertj.core.api.Assertions.assertThat;import static org.mockito.Mockito.when;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;import org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;import java.util.List;import org.assertj.core.api.Assertions;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.Mock;import org.mockito.junit.MockitoJUnitRunner;@RunWith(MockitoJUnitRunner.class)public class NetListeningTest {  private NetListening method;  @Mock private P2PNetwork p2PNetwork;  @Before  public void before() {    this.method = new NetListening(p2PNetwork);  }  @Test  public void shouldReturnTrueWhenNetworkIsListening() {    when(p2PNetwork.isListening()).thenReturn(true);    final JsonRpcRequestContext request = netListeningRequest();    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, true);    Assertions.assertThat(method.response(request))        .isEqualToComparingFieldByField(expectedResponse);  }  @Test  public void shouldReturnFalseWhenNetworkIsNotListening() {    when(p2PNetwork.isListening()).thenReturn(false);    final JsonRpcRequestContext request = netListeningRequest();    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, false);    Assertions.assertThat(method.response(request))        .isEqualToComparingFieldByField(expectedResponse);  }  @Test  public void getPermissions() {    List<String> permissions = method.getPermissions();    assertThat(permissions).containsExactlyInAnyOrder(\"net:*\", \"net:listening\", \"*:*\");  }  private JsonRpcRequestContext netListeningRequest() {    return new JsonRpcRequestContext(new JsonRpcRequest(\"2.0\", \"net_listening\", new Object[] {}));  }}"}
{"code": "import static org.apache.tuweni.bytes.Bytes32.leftPad;import org.hyperledger.besu.evm.EVM;import org.hyperledger.besu.evm.frame.MessageFrame;import org.hyperledger.besu.evm.gascalculator.GasCalculator;import org.apache.tuweni.bytes.Bytes;import org.apache.tuweni.bytes.Bytes32;import org.apache.tuweni.units.bigints.UInt256;public class SarOperation extends AbstractFixedCostOperation {  private static final UInt256 ALL_BITS = UInt256.MAX_VALUE;  public SarOperation(final GasCalculator gasCalculator) {    super(0x1d, \"SAR\", 2, 1, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());  }  @Override  public Operation.OperationResult executeFixedCostOperation(      final MessageFrame frame, final EVM evm) {    Bytes shiftAmount = frame.popStackItem();    final Bytes value = leftPad(frame.popStackItem());    final boolean negativeNumber = value.get(0) < 0;    if (shiftAmount.size() > 4 && (shiftAmount = shiftAmount.trimLeadingZeros()).size() > 4) {      frame.pushStackItem(negativeNumber ? ALL_BITS : UInt256.ZERO);    } else {      final int shiftAmountInt = shiftAmount.toInt();      if (shiftAmountInt >= 256 || shiftAmountInt < 0) {        frame.pushStackItem(negativeNumber ? ALL_BITS : UInt256.ZERO);      } else {        Bytes result = value.shiftRight(shiftAmountInt);        if (negativeNumber) {          final Bytes32 significantBits = ALL_BITS.shiftLeft(256 - shiftAmountInt);          result = result.or(significantBits);        }        frame.pushStackItem(result);      }    }    return successResponse;  }}", "nl": "import static org.apache.tuweni.bytes.Bytes32.leftPad;import org.hyperledger.besu.evm.EVM;import org.hyperledger.besu.evm.frame.MessageFrame;import org.hyperledger.besu.evm.gascalculator.GasCalculator;import org.apache.tuweni.bytes.Bytes;import org.apache.tuweni.bytes.Bytes32;import org.apache.tuweni.units.bigints.UInt256;public class SarOperation extends AbstractFixedCostOperation {  private static final UInt256 ALL_BITS = UInt256.MAX_VALUE;  public SarOperation(final GasCalculator gasCalculator) {    super(0x1d, \"SAR\", 2, 1, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());  }  @Override  public Operation.OperationResult executeFixedCostOperation(      final MessageFrame frame, final EVM evm) {    Bytes shiftAmount = frame.popStackItem();    final Bytes value = leftPad(frame.popStackItem());    final boolean negativeNumber = value.get(0) < 0;    if (shiftAmount.size() > 4 && (shiftAmount = shiftAmount.trimLeadingZeros()).size() > 4) {      frame.pushStackItem(negativeNumber ? ALL_BITS : UInt256.ZERO);    } else {      final int shiftAmountInt = shiftAmount.toInt();      if (shiftAmountInt >= 256) {        frame.pushStackItem(negativeNumber ? ALL_BITS : UInt256.ZERO);      } else {        Bytes result = value.shiftRight(shiftAmountInt);        if (negativeNumber) {          final Bytes32 significantBits = ALL_BITS.shiftLeft(256 - shiftAmountInt);          result = result.or(significantBits);        }        frame.pushStackItem(result);      }    }    return successResponse;  }}"}
{"code": "import static org.apache.tuweni.bytes.Bytes32.leftPad;import org.hyperledger.besu.evm.EVM;import org.hyperledger.besu.evm.frame.MessageFrame;import org.hyperledger.besu.evm.gascalculator.GasCalculator;import org.apache.tuweni.bytes.Bytes;import org.apache.tuweni.units.bigints.UInt256;public class ShlOperation extends AbstractFixedCostOperation {  public ShlOperation(final GasCalculator gasCalculator) {    super(0x1b, \"SHL\", 2, 1, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());  }  @Override  public Operation.OperationResult executeFixedCostOperation(      final MessageFrame frame, final EVM evm) {    Bytes shiftAmount = frame.popStackItem();    if (shiftAmount.size() > 4 && (shiftAmount = shiftAmount.trimLeadingZeros()).size() > 4) {      frame.popStackItem();      frame.pushStackItem(UInt256.ZERO);    } else {      final int shiftAmountInt = shiftAmount.toInt();      final Bytes value = leftPad(frame.popStackItem());      if (shiftAmountInt >= 256 || shiftAmountInt < 0) {        frame.pushStackItem(UInt256.ZERO);      } else {        frame.pushStackItem(value.shiftLeft(shiftAmountInt));      }    }    return successResponse;  }}", "nl": "import static org.apache.tuweni.bytes.Bytes32.leftPad;import org.hyperledger.besu.evm.EVM;import org.hyperledger.besu.evm.frame.MessageFrame;import org.hyperledger.besu.evm.gascalculator.GasCalculator;import org.apache.tuweni.bytes.Bytes;import org.apache.tuweni.units.bigints.UInt256;public class ShlOperation extends AbstractFixedCostOperation {  public ShlOperation(final GasCalculator gasCalculator) {    super(0x1b, \"SHL\", 2, 1, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());  }  @Override  public Operation.OperationResult executeFixedCostOperation(      final MessageFrame frame, final EVM evm) {    Bytes shiftAmount = frame.popStackItem();    if (shiftAmount.size() > 4 && (shiftAmount = shiftAmount.trimLeadingZeros()).size() > 4) {      frame.popStackItem();      frame.pushStackItem(UInt256.ZERO);    } else {      final int shiftAmountInt = shiftAmount.toInt();      final Bytes value = leftPad(frame.popStackItem());      if (shiftAmountInt >= 256) {        frame.pushStackItem(UInt256.ZERO);      } else {        frame.pushStackItem(value.shiftLeft(shiftAmountInt));      }    }    return successResponse;  }}"}
{"code": "import static org.apache.tuweni.bytes.Bytes32.leftPad;import org.hyperledger.besu.evm.EVM;import org.hyperledger.besu.evm.frame.MessageFrame;import org.hyperledger.besu.evm.gascalculator.GasCalculator;import org.apache.tuweni.bytes.Bytes;import org.apache.tuweni.units.bigints.UInt256;public class ShrOperation extends AbstractFixedCostOperation {  public ShrOperation(final GasCalculator gasCalculator) {    super(0x1c, \"SHR\", 2, 1, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());  }  @Override  public Operation.OperationResult executeFixedCostOperation(      final MessageFrame frame, final EVM evm) {    Bytes shiftAmount = frame.popStackItem();    if (shiftAmount.size() > 4 && (shiftAmount = shiftAmount.trimLeadingZeros()).size() > 4) {      frame.popStackItem();      frame.pushStackItem(UInt256.ZERO);    } else {      final int shiftAmountInt = shiftAmount.toInt();      final Bytes value = leftPad(frame.popStackItem());      if (shiftAmountInt >= 256 || shiftAmountInt < 0) {        frame.pushStackItem(UInt256.ZERO);      } else {        frame.pushStackItem(value.shiftRight(shiftAmountInt));      }    }    return successResponse;  }}", "nl": "import static org.apache.tuweni.bytes.Bytes32.leftPad;import org.hyperledger.besu.evm.EVM;import org.hyperledger.besu.evm.frame.MessageFrame;import org.hyperledger.besu.evm.gascalculator.GasCalculator;import org.apache.tuweni.bytes.Bytes;import org.apache.tuweni.units.bigints.UInt256;public class ShrOperation extends AbstractFixedCostOperation {  public ShrOperation(final GasCalculator gasCalculator) {    super(0x1c, \"SHR\", 2, 1, 1, gasCalculator, gasCalculator.getVeryLowTierGasCost());  }  @Override  public Operation.OperationResult executeFixedCostOperation(      final MessageFrame frame, final EVM evm) {    Bytes shiftAmount = frame.popStackItem();    if (shiftAmount.size() > 4 && (shiftAmount = shiftAmount.trimLeadingZeros()).size() > 4) {      frame.popStackItem();      frame.pushStackItem(UInt256.ZERO);    } else {      final int shiftAmountInt = shiftAmount.toInt();      final Bytes value = leftPad(frame.popStackItem());      if (shiftAmountInt >= 256) {        frame.pushStackItem(UInt256.ZERO);      } else {        frame.pushStackItem(value.shiftRight(shiftAmountInt));      }    }    return successResponse;  }}"}
{"code": "import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.Reader;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;import java.sql.SQLException;import java.sql.SQLXML;import java.util.HashMap;import java.util.Map;import javax.xml.XMLConstants;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.stream.XMLInputFactory;import javax.xml.stream.XMLOutputFactory;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.URIResolver;import javax.xml.transform.dom.DOMResult;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.sax.SAXResult;import javax.xml.transform.sax.SAXSource;import javax.xml.transform.sax.SAXTransformerFactory;import javax.xml.transform.sax.TransformerHandler;import javax.xml.transform.stax.StAXResult;import javax.xml.transform.stax.StAXSource;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;import org.h2.message.DbException;import org.h2.message.TraceObject;import org.h2.value.Value;import org.w3c.dom.Node;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.XMLReader;import org.xml.sax.helpers.DefaultHandler;import org.xml.sax.helpers.XMLReaderFactory;public final class JdbcSQLXML extends JdbcLob implements SQLXML {    private static final Map<String,Boolean> secureFeatureMap = new HashMap<>();    private static final EntityResolver NOOP_ENTITY_RESOLVER = (publicId, systemId) -> new InputSource(new StringReader(\"\"));    private static final URIResolver NOOP_URI_RESOLVER = (href, base) -> new StreamSource(new StringReader(\"\"));    static {        secureFeatureMap.put(XMLConstants.FEATURE_SECURE_PROCESSING, true);        secureFeatureMap.put(\"http:        secureFeatureMap.put(\"http:        secureFeatureMap.put(\"http:        secureFeatureMap.put(\"http:    }    private DOMResult domResult;    private Closeable closable;    public JdbcSQLXML(JdbcConnection conn, Value value, State state, int id) {        super(conn, value, state, TraceObject.SQLXML, id);    }    @Override    void checkReadable() throws SQLException, IOException {        checkClosed();        if (state == State.SET_CALLED) {            if (domResult != null) {                Node node = domResult.getNode();                domResult = null;                TransformerFactory factory = TransformerFactory.newInstance();                try {                    Transformer transformer = factory.newTransformer();                    DOMSource domSource = new DOMSource(node);                    StringWriter stringWriter = new StringWriter();                    StreamResult streamResult = new StreamResult(stringWriter);                    transformer.transform(domSource, streamResult);                    completeWrite(conn.createClob(new StringReader(stringWriter.toString()), -1));                } catch (Exception e) {                    throw logAndConvert(e);                }                return;            } else if (closable != null) {                closable.close();                closable = null;                return;            }            throw DbException.getUnsupportedException(\"Stream setter is not yet closed.\");        }    }    @Override    public InputStream getBinaryStream() throws SQLException {        return super.getBinaryStream();    }    @Override    public Reader getCharacterStream() throws SQLException {        return super.getCharacterStream();    }    @SuppressWarnings(\"unchecked\")    @Override    public <T extends Source> T getSource(Class<T> sourceClass) throws SQLException {        try {            if (isDebugEnabled()) {                debugCode(                        \"getSource(\" + (sourceClass != null ? sourceClass.getSimpleName() + \".class\" : \"null\") + ')');            }            checkReadable();            if (sourceClass == null || sourceClass == DOMSource.class) {                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();                for (Map.Entry<String,Boolean> entry : secureFeatureMap.entrySet()) {                    try {                        dbf.setFeature(entry.getKey(), entry.getValue());                    } catch (Exception ignore) {}                }                dbf.setXIncludeAware(false);                dbf.setExpandEntityReferences(false);                dbf.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");                DocumentBuilder db = dbf.newDocumentBuilder();                db.setEntityResolver(NOOP_ENTITY_RESOLVER);                return (T) new DOMSource(db.parse(new InputSource(value.getInputStream())));            } else if (sourceClass == SAXSource.class) {                XMLReader reader = XMLReaderFactory.createXMLReader();                for (Map.Entry<String,Boolean> entry : secureFeatureMap.entrySet()) {                    try {                        reader.setFeature(entry.getKey(), entry.getValue());                    } catch (Exception ignore) {}                }                reader.setEntityResolver(NOOP_ENTITY_RESOLVER);                return (T) new SAXSource(reader, new InputSource(value.getInputStream()));            } else if (sourceClass == StAXSource.class) {                XMLInputFactory xif = XMLInputFactory.newInstance();                xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);                xif.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");                xif.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);                return (T) new StAXSource(xif.createXMLStreamReader(value.getInputStream()));            } else if (sourceClass == StreamSource.class) {                TransformerFactory tf = TransformerFactory.newInstance();                tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");                tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");                tf.setURIResolver(NOOP_URI_RESOLVER);                tf.newTransformer().transform(new StreamSource(value.getInputStream()), new SAXResult(new DefaultHandler()));                return (T) new StreamSource(value.getInputStream());            }            throw unsupported(sourceClass.getName());        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public String getString() throws SQLException {        try {            debugCodeCall(\"getString\");            checkReadable();            return value.getString();        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public OutputStream setBinaryStream() throws SQLException {        try {            debugCodeCall(\"setBinaryStream\");            checkEditable();            state = State.SET_CALLED;            return new BufferedOutputStream(setClobOutputStreamImpl());        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public Writer setCharacterStream() throws SQLException {        try {            debugCodeCall(\"setCharacterStream\");            checkEditable();            state = State.SET_CALLED;            return setCharacterStreamImpl();        } catch (Exception e) {            throw logAndConvert(e);        }    }    @SuppressWarnings(\"unchecked\")    @Override    public <T extends Result> T setResult(Class<T> resultClass) throws SQLException {        try {            if (isDebugEnabled()) {                debugCode(                        \"setResult(\" + (resultClass != null ? resultClass.getSimpleName() + \".class\" : \"null\") + ')');            }            checkEditable();            if (resultClass == null || resultClass == DOMResult.class) {                domResult = new DOMResult();                state = State.SET_CALLED;                return (T) domResult;            } else if (resultClass == SAXResult.class) {                SAXTransformerFactory transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();                TransformerHandler transformerHandler = transformerFactory.newTransformerHandler();                Writer writer = setCharacterStreamImpl();                transformerHandler.setResult(new StreamResult(writer));                SAXResult saxResult = new SAXResult(transformerHandler);                closable = writer;                state = State.SET_CALLED;                return (T) saxResult;            } else if (resultClass == StAXResult.class) {                XMLOutputFactory xof = XMLOutputFactory.newInstance();                Writer writer = setCharacterStreamImpl();                StAXResult staxResult = new StAXResult(xof.createXMLStreamWriter(writer));                closable = writer;                state = State.SET_CALLED;                return (T) staxResult;            } else if (StreamResult.class.equals(resultClass)) {                Writer writer = setCharacterStreamImpl();                StreamResult streamResult = new StreamResult(writer);                closable = writer;                state = State.SET_CALLED;                return (T) streamResult;            }            throw unsupported(resultClass.getName());        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public void setString(String value) throws SQLException {        try {            if (isDebugEnabled()) {                debugCodeCall(\"getSource\", value);            }            checkEditable();            completeWrite(conn.createClob(new StringReader(value), -1));        } catch (Exception e) {            throw logAndConvert(e);        }    }}", "nl": "import java.io.BufferedOutputStream;import java.io.Closeable;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.Reader;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;import java.sql.SQLException;import java.sql.SQLXML;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.stream.XMLInputFactory;import javax.xml.stream.XMLOutputFactory;import javax.xml.transform.Result;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMResult;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.sax.SAXResult;import javax.xml.transform.sax.SAXSource;import javax.xml.transform.sax.SAXTransformerFactory;import javax.xml.transform.sax.TransformerHandler;import javax.xml.transform.stax.StAXResult;import javax.xml.transform.stax.StAXSource;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;import org.h2.message.DbException;import org.h2.message.TraceObject;import org.h2.value.Value;import org.w3c.dom.Node;import org.xml.sax.InputSource;public final class JdbcSQLXML extends JdbcLob implements SQLXML {    private DOMResult domResult;    private Closeable closable;    public JdbcSQLXML(JdbcConnection conn, Value value, State state, int id) {        super(conn, value, state, TraceObject.SQLXML, id);    }    @Override    void checkReadable() throws SQLException, IOException {        checkClosed();        if (state == State.SET_CALLED) {            if (domResult != null) {                Node node = domResult.getNode();                domResult = null;                TransformerFactory factory = TransformerFactory.newInstance();                try {                    Transformer transformer = factory.newTransformer();                    DOMSource domSource = new DOMSource(node);                    StringWriter stringWriter = new StringWriter();                    StreamResult streamResult = new StreamResult(stringWriter);                    transformer.transform(domSource, streamResult);                    completeWrite(conn.createClob(new StringReader(stringWriter.toString()), -1));                } catch (Exception e) {                    throw logAndConvert(e);                }                return;            } else if (closable != null) {                closable.close();                closable = null;                return;            }            throw DbException.getUnsupportedException(\"Stream setter is not yet closed.\");        }    }    @Override    public InputStream getBinaryStream() throws SQLException {        return super.getBinaryStream();    }    @Override    public Reader getCharacterStream() throws SQLException {        return super.getCharacterStream();    }    @SuppressWarnings(\"unchecked\")    @Override    public <T extends Source> T getSource(Class<T> sourceClass) throws SQLException {        try {            if (isDebugEnabled()) {                debugCode(                        \"getSource(\" + (sourceClass != null ? sourceClass.getSimpleName() + \".class\" : \"null\") + ')');            }            checkReadable();            if (sourceClass == null || sourceClass == DOMSource.class) {                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();                return (T) new DOMSource(dbf.newDocumentBuilder().parse(new InputSource(value.getInputStream())));            } else if (sourceClass == SAXSource.class) {                return (T) new SAXSource(new InputSource(value.getInputStream()));            } else if (sourceClass == StAXSource.class) {                XMLInputFactory xif = XMLInputFactory.newInstance();                return (T) new StAXSource(xif.createXMLStreamReader(value.getInputStream()));            } else if (sourceClass == StreamSource.class) {                return (T) new StreamSource(value.getInputStream());            }            throw unsupported(sourceClass.getName());        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public String getString() throws SQLException {        try {            debugCodeCall(\"getString\");            checkReadable();            return value.getString();        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public OutputStream setBinaryStream() throws SQLException {        try {            debugCodeCall(\"setBinaryStream\");            checkEditable();            state = State.SET_CALLED;            return new BufferedOutputStream(setClobOutputStreamImpl());        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public Writer setCharacterStream() throws SQLException {        try {            debugCodeCall(\"setCharacterStream\");            checkEditable();            state = State.SET_CALLED;            return setCharacterStreamImpl();        } catch (Exception e) {            throw logAndConvert(e);        }    }    @SuppressWarnings(\"unchecked\")    @Override    public <T extends Result> T setResult(Class<T> resultClass) throws SQLException {        try {            if (isDebugEnabled()) {                debugCode(                        \"getSource(\" + (resultClass != null ? resultClass.getSimpleName() + \".class\" : \"null\") + ')');            }            checkEditable();            if (resultClass == null || resultClass == DOMResult.class) {                domResult = new DOMResult();                state = State.SET_CALLED;                return (T) domResult;            } else if (resultClass == SAXResult.class) {                SAXTransformerFactory transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();                TransformerHandler transformerHandler = transformerFactory.newTransformerHandler();                Writer writer = setCharacterStreamImpl();                transformerHandler.setResult(new StreamResult(writer));                SAXResult saxResult = new SAXResult(transformerHandler);                closable = writer;                state = State.SET_CALLED;                return (T) saxResult;            } else if (resultClass == StAXResult.class) {                XMLOutputFactory xof = XMLOutputFactory.newInstance();                Writer writer = setCharacterStreamImpl();                StAXResult staxResult = new StAXResult(xof.createXMLStreamWriter(writer));                closable = writer;                state = State.SET_CALLED;                return (T) staxResult;            } else if (StreamResult.class.equals(resultClass)) {                Writer writer = setCharacterStreamImpl();                StreamResult streamResult = new StreamResult(writer);                closable = writer;                state = State.SET_CALLED;                return (T) streamResult;            }            throw unsupported(resultClass.getName());        } catch (Exception e) {            throw logAndConvert(e);        }    }    @Override    public void setString(String value) throws SQLException {        try {            if (isDebugEnabled()) {                debugCodeCall(\"getSource\", value);            }            checkEditable();            completeWrite(conn.createClob(new StringReader(value), -1));        } catch (Exception e) {            throw logAndConvert(e);        }    }}"}
{"code": "import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import javax.imageio.IIOException;import javax.imageio.stream.ImageInputStream;import javax.xml.XMLConstants;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import org.w3c.dom.Document;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import com.twelvemonkeys.imageio.metadata.Directory;import com.twelvemonkeys.imageio.metadata.Entry;import com.twelvemonkeys.imageio.metadata.MetadataReader;import com.twelvemonkeys.imageio.util.IIOUtil;import com.twelvemonkeys.lang.Validate;public final class XMPReader extends MetadataReader {    @Override    public Directory read(final ImageInputStream input) throws IOException {        Validate.notNull(input, \"input\");        try {            DocumentBuilderFactory factory = createDocumentBuilderFactory();            DocumentBuilder builder = factory.newDocumentBuilder();            builder.setErrorHandler(new DefaultHandler());            Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));            String toolkit = getToolkit(document);            Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);            NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");            return parseDirectories(rdfRoot, descriptions, toolkit);        }        catch (SAXException e) {            throw new IIOException(e.getMessage(), e);        }        catch (ParserConfigurationException e) {            throw new RuntimeException(e);        }    }    private DocumentBuilderFactory createDocumentBuilderFactory() throws ParserConfigurationException {        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        factory.setNamespaceAware(true);        factory.setXIncludeAware(false);        factory.setExpandEntityReferences(false);        factory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true);        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");        factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");        factory.setFeature(\"http:        factory.setFeature(\"http:        factory.setFeature(\"http:        return factory;    }    private String getToolkit(Document document) {        NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");        if (xmpmeta == null || xmpmeta.getLength() <= 0) {            return null;        }        Node toolkit = xmpmeta.item(0).getAttributes().getNamedItemNS(XMP.NS_X, \"xmptk\");        return toolkit != null ? toolkit.getNodeValue() : null;    }    private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {        Map<String, List<Entry>> subdirs = new LinkedHashMap<>();        for (Node desc : asIterable(pNodes)) {            if (desc.getParentNode() != pParentNode) {                continue;            }            parseAttributesForKnownElements(subdirs, desc);            for (Node node : asIterable(desc.getChildNodes())) {                if (node.getNodeType() != Node.ELEMENT_NODE) {                    continue;                }                List<Entry> dir = subdirs.get(node.getNamespaceURI());                if (dir == null) {                    dir = new ArrayList<>();                    subdirs.put(node.getNamespaceURI(), dir);                }                Object value;                if (isResourceType(node)) {                    value = parseAsResource(node);                }                else {                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<>();                    parseAttributesForKnownElements(subsubdirs, node);                    if (!subsubdirs.isEmpty()) {                        List<Entry> entries = new ArrayList<>(subsubdirs.size());                        for (Map.Entry<String, List<Entry>> entry : subsubdirs.entrySet()) {                            entries.addAll(entry.getValue());                        }                        value = new RDFDescription(entries);                    }                    else {                        value = getChildTextValue(node);                    }                }                dir.add(new XMPEntry(node.getNamespaceURI() + node.getLocalName(), node.getLocalName(), value));            }        }        List<Directory> entries = new ArrayList<>(subdirs.size());        for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {            entries.add(new RDFDescription(entry.getKey(), entry.getValue()));        }        return new XMPDirectory(entries, toolkit);    }    private boolean isResourceType(Node node) {        Node parseType = node.getAttributes().getNamedItemNS(XMP.NS_RDF, \"parseType\");        return parseType != null && \"Resource\".equals(parseType.getNodeValue());    }    private RDFDescription parseAsResource(Node node) {        List<Entry> entries = new ArrayList<>();        for (Node child : asIterable(node.getChildNodes())) {            if (child.getNodeType() != Node.ELEMENT_NODE) {                continue;            }            entries.add(new XMPEntry(child.getNamespaceURI() + child.getLocalName(), child.getLocalName(), getChildTextValue(child)));        }        return new RDFDescription(entries);    }    private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, Node desc) {        NamedNodeMap attributes = desc.getAttributes();        for (Node attr : asIterable(attributes)) {            if (!XMP.ELEMENTS.contains(attr.getNamespaceURI())) {                continue;            }            List<Entry> dir = subdirs.get(attr.getNamespaceURI());            if (dir == null) {                dir = new ArrayList<>();                subdirs.put(attr.getNamespaceURI(), dir);            }            dir.add(new XMPEntry(attr.getNamespaceURI() + attr.getLocalName(), attr.getLocalName(), attr.getNodeValue()));        }    }    private Object getChildTextValue(final Node node) {        for (Node child : asIterable(node.getChildNodes())) {            if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {                Map<String, Object> alternatives = new LinkedHashMap<>();                for (Node alternative : asIterable(child.getChildNodes())) {                    if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {                        NamedNodeMap attributes = alternative.getAttributes();                        Node key = attributes.getNamedItem(\"xml:lang\");                        alternatives.put(key == null ? null : key.getTextContent(), getChildTextValue(alternative));                    }                }                return alternatives;            }            else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {                List<Object> seq = new ArrayList<>();                for (Node sequence : asIterable(child.getChildNodes())) {                    if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {                        Object value = getChildTextValue(sequence);                        seq.add(value);                    }                }                return Collections.unmodifiableList(seq);            }        }        if (isResourceType(node)) {            return parseAsResource(node);        }        Node child = node.getFirstChild();        String strVal = child != null ? child.getNodeValue() : null;        return strVal != null ? strVal.trim() : \"\";    }    private Iterable<? extends Node> asIterable(final NamedNodeMap pNodeList) {        return new Iterable<Node>() {            public Iterator<Node> iterator() {                return new Iterator<Node>() {                    private int index;                    public boolean hasNext() {                        return pNodeList != null && pNodeList.getLength() > index;                    }                    public Node next() {                        return pNodeList.item(index++);                    }                    public void remove() {                        throw new UnsupportedOperationException(\"Method remove not supported\");                    }                };            }        };    }    private Iterable<? extends Node> asIterable(final NodeList pNodeList) {        return new Iterable<Node>() {            public Iterator<Node> iterator() {                return new Iterator<Node>() {                    private int index;                    public boolean hasNext() {                        return pNodeList != null && pNodeList.getLength() > index;                    }                    public Node next() {                        return pNodeList.item(index++);                    }                    public void remove() {                        throw new UnsupportedOperationException(\"Method remove not supported\");                    }                };            }        };    }}", "nl": "import com.twelvemonkeys.imageio.metadata.Directory;import com.twelvemonkeys.imageio.metadata.Entry;import com.twelvemonkeys.imageio.metadata.MetadataReader;import com.twelvemonkeys.imageio.util.IIOUtil;import com.twelvemonkeys.lang.Validate;import org.w3c.dom.Document;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;import javax.imageio.IIOException;import javax.imageio.stream.ImageInputStream;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import java.io.IOException;import java.util.*;public final class XMPReader extends MetadataReader {    @Override    public Directory read(final ImageInputStream input) throws IOException {        Validate.notNull(input, \"input\");        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        factory.setNamespaceAware(true);        try {            DocumentBuilder builder = factory.newDocumentBuilder();            builder.setErrorHandler(new DefaultHandler());            Document document = builder.parse(new InputSource(IIOUtil.createStreamAdapter(input)));            String toolkit = getToolkit(document);            Node rdfRoot = document.getElementsByTagNameNS(XMP.NS_RDF, \"RDF\").item(0);            NodeList descriptions = document.getElementsByTagNameNS(XMP.NS_RDF, \"Description\");            return parseDirectories(rdfRoot, descriptions, toolkit);        }        catch (SAXException e) {            throw new IIOException(e.getMessage(), e);        }        catch (ParserConfigurationException e) {            throw new RuntimeException(e);         }    }    private String getToolkit(Document document) {        NodeList xmpmeta = document.getElementsByTagNameNS(XMP.NS_X, \"xmpmeta\");        if (xmpmeta == null || xmpmeta.getLength() <= 0) {            return null;        }        Node toolkit = xmpmeta.item(0).getAttributes().getNamedItemNS(XMP.NS_X, \"xmptk\");        return toolkit != null ? toolkit.getNodeValue() : null;    }    private XMPDirectory parseDirectories(final Node pParentNode, NodeList pNodes, String toolkit) {        Map<String, List<Entry>> subdirs = new LinkedHashMap<String, List<Entry>>();        for (Node desc : asIterable(pNodes)) {            if (desc.getParentNode() != pParentNode) {                continue;            }            parseAttributesForKnownElements(subdirs, desc);            for (Node node : asIterable(desc.getChildNodes())) {                if (node.getNodeType() != Node.ELEMENT_NODE) {                    continue;                }                List<Entry> dir = subdirs.get(node.getNamespaceURI());                if (dir == null) {                    dir = new ArrayList<Entry>();                    subdirs.put(node.getNamespaceURI(), dir);                }                Object value;                if (isResourceType(node)) {                    value = parseAsResource(node);                }                else {                    Map<String, List<Entry>> subsubdirs = new LinkedHashMap<String, List<Entry>>();                    parseAttributesForKnownElements(subsubdirs, node);                    if (!subsubdirs.isEmpty()) {                        List<Entry> entries = new ArrayList<>(subsubdirs.size());                        for (Map.Entry<String, List<Entry>> entry : subsubdirs.entrySet()) {                            entries.addAll(entry.getValue());                        }                        value = new RDFDescription(entries);                    }                    else {                        value = getChildTextValue(node);                    }                }                dir.add(new XMPEntry(node.getNamespaceURI() + node.getLocalName(), node.getLocalName(), value));            }        }        List<Directory> entries = new ArrayList<Directory>(subdirs.size());        for (Map.Entry<String, List<Entry>> entry : subdirs.entrySet()) {            entries.add(new RDFDescription(entry.getKey(), entry.getValue()));        }        return new XMPDirectory(entries, toolkit);    }    private boolean isResourceType(Node node) {        Node parseType = node.getAttributes().getNamedItemNS(XMP.NS_RDF, \"parseType\");        return parseType != null && \"Resource\".equals(parseType.getNodeValue());    }    private RDFDescription parseAsResource(Node node) {        List<Entry> entries = new ArrayList<Entry>();        for (Node child : asIterable(node.getChildNodes())) {            if (child.getNodeType() != Node.ELEMENT_NODE) {                continue;            }            entries.add(new XMPEntry(child.getNamespaceURI() + child.getLocalName(), child.getLocalName(), getChildTextValue(child)));        }        return new RDFDescription(entries);    }    private void parseAttributesForKnownElements(Map<String, List<Entry>> subdirs, Node desc) {        NamedNodeMap attributes = desc.getAttributes();        for (Node attr : asIterable(attributes)) {            if (!XMP.ELEMENTS.contains(attr.getNamespaceURI())) {                continue;            }            List<Entry> dir = subdirs.get(attr.getNamespaceURI());            if (dir == null) {                dir = new ArrayList<Entry>();                subdirs.put(attr.getNamespaceURI(), dir);            }            dir.add(new XMPEntry(attr.getNamespaceURI() + attr.getLocalName(), attr.getLocalName(), attr.getNodeValue()));        }    }    private Object getChildTextValue(final Node node) {        for (Node child : asIterable(node.getChildNodes())) {            if (XMP.NS_RDF.equals(child.getNamespaceURI()) && \"Alt\".equals(child.getLocalName())) {                Map<String, Object> alternatives = new LinkedHashMap<String, Object>();                for (Node alternative : asIterable(child.getChildNodes())) {                    if (XMP.NS_RDF.equals(alternative.getNamespaceURI()) && \"li\".equals(alternative.getLocalName())) {                        NamedNodeMap attributes = alternative.getAttributes();                        Node key = attributes.getNamedItem(\"xml:lang\");                        alternatives.put(key == null ? null : key.getTextContent(), getChildTextValue(alternative));                    }                }                return alternatives;            }            else if (XMP.NS_RDF.equals(child.getNamespaceURI()) && (\"Seq\".equals(child.getLocalName()) || \"Bag\".equals(child.getLocalName()))) {                List<Object> seq = new ArrayList<Object>();                for (Node sequence : asIterable(child.getChildNodes())) {                    if (XMP.NS_RDF.equals(sequence.getNamespaceURI()) && \"li\".equals(sequence.getLocalName())) {                        Object value = getChildTextValue(sequence);                        seq.add(value);                    }                }                return Collections.unmodifiableList(seq);            }        }        if (isResourceType(node)) {            return parseAsResource(node);        }        Node child = node.getFirstChild();        String strVal = child != null ? child.getNodeValue() : null;        return strVal != null ? strVal.trim() : \"\";    }    private Iterable<? extends Node> asIterable(final NamedNodeMap pNodeList) {        return new Iterable<Node>() {            public Iterator<Node> iterator() {                return new Iterator<Node>() {                    private int index;                    public boolean hasNext() {                        return pNodeList != null && pNodeList.getLength() > index;                    }                    public Node next() {                        return pNodeList.item(index++);                    }                    public void remove() {                        throw new UnsupportedOperationException(\"Method remove not supported\");                    }                };            }        };    }    private Iterable<? extends Node> asIterable(final NodeList pNodeList) {        return new Iterable<Node>() {            public Iterator<Node> iterator() {                return new Iterator<Node>() {                    private int index;                    public boolean hasNext() {                        return pNodeList != null && pNodeList.getLength() > index;                    }                    public Node next() {                        return pNodeList.item(index++);                    }                    public void remove() {                        throw new UnsupportedOperationException(\"Method remove not supported\");                    }                };            }        };    }}"}
{"code": "import static org.hamcrest.CoreMatchers.instanceOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketException;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import javax.imageio.ImageIO;import javax.imageio.stream.ImageInputStream;import org.junit.Test;import com.twelvemonkeys.imageio.metadata.CompoundDirectory;import com.twelvemonkeys.imageio.metadata.Directory;import com.twelvemonkeys.imageio.metadata.Entry;import com.twelvemonkeys.imageio.metadata.MetadataReaderAbstractTest;public class XMPReaderTest extends MetadataReaderAbstractTest {    @Override    protected InputStream getData() throws IOException {        return getResource(\"/xmp/xmp-jpeg-example.xml\").openStream();    }    private ImageInputStream getResourceAsIIS(final String name) throws IOException {        return ImageIO.createImageInputStream(getResource(name));    }    @Override    protected XMPReader createReader() {       return new XMPReader();    }    @Test    public void testDirectoryContent() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertEquals(29, directory.size());        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:                new RDFDescription(Arrays.asList(                        new XMPEntry(\"http:                        new XMPEntry(\"http:                ))        ));        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:    }    @Test    public void testCompoundDirectory() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        assertEquals(6, compound.directoryCount());        int size = 0;        for (int i = 0; i < compound.directoryCount(); i++) {            Directory sub = compound.getDirectory(i);            assertNotNull(sub);            size += sub.size();        }        assertEquals(directory.size(), size);    }    @Test    public void testCompoundDirectoryContentPhotoshop() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory photoshop = compound.getDirectory(0);        assertEquals(4, photoshop.size());        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentMM() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory mm = compound.getDirectory(1);        assertEquals(3, mm.size());        assertThat(mm.getEntryById(\"http:        assertThat(mm.getEntryById(\"http:        assertThat(mm.getEntryById(\"http:                new RDFDescription(Arrays.asList(                        new XMPEntry(\"http:                        new XMPEntry(\"http:                ))        ));    }    @Test    public void testCompoundDirectoryContentDC() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory dc = compound.getDirectory(2);        assertEquals(2, dc.size());        assertThat(dc.getEntryById(\"http:        assertThat(dc.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentTIFF() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory tiff = compound.getDirectory(3);        assertEquals(12, tiff.size());        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentXAP() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory xap = compound.getDirectory(4);        assertEquals(4, xap.size());        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentEXIF() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory exif = compound.getDirectory(5);        assertEquals(4, exif.size());        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:    }    @Test    public void testRDFBag() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-bag-example.xml\"));        assertEquals(1, directory.size());        assertThat(directory.getEntryById(\"http:    }    @Test    public void testRDFSeq() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-seq-example.xml\"));        assertEquals(1, directory.size());        assertThat(directory.getEntryById(\"http:    }    @Test    public void testRDFAlt() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-alt-example.xml\"));        assertEquals(1, directory.size());        assertThat(directory.getEntryById(\"http:            put(\"x-default\", \"One\");            put(\"en-us\", \"One\");            put(\"de\", \"Ein\");            put(\"no-nb\", \"En\");        }}));    }    @Test    public void testRDFAttributeSyntax() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertEquals(20, directory.size());        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        Entry derivedFrom = directory.getEntryById(\"http:        assertNotNull(derivedFrom);        assertThat(derivedFrom.getValue(), instanceOf(RDFDescription.class));        RDFDescription stRef = (RDFDescription) derivedFrom.getValue();        assertThat(stRef.getEntryById(\"http:        assertThat(stRef.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompound() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        assertEquals(6, compound.directoryCount());        int size = 0;        for (int i = 0; i < compound.directoryCount(); i++) {            Directory sub = compound.getDirectory(i);            assertNotNull(sub);            size += sub.size();        }        assertEquals(directory.size(), size);    }    private Directory getDirectoryByNS(final CompoundDirectory compound, final String namespace) {        for (int i = 0; i < compound.directoryCount(); i++) {            Directory candidate = compound.getDirectory(i);            Iterator<Entry> entries = candidate.iterator();            if (entries.hasNext()) {                Entry entry = entries.next();                if (entry.getIdentifier() instanceof String && ((String) entry.getIdentifier()).startsWith(namespace)) {                    return candidate;                }            }        }        return null;    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentPhotoshop() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory photoshop = getDirectoryByNS(compound, XMP.NS_PHOTOSHOP);        assertNotNull(photoshop);        assertEquals(3, photoshop.size());        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentMM() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory mm = getDirectoryByNS(compound, XMP.NS_XAP_MM);        assertNotNull(mm);        assertEquals(3, mm.size());        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        Entry derivedFrom = directory.getEntryById(\"http:        assertNotNull(derivedFrom);        assertThat(derivedFrom.getValue(), instanceOf(RDFDescription.class));        RDFDescription stRef = (RDFDescription) derivedFrom.getValue();        assertThat(stRef.getEntryById(\"http:        assertThat(stRef.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentDC() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory dc = getDirectoryByNS(compound, XMP.NS_DC);        assertNotNull(dc);        assertEquals(1, dc.size());        assertThat(dc.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentTIFF() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory tiff = getDirectoryByNS(compound, XMP.NS_TIFF);        assertNotNull(tiff);        assertEquals(5, tiff.size());        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentXAP() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory xap = getDirectoryByNS(compound, XMP.NS_XAP);        assertNotNull(xap);        assertEquals(4, xap.size());        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentEXIF() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory exif = getDirectoryByNS(compound, XMP.NS_EXIF);        assertNotNull(exif);        assertEquals(4, exif.size());        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:    }    @Test(timeout = 1500L)    public void testNoExternalRequest() throws Exception {        try (HTTPServer server = new HTTPServer(7777)) {            try {                createReader().read(getResourceAsIIS(\"/xmp/xmp-jpeg-xxe.xml\"));            } catch (IOException ioe) {                if (ioe.getMessage().contains(\"501\")) {                    throw new AssertionError(\"Reading should not cause external requests\", ioe);                }                throw ioe;            }        }    }    private static class HTTPServer implements AutoCloseable {        private final ServerSocket server;        private final Thread thread;        HTTPServer(int port) throws IOException {            server = new ServerSocket(port, 1);            thread = new Thread(new Runnable() {                @Override public void run() {                    serve();                }            });            thread.start();        }        private void serve() {            try {                Socket client = server.accept();                try (InputStream inputStream = client.getInputStream()) {                    while (inputStream.available() > 0) {                        if (inputStream.read() == -1) {                            break;                        }                    }                    try (OutputStream outputStream = client.getOutputStream()) {                        outputStream.write(\"HTTP/1.0 501 Not Implemented\\r\\n\\r\\n\".getBytes(StandardCharsets.UTF_8));                    }                }            }            catch (IOException e) {                if (server.isClosed() && e instanceof SocketException) {                    return;                }                throw new RuntimeException(e);            }        }        @Override public void close() throws Exception {            server.close();            thread.join();         }    }}", "nl": "import com.twelvemonkeys.imageio.metadata.CompoundDirectory;import com.twelvemonkeys.imageio.metadata.Directory;import com.twelvemonkeys.imageio.metadata.Entry;import com.twelvemonkeys.imageio.metadata.MetadataReaderAbstractTest;import org.junit.Test;import javax.imageio.ImageIO;import javax.imageio.stream.ImageInputStream;import java.io.IOException;import java.io.InputStream;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import static org.hamcrest.CoreMatchers.instanceOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;public class XMPReaderTest extends MetadataReaderAbstractTest {    @Override    protected InputStream getData() throws IOException {        return getResource(\"/xmp/xmp-jpeg-example.xml\").openStream();    }    private ImageInputStream getResourceAsIIS(final String name) throws IOException {        return ImageIO.createImageInputStream(getResource(name));    }    @Override    protected XMPReader createReader() {       return new XMPReader();    }    @Test    public void testDirectoryContent() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertEquals(29, directory.size());        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:                new RDFDescription(Arrays.asList(                        new XMPEntry(\"http:                        new XMPEntry(\"http:                ))        ));        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:    }    @Test    public void testCompoundDirectory() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        assertEquals(6, compound.directoryCount());        int size = 0;        for (int i = 0; i < compound.directoryCount(); i++) {            Directory sub = compound.getDirectory(i);            assertNotNull(sub);            size += sub.size();        }        assertEquals(directory.size(), size);    }    @Test    public void testCompoundDirectoryContentPhotoshop() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory photoshop = compound.getDirectory(0);        assertEquals(4, photoshop.size());        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentMM() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory mm = compound.getDirectory(1);        assertEquals(3, mm.size());        assertThat(mm.getEntryById(\"http:        assertThat(mm.getEntryById(\"http:        assertThat(mm.getEntryById(\"http:                new RDFDescription(Arrays.asList(                        new XMPEntry(\"http:                        new XMPEntry(\"http:                ))        ));    }    @Test    public void testCompoundDirectoryContentDC() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory dc = compound.getDirectory(2);        assertEquals(2, dc.size());        assertThat(dc.getEntryById(\"http:        assertThat(dc.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentTIFF() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory tiff = compound.getDirectory(3);        assertEquals(12, tiff.size());        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentXAP() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory xap = compound.getDirectory(4);        assertEquals(4, xap.size());        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:    }    @Test    public void testCompoundDirectoryContentEXIF() throws IOException {        Directory directory = createReader().read(getDataAsIIS());        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory exif = compound.getDirectory(5);        assertEquals(4, exif.size());        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:    }    @Test    public void testRDFBag() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-bag-example.xml\"));        assertEquals(1, directory.size());        assertThat(directory.getEntryById(\"http:    }    @Test    public void testRDFSeq() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-seq-example.xml\"));        assertEquals(1, directory.size());        assertThat(directory.getEntryById(\"http:    }    @Test    public void testRDFAlt() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-alt-example.xml\"));        assertEquals(1, directory.size());        assertThat(directory.getEntryById(\"http:            put(\"x-default\", \"One\");            put(\"en-us\", \"One\");            put(\"de\", \"Ein\");            put(\"no-nb\", \"En\");        }}));    }    @Test    public void testRDFAttributeSyntax() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertEquals(20, directory.size());        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        Entry derivedFrom = directory.getEntryById(\"http:        assertNotNull(derivedFrom);        assertThat(derivedFrom.getValue(), instanceOf(RDFDescription.class));        RDFDescription stRef = (RDFDescription) derivedFrom.getValue();        assertThat(stRef.getEntryById(\"http:        assertThat(stRef.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompound() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        assertEquals(6, compound.directoryCount());        int size = 0;        for (int i = 0; i < compound.directoryCount(); i++) {            Directory sub = compound.getDirectory(i);            assertNotNull(sub);            size += sub.size();        }        assertEquals(directory.size(), size);    }    private Directory getDirectoryByNS(final CompoundDirectory compound, final String namespace) {        for (int i = 0; i < compound.directoryCount(); i++) {            Directory candidate = compound.getDirectory(i);            Iterator<Entry> entries = candidate.iterator();            if (entries.hasNext()) {                Entry entry = entries.next();                if (entry.getIdentifier() instanceof String && ((String) entry.getIdentifier()).startsWith(namespace)) {                    return candidate;                }            }        }        return null;    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentPhotoshop() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory photoshop = getDirectoryByNS(compound, XMP.NS_PHOTOSHOP);        assertNotNull(photoshop);        assertEquals(3, photoshop.size());        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:        assertThat(photoshop.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentMM() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory mm = getDirectoryByNS(compound, XMP.NS_XAP_MM);        assertNotNull(mm);        assertEquals(3, mm.size());        assertThat(directory.getEntryById(\"http:        assertThat(directory.getEntryById(\"http:        Entry derivedFrom = directory.getEntryById(\"http:        assertNotNull(derivedFrom);        assertThat(derivedFrom.getValue(), instanceOf(RDFDescription.class));        RDFDescription stRef = (RDFDescription) derivedFrom.getValue();        assertThat(stRef.getEntryById(\"http:        assertThat(stRef.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentDC() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory dc = getDirectoryByNS(compound, XMP.NS_DC);        assertNotNull(dc);        assertEquals(1, dc.size());        assertThat(dc.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentTIFF() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory tiff = getDirectoryByNS(compound, XMP.NS_TIFF);        assertNotNull(tiff);        assertEquals(5, tiff.size());        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:        assertThat(tiff.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentXAP() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory xap = getDirectoryByNS(compound, XMP.NS_XAP);        assertNotNull(xap);        assertEquals(4, xap.size());        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:        assertThat(xap.getEntryById(\"http:    }    @Test    public void testRDFAttributeSyntaxCompoundDirectoryContentEXIF() throws IOException {        Directory directory = createReader().read(getResourceAsIIS(\"/xmp/rdf-attribute-shorthand.xml\"));        assertThat(directory, instanceOf(CompoundDirectory.class));        CompoundDirectory compound = (CompoundDirectory) directory;        Directory exif = getDirectoryByNS(compound, XMP.NS_EXIF);        assertNotNull(exif);        assertEquals(4, exif.size());        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:        assertThat(exif.getEntryById(\"http:    }}"}
{"code": "import java.io.IOException;import java.math.BigInteger;import java.util.Arrays;import java.util.Iterator;import java.util.Locale;import java.util.Random;import javax.annotation.Nullable;import junit.framework.TestCase;import org.junit.Test;@SuppressWarnings(\"javadoc\")public final class FuzzyTest extends TestCase {  @Test  public static final void testSanitizerLikesFuzzyWuzzyInputs()  throws Throwable {    int nRuns = 10000;    long seed;    {      String seedString = System.getProperty(\"fuzz.seed\", null);      if (seedString != null) {        seed = Long.parseLong(seedString, 16);      } else {        seed = new Random().nextLong();      }    }    System.err.println(\"Fuzzing with -Dfuzz.seed=\" + Long.toHexString(seed));    System.err.flush();    Random rnd = new Random(seed);    for (String fuzzyWuzzyString : new FuzzyStringGenerator(rnd)) {      try {        String sanitized0 = JsonSanitizer.sanitize(fuzzyWuzzyString);        String sanitized1 = JsonSanitizer.sanitize(sanitized0);        if (!sanitized0.equals(sanitized1)) {          int commonPrefixLen = 0;          int minLength = Math.min(sanitized0.length(), sanitized1.length());          while (commonPrefixLen < minLength) {            if (sanitized0.charAt(commonPrefixLen) != sanitized1.charAt(commonPrefixLen)) {              break;            }            ++commonPrefixLen;          }          int right0 = sanitized0.length();          int right1 = sanitized1.length();          while (right0 > commonPrefixLen && right1 > commonPrefixLen) {            if (sanitized0.charAt(right0 - 1) != sanitized1.charAt(right1 - 1)) {              break;            }            --right0;            --right1;          }          int commonSuffixLen = sanitized0.length() - right0;          System.err.println(\"Difference at \" + commonPrefixLen + \" to -\" + commonSuffixLen);          System.err.println(\"Before: \" + excerpt(sanitized0, commonPrefixLen, right0));          System.err.println(\"After:  \" + excerpt(sanitized0, commonPrefixLen, right1));        }        assertEquals(fuzzyWuzzyString + \"  =>  \" + sanitized0, sanitized0,                     sanitized1);      } catch (Throwable th) {        System.err.println(\"Failed on `\" + fuzzyWuzzyString + \"`\");        hexDump(fuzzyWuzzyString.getBytes(\"UTF16\"), System.err);        System.err.println(\"\");        throw th;      }      if (--nRuns <= 0) { break; }    }  }  private static void hexDump(byte[] bytes, Appendable app)    throws IOException {    for (int i = 0; i < bytes.length; ++i) {      if ((i % 16) == 0) {        if (i != 0) {          app.append('\\n');        }      } else {        app.append(' ');      }      byte b = bytes[i];      app.append(\"0123456789ABCDEF\".charAt((b >>> 4) & 0xf));      app.append(\"0123456789ABCDEF\".charAt((b >>> 0) & 0xf));    }  }  private static String excerpt(String s, int left, int right) {    int leftIncl = left - 10;    boolean ellipseLeft = leftIncl > 0;    if (!ellipseLeft) { leftIncl = 0; }    int rightIncl = right + 10;    boolean ellipseRight = s.length() > rightIncl;    if (!ellipseRight) {      rightIncl = s.length();    }    return s.substring(leftIncl, rightIncl)            .replace(\"\\r\", \"\\\\r\")            .replace(\"\\n\", \"\\\\n\")            .replace(\"\\\\\", \"\\\\\\\\\");  }}final class FuzzyStringGenerator implements Iterable<String> {  final Random rnd;  FuzzyStringGenerator(Random rnd) {    this.rnd = rnd;  }  @Override  public Iterator<String> iterator() {    return new Iterator<String>() {      private @Nullable String basis;      private @Nullable String pending;      @Override      public boolean hasNext() {        return true;      }      @Override      public String next() {        if (pending == null) {          fuzz();        }        String s = pending;        pending = null;        if (0 == rnd.nextInt(16)) { basis = null; }        return s;      }      @Override      public void remove() {        throw new UnsupportedOperationException();      }      @SuppressWarnings(\"synthetic-access\")      private void fuzz() {        if (basis == null) {          pending = basis = makeRandomJson();          return;        }        pending = mutate(basis);      }    };  }  private String makeRandomJson() {    int maxDepth = 1 + rnd.nextInt(8);    int maxBreadth = 4 + rnd.nextInt(16);    StringBuilder sb = new StringBuilder();    appendWhitespace(sb);    appendRandomJson(maxDepth, maxBreadth, sb);    appendWhitespace(sb);    return sb.toString();  }  private static final String[] FLOAT_FORMAT_STRING = {    \"%g\", \"%G\", \"%e\", \"%E\", \"%f\"  };  private static final String[] INT_FORMAT_STRING = {    \"%x\", \"%X\", \"%d\"  };  private void appendRandomJson(      int maxDepth, int maxBreadth, StringBuilder sb) {    int r = rnd.nextInt(maxDepth > 0 ? 8 : 6);    switch (r) {      case 0: sb.append(\"null\"); break;      case 1: sb.append(\"true\"); break;      case 2: sb.append(\"false\"); break;      case 3: {        String fmt = FLOAT_FORMAT_STRING          [rnd.nextInt(FLOAT_FORMAT_STRING.length)];        sb.append(String.format(Locale.ROOT, fmt, 1.0 / rnd.nextGaussian()));        break;      }      case 4: {        switch (rnd.nextInt(3)) {          case 0: break;          case 1: sb.append('-'); break;          case 2: sb.append('+'); break;        }        String fmt = INT_FORMAT_STRING          [rnd.nextInt(INT_FORMAT_STRING.length)];        BigInteger num = new BigInteger(randomDecimalDigits(maxBreadth * 2));        sb.append(String.format(Locale.ROOT, fmt, num));        break;      }      case 5:        appendRandomString(maxBreadth, sb);        break;      case 6:        sb.append('[');        appendWhitespace(sb);        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {          appendWhitespace(sb);          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);          if (i != 1) {            appendWhitespace(sb);            sb.append(',');          }        }        appendWhitespace(sb);        sb.append(']');        break;      case 7:        sb.append('{');        appendWhitespace(sb);        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {          appendWhitespace(sb);          appendRandomString(maxBreadth, sb);          appendWhitespace(sb);          sb.append(':');          appendWhitespace(sb);          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);          if (i != 1) {            appendWhitespace(sb);            sb.append(',');          }        }        appendWhitespace(sb);        sb.append('}');        break;    }  }  private void appendRandomString(int maxBreadth, StringBuilder sb) {    sb.append('\"');    appendRandomChars(rnd.nextInt(maxBreadth * 4), sb);    sb.append('\"');  }  private void appendRandomChars(int nChars, StringBuilder sb) {    for (int i = nChars; --i >= 0;) {      appendRandomChar(sb);    }  }  private void appendRandomChar(StringBuilder sb) {    char delim = rnd.nextInt(8) == 0 ? '\\'' : '\"';    int cpMax;    switch (rnd.nextInt(7)) {      case 0: case 1: case 2: case 3: cpMax = 0x100; break;      case 4: case 5: cpMax = 0x10000; break;      default: cpMax = Character.MAX_CODE_POINT; break;    }    int cp = rnd.nextInt(cpMax);    boolean encode = false;    if (cp == delim || cp < 0x20 || cp == '\\\\') {      encode = true;    }    if (!encode && 0 == rnd.nextInt(8)) {      encode = true;    }    if (encode) {      if (rnd.nextBoolean()) {        for (char cu : Character.toChars(cp)) {          sb.append(\"\\\\u\").append(String.format(\"%04x\", (int) cu));        }      } else {        sb.append('\\\\');        switch (cp) {          case 0xa: sb.append('\\n'); break;          case 0xd: sb.append('\\r'); break;          default: sb.appendCodePoint(cp); break;        }      }    } else {      sb.appendCodePoint(cp);    }  }  private void appendWhitespace(StringBuilder sb) {    if (rnd.nextInt(4) == 0) {      for (int i = rnd.nextInt(4); --i >= 0;) {        sb.append(\" \\t\\r\\n\".charAt(rnd.nextInt(4)));      }    }  }  private String randomDecimalDigits(int maxDigits) {    int nDigits = Math.max(1, rnd.nextInt(maxDigits));    StringBuilder sb = new StringBuilder(nDigits);    for (int i = nDigits; --i >= 0;) {      sb.append((char) ('0' + rnd.nextInt(10)));    }    return sb.toString();  }  private String mutate(String s) {    int n = rnd.nextInt(16) + 1;      int len = s.length();    int[] locations = new int[n];    for (int i = n; --i >= 0;) {      locations[i] = rnd.nextInt(len);    }    Arrays.sort(locations);    {      int k = 1;      for (int i = 1; i < n; ++i) {        if (locations[i] != locations[i - 1]) {          locations[k++] = locations[i];        }      }      n = k;      }    int left = 0;    StringBuilder delta = new StringBuilder(len);    for (int i = 0; i < n; ++i) {      int loc = locations[i];      int nextLoc = i + 1 == n ? len : locations[i + 1];      int size = nextLoc - loc;      int rndSliceLen = 1;      if (size > 1) {        rndSliceLen = rnd.nextInt(size);      }      delta.append(s, left, loc);      left = loc;      switch (rnd.nextInt(3)) {        case 0:            appendRandomChars(rndSliceLen, delta);          break;        case 1:            appendRandomChars(rndSliceLen, delta);          left += rndSliceLen;          break;        case 2:            left += rndSliceLen;          break;      }    }    delta.append(s, left, len);    return delta.toString();  }}", "nl": "import java.io.IOException;import java.math.BigInteger;import java.util.Arrays;import java.util.Iterator;import java.util.Locale;import java.util.Random;import javax.annotation.Nullable;import junit.framework.TestCase;import org.junit.Test;@SuppressWarnings(\"javadoc\")public final class FuzzyTest extends TestCase {  @Test  public static final void testSanitizerLikesFuzzyWuzzyInputs()  throws Throwable {    int nRuns = 10000;    long seed;    {      String seedString = System.getProperty(\"fuzz.seed\", null);      if (seedString != null) {        seed = Long.parseLong(seedString, 16);      } else {        seed = new Random().nextLong();      }    }    System.err.println(\"Fuzzing with -Dfuzz.seed=\" + Long.toHexString(seed));    System.err.flush();    Random rnd = new Random(seed);    for (String fuzzyWuzzyString : new FuzzyStringGenerator(rnd)) {      try {        String sanitized0 = JsonSanitizer.sanitize(fuzzyWuzzyString);        String sanitized1 = JsonSanitizer.sanitize(sanitized0);        assertEquals(fuzzyWuzzyString + \"  =>  \" + sanitized0, sanitized0,                     sanitized1);      } catch (Throwable th) {        System.err.println(\"Failed on `\" + fuzzyWuzzyString + \"`\");        hexDump(fuzzyWuzzyString.getBytes(\"UTF16\"), System.err);        System.err.println(\"\");        throw th;      }      if (--nRuns <= 0) { break; }    }  }  private static void hexDump(byte[] bytes, Appendable app)    throws IOException {    for (int i = 0; i < bytes.length; ++i) {      if ((i % 16) == 0) {        if (i != 0) {          app.append('\\n');        }      } else {        app.append(' ');      }      byte b = bytes[i];      app.append(\"0123456789ABCDEF\".charAt((b >>> 4) & 0xf));      app.append(\"0123456789ABCDEF\".charAt((b >>> 0) & 0xf));    }  }}final class FuzzyStringGenerator implements Iterable<String> {  final Random rnd;  FuzzyStringGenerator(Random rnd) {    this.rnd = rnd;  }  @Override  public Iterator<String> iterator() {    return new Iterator<String>() {      private @Nullable String basis;      private @Nullable String pending;      @Override      public boolean hasNext() {        return true;      }      @Override      public String next() {        if (pending == null) {          fuzz();        }        String s = pending;        pending = null;        if (0 == rnd.nextInt(16)) { basis = null; }        return s;      }      @Override      public void remove() {        throw new UnsupportedOperationException();      }      @SuppressWarnings(\"synthetic-access\")      private void fuzz() {        if (basis == null) {          pending = basis = makeRandomJson();          return;        }        pending = mutate(basis);      }    };  }  private String makeRandomJson() {    int maxDepth = 1 + rnd.nextInt(8);    int maxBreadth = 4 + rnd.nextInt(16);    StringBuilder sb = new StringBuilder();    appendWhitespace(sb);    appendRandomJson(maxDepth, maxBreadth, sb);    appendWhitespace(sb);    return sb.toString();  }  private static final String[] FLOAT_FORMAT_STRING = {    \"%g\", \"%G\", \"%e\", \"%E\", \"%f\"  };  private static final String[] INT_FORMAT_STRING = {    \"%x\", \"%X\", \"%d\"  };  private void appendRandomJson(      int maxDepth, int maxBreadth, StringBuilder sb) {    int r = rnd.nextInt(maxDepth > 0 ? 8 : 6);    switch (r) {      case 0: sb.append(\"null\"); break;      case 1: sb.append(\"true\"); break;      case 2: sb.append(\"false\"); break;      case 3: {        String fmt = FLOAT_FORMAT_STRING          [rnd.nextInt(FLOAT_FORMAT_STRING.length)];        sb.append(String.format(Locale.ROOT, fmt, 1.0 / rnd.nextGaussian()));        break;      }      case 4: {        switch (rnd.nextInt(3)) {          case 0: break;          case 1: sb.append('-'); break;          case 2: sb.append('+'); break;        }        String fmt = INT_FORMAT_STRING          [rnd.nextInt(INT_FORMAT_STRING.length)];        BigInteger num = new BigInteger(randomDecimalDigits(maxBreadth * 2));        sb.append(String.format(Locale.ROOT, fmt, num));        break;      }      case 5:        appendRandomString(maxBreadth, sb);        break;      case 6:        sb.append('[');        appendWhitespace(sb);        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {          appendWhitespace(sb);          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);          if (i != 1) {            appendWhitespace(sb);            sb.append(',');          }        }        appendWhitespace(sb);        sb.append(']');        break;      case 7:        sb.append('{');        appendWhitespace(sb);        for (int i = rnd.nextInt(maxBreadth); --i >= 0;) {          appendWhitespace(sb);          appendRandomString(maxBreadth, sb);          appendWhitespace(sb);          sb.append(':');          appendWhitespace(sb);          appendRandomJson(maxDepth - 1, Math.max(1, maxBreadth - 1), sb);          if (i != 1) {            appendWhitespace(sb);            sb.append(',');          }        }        appendWhitespace(sb);        sb.append('}');        break;    }  }  private void appendRandomString(int maxBreadth, StringBuilder sb) {    sb.append('\"');    appendRandomChars(rnd.nextInt(maxBreadth * 4), sb);    sb.append('\"');  }  private void appendRandomChars(int nChars, StringBuilder sb) {    for (int i = nChars; --i >= 0;) {      appendRandomChar(sb);    }  }  private void appendRandomChar(StringBuilder sb) {    char delim = rnd.nextInt(8) == 0 ? '\\'' : '\"';    int cpMax;    switch (rnd.nextInt(7)) {      case 0: case 1: case 2: case 3: cpMax = 0x100; break;      case 4: case 5: cpMax = 0x10000; break;      default: cpMax = Character.MAX_CODE_POINT; break;    }    int cp = rnd.nextInt(cpMax);    boolean encode = false;    if (cp == delim || cp < 0x20 || cp == '\\\\') {      encode = true;    }    if (!encode && 0 == rnd.nextInt(8)) {      encode = true;    }    if (encode) {      if (rnd.nextBoolean()) {        for (char cu : Character.toChars(cp)) {          sb.append(\"\\\\u\").append(String.format(\"%04x\", (int) cu));        }      } else {        sb.append('\\\\');        switch (cp) {          case 0xa: sb.append('\\n'); break;          case 0xd: sb.append('\\r'); break;          default: sb.appendCodePoint(cp); break;        }      }    } else {      sb.appendCodePoint(cp);    }  }  private void appendWhitespace(StringBuilder sb) {    if (rnd.nextInt(4) == 0) {      for (int i = rnd.nextInt(4); --i >= 0;) {        sb.append(\" \\t\\r\\n\".charAt(rnd.nextInt(4)));      }    }  }  private String randomDecimalDigits(int maxDigits) {    int nDigits = Math.max(1, rnd.nextInt(maxDigits));    StringBuilder sb = new StringBuilder(nDigits);    for (int i = nDigits; --i >= 0;) {      sb.append((char) ('0' + rnd.nextInt(10)));    }    return sb.toString();  }  private String mutate(String s) {    int n = rnd.nextInt(16) + 1;      int len = s.length();    int[] locations = new int[n];    for (int i = n; --i >= 0;) {      locations[i] = rnd.nextInt(len);    }    Arrays.sort(locations);    {      int k = 1;      for (int i = 1; i < n; ++i) {        if (locations[i] != locations[i - 1]) {          locations[k++] = locations[i];        }      }      n = k;      }    int left = 0;    StringBuilder delta = new StringBuilder(len);    for (int i = 0; i < n; ++i) {      int loc = locations[i];      int nextLoc = i + 1 == n ? len : locations[i + 1];      int size = nextLoc - loc;      int rndSliceLen = 1;      if (size > 1) {        rndSliceLen = rnd.nextInt(size);      }      delta.append(s, left, loc);      left = loc;      switch (rnd.nextInt(3)) {        case 0:            appendRandomChars(rndSliceLen, delta);          break;        case 1:            appendRandomChars(rndSliceLen, delta);          left += rndSliceLen;          break;        case 2:            left += rndSliceLen;          break;      }    }    delta.append(s, left, len);    return delta.toString();  }}"}
{"code": "import static com.google.json.JsonSanitizer.DEFAULT_NESTING_DEPTH;import static com.google.json.JsonSanitizer.sanitize;import java.util.Locale;import java.util.logging.Level;import java.util.logging.Logger;import junit.framework.TestCase;import org.junit.Test;@SuppressWarnings(\"javadoc\")public final class JsonSanitizerTest extends TestCase {  private static void assertSanitized(String golden, String input) {    assertSanitized(golden, input, DEFAULT_NESTING_DEPTH);  }  private static void assertSanitized(String golden, String input, int maximumNestingDepth) {    String actual = sanitize(input, maximumNestingDepth);    assertEquals(input, golden, actual);    if (actual.equals(input)) {      assertSame(input, input, actual);    }  }  private static void assertSanitized(String sanitary) {    assertSanitized(sanitary, sanitary);  }  @Test  public static final void testSanitize() {    assertSanitized(\"null\", null);    assertSanitized(\"null\", \"\");    assertSanitized(\"null\");    assertSanitized(\"false\");    assertSanitized(\"true\");    assertSanitized(\" false \");    assertSanitized(\"  false\");    assertSanitized(\"false\\n\");    assertSanitized(\"false\", \"false,true\");    assertSanitized(\"\\\"foo\\\"\");    assertSanitized(\"\\\"foo\\\"\", \"'foo'\");    assertSanitized(        \"\\\"\\\\u003cscript>foo()\\\\u003c/script>\\\"\", \"\\\"<script>foo()</script>\\\"\");    assertSanitized(\"\\\"\\\\u003c/SCRIPT\\\\n>\\\"\", \"\\\"</SCRIPT\\n>\\\"\");    assertSanitized(\"\\\"\\\\u003c/ScRIpT\\\"\", \"\\\"</ScRIpT\\\"\");    assertSanitized(\"\\\"\\\\u003c/ScR\\u0130pT\\\"\", \"\\\"</ScR\\u0130pT\\\"\");    assertSanitized(\"\\\"<b>Hello</b>\\\"\");    assertSanitized(\"\\\"<s>Hello</s>\\\"\");    assertSanitized(\"\\\"<[[\\\\u005d]>\\\"\", \"'<[[]]>'\");    assertSanitized(\"\\\"\\\\u005d]>\\\"\", \"']]>'\");    assertSanitized(\"[[0]]\", \"[[0]]>\");    assertSanitized(\"[1,-1,0.0,-0.5,1e2]\", \"[1,-1,0.0,-0.5,1e2,\");    assertSanitized(\"[1,2,3]\", \"[1,2,3,]\");    assertSanitized(\"[1,null,3]\", \"[1,,3,]\");    assertSanitized(\"[1 ,2 ,3]\", \"[1 2 3]\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ \\\"foo\\\": \\\"bar\\\", }\");    assertSanitized(\"{\\\"foo\\\":\\\"bar\\\"}\", \"{\\\"foo\\\",\\\"bar\\\"}\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ foo: \\\"bar\\\" }\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\"}\", \"{ foo: 'bar\");    assertSanitized(\"{ \\\"foo\\\": [\\\"bar\\\"]}\", \"{ foo: ['bar\");    assertSanitized(\"false\", \"    assertSanitized(\"false\", \"false    assertSanitized(\"false\", \"false    assertSanitized(\"false\", \"false\");    assertSanitized(\"false\", \"falsetrue**/false\");    assertSanitized(\"1\");    assertSanitized(\"-1\");    assertSanitized(\"1.0\");    assertSanitized(\"-1.0\");    assertSanitized(\"1.05\");    assertSanitized(\"427.0953333\");    assertSanitized(\"6.0221412927e+23\");    assertSanitized(\"6.0221412927e23\");    assertSanitized(\"6.0221412927e0\", \"6.0221412927e\");    assertSanitized(\"6.0221412927e-0\", \"6.0221412927e-\");    assertSanitized(\"6.0221412927e+0\", \"6.0221412927e+\");    assertSanitized(\"1.660538920287695E-24\");    assertSanitized(\"-6.02e-23\");    assertSanitized(\"1.0\", \"1.\");    assertSanitized(\"0.5\", \".5\");    assertSanitized(\"-0.5\", \"-.5\");    assertSanitized(\"0.5\", \"+.5\");    assertSanitized(\"0.5e2\", \"+.5e2\");    assertSanitized(\"1.5e+2\", \"+1.5e+2\");    assertSanitized(\"0.5e-2\", \"+.5e-2\");    assertSanitized(\"{\\\"0\\\":0}\", \"{0:0}\");    assertSanitized(\"{\\\"0\\\":0}\", \"{-0:0}\");    assertSanitized(\"{\\\"0\\\":0}\", \"{+0:0}\");    assertSanitized(\"{\\\"1\\\":0}\", \"{1.0:0}\");    assertSanitized(\"{\\\"1\\\":0}\", \"{1.:0}\");    assertSanitized(\"{\\\"0.5\\\":0}\", \"{.5:0}\");    assertSanitized(\"{\\\"-0.5\\\":0}\", \"{-.5:0}\");    assertSanitized(\"{\\\"0.5\\\":0}\", \"{+.5:0}\");    assertSanitized(\"{\\\"50\\\":0}\", \"{+.5e2:0}\");    assertSanitized(\"{\\\"150\\\":0}\", \"{+1.5e+2:0}\");    assertSanitized(\"{\\\"0.1\\\":0}\", \"{+.1:0}\");    assertSanitized(\"{\\\"0.01\\\":0}\", \"{+.01:0}\");    assertSanitized(\"{\\\"0.005\\\":0}\", \"{+.5e-2:0}\");    assertSanitized(\"{\\\"1e+101\\\":0}\", \"{10e100:0}\");    assertSanitized(\"{\\\"1e-99\\\":0}\", \"{10e-100:0}\");    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.5e-100:0}\");    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.500e-100:0}\");    assertSanitized(\"{\\\"1.234e+101\\\":0}\", \"{12.34e100:0}\");    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");    assertSanitized(\"{}\");    assertSanitized(\"{}\", \"({})\");    assertSanitized(\"\\\"\\\\u0000\\\\u0008\\\\u001f\\\"\", \"'\\u0000\\u0008\\u001f'\");    assertSanitized(\"\\\"\\ud800\\udc00\\\\udc00\\\\ud800\\\"\",                    \"'\\ud800\\udc00\\udc00\\ud800'\");    assertSanitized(\"\\\"\\ufffd\\\\ufffe\\\\uffff\\\"\", \"'\\ufffd\\ufffe\\uffff'\");    assertSanitized(\"42\", \"\\uffef\\u000042\\u0008\\ud800\\uffff\\udc00\");    assertSanitized(\"null\", \"\\uffef\\u0000\\u0008\\ud800\\uffff\\udc00\");    assertSanitized(\"[null]\", \"[,]\");    assertSanitized(\"[null]\", \"[null,]\");    assertSanitized(\"{\\\"a\\\":0,\\\"false\\\":\\\"x\\\",\\\"\\\":{\\\"\\\":-1}}\",                    \"{\\\"a\\\":0,false\\\"x\\\":{\\\"\\\":-1}}\");    assertSanitized(\"[true ,false]\", \"[true false]\");    assertSanitized(\"[\\\"\\\\u00a0\\\\u1234\\\"]\");    assertSanitized(\"{\\\"a\\\\b\\\":\\\"c\\\"}\", \"{a\\\\b\\\"c\");    assertSanitized(\"{\\\"a\\\":\\\"b\\\",\\\"c\\\":null}\", \"{\\\"a\\\":\\\"b\\\",\\\"c\\\":\");    assertSanitized(        \"{\\\"1e0001234567890123456789123456789123456789\\\":0}\",        \"{1e0001234567890123456789123456789123456789:0}\"                    );    assertSanitized(\"-16923547559\", \"-016923547559\");  }  @Test  public static final void testIssue3() {    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{},\\u00E4\");    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{\\u00E4\\u00E4},\\u00E4\");  }  @Test  public static final void testIssue4() {    assertSanitized(\"\\\"dev\\\"\", \"dev\");    assertSanitized(\"\\\"eval\\\"\", \"eval\");    assertSanitized(\"\\\"comment\\\"\", \"comment\");    assertSanitized(\"\\\"fasle\\\"\", \"fasle\");    assertSanitized(\"\\\"FALSE\\\"\", \"FALSE\");    assertSanitized(\"\\\"dev/comment\\\"\", \"dev/comment\");    assertSanitized(\"\\\"devcomment\\\"\", \"dev\\\\comment\");    assertSanitized(\"\\\"dev\\\\ncomment\\\"\", \"dev\\\\ncomment\");    assertSanitized(\"[\\\"dev\\\", \\\"comment\\\"]\", \"[dev\\\\, comment]\");  }  @Test  public static final void testMaximumNestingLevel() {    String nestedMaps = \"{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";    String sanitizedNestedMaps = \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";    boolean exceptionIfTooMuchNesting = false;    try {      assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH);    } catch (ArrayIndexOutOfBoundsException e) {      Logger.getAnonymousLogger().log(Level.FINEST, \"Expected exception in testing maximum nesting level\", e);      exceptionIfTooMuchNesting = true;    }    assertTrue(\"Expecting failure for too nested JSON\", exceptionIfTooMuchNesting);    assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH + 1);  }  @Test  public static final void testMaximumNestingLevelAssignment() {    assertEquals(1, new JsonSanitizer(\"\", Integer.MIN_VALUE).getMaximumNestingDepth());    assertEquals(JsonSanitizer.MAXIMUM_NESTING_DEPTH, new JsonSanitizer(\"\", Integer.MAX_VALUE).getMaximumNestingDepth());  }  @Test  public static final void testUnopenedArray() {    assertSanitized(\"-1742461140214282\", \"\\ufeff-01742461140214282]\");  }  @Test  public static final void testIssue13() {    assertSanitized(        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\",        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\");  }  @Test  public static final void testHtmlParserStateChanges() {    assertSanitized(\"\\\"\\\\u003cscript\\\"\", \"\\\"<script\\\"\");    assertSanitized(\"\\\"\\\\u003cScript\\\"\", \"\\\"<Script\\\"\");    assertSanitized(\"\\\"\\\\u003cScR\\u0130pT\\\"\", \"\\\"<ScR\\u0130pT\\\"\");    assertSanitized(\"\\\"\\\\u003cSCRIPT\\\\n>\\\"\", \"\\\"<SCRIPT\\n>\\\"\");    assertSanitized(\"\\\"script\\\"\", \"<script\");    assertSanitized(\"\\\"\\\\u003c!--\\\"\", \"\\\"<!--\\\"\");    assertSanitized(\"-0\", \"<!--\");    assertSanitized(\"\\\"--\\\\u003e\\\"\", \"\\\"-->\\\"\");    assertSanitized(\"-0\", \"-->\");    assertSanitized(\"\\\"\\\\u003c!--\\\\u003cscript>\\\"\", \"\\\"<!--<script>\\\"\");  }  @Test  public static final void testLongOctalNumberWithBadDigits() {    assertEquals(            \"-888888888888888888888\",            JsonSanitizer.sanitize(\"-0888888888888888888888\")    );  }  @Test  public static final void testLongNumberInUnclosedInputWithU80() {    assertEquals(            \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"x80\\\":{\\\"\\\":{\\\"\\\":[-400557869725698078427]}}}}}}}}}\",            JsonSanitizer.sanitize(\"{{{{{{{\\\\x80{{([-053333333304233333333333\")    );  }  @Test  public static final void testSlashFour() {    assertEquals(\"\\\"y\\\\u0004\\\"\", JsonSanitizer.sanitize(\"y\\\\4\"));   }  @Test  public static final void testUnterminatedObject() {    String input = \"?\\u0000\\u0000\\u0000{{\\u0000\\ufffd\\u0003]ve{R]\\u00000\\ufffd\\u0016&e{\\u0003]\\ufffda<!.b<!<!cc1x\\u0000\\u00005{281<\\u0000.{t\\u0001\\ufffd5\\ufffd{5\\ufffd\\ufffd0\\ufffd15\\r\\ufffd\\u0000\\u0000\\u0000~~-0081273222428822883223759,55\\ufffd\\u0000\\ufffd\\t\\u0000\\ufffd\";    String got = JsonSanitizer.sanitize(input);    String want = \"{\\\"\\\":{},\\\"ve\\\":{\\\"R\\\":null},\\\"0\\\":\\\"e\\\",\\\"\\\":{},\\\"a<!.b<!<!cc1x\\\":5,\\\"\\\":{\\\"281\\\":0.0,\\\"\\\":{\\\"t\\\":5,\\\"\\\":{\\\"5\\\":0,\\\"15\\\"\\r:-81273222428822883223759,\\\"55\\\"\\t:null}}}}\";    assertEquals(want, got);  }  @Test  public static final void testCrash1() {    String input = \"?\\u0000\\u0000\\u0000{{\\u0000\\ufffd\\u0003]ve{R]\\u00000\\ufffd\\ufffd\\u0016&e{\\u0003]\\ufffda<!.b<!<!c\\u00005{281<\\u0000.{t\\u0001\\ufffd5\\ufffd{515\\r[\\u0000\\u0000\\u0000~~-008127322242\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd23759,551x\\u0000\\u00006{281<\\u0000.{t\\u0001\\ufffd5\\ufffd{5\\ufffd\\ufffd0\\ufffd15\\r[\\u0000\\u0000\\u0000~~-0081273222428822883223759,\\ufffd\";    String want = \"{\\\"\\\":{},\\\"ve\\\":{\\\"R\\\":null},\\\"0\\\":\\\"e\\\",\\\"\\\":{},\\\"a<!.b<!<!c\\\":5,\\\"\\\":{\\\"281\\\":0.0,\\\"\\\":{\\\"t\\\":5,\\\"\\\":{\\\"515\\\"\\r:[-8127322242,23759,551,6,{\\\"281\\\":0.0,\\\"\\\":{\\\"t\\\":5,\\\"\\\":{\\\"5\\\":0,\\\"15\\\"\\r:[-81273222428822883223759]}}}]}}}}\";    String got = JsonSanitizer.sanitize(input);    assertEquals(want, got);  }  @Test  public static final void testDisallowedSubstrings() {    String[] inputs = {            \"x<\\\\script>\",            \"x</\\\\script>\",            \"x</sc\\\\ript>\",            \"x<\\\\163cript>\",            \"x</\\\\163cript>\",            \"x<\\\\123cript>\",            \"x</\\\\123cript>\",            \"u\\\\u\\\\uu\\ufffd\\ufffd\\\\u7u\\\\u\\\\u\\\\u\\ufffdu<\\\\script>5\",            \"z\\\\<\\\\!--\",            \"z\\\\<!\\\\--\",            \"z\\\\<!-\\\\-\",            \"z\\\\<\\\\!--\",            \"\\\"\\\\]]\\\\>\",    };    for (String input : inputs) {      String out = JsonSanitizer.sanitize(input).toLowerCase(Locale.ROOT);      assertFalse(out, out.contains(\"<!--\"));      assertFalse(out, out.contains(\"-->\"));      assertFalse(out, out.contains(\"<script\"));      assertFalse(out, out.contains(\"</script\"));      assertFalse(out, out.contains(\"]]>\"));      assertFalse(out, out.contains(\"<![cdata[\"));    }  }  @Test  public static final void testXssPayload() {    String input = \"x</\\\\script>u\\\\u\\\\uu\\ufffd\\ufffd\\\\u7u\\\\u\\\\u\\\\u\\ufffdu<\\\\script>5+alert(1)    assertEquals(            \"\\\"x\\\\u003c/script>uuuu\\uFFFD\\uFFFDu7uuuu\\uFFFDu\\\\u003cscript>5+alert(1)            JsonSanitizer.sanitize(input)    );  }  @Test  public static final void testInvalidOutput() {    String input = \"\\u0010{'\\u0000\\u0000'\\\"\\u0000\\\"{.\\ufffd-0X29295909049550970,\\n\\n0\";    String want = \"{\\\"\\\\u0000\\\\u0000\\\":\\\"\\\\u0000\\\",\\\"\\\":{\\\"0\\\":-47455995597866469744,\\n\\n\\\"0\\\":null}}\";    String got = JsonSanitizer.sanitize(input);    assertEquals(want, got);  }  @Test  public static final void testBadNumber() {    String input = \"¶0x.\\\\蹃4\\\\À906\";    String want = \"0.0\";    String got = JsonSanitizer.sanitize(input);    assertEquals(want, got);  }}", "nl": "import static com.google.json.JsonSanitizer.DEFAULT_NESTING_DEPTH;import static com.google.json.JsonSanitizer.sanitize;import java.util.logging.Level;import java.util.logging.Logger;import junit.framework.TestCase;import org.junit.Test;@SuppressWarnings(\"javadoc\")public final class JsonSanitizerTest extends TestCase {  private static void assertSanitized(String golden, String input) {    assertSanitized(golden, input, DEFAULT_NESTING_DEPTH);  }  private static void assertSanitized(String golden, String input, int maximumNestingDepth) {    String actual = sanitize(input, maximumNestingDepth);    assertEquals(input, golden, actual);    if (actual.equals(input)) {      assertSame(input, input, actual);    }  }  private static void assertSanitized(String sanitary) {    assertSanitized(sanitary, sanitary);  }  @Test  public static final void testSanitize() {    assertSanitized(\"null\", null);    assertSanitized(\"null\", \"\");    assertSanitized(\"null\");    assertSanitized(\"false\");    assertSanitized(\"true\");    assertSanitized(\" false \");    assertSanitized(\"  false\");    assertSanitized(\"false\\n\");    assertSanitized(\"false\", \"false,true\");    assertSanitized(\"\\\"foo\\\"\");    assertSanitized(\"\\\"foo\\\"\", \"'foo'\");    assertSanitized(        \"\\\"\\\\u003cscript>foo()\\\\u003c/script>\\\"\", \"\\\"<script>foo()</script>\\\"\");    assertSanitized(\"\\\"\\\\u003c/SCRIPT\\\\n>\\\"\", \"\\\"</SCRIPT\\n>\\\"\");    assertSanitized(\"\\\"\\\\u003c/ScRIpT\\\"\", \"\\\"</ScRIpT\\\"\");    assertSanitized(\"\\\"\\\\u003c/ScR\\u0130pT\\\"\", \"\\\"</ScR\\u0130pT\\\"\");    assertSanitized(\"\\\"<b>Hello</b>\\\"\");    assertSanitized(\"\\\"<s>Hello</s>\\\"\");    assertSanitized(\"\\\"<[[\\\\u005d]>\\\"\", \"'<[[]]>'\");    assertSanitized(\"\\\"\\\\u005d]>\\\"\", \"']]>'\");    assertSanitized(\"[[0]]\", \"[[0]]>\");    assertSanitized(\"[1,-1,0.0,-0.5,1e2]\", \"[1,-1,0.0,-0.5,1e2,\");    assertSanitized(\"[1,2,3]\", \"[1,2,3,]\");    assertSanitized(\"[1,null,3]\", \"[1,,3,]\");    assertSanitized(\"[1 ,2 ,3]\", \"[1 2 3]\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ \\\"foo\\\": \\\"bar\\\", }\");    assertSanitized(\"{\\\"foo\\\":\\\"bar\\\"}\", \"{\\\"foo\\\",\\\"bar\\\"}\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\" }\", \"{ foo: \\\"bar\\\" }\");    assertSanitized(\"{ \\\"foo\\\": \\\"bar\\\"}\", \"{ foo: 'bar\");    assertSanitized(\"{ \\\"foo\\\": [\\\"bar\\\"]}\", \"{ foo: ['bar\");    assertSanitized(\"false\", \"    assertSanitized(\"false\", \"false    assertSanitized(\"false\", \"false    assertSanitized(\"false\", \"false\");    assertSanitized(\"false\", \"falsetrue**/false\");    assertSanitized(\"1\");    assertSanitized(\"-1\");    assertSanitized(\"1.0\");    assertSanitized(\"-1.0\");    assertSanitized(\"1.05\");    assertSanitized(\"427.0953333\");    assertSanitized(\"6.0221412927e+23\");    assertSanitized(\"6.0221412927e23\");    assertSanitized(\"6.0221412927e0\", \"6.0221412927e\");    assertSanitized(\"6.0221412927e-0\", \"6.0221412927e-\");    assertSanitized(\"6.0221412927e+0\", \"6.0221412927e+\");    assertSanitized(\"1.660538920287695E-24\");    assertSanitized(\"-6.02e-23\");    assertSanitized(\"1.0\", \"1.\");    assertSanitized(\"0.5\", \".5\");    assertSanitized(\"-0.5\", \"-.5\");    assertSanitized(\"0.5\", \"+.5\");    assertSanitized(\"0.5e2\", \"+.5e2\");    assertSanitized(\"1.5e+2\", \"+1.5e+2\");    assertSanitized(\"0.5e-2\", \"+.5e-2\");    assertSanitized(\"{\\\"0\\\":0}\", \"{0:0}\");    assertSanitized(\"{\\\"0\\\":0}\", \"{-0:0}\");    assertSanitized(\"{\\\"0\\\":0}\", \"{+0:0}\");    assertSanitized(\"{\\\"1\\\":0}\", \"{1.0:0}\");    assertSanitized(\"{\\\"1\\\":0}\", \"{1.:0}\");    assertSanitized(\"{\\\"0.5\\\":0}\", \"{.5:0}\");    assertSanitized(\"{\\\"-0.5\\\":0}\", \"{-.5:0}\");    assertSanitized(\"{\\\"0.5\\\":0}\", \"{+.5:0}\");    assertSanitized(\"{\\\"50\\\":0}\", \"{+.5e2:0}\");    assertSanitized(\"{\\\"150\\\":0}\", \"{+1.5e+2:0}\");    assertSanitized(\"{\\\"0.1\\\":0}\", \"{+.1:0}\");    assertSanitized(\"{\\\"0.01\\\":0}\", \"{+.01:0}\");    assertSanitized(\"{\\\"0.005\\\":0}\", \"{+.5e-2:0}\");    assertSanitized(\"{\\\"1e+101\\\":0}\", \"{10e100:0}\");    assertSanitized(\"{\\\"1e-99\\\":0}\", \"{10e-100:0}\");    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.5e-100:0}\");    assertSanitized(\"{\\\"1.05e-99\\\":0}\", \"{10.500e-100:0}\");    assertSanitized(\"{\\\"1.234e+101\\\":0}\", \"{12.34e100:0}\");    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");    assertSanitized(\"{\\\"1.234e-102\\\":0}\", \"{.01234e-100:0}\");    assertSanitized(\"{}\");    assertSanitized(\"{}\", \"({})\");    assertSanitized(\"\\\"\\\\u0000\\\\u0008\\\\u001f\\\"\", \"'\\u0000\\u0008\\u001f'\");    assertSanitized(\"\\\"\\ud800\\udc00\\\\udc00\\\\ud800\\\"\",                    \"'\\ud800\\udc00\\udc00\\ud800'\");    assertSanitized(\"\\\"\\ufffd\\\\ufffe\\\\uffff\\\"\", \"'\\ufffd\\ufffe\\uffff'\");    assertSanitized(\"42\", \"\\uffef\\u000042\\u0008\\ud800\\uffff\\udc00\");    assertSanitized(\"null\", \"\\uffef\\u0000\\u0008\\ud800\\uffff\\udc00\");    assertSanitized(\"[null]\", \"[,]\");    assertSanitized(\"[null]\", \"[null,]\");    assertSanitized(\"{\\\"a\\\":0,\\\"false\\\":\\\"x\\\",\\\"\\\":{\\\"\\\":-1}}\",                    \"{\\\"a\\\":0,false\\\"x\\\":{\\\"\\\":-1}}\");    assertSanitized(\"[true ,false]\", \"[true false]\");    assertSanitized(\"[\\\"\\\\u00a0\\\\u1234\\\"]\");    assertSanitized(\"{\\\"a\\\\b\\\":\\\"c\\\"}\", \"{a\\\\b\\\"c\");    assertSanitized(\"{\\\"a\\\":\\\"b\\\",\\\"c\\\":null}\", \"{\\\"a\\\":\\\"b\\\",\\\"c\\\":\");    assertSanitized(        \"{\\\"1e0001234567890123456789123456789123456789\\\":0}\",        \"{1e0001234567890123456789123456789123456789:0}\"                    );    assertSanitized(\"-16923547559\", \"-016923547559\");  }  @Test  public static final void testIssue3() {    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{},\\u00E4\");    assertSanitized(\"[{\\\"\\\":{}}]\", \"[{{\\u00E4\\u00E4},\\u00E4\");  }  @Test  public static final void testIssue4() {    assertSanitized(\"\\\"dev\\\"\", \"dev\");    assertSanitized(\"\\\"eval\\\"\", \"eval\");    assertSanitized(\"\\\"comment\\\"\", \"comment\");    assertSanitized(\"\\\"fasle\\\"\", \"fasle\");    assertSanitized(\"\\\"FALSE\\\"\", \"FALSE\");    assertSanitized(\"\\\"dev/comment\\\"\", \"dev/comment\");    assertSanitized(\"\\\"devcomment\\\"\", \"dev\\\\comment\");    assertSanitized(\"\\\"dev\\\\ncomment\\\"\", \"dev\\\\ncomment\");    assertSanitized(\"[\\\"dev\\\", \\\"comment\\\"]\", \"[dev\\\\, comment]\");  }  @Test  public static final void testMaximumNestingLevel() {    String nestedMaps = \"{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";    String sanitizedNestedMaps = \"{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{\\\"\\\":{}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\";    boolean exceptionIfTooMuchNesting = false;    try {      assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH);    } catch (ArrayIndexOutOfBoundsException e) {      Logger.getAnonymousLogger().log(Level.FINEST, \"Expected exception in testing maximum nesting level\", e);      exceptionIfTooMuchNesting = true;    }    assertTrue(\"Expecting failure for too nested JSON\", exceptionIfTooMuchNesting);    assertSanitized(sanitizedNestedMaps, nestedMaps, DEFAULT_NESTING_DEPTH + 1);  }  @Test  public static final void testMaximumNestingLevelAssignment() {    assertEquals(1, new JsonSanitizer(\"\", Integer.MIN_VALUE).getMaximumNestingDepth());    assertEquals(JsonSanitizer.MAXIMUM_NESTING_DEPTH, new JsonSanitizer(\"\", Integer.MAX_VALUE).getMaximumNestingDepth());  }  @Test  public static final void testClosedArray() {    assertSanitized(\"-1742461140214282\", \"\\ufeff-01742461140214282]\");  }  @Test  public static final void testIssue13() {    assertSanitized(        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\",        \"[ { \\\"description\\\": \\\"aa##############aa\\\" }, 1 ]\");  }  @Test  public static final void testHtmlParserStateChanges() {    assertSanitized(\"\\\"\\\\u003cscript\\\"\", \"\\\"<script\\\"\");    assertSanitized(\"\\\"\\\\u003cScript\\\"\", \"\\\"<Script\\\"\");    assertSanitized(\"\\\"\\\\u003cScR\\u0130pT\\\"\", \"\\\"<ScR\\u0130pT\\\"\");    assertSanitized(\"\\\"\\\\u003cSCRIPT\\\\n>\\\"\", \"\\\"<SCRIPT\\n>\\\"\");    assertSanitized(\"\\\"script\\\"\", \"<script\");    assertSanitized(\"\\\"\\\\u003c!--\\\"\", \"\\\"<!--\\\"\");    assertSanitized(\"-0\", \"<!--\");    assertSanitized(\"\\\"--\\\\u003e\\\"\", \"\\\"-->\\\"\");    assertSanitized(\"-0\", \"-->\");    assertSanitized(\"\\\"\\\\u003c!--\\\\u003cscript>\\\"\", \"\\\"<!--<script>\\\"\");  }}"}
{"code": "import com.thoughtworks.go.api.ApiController;import com.thoughtworks.go.api.ApiVersion;import com.thoughtworks.go.api.CrudController;import com.thoughtworks.go.api.base.OutputWriter;import com.thoughtworks.go.api.representers.JsonReader;import com.thoughtworks.go.api.spring.ApiAuthenticationHelper;import com.thoughtworks.go.api.util.GsonTransformer;import com.thoughtworks.go.api.util.MessageJson;import com.thoughtworks.go.apiv1.backupconfig.representers.BackupConfigRepresenter;import com.thoughtworks.go.config.BackupConfig;import com.thoughtworks.go.config.exceptions.EntityType;import com.thoughtworks.go.config.exceptions.GoConfigInvalidException;import com.thoughtworks.go.config.update.CreateOrUpdateBackupConfigCommand;import com.thoughtworks.go.config.update.DeleteBackupConfigCommand;import com.thoughtworks.go.server.service.GoConfigService;import com.thoughtworks.go.spark.Routes;import com.thoughtworks.go.spark.spring.SparkSpringController;import org.apache.http.HttpStatus;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import spark.Request;import spark.Response;import java.io.IOException;import java.util.function.Consumer;import static spark.Spark.*;@Componentpublic class BackupConfigControllerV1 extends ApiController implements SparkSpringController, CrudController<BackupConfig> {    private final ApiAuthenticationHelper apiAuthenticationHelper;    private final GoConfigService goConfigService;    @Autowired    public BackupConfigControllerV1(ApiAuthenticationHelper apiAuthenticationHelper, GoConfigService goConfigService) {        super(ApiVersion.v1);        this.apiAuthenticationHelper = apiAuthenticationHelper;        this.goConfigService = goConfigService;    }    @Override    public String controllerBasePath() {        return Routes.BackupConfig.BASE;    }    @Override    public void setupRoutes() {        path(controllerBasePath(), () -> {            before(\"\", mimeType, this::setContentType);            before(\"/*\", mimeType, this::setContentType);            before(\"\", mimeType, this::verifyContentType);            before(\"/*\", mimeType, this::verifyContentType);            before(\"\", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);            get(\"\", mimeType, this::show);            post(\"\", mimeType, this::createOrUpdate);            put(\"\", mimeType, this::createOrUpdate);            delete(\"\", mimeType, this::deleteBackupConfig);        });    }    public String show(Request req, Response res) throws IOException {        BackupConfig backupConfig = doFetchEntityFromConfig();        if (backupConfig == null) {            backupConfig = new BackupConfig();        }        return writerForTopLevelObject(req, res, jsonWriter(backupConfig));    }    public String createOrUpdate(Request req, Response res) throws IOException {        BackupConfig backupConfig = buildEntityFromRequestBody(req);        try {            goConfigService.updateConfig(new CreateOrUpdateBackupConfigCommand(backupConfig), currentUsername());        } catch (GoConfigInvalidException e) {            res.status(HttpStatus.SC_UNPROCESSABLE_ENTITY);            return MessageJson.create(e.getMessage(), jsonWriter(backupConfig));        }        return show(req, res);    }    public String deleteBackupConfig(Request req, Response res) throws IOException {        fetchEntityFromConfig();        goConfigService.updateConfig(new DeleteBackupConfigCommand(), currentUsername());        return renderMessage(res, 200, EntityType.BackupConfig.deleteSuccessful());    }    @Override    public String etagFor(BackupConfig entityFromServer) {        throw new UnsupportedOperationException();    }    @Override    public EntityType getEntityType() {        return EntityType.BackupConfig;    }    @Override    public BackupConfig doFetchEntityFromConfig() {        return goConfigService.serverConfig().getBackupConfig();    }    @Override    public BackupConfig buildEntityFromRequestBody(Request req) {        JsonReader jsonReader = GsonTransformer.getInstance().jsonReaderFrom(req.body());        return BackupConfigRepresenter.fromJSON(jsonReader);    }    @Override    public Consumer<OutputWriter> jsonWriter(BackupConfig backupConfig) {        return outputWriter -> BackupConfigRepresenter.toJSON(outputWriter, backupConfig);    }}", "nl": "import com.thoughtworks.go.api.ApiController;import com.thoughtworks.go.api.ApiVersion;import com.thoughtworks.go.api.CrudController;import com.thoughtworks.go.api.base.OutputWriter;import com.thoughtworks.go.api.representers.JsonReader;import com.thoughtworks.go.api.spring.ApiAuthenticationHelper;import com.thoughtworks.go.api.util.GsonTransformer;import com.thoughtworks.go.api.util.MessageJson;import com.thoughtworks.go.apiv1.backupconfig.representers.BackupConfigRepresenter;import com.thoughtworks.go.config.BackupConfig;import com.thoughtworks.go.config.exceptions.EntityType;import com.thoughtworks.go.config.exceptions.GoConfigInvalidException;import com.thoughtworks.go.config.update.CreateOrUpdateBackupConfigCommand;import com.thoughtworks.go.config.update.DeleteBackupConfigCommand;import com.thoughtworks.go.server.service.GoConfigService;import com.thoughtworks.go.spark.Routes;import com.thoughtworks.go.spark.spring.SparkSpringController;import org.apache.http.HttpStatus;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import spark.Request;import spark.Response;import java.io.IOException;import java.util.function.Consumer;import static spark.Spark.*;@Componentpublic class BackupConfigControllerV1 extends ApiController implements SparkSpringController, CrudController<BackupConfig> {    private final ApiAuthenticationHelper apiAuthenticationHelper;    private final GoConfigService goConfigService;    @Autowired    public BackupConfigControllerV1(ApiAuthenticationHelper apiAuthenticationHelper, GoConfigService goConfigService) {        super(ApiVersion.v1);        this.apiAuthenticationHelper = apiAuthenticationHelper;        this.goConfigService = goConfigService;    }    @Override    public String controllerBasePath() {        return Routes.BackupConfig.BASE;    }    @Override    public void setupRoutes() {        path(controllerBasePath(), () -> {            before(\"\", mimeType, this::setContentType);            before(\"\", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);            get(\"\", mimeType, this::show);            post(\"\", mimeType, this::createOrUpdate);            put(\"\", mimeType, this::createOrUpdate);            delete(\"\", mimeType, this::deleteBackupConfig);        });    }    public String show(Request req, Response res) throws IOException {        BackupConfig backupConfig = doFetchEntityFromConfig();        if (backupConfig == null) {            backupConfig = new BackupConfig();        }        return writerForTopLevelObject(req, res, jsonWriter(backupConfig));    }    public String createOrUpdate(Request req, Response res) throws IOException {        BackupConfig backupConfig = buildEntityFromRequestBody(req);        try {            goConfigService.updateConfig(new CreateOrUpdateBackupConfigCommand(backupConfig), currentUsername());        } catch (GoConfigInvalidException e) {            res.status(HttpStatus.SC_UNPROCESSABLE_ENTITY);            return MessageJson.create(e.getMessage(), jsonWriter(backupConfig));        }        return show(req, res);    }    public String deleteBackupConfig(Request req, Response res) throws IOException {        fetchEntityFromConfig();        goConfigService.updateConfig(new DeleteBackupConfigCommand(), currentUsername());        return renderMessage(res, 200, EntityType.BackupConfig.deleteSuccessful());    }    @Override    public String etagFor(BackupConfig entityFromServer) {        throw new UnsupportedOperationException();    }    @Override    public EntityType getEntityType() {        return EntityType.BackupConfig;    }    @Override    public BackupConfig doFetchEntityFromConfig() {        return goConfigService.serverConfig().getBackupConfig();    }    @Override    public BackupConfig buildEntityFromRequestBody(Request req) {        JsonReader jsonReader = GsonTransformer.getInstance().jsonReaderFrom(req.body());        return BackupConfigRepresenter.fromJSON(jsonReader);    }    @Override    public Consumer<OutputWriter> jsonWriter(BackupConfig backupConfig) {        return outputWriter -> BackupConfigRepresenter.toJSON(outputWriter, backupConfig);    }}"}
{"code": "import com.google.gson.Gson;import com.thoughtworks.go.addon.businesscontinuity.ConfigFileType;import com.thoughtworks.go.addon.businesscontinuity.DatabaseStatusProvider;import com.thoughtworks.go.addon.businesscontinuity.FileDetails;import com.thoughtworks.go.addon.businesscontinuity.PluginsList;import com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;import com.thoughtworks.go.addon.businesscontinuity.primary.service.GoFilesStatusProvider;import com.thoughtworks.go.util.SystemEnvironment;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.HashMap;import java.util.Map;import static org.apache.commons.io.IOUtils.copy;import static org.apache.commons.lang3.StringUtils.isBlank;import static org.apache.commons.lang3.StringUtils.isEmpty;@Controller@SuppressWarnings(\"WeakerAccess\")public class PrimaryStatusProviderController {    private GoFilesStatusProvider goFilesStatusProvider;    private DatabaseStatusProvider databaseStatusProvider;    private final SystemEnvironment systemEnvironment;    private PluginsList pluginsList;    @Autowired    public PrimaryStatusProviderController(GoFilesStatusProvider goFilesStatusProvider, DatabaseStatusProvider databaseStatusProvider, PluginsList pluginsList, SystemEnvironment systemEnvironment) {        this.goFilesStatusProvider = goFilesStatusProvider;        this.databaseStatusProvider = databaseStatusProvider;        this.pluginsList = pluginsList;        this.systemEnvironment = systemEnvironment;    }    @RequestMapping(value = \"/health-check\", method = RequestMethod.GET)    @ResponseBody    public String healthCheck() {        return \"OK!\";    }    @RequestMapping(value = \"/latest_database_wal_location\", method = RequestMethod.GET)    @ResponseBody    public String latestDatabaseWalLocation() {        return databaseStatusProvider.latestWalLocation();    }    @RequestMapping(value = \"/config_files_status\", method = RequestMethod.GET)    public void latestStatus(HttpServletResponse response) throws IOException {        Map<ConfigFileType, String> latestFileStatusMap = goFilesStatusProvider.getLatestStatusMap();        Map<ConfigFileType, FileDetails> fileDetailsMap = new HashMap<>();        for (ConfigFileType configFileType : latestFileStatusMap.keySet()) {            if (!isEmpty(latestFileStatusMap.get(configFileType))) {                fileDetailsMap.put(configFileType, new FileDetails(latestFileStatusMap.get(configFileType)));            }        }        ServerStatusResponse serverStatusResponse = new ServerStatusResponse(goFilesStatusProvider.updateInterval(), goFilesStatusProvider.getLastUpdateTime(), fileDetailsMap);        String responseBody = new Gson().toJson(serverStatusResponse);        response.setContentType(\"application/json\");        response.getOutputStream().print(responseBody);    }    @RequestMapping(value = \"/cruise_config\", method = RequestMethod.GET)    public void getLatestCruiseConfigXML(HttpServletResponse response) {        serveFile(ConfigFileType.CRUISE_CONFIG_XML.load(systemEnvironment), response, \"text/xml\");    }    @RequestMapping(value = \"/user_feature_toggle\", method = RequestMethod.GET)    public void geUserFeatureToggleFile(HttpServletResponse response) {        serveFile(ConfigFileType.USER_FEATURE_TOGGLE.load(systemEnvironment), response, \"text/json\");    }    @RequestMapping(value = \"/cipher.aes\", method = RequestMethod.GET)    public void getLatestAESCipher(HttpServletResponse response) {        serveFile(ConfigFileType.AES_CIPHER.load(systemEnvironment), response, \"text/plain\");    }    @RequestMapping(value = \"/jetty_config\", method = RequestMethod.GET)    public void getLatestJettyXML(HttpServletResponse response) {        serveFile(ConfigFileType.JETTY_XML.load(systemEnvironment), response, \"text/xml\");    }    @RequestMapping(value = \"/plugin_files_status\", method = RequestMethod.GET)    public void latest(HttpServletResponse response) throws IOException {        String pluginsJSON = pluginsList.getPluginsJSON();        response.setContentType(\"application/json\");        response.getOutputStream().print(pluginsJSON);    }    @RequestMapping(value = \"/plugin\", method = RequestMethod.GET)    public void getPluginFile(            @RequestParam(\"folderName\") String folderName,            @RequestParam(\"pluginName\") String pluginName,            HttpServletResponse response) {        String pluginFolderPath = isBlank(folderName) || folderName.equalsIgnoreCase(\"bundled\") ? systemEnvironment.getBundledPluginAbsolutePath() : systemEnvironment.getExternalPluginAbsolutePath();        File pluginFile = new File(pluginFolderPath, pluginName);        serveFile(pluginFile, response, \"application/octet-stream\");    }    private void serveFile(File file, HttpServletResponse response, String contentType) {        try (FileInputStream inputStream = new FileInputStream(file)) {            response.setStatus(HttpServletResponse.SC_OK);            response.setCharacterEncoding(\"UTF-8\");            response.setContentType(contentType);            copy(inputStream, response.getOutputStream());            response.flushBuffer();        } catch (IOException e) {            throw new RuntimeException(e);        }    }}", "nl": "import com.google.gson.Gson;import com.thoughtworks.go.addon.businesscontinuity.ConfigFileType;import com.thoughtworks.go.addon.businesscontinuity.DatabaseStatusProvider;import com.thoughtworks.go.addon.businesscontinuity.FileDetails;import com.thoughtworks.go.addon.businesscontinuity.PluginsList;import com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;import com.thoughtworks.go.addon.businesscontinuity.primary.service.GoFilesStatusProvider;import com.thoughtworks.go.util.SystemEnvironment;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.HashMap;import java.util.Map;import static org.apache.commons.io.IOUtils.copy;import static org.apache.commons.lang3.StringUtils.isBlank;import static org.apache.commons.lang3.StringUtils.isEmpty;@Controller@SuppressWarnings(\"WeakerAccess\")@RequestMapping(value = \"/add-on/business-continuity/api\")public class PrimaryStatusProviderController {    private GoFilesStatusProvider goFilesStatusProvider;    private DatabaseStatusProvider databaseStatusProvider;    private final SystemEnvironment systemEnvironment;    private PluginsList pluginsList;    @Autowired    public PrimaryStatusProviderController(GoFilesStatusProvider goFilesStatusProvider, DatabaseStatusProvider databaseStatusProvider, PluginsList pluginsList, SystemEnvironment systemEnvironment) {        this.goFilesStatusProvider = goFilesStatusProvider;        this.databaseStatusProvider = databaseStatusProvider;        this.pluginsList = pluginsList;        this.systemEnvironment = systemEnvironment;    }    @RequestMapping(value = \"/health-check\", method = RequestMethod.GET)    @ResponseBody    public String healthCheck() {        return \"OK!\";    }    @RequestMapping(value = \"/latest_database_wal_location\", method = RequestMethod.GET)    @ResponseBody    public String latestDatabaseWalLocation() {        return databaseStatusProvider.latestWalLocation();    }    @RequestMapping(value = \"/config_files_status\", method = RequestMethod.GET)    public void latestStatus(HttpServletResponse response) throws IOException {        Map<ConfigFileType, String> latestFileStatusMap = goFilesStatusProvider.getLatestStatusMap();        Map<ConfigFileType, FileDetails> fileDetailsMap = new HashMap<>();        for (ConfigFileType configFileType : latestFileStatusMap.keySet()) {            if (!isEmpty(latestFileStatusMap.get(configFileType))) {                fileDetailsMap.put(configFileType, new FileDetails(latestFileStatusMap.get(configFileType)));            }        }        ServerStatusResponse serverStatusResponse = new ServerStatusResponse(goFilesStatusProvider.updateInterval(), goFilesStatusProvider.getLastUpdateTime(), fileDetailsMap);        String responseBody = new Gson().toJson(serverStatusResponse);        response.setContentType(\"application/json\");        response.getOutputStream().print(responseBody);    }    @RequestMapping(value = \"/cruise_config\", method = RequestMethod.GET)    public void getLatestCruiseConfigXML(HttpServletResponse response) {        serveFile(ConfigFileType.CRUISE_CONFIG_XML.load(systemEnvironment), response, \"text/xml\");    }    @RequestMapping(value = \"/user_feature_toggle\", method = RequestMethod.GET)    public void geUserFeatureToggleFile(HttpServletResponse response) {        serveFile(ConfigFileType.USER_FEATURE_TOGGLE.load(systemEnvironment), response, \"text/json\");    }    @RequestMapping(value = \"/cipher.aes\", method = RequestMethod.GET)    public void getLatestAESCipher(HttpServletResponse response) {        serveFile(ConfigFileType.AES_CIPHER.load(systemEnvironment), response, \"text/plain\");    }    @RequestMapping(value = \"/jetty_config\", method = RequestMethod.GET)    public void getLatestJettyXML(HttpServletResponse response) {        serveFile(ConfigFileType.JETTY_XML.load(systemEnvironment), response, \"text/xml\");    }    @RequestMapping(value = \"/plugin_files_status\", method = RequestMethod.GET)    public void latest(HttpServletResponse response) throws IOException {        String pluginsJSON = pluginsList.getPluginsJSON();        response.setContentType(\"application/json\");        response.getOutputStream().print(pluginsJSON);    }    @RequestMapping(value = \"/plugin\", method = RequestMethod.GET)    public void getPluginFile(            @RequestParam(\"folderName\") String folderName,            @RequestParam(\"pluginName\") String pluginName,            HttpServletResponse response) {        String pluginFolderPath = isBlank(folderName) || folderName.equalsIgnoreCase(\"bundled\") ? systemEnvironment.getBundledPluginAbsolutePath() : systemEnvironment.getExternalPluginAbsolutePath();        File pluginFile = new File(pluginFolderPath, pluginName);        serveFile(pluginFile, response, \"application/octet-stream\");    }    private void serveFile(File file, HttpServletResponse response, String contentType) {        try (FileInputStream inputStream = new FileInputStream(file)) {            response.setStatus(HttpServletResponse.SC_OK);            response.setCharacterEncoding(\"UTF-8\");            response.setContentType(contentType);            copy(inputStream, response.getOutputStream());            response.flushBuffer();        } catch (IOException e) {            throw new RuntimeException(e);        }    }}"}
{"code": "import com.google.common.collect.Sets;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.thoughtworks.go.CurrentGoCDVersion;import com.thoughtworks.go.addon.businesscontinuity.*;import com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;import com.thoughtworks.go.addon.businesscontinuity.standby.service.PrimaryServerCommunicationService;import com.thoughtworks.go.addon.businesscontinuity.standby.service.StandbyFileSyncService;import com.thoughtworks.go.server.newsecurity.models.UsernamePassword;import com.thoughtworks.go.server.service.RailsAssetsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.*;import java.util.function.BiFunction;import java.util.stream.Collectors;import static com.thoughtworks.go.server.newsecurity.utils.BasicAuthHeaderExtractor.extractBasicAuthenticationCredentials;import static java.lang.String.format;import static org.apache.commons.lang3.StringUtils.join;@Controllerpublic class DashBoardController {    private final AuthToken authToken;    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardHTML;    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardJSON;    private AddOnConfiguration addOnConfiguration;    private PrimaryServerCommunicationService primaryServerCommunicationService;    private StandbyFileSyncService standbyFileSyncService;    private ViewResolver viewResolver;    private DatabaseStatusProvider databaseStatusProvider;    private RailsAssetsService railsAssetsService;    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().setDateFormat(\"MMM d, YYYY HH:mm:ss\").create();    private static final String CREDENTIALS_KEY = DashBoardController.class.getName() + \".existing-credentials\";    @Autowired    public DashBoardController(AddOnConfiguration addOnConfiguration, PrimaryServerCommunicationService primaryServerCommunicationService,                               StandbyFileSyncService standbyFileSyncService,                               ViewResolver viewResolver, DatabaseStatusProvider databaseStatusProvider, RailsAssetsService railsAssetsService, AuthToken authToken) {        this.addOnConfiguration = addOnConfiguration;        this.primaryServerCommunicationService = primaryServerCommunicationService;        this.standbyFileSyncService = standbyFileSyncService;        this.viewResolver = viewResolver;        this.databaseStatusProvider = databaseStatusProvider;        this.railsAssetsService = railsAssetsService;        this.authToken = authToken;        this.dashboardHTML = this::showStatusPage;        this.dashboardJSON = this::showStatusJSON;    }    @ResponseBody    public String dashboard(HttpServletRequest request, HttpServletResponse response) {        return renderAfterAuthentication(request, response, dashboardHTML);    }    @ResponseBody    public String dashboardData(HttpServletRequest request, HttpServletResponse response) {        return renderAfterAuthentication(request, response, dashboardJSON);    }    private String renderAfterAuthentication(HttpServletRequest request, HttpServletResponse response, BiFunction<HttpServletRequest, HttpServletResponse, String> renderer) {        if (!authToken.isValid()) {            response.setStatus(422);            return \"Please setup business continuity according to the documentation at https:        }        HttpSession session = request.getSession();        UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));        UsernamePassword credentialsOnDisk = authToken.toUsernamePassword();        UsernamePassword existingCredentialsInSession = (UsernamePassword) session.getAttribute(CREDENTIALS_KEY);        HashSet<UsernamePassword> submittedPasswords = Sets.newHashSet(usernamePassword, existingCredentialsInSession);        submittedPasswords.remove(null);        if (submittedPasswords.isEmpty()) {            return forceBasicAuth(request, response);        }        if (submittedPasswords.stream().allMatch(up -> up.equals(credentialsOnDisk))) {            return renderer.apply(request, response);        }        if (credentialsOnDisk.equals(usernamePassword)) {            session.invalidate();            loginCurrentUser(request, request.getSession(true), usernamePassword);            return renderer.apply(request, response);        }        return forceBasicAuth(request, response);    }    private void loginCurrentUser(HttpServletRequest request, HttpSession session, UsernamePassword usernamePassword) {        session.invalidate();        session = request.getSession(true);        session.setAttribute(CREDENTIALS_KEY, usernamePassword);    }    private String showStatusPage(HttpServletRequest request, HttpServletResponse response) {        Map<String, String> modelMap = new HashMap<>();        modelMap.put(\"REPLACED_BY_GO:application.css\", railsAssetsService.getAssetPath(\"application.css\"));        modelMap.put(\"REPLACED_BY_GO:patterns/application.css\", railsAssetsService.getAssetPath(\"patterns/application.css\"));        modelMap.put(\"REPLACED_BY_GO:application.js\", railsAssetsService.getAssetPath(\"application.js\"));        modelMap.put(\"REPLACED_BY_GO:cruise.ico\", railsAssetsService.getAssetPath(\"cruise.ico\"));        if (addOnConfiguration.isServerInStandby()) {            return viewResolver.resolveView(\"standby_dashboard\", modelMap);        } else {            return viewResolver.resolveView(\"error\", modelMap);        }    }    private String forceBasicAuth(HttpServletRequest request, HttpServletResponse response) {        response.addHeader(\"WWW-Authenticate\", \"Basic realm=\\\"GoCD Business Continuity\\\"\");        response.setStatus(401);        return \"bad credentials!\";    }    private String showStatusJSON(HttpServletRequest request, HttpServletResponse response) {        response.setContentType(\"application/json\");        if (addOnConfiguration.isServerInStandby()) {            Map<String, Object> dashboardContent = new HashMap<>();            UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));            dashboardContent.put(\"userName\", usernamePassword.getUsername());            if (!primaryServerCommunicationService.ableToConnect()) {                dashboardContent.put(\"setupStatus\", \"incomplete\");                dashboardContent.put(\"syncErrors\", Collections.singletonList(\"Unable to connect to primary, please check that the business-continuity-token file is identical on primary and secondary, and that this server can connect to the primary server.\"));            } else {                dashboardContent.put(\"setupStatus\", \"success\");                dashboardContent.put(\"primaryServerDetails\", primaryServerDetails());                dashboardContent.put(\"standbyServerDetails\", standbyServerDetails());                dashboardContent.put(\"syncErrors\", standbyFileSyncService.syncErrors());            }            return GSON.toJson(dashboardContent);        }        throw new RuntimeException(\"This information only available for standby server\");    }    Map<String, Object> standbyServerDetails() {        Map<String, Object> details = new HashMap<>();        details.put(\"primaryStatusCheckInterval\", standbyFileSyncService.primaryStatusCheckInterval());        details.put(\"lastUpdateTime\", new Date(standbyFileSyncService.lastUpdateTime()));        details.put(\"latestReceivedDatabaseWalLocation\", databaseStatusProvider.latestReceivedWalLocation());        Map<ConfigFileType, String> currentFileStatus = standbyFileSyncService.getCurrentFileStatus();        for (ConfigFileType configFileType : currentFileStatus.keySet()) {            details.put(configFileType.name(), currentFileStatus.get(configFileType));        }        details.put(\"pluginStatus\", standbyPluginStatus());        return details;    }    Map<String, Object> primaryServerDetails() {        Map<String, Object> details = new HashMap<>();        String primaryServerUrl = primaryServerCommunicationService.primaryServerUrl();        details.put(\"url\", primaryServerUrl);        try {            details.put(\"latestDatabaseWalLocation\", primaryServerCommunicationService.latestDatabaseWalLocation());            ServerStatusResponse latestFileStatus = primaryServerCommunicationService.getLatestFileStatus();            details.put(\"configFilesUpdateInterval\", latestFileStatus.getConfigFilesUpdateInterval());            details.put(\"lastConfigUpdateTime\", new Date(latestFileStatus.getLastConfigFilesUpdateTime()));            Map<ConfigFileType, FileDetails> fileDetailsMap = latestFileStatus.getFileDetailsMap();            for (ConfigFileType fileType : fileDetailsMap.keySet()) {                details.put(fileType.name(), fileDetailsMap.get(fileType));            }            details.put(\"pluginStatus\", primaryPluginStatus());        } catch (Exception e) {            details.put(\"error\", format(\"Could not fetch latest file status from master, Reason, %s\", e.getMessage()));        }        return details;    }    private String standbyPluginStatus() {        final Map<String, String> currentExternalPluginsStatus = standbyFileSyncService.getCurrentExternalPluginsStatus();        List<String> pluginsMd5 = currentExternalPluginsStatus.keySet().stream().map(pluginName -> format(\"%s=%s\", pluginName, currentExternalPluginsStatus.get(pluginName))).sorted().collect(Collectors.toList());        return join(pluginsMd5, \", \");    }    private String primaryPluginStatus() {        List<Map> externalPlugins = (List<Map>) primaryServerCommunicationService.getLatestPluginsStatus().get(\"external\");        return externalPlugins.stream().map(map -> format(\"%s=%s\", map.get(\"name\"), map.get(\"md5\"))).collect(Collectors.joining(\", \"));    }}", "nl": "import com.google.common.collect.Sets;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.thoughtworks.go.CurrentGoCDVersion;import com.thoughtworks.go.addon.businesscontinuity.*;import com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;import com.thoughtworks.go.addon.businesscontinuity.standby.service.PrimaryServerCommunicationService;import com.thoughtworks.go.addon.businesscontinuity.standby.service.StandbyFileSyncService;import com.thoughtworks.go.server.newsecurity.models.UsernamePassword;import com.thoughtworks.go.server.service.RailsAssetsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.*;import java.util.function.BiFunction;import java.util.stream.Collectors;import static com.thoughtworks.go.server.newsecurity.utils.BasicAuthHeaderExtractor.extractBasicAuthenticationCredentials;import static java.lang.String.format;import static org.apache.commons.lang3.StringUtils.join;@Controllerpublic class DashBoardController {    private final AuthToken authToken;    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardHTML;    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardJSON;    private AddOnConfiguration addOnConfiguration;    private PrimaryServerCommunicationService primaryServerCommunicationService;    private StandbyFileSyncService standbyFileSyncService;    private ViewResolver viewResolver;    private DatabaseStatusProvider databaseStatusProvider;    private RailsAssetsService railsAssetsService;    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().setDateFormat(\"MMM d, YYYY HH:mm:ss\").create();    private static final String CREDENTIALS_KEY = DashBoardController.class.getName() + \".existing-credentials\";    @Autowired    public DashBoardController(AddOnConfiguration addOnConfiguration, PrimaryServerCommunicationService primaryServerCommunicationService,                               StandbyFileSyncService standbyFileSyncService,                               ViewResolver viewResolver, DatabaseStatusProvider databaseStatusProvider, RailsAssetsService railsAssetsService, AuthToken authToken) {        this.addOnConfiguration = addOnConfiguration;        this.primaryServerCommunicationService = primaryServerCommunicationService;        this.standbyFileSyncService = standbyFileSyncService;        this.viewResolver = viewResolver;        this.databaseStatusProvider = databaseStatusProvider;        this.railsAssetsService = railsAssetsService;        this.authToken = authToken;        this.dashboardHTML = this::showStatusPage;        this.dashboardJSON = this::showStatusJSON;    }    @RequestMapping(value = \"/add-on/business-continuity/admin/dashboard\", method = RequestMethod.GET)    @ResponseBody    public String dashboard(HttpServletRequest request, HttpServletResponse response) {        return renderAfterAuthentication(request, response, dashboardHTML);    }    @RequestMapping(value = \"/add-on/business-continuity/admin/dashboard.json\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)    @ResponseBody    public String dashboardData(HttpServletRequest request, HttpServletResponse response) {        return renderAfterAuthentication(request, response, dashboardJSON);    }    private String renderAfterAuthentication(HttpServletRequest request, HttpServletResponse response, BiFunction<HttpServletRequest, HttpServletResponse, String> renderer) {        if (!authToken.isValid()) {            response.setStatus(422);            return \"Please setup business continuity according to the documentation at https:        }        HttpSession session = request.getSession();        UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));        UsernamePassword credentialsOnDisk = authToken.toUsernamePassword();        UsernamePassword existingCredentialsInSession = (UsernamePassword) session.getAttribute(CREDENTIALS_KEY);        HashSet<UsernamePassword> submittedPasswords = Sets.newHashSet(usernamePassword, existingCredentialsInSession);        submittedPasswords.remove(null);        if (submittedPasswords.isEmpty()) {            return forceBasicAuth(request, response);        }        if (submittedPasswords.stream().allMatch(up -> up.equals(credentialsOnDisk))) {            return renderer.apply(request, response);        }        if (credentialsOnDisk.equals(usernamePassword)) {            session.invalidate();            loginCurrentUser(request, request.getSession(true), usernamePassword);            return renderer.apply(request, response);        }        return forceBasicAuth(request, response);    }    private void loginCurrentUser(HttpServletRequest request, HttpSession session, UsernamePassword usernamePassword) {        session.invalidate();        session = request.getSession(true);        session.setAttribute(CREDENTIALS_KEY, usernamePassword);    }    private String showStatusPage(HttpServletRequest request, HttpServletResponse response) {        Map<String, String> modelMap = new HashMap<>();        modelMap.put(\"REPLACED_BY_GO:application.css\", railsAssetsService.getAssetPath(\"application.css\"));        modelMap.put(\"REPLACED_BY_GO:patterns/application.css\", railsAssetsService.getAssetPath(\"patterns/application.css\"));        modelMap.put(\"REPLACED_BY_GO:application.js\", railsAssetsService.getAssetPath(\"application.js\"));        modelMap.put(\"REPLACED_BY_GO:cruise.ico\", railsAssetsService.getAssetPath(\"cruise.ico\"));        if (addOnConfiguration.isServerInStandby()) {            return viewResolver.resolveView(\"standby_dashboard\", modelMap);        } else {            return viewResolver.resolveView(\"error\", modelMap);        }    }    private String forceBasicAuth(HttpServletRequest request, HttpServletResponse response) {        response.addHeader(\"WWW-Authenticate\", \"Basic realm=\\\"GoCD Business Continuity\\\"\");        response.setStatus(401);        return \"bad credentials!\";    }    private String showStatusJSON(HttpServletRequest request, HttpServletResponse response) {        response.setContentType(\"application/json\");        if (addOnConfiguration.isServerInStandby()) {            Map<String, Object> dashboardContent = new HashMap<>();            UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));            dashboardContent.put(\"userName\", usernamePassword.getUsername());            if (!primaryServerCommunicationService.ableToConnect()) {                dashboardContent.put(\"setupStatus\", \"incomplete\");                dashboardContent.put(\"syncErrors\", Collections.singletonList(\"Unable to connect to primary, please check that the business-continuity-token file is identical on primary and secondary, and that this server can connect to the primary server.\"));            } else {                dashboardContent.put(\"setupStatus\", \"success\");                dashboardContent.put(\"primaryServerDetails\", primaryServerDetails());                dashboardContent.put(\"standbyServerDetails\", standbyServerDetails());                dashboardContent.put(\"syncErrors\", standbyFileSyncService.syncErrors());            }            return GSON.toJson(dashboardContent);        }        throw new RuntimeException(\"This information only available for standby server\");    }    Map<String, Object> standbyServerDetails() {        Map<String, Object> details = new HashMap<>();        details.put(\"primaryStatusCheckInterval\", standbyFileSyncService.primaryStatusCheckInterval());        details.put(\"lastUpdateTime\", new Date(standbyFileSyncService.lastUpdateTime()));        details.put(\"latestReceivedDatabaseWalLocation\", databaseStatusProvider.latestReceivedWalLocation());        Map<ConfigFileType, String> currentFileStatus = standbyFileSyncService.getCurrentFileStatus();        for (ConfigFileType configFileType : currentFileStatus.keySet()) {            details.put(configFileType.name(), currentFileStatus.get(configFileType));        }        details.put(\"pluginStatus\", standbyPluginStatus());        return details;    }    Map<String, Object> primaryServerDetails() {        Map<String, Object> details = new HashMap<>();        String primaryServerUrl = primaryServerCommunicationService.primaryServerUrl();        details.put(\"url\", primaryServerUrl);        try {            details.put(\"latestDatabaseWalLocation\", primaryServerCommunicationService.latestDatabaseWalLocation());            ServerStatusResponse latestFileStatus = primaryServerCommunicationService.getLatestFileStatus();            details.put(\"configFilesUpdateInterval\", latestFileStatus.getConfigFilesUpdateInterval());            details.put(\"lastConfigUpdateTime\", new Date(latestFileStatus.getLastConfigFilesUpdateTime()));            Map<ConfigFileType, FileDetails> fileDetailsMap = latestFileStatus.getFileDetailsMap();            for (ConfigFileType fileType : fileDetailsMap.keySet()) {                details.put(fileType.name(), fileDetailsMap.get(fileType));            }            details.put(\"pluginStatus\", primaryPluginStatus());        } catch (Exception e) {            details.put(\"error\", format(\"Could not fetch latest file status from master, Reason, %s\", e.getMessage()));        }        return details;    }    private String standbyPluginStatus() {        final Map<String, String> currentExternalPluginsStatus = standbyFileSyncService.getCurrentExternalPluginsStatus();        List<String> pluginsMd5 = currentExternalPluginsStatus.keySet().stream().map(pluginName -> format(\"%s=%s\", pluginName, currentExternalPluginsStatus.get(pluginName))).sorted().collect(Collectors.toList());        return join(pluginsMd5, \", \");    }    private String primaryPluginStatus() {        List<Map> externalPlugins = (List<Map>) primaryServerCommunicationService.getLatestPluginsStatus().get(\"external\");        return externalPlugins.stream().map(map -> format(\"%s=%s\", map.get(\"name\"), map.get(\"md5\"))).collect(Collectors.joining(\", \"));    }}"}
{"code": "import com.thoughtworks.go.CurrentGoCDVersion;import com.thoughtworks.go.server.presentation.html.HtmlElement;import com.thoughtworks.go.server.presentation.html.HtmlRenderable;import com.thoughtworks.go.server.presentation.models.HtmlRenderer;import com.thoughtworks.go.util.json.JsonAware;import java.util.ArrayList;import java.util.List;import java.util.Map;import static com.thoughtworks.go.server.presentation.html.HtmlElement.p;public class DirectoryEntries extends ArrayList<DirectoryEntry> implements HtmlRenderable, JsonAware {    private boolean isArtifactsDeleted;    @Override    public void render(HtmlRenderer renderer) {        if (isArtifactsDeleted || isEmpty()) {            HtmlElement element = p().unsafecontent(\"Artifacts for this job instance are unavailable as they may have been <a href='\" +                    CurrentGoCDVersion.docsUrl(\"configuration/delete_artifacts.html\") +                    \"' target='blank'>purged by Go</a> or deleted externally. \"                    + \"Re-run the stage or job to generate them again.\");            element.render(renderer);        }        for (DirectoryEntry entry : this) {            entry.toHtml().render(renderer);        }    }    @Override    public List<Map<String, Object>> toJson() {        List<Map<String, Object>> jsonList = new ArrayList();        for (DirectoryEntry entry : this) {            jsonList.add(entry.toJson());        }        return jsonList;    }    public boolean isArtifactsDeleted() {        return isArtifactsDeleted;    }    public void setIsArtifactsDeleted(boolean artifactsDeleted) {        isArtifactsDeleted = artifactsDeleted;    }    public FolderDirectoryEntry addFolder(String folderName) {        FolderDirectoryEntry folderDirectoryEntry = new FolderDirectoryEntry(folderName, \"\", new DirectoryEntries());        add(folderDirectoryEntry);        return folderDirectoryEntry;    }    public void addFile(String fileName, String url) {        add(new FileDirectoryEntry(fileName, url));    }}", "nl": "import com.thoughtworks.go.CurrentGoCDVersion;import com.thoughtworks.go.server.presentation.html.HtmlElement;import com.thoughtworks.go.server.presentation.html.HtmlRenderable;import com.thoughtworks.go.server.presentation.models.HtmlRenderer;import com.thoughtworks.go.util.json.JsonAware;import java.util.ArrayList;import java.util.List;import java.util.Map;import static com.thoughtworks.go.server.presentation.html.HtmlElement.p;public class DirectoryEntries extends ArrayList<DirectoryEntry> implements HtmlRenderable, JsonAware {    private boolean isArtifactsDeleted;    @Override    public void render(HtmlRenderer renderer) {        if (isArtifactsDeleted || isEmpty()) {            HtmlElement element = p().content(\"Artifacts for this job instance are unavailable as they may have been <a href='\" +                    CurrentGoCDVersion.docsUrl(\"configuration/delete_artifacts.html\") +                    \"' target='blank'>purged by Go</a> or deleted externally. \"                    + \"Re-run the stage or job to generate them again.\");            element.render(renderer);        }        for (DirectoryEntry entry : this) {            entry.toHtml().render(renderer);        }    }    @Override    public List<Map<String, Object>> toJson() {        List<Map<String, Object>> jsonList = new ArrayList();        for (DirectoryEntry entry : this) {            jsonList.add(entry.toJson());        }        return jsonList;    }    public boolean isArtifactsDeleted() {        return isArtifactsDeleted;    }    public void setIsArtifactsDeleted(boolean artifactsDeleted) {        isArtifactsDeleted = artifactsDeleted;    }    public FolderDirectoryEntry addFolder(String folderName) {        FolderDirectoryEntry folderDirectoryEntry = new FolderDirectoryEntry(folderName, \"\", new DirectoryEntries());        add(folderDirectoryEntry);        return folderDirectoryEntry;    }    public void addFile(String fileName, String url) {        add(new FileDirectoryEntry(fileName, url));    }}"}
{"code": "import com.thoughtworks.go.server.presentation.html.HtmlRenderable;import com.thoughtworks.go.server.presentation.html.HtmlAttribute;import com.thoughtworks.go.server.presentation.html.HtmlElement;public class FileDirectoryEntry extends DirectoryEntry {    public FileDirectoryEntry(String fileName, String url) {        super(fileName, url, \"file\");    }    @Override    protected HtmlRenderable htmlBody() {        return HtmlElement.li().content(            HtmlElement.span(HtmlAttribute.cssClass(\"artifact\")).content(                HtmlElement.a(HtmlAttribute.href(getUrl()))                        .safecontent(getFileName())            )        );    }}", "nl": "import com.thoughtworks.go.server.presentation.html.HtmlRenderable;import com.thoughtworks.go.server.presentation.html.HtmlAttribute;import com.thoughtworks.go.server.presentation.html.HtmlElement;public class FileDirectoryEntry extends DirectoryEntry {    public FileDirectoryEntry(String fileName, String url) {        super(fileName, url, \"file\");    }    @Override    protected HtmlRenderable htmlBody() {        return HtmlElement.li().content(            HtmlElement.span(HtmlAttribute.cssClass(\"artifact\")).content(                HtmlElement.a(HtmlAttribute.href(getUrl()))                        .content(getFileName())            )        );    }}"}
{"code": "import com.thoughtworks.go.server.presentation.html.HtmlElement;import com.thoughtworks.go.server.presentation.html.HtmlRenderable;import java.util.Map;import static com.thoughtworks.go.server.presentation.html.HtmlAttribute.*;import static com.thoughtworks.go.server.presentation.html.ListedElements.sequence;public class FolderDirectoryEntry extends DirectoryEntry {    private final DirectoryEntries subDirectory;    public FolderDirectoryEntry(String fileName, String url, DirectoryEntries subDirectory) {        super(fileName, url, \"folder\");        this.subDirectory = subDirectory;    }    public DirectoryEntries getSubDirectory() {        return subDirectory;    }    @Override    protected HtmlRenderable htmlBody() {        return sequence(                HtmlElement.div(cssClass(\"dir-container\")).content(                    HtmlElement.span(cssClass(\"directory\")).content(                        HtmlElement.a(onclick(\"BuildDetail.tree_navigator(this)\"))                                .safecontent(getFileName())                    )                ),                HtmlElement.div(cssClass(\"subdir-container\"), style(\"display:none\"))                        .content(subDirectory)        );    }    @Override    public Map<String, Object> toJson() {        Map json = super.toJson();        json.put(\"files\", subDirectory.toJson());        return json;    }    public void addFile(String fileName, String url) {        subDirectory.addFile(fileName, url);    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        FolderDirectoryEntry that = (FolderDirectoryEntry) o;        if (!subDirectory.equals(that.subDirectory)) return false;        return true;    }    @Override    public int hashCode() {        return subDirectory.hashCode();    }}", "nl": "import com.thoughtworks.go.server.presentation.html.HtmlElement;import com.thoughtworks.go.server.presentation.html.HtmlRenderable;import java.util.Map;import static com.thoughtworks.go.server.presentation.html.HtmlAttribute.*;import static com.thoughtworks.go.server.presentation.html.ListedElements.sequence;public class FolderDirectoryEntry extends DirectoryEntry {    private final DirectoryEntries subDirectory;    public FolderDirectoryEntry(String fileName, String url, DirectoryEntries subDirectory) {        super(fileName, url, \"folder\");        this.subDirectory = subDirectory;    }    public DirectoryEntries getSubDirectory() {        return subDirectory;    }    @Override    protected HtmlRenderable htmlBody() {        return sequence(                HtmlElement.div(cssClass(\"dir-container\")).content(                    HtmlElement.span(cssClass(\"directory\")).content(                        HtmlElement.a(onclick(\"BuildDetail.tree_navigator(this)\"))                                .content(getFileName())                    )                ),                HtmlElement.div(cssClass(\"subdir-container\"), style(\"display:none\"))                        .content(subDirectory)        );    }    @Override    public Map<String, Object> toJson() {        Map json = super.toJson();        json.put(\"files\", subDirectory.toJson());        return json;    }    public void addFile(String fileName, String url) {        subDirectory.addFile(fileName, url);    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        FolderDirectoryEntry that = (FolderDirectoryEntry) o;        if (!subDirectory.equals(that.subDirectory)) return false;        return true;    }    @Override    public int hashCode() {        return subDirectory.hashCode();    }}"}
{"code": "import java.util.ArrayList;import java.util.List;import com.thoughtworks.go.server.presentation.models.HtmlRenderer;import org.apache.commons.text.StringEscapeUtils;public class HtmlElement implements HtmlRenderable {    public static HtmlElement div(HtmlAttribute... attributes) { return new HtmlElement(\"div\", attributes); }    public static HtmlElement span(HtmlAttribute... attributes) { return new HtmlElement(\"span\", attributes); }    public static HtmlElement a(HtmlAttribute... attributes) { return new HtmlElement(\"a\", attributes); }    public static HtmlElement p(HtmlAttribute... attributes) { return new HtmlElement(\"p\", attributes); }    public static HtmlElement ul(HtmlAttribute... attributes) { return new HtmlElement(\"ul\", attributes); }    public static HtmlElement li(HtmlAttribute... attributes) { return new HtmlElement(\"li\", attributes); }    private final String elementName;    private final HtmlAttribute[] attributes;    private final List<HtmlRenderable> elements = new ArrayList<>();    private HtmlElement(String elementName, HtmlAttribute... attributes) {        this.elementName = elementName;        this.attributes = attributes;    }    public HtmlElement unsafecontent(String body) {        return content(new TextElement(body));    }    public HtmlElement safecontent(String body) {        return content(new TextElement(StringEscapeUtils.escapeHtml4(body)));    }    public HtmlElement content(HtmlRenderable... elements) {        for (HtmlRenderable element : elements) {            addToBody(element);        }        return this;    }    public HtmlElement content(List<? extends Htmlable> htmlables) {        for (Htmlable htmlable : htmlables) {            addToBody(htmlable.toHtml());        }        return this;    }    public HtmlElement addToBody(HtmlRenderable element) {        this.elements.add(element);        return this;    }    @Override    public void render(HtmlRenderer renderer) {        renderer.append(\"<\" + elementName);        for (HtmlAttribute attribute : attributes) {            attribute.render(renderer);        }        if (elements.isEmpty()) {            renderer.append(\" />\\n\");        } else {            renderer.append(\">\\n\");            for (HtmlRenderable element : elements) {                element.render(renderer);            }            renderer.append(\"</\" + elementName + \">\\n\");        }    }}", "nl": "import java.util.ArrayList;import java.util.List;import com.thoughtworks.go.server.presentation.models.HtmlRenderer;public class HtmlElement implements HtmlRenderable {    public static HtmlElement div(HtmlAttribute... attributes) { return new HtmlElement(\"div\", attributes); }    public static HtmlElement span(HtmlAttribute... attributes) { return new HtmlElement(\"span\", attributes); }    public static HtmlElement a(HtmlAttribute... attributes) { return new HtmlElement(\"a\", attributes); }    public static HtmlElement p(HtmlAttribute... attributes) { return new HtmlElement(\"p\", attributes); }    public static HtmlElement ul(HtmlAttribute... attributes) { return new HtmlElement(\"ul\", attributes); }    public static HtmlElement li(HtmlAttribute... attributes) { return new HtmlElement(\"li\", attributes); }    private final String elementName;    private final HtmlAttribute[] attributes;    private final List<HtmlRenderable> elements = new ArrayList<>();    private HtmlElement(String elementName, HtmlAttribute... attributes) {        this.elementName = elementName;        this.attributes = attributes;    }    public HtmlElement content(String body) {        return content(new TextElement(body));    }    public HtmlElement content(HtmlRenderable... elements) {        for (HtmlRenderable element : elements) {            addToBody(element);        }        return this;    }    public HtmlElement content(List<? extends Htmlable> htmlables) {        for (Htmlable htmlable : htmlables) {            addToBody(htmlable.toHtml());        }        return this;    }    public HtmlElement addToBody(HtmlRenderable element) {        this.elements.add(element);        return this;    }    @Override    public void render(HtmlRenderer renderer) {        renderer.append(\"<\" + elementName);        for (HtmlAttribute attribute : attributes) {            attribute.render(renderer);        }        if (elements.isEmpty()) {            renderer.append(\" />\\n\");        } else {            renderer.append(\">\\n\");            for (HtmlRenderable element : elements) {                element.render(renderer);            }            renderer.append(\"</\" + elementName + \">\\n\");        }    }}"}
{"code": "import com.thoughtworks.go.server.presentation.models.HtmlRenderer;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;class FileDirectoryEntryTest {    @Test    void shouldEscapeFilename() {        FileDirectoryEntry entry = new FileDirectoryEntry(\"<div>Hello</div>\", \"https:        HtmlRenderer renderer = new HtmlRenderer(\"\");        entry.htmlBody().render(renderer);        assertTrue(renderer.asString().contains(\"&lt;div&gt;Hello&lt;/div&gt;\"));        assertFalse(renderer.asString().contains(\"<div>Hello</div>\"));    }}", "nl": ""}
{"code": "import com.thoughtworks.go.server.presentation.models.HtmlRenderer;import org.junit.jupiter.api.Test;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;public class FolderDirectoryEntryTest {    @Test    public void shouldAddFile() throws Exception {        DirectoryEntries subDirectory = new DirectoryEntries();        FolderDirectoryEntry entry = new FolderDirectoryEntry(\"file\", \"url\", subDirectory);        entry.addFile(\"file\", \"path\");        assertThat(subDirectory, hasItem(new FileDirectoryEntry(\"file\", \"path\")));    }    @Test    public void shouldEscapeFolderName() throws Exception {        DirectoryEntries subDirectory = new DirectoryEntries();        FolderDirectoryEntry entry = new FolderDirectoryEntry(\"<div>Hello</div>\", \"url\", subDirectory);        HtmlRenderer renderer = new HtmlRenderer(\"\");        entry.htmlBody().render(renderer);        assertThat(renderer.asString(), containsString(\"&lt;div&gt;Hello&lt;/div&gt;\"));        assertThat(renderer.asString(), not(containsString(\"<div>Hello</div>\")));    }}", "nl": "import org.junit.jupiter.api.Test;import static org.hamcrest.Matchers.hasItem;import static org.hamcrest.MatcherAssert.assertThat;public class FolderDirectoryEntryTest {    @Test    public void shouldAddFile() throws Exception {        DirectoryEntries subDirectory = new DirectoryEntries();        FolderDirectoryEntry entry = new FolderDirectoryEntry(\"file\", \"url\", subDirectory);        entry.addFile(\"file\", \"path\");        assertThat(subDirectory, hasItem(new FileDirectoryEntry(\"file\", \"path\")));    }}"}
{"code": "import com.thoughtworks.go.server.presentation.models.HtmlRenderer;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;class HtmlElementTest {    @Test    void shouldEscapeContent() {        HtmlElement element = HtmlElement.span().safecontent(\"<div>Hello</div>\");        HtmlRenderer renderer = new HtmlRenderer(\"\");        element.render(renderer);        assertEquals(\"<span>\\n&lt;div&gt;Hello&lt;/div&gt;\\n</span>\\n\", renderer.asString());    }}", "nl": ""}
{"code": "import com.thoughtworks.go.domain.ConsoleConsumer;import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.domain.exception.IllegalArtifactLocationException;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.security.HeaderConstraint;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.util.ErrorHandler;import com.thoughtworks.go.server.view.artifacts.ArtifactsView;import com.thoughtworks.go.server.view.artifacts.LocalArtifactsView;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.FileModelAndView;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.ArtifactLogUtil;import com.thoughtworks.go.util.SystemEnvironment;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.server.web.ZipArtifactFolderViewFactory.zipViewFactory;import static com.thoughtworks.go.util.ArtifactLogUtil.isConsoleOutput;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;@Controllerpublic class ArtifactsController {    private static final Logger LOGGER = LoggerFactory.getLogger(ArtifactsController.class);    private final JobInstanceDao jobInstanceDao;    private final ConsoleActivityMonitor consoleActivityMonitor;    private final ArtifactFolderViewFactory folderViewFactory;    private final ArtifactFolderViewFactory jsonViewFactory;    private final ArtifactFolderViewFactory zipViewFactory;    private final Charset consoleLogCharset;    private ArtifactsService artifactsService;    private RestfulService restfulService;    private ConsoleService consoleService;    private HeaderConstraint headerConstraint;    @Autowired    ArtifactsController(ArtifactsService artifactsService, RestfulService restfulService, ZipArtifactCache zipArtifactCache, JobInstanceDao jobInstanceDao,                        ConsoleActivityMonitor consoleActivityMonitor, ConsoleService consoleService, SystemEnvironment systemEnvironment) {        this.artifactsService = artifactsService;        this.restfulService = restfulService;        this.jobInstanceDao = jobInstanceDao;        this.consoleActivityMonitor = consoleActivityMonitor;        this.consoleService = consoleService;        this.folderViewFactory = FileModelAndView.htmlViewFactory();        this.jsonViewFactory = FileModelAndView.jsonViewfactory();        this.zipViewFactory = zipViewFactory(zipArtifactCache);        this.headerConstraint = new HeaderConstraint(systemEnvironment);        this.consoleLogCharset = systemEnvironment.consoleLogCharsetAsCharset();    }    @RequestMapping(value = \"/repository/restful/artifact/GET/html\", method = RequestMethod.GET)    public ModelAndView getArtifactAsHtml(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha,                                          @RequestParam(value = \"serverAlias\", required = false) String serverAlias) throws Exception {        return getArtifact(filePath, folderViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, serverAlias);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/json\", method = RequestMethod.GET)    public ModelAndView getArtifactAsJson(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        return getArtifact(filePath, jsonViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/zip\", method = RequestMethod.GET)    public ModelAndView getArtifactAsZip(@RequestParam(\"pipelineName\") String pipelineName,                                         @RequestParam(\"pipelineCounter\") String pipelineCounter,                                         @RequestParam(\"stageName\") String stageName,                                         @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                         @RequestParam(\"buildName\") String buildName,                                         @RequestParam(\"filePath\") String filePath,                                         @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        if (filePath.equals(\".zip\")) {            filePath = \"./.zip\";        }        return getArtifact(filePath, zipViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET    @RequestMapping(value = \"consoleout.json\", method = RequestMethod.GET)    public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName,                                   @RequestParam(\"pipelineCounter\") String pipelineCounter,                                   @RequestParam(\"stageName\") String stageName,                                   @RequestParam(\"buildName\") String buildName,                                   @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                   @RequestParam(value = \"startLineNumber\", required = false) Long start    ) {        start = start == null ? 0L : start;        try {            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {                return logsNotFound(identifier);            }            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));        } catch (Exception e) {            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);        }    }    @ErrorHandler    public ModelAndView handleError(HttpServletRequest request, HttpServletResponse response, Exception e) {        LOGGER.error(\"Error loading artifacts: \", e);        Map model = new HashMap();        model.put(ERROR_FOR_PAGE, \"Artifact does not exist.\");        return new ModelAndView(\"exceptions_page\", model);    }    ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);        long before = System.currentTimeMillis();        ArtifactsView view;        JobIdentifier translatedId;        try {            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        } catch (Exception e) {            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        }        if (filePath.contains(\"..\")) {            return FileModelAndView.forbiddenUrl(filePath);        }        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);        ModelAndView createdView = view.createView(filePath, sha);        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);        return createdView;    }    private boolean shouldUnzipStream(MultipartFile multipartFile) {        return multipartFile.getName().equals(ZIP_MULTIPART_FILENAME);    }    private MultipartFile multipartFile(MultipartHttpServletRequest request) {        MultipartFile multipartFile = request.getFile(REGULAR_MULTIPART_FILENAME);        if (multipartFile == null) {            multipartFile = request.getFile(ZIP_MULTIPART_FILENAME);        }        return multipartFile;    }    private MultipartFile getChecksumFile(MultipartHttpServletRequest request) {        return request.getFile(CHECKSUM_MULTIPART_FILENAME);    }    private ModelAndView putConsoleOutput(final JobIdentifier jobIdentifier, final InputStream inputStream) throws Exception {        File consoleLogFile = consoleService.consoleLogFile(jobIdentifier);        boolean updated = consoleService.updateConsoleLog(consoleLogFile, inputStream);        if (updated) {            consoleActivityMonitor.consoleUpdatedFor(jobIdentifier);            return FileModelAndView.fileAppended(consoleLogFile.getPath());        } else {            return FileModelAndView.errorSavingFile(consoleLogFile.getPath());        }    }    private ModelAndView putArtifact(JobIdentifier jobIdentifier, String filePath,                                     InputStream inputStream) throws Exception {        File artifact = artifactsService.findArtifact(jobIdentifier, filePath);        if (artifactsService.saveOrAppendFile(artifact, inputStream)) {            return FileModelAndView.fileAppended(filePath);        } else {            return FileModelAndView.errorSavingFile(filePath);        }    }    private ModelAndView buildNotFound(String pipelineName, String counterOrLabel, String stageName,                                       String stageCounter,                                       String buildName) {        return ResponseCodeView.create(SC_NOT_FOUND, String.format(\"Job %s/%s/%s/%s/%s not found.\", pipelineName,                counterOrLabel, stageName, stageCounter, buildName));    }    private ModelAndView logsNotFound(JobIdentifier identifier) {        String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());        return ResponseCodeView.create(SC_NOT_FOUND, notFound);    }    private boolean isValidStageCounter(String stageCounter) {        if (StringUtils.isEmpty(stageCounter)) {            return true;        }        try {            int value = Integer.parseInt(stageCounter);            return value > 0;        } catch (Exception e) {            return false;        }    }}", "nl": "import com.thoughtworks.go.domain.ConsoleConsumer;import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.domain.exception.IllegalArtifactLocationException;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.security.HeaderConstraint;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.util.ErrorHandler;import com.thoughtworks.go.server.view.artifacts.ArtifactsView;import com.thoughtworks.go.server.view.artifacts.LocalArtifactsView;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.FileModelAndView;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.ArtifactLogUtil;import com.thoughtworks.go.util.SystemEnvironment;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.server.web.ZipArtifactFolderViewFactory.zipViewFactory;import static com.thoughtworks.go.util.ArtifactLogUtil.isConsoleOutput;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;@Controllerpublic class ArtifactsController {    private static final Logger LOGGER = LoggerFactory.getLogger(ArtifactsController.class);    private final JobInstanceDao jobInstanceDao;    private final ConsoleActivityMonitor consoleActivityMonitor;    private final ArtifactFolderViewFactory folderViewFactory;    private final ArtifactFolderViewFactory jsonViewFactory;    private final ArtifactFolderViewFactory zipViewFactory;    private final Charset consoleLogCharset;    private ArtifactsService artifactsService;    private RestfulService restfulService;    private ConsoleService consoleService;    private HeaderConstraint headerConstraint;    @Autowired    ArtifactsController(ArtifactsService artifactsService, RestfulService restfulService, ZipArtifactCache zipArtifactCache, JobInstanceDao jobInstanceDao,                        ConsoleActivityMonitor consoleActivityMonitor, ConsoleService consoleService, SystemEnvironment systemEnvironment) {        this.artifactsService = artifactsService;        this.restfulService = restfulService;        this.jobInstanceDao = jobInstanceDao;        this.consoleActivityMonitor = consoleActivityMonitor;        this.consoleService = consoleService;        this.folderViewFactory = FileModelAndView.htmlViewFactory();        this.jsonViewFactory = FileModelAndView.jsonViewfactory();        this.zipViewFactory = zipViewFactory(zipArtifactCache);        this.headerConstraint = new HeaderConstraint(systemEnvironment);        this.consoleLogCharset = systemEnvironment.consoleLogCharsetAsCharset();    }    @RequestMapping(value = \"/repository/restful/artifact/GET/html\", method = RequestMethod.GET)    public ModelAndView getArtifactAsHtml(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha,                                          @RequestParam(value = \"serverAlias\", required = false) String serverAlias) throws Exception {        return getArtifact(filePath, folderViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, serverAlias);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/json\", method = RequestMethod.GET)    public ModelAndView getArtifactAsJson(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        return getArtifact(filePath, jsonViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/zip\", method = RequestMethod.GET)    public ModelAndView getArtifactAsZip(@RequestParam(\"pipelineName\") String pipelineName,                                         @RequestParam(\"pipelineCounter\") String pipelineCounter,                                         @RequestParam(\"stageName\") String stageName,                                         @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                         @RequestParam(\"buildName\") String buildName,                                         @RequestParam(\"filePath\") String filePath,                                         @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        if (filePath.equals(\".zip\")) {            filePath = \"./.zip\";        }        return getArtifact(filePath, zipViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET    @RequestMapping(value = \"consoleout.json\", method = RequestMethod.GET)    public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName,                                   @RequestParam(\"pipelineCounter\") String pipelineCounter,                                   @RequestParam(\"stageName\") String stageName,                                   @RequestParam(\"buildName\") String buildName,                                   @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                   @RequestParam(value = \"startLineNumber\", required = false) Long start    ) {        start = start == null ? 0L : start;        try {            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {                return logsNotFound(identifier);            }            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));        } catch (Exception e) {            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);        }    }    @ErrorHandler    public ModelAndView handleError(HttpServletRequest request, HttpServletResponse response, Exception e) {        LOGGER.error(\"Error loading artifacts: \", e);        Map model = new HashMap();        model.put(ERROR_FOR_PAGE, \"Artifact does not exist.\");        return new ModelAndView(\"exceptions_page\", model);    }    ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);        long before = System.currentTimeMillis();        ArtifactsView view;        JobIdentifier translatedId;        try {            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        } catch (Exception e) {            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        }        if (filePath.contains(\"..\")) {            return FileModelAndView.forbiddenUrl(filePath);        }        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);        ModelAndView createdView = view.createView(filePath, sha);        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);        return createdView;    }    private boolean shouldUnzipStream(MultipartFile multipartFile) {        return multipartFile.getName().equals(ZIP_MULTIPART_FILENAME);    }    private MultipartFile multipartFile(MultipartHttpServletRequest request) {        MultipartFile multipartFile = request.getFile(REGULAR_MULTIPART_FILENAME);        if (multipartFile == null) {            multipartFile = request.getFile(ZIP_MULTIPART_FILENAME);        }        return multipartFile;    }    private MultipartFile getChecksumFile(MultipartHttpServletRequest request) {        return request.getFile(CHECKSUM_MULTIPART_FILENAME);    }    private ModelAndView putConsoleOutput(final JobIdentifier jobIdentifier, final InputStream inputStream) throws Exception {        File consoleLogFile = consoleService.consoleLogFile(jobIdentifier);        boolean updated = consoleService.updateConsoleLog(consoleLogFile, inputStream);        if (updated) {            consoleActivityMonitor.consoleUpdatedFor(jobIdentifier);            return FileModelAndView.fileAppended(consoleLogFile.getPath());        } else {            return FileModelAndView.errorSavingFile(consoleLogFile.getPath());        }    }    private ModelAndView putArtifact(JobIdentifier jobIdentifier, String filePath,                                     InputStream inputStream) throws Exception {        File artifact = artifactsService.findArtifact(jobIdentifier, filePath);        if (artifactsService.saveOrAppendFile(artifact, inputStream)) {            return FileModelAndView.fileAppended(filePath);        } else {            return FileModelAndView.errorSavingFile(filePath);        }    }    private ModelAndView buildNotFound(String pipelineName, String counterOrLabel, String stageName,                                       String stageCounter,                                       String buildName) {        return ResponseCodeView.create(SC_NOT_FOUND, String.format(\"Job %s/%s/%s/%s/%s not found.\", pipelineName,                counterOrLabel, stageName, stageCounter, buildName));    }    private ModelAndView logsNotFound(JobIdentifier identifier) {        String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());        return ResponseCodeView.create(SC_NOT_FOUND, notFound);    }}"}
{"code": "import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.SystemEnvironment;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.mock.web.MockMultipartFile;import org.springframework.mock.web.MockMultipartHttpServletRequest;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.InputStream;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;import static org.hamcrest.Matchers.*;import static org.hamcrest.MatcherAssert.assertThat;import static org.mockito.Mockito.any;import static org.mockito.Mockito.*;public class ArtifactsControllerTest {    private ArtifactsController artifactsController;    private MockHttpServletRequest request;    private ConsoleActivityMonitor consoleActivityMonitor;    private RestfulService restfulService;    private ArtifactsService artifactService;    private ConsoleService consoleService;    private SystemEnvironment systemEnvironment;    private JobInstanceDao jobInstanceDao;    @BeforeEach    public void setUp() {        consoleActivityMonitor = mock(ConsoleActivityMonitor.class);        restfulService = mock(RestfulService.class);        artifactService = mock(ArtifactsService.class);        consoleService = mock(ConsoleService.class);        jobInstanceDao = mock(JobInstanceDao.class);        systemEnvironment = mock(SystemEnvironment.class);        artifactsController = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment);        request = new MockHttpServletRequest();    }    @Test    public void shouldUpdateLastConsoleActivityOnConsoleLogPut() throws Exception {        String content = \"Testing:\";        request.setContent(content.getBytes());        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l)).thenReturn(jobIdentifier);        String path = \"cruise-output/console.log\";        File artifactFile = new File(\"junk\");        when(consoleService.consoleLogFile(jobIdentifier)).thenReturn(artifactFile);        when(consoleService.updateConsoleLog(eq(artifactFile), any(InputStream.class))).thenReturn(true);        assertThat(((ResponseCodeView) artifactsController.putArtifact(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l, path, \"agent-id\", request).getView()).getStatusCode(), is(HttpServletResponse.SC_OK));        verify(consoleActivityMonitor).consoleUpdatedFor(jobIdentifier);    }    @Test    public void testConsoleOutShouldReturnErrorWhenJobHasBeenCompletedAndLogsNotFound() throws Exception {        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\")).thenReturn(jobIdentifier);        when(jobInstanceDao.isJobCompleted(jobIdentifier)).thenReturn(true);        when(consoleService.doesLogExist(jobIdentifier)).thenReturn(false);        ModelAndView view = artifactsController.consoleout(\"pipeline\", \"10\", \"stage\", \"build\", \"2\", 1L);        assertThat(view.getView().getContentType(), is(RESPONSE_CHARSET));        assertThat(view.getView(), is(instanceOf((ResponseCodeView.class))));        assertThat(((ResponseCodeView) view.getView()).getContent(), containsString(\"Console log for Build [pipeline/10/stage/2/build/103] is unavailable as it may have been purged by Go or deleted externally\"));    }    @Test    public void shouldReturnHttpErrorCodeWhenChecksumFileSaveFails() throws Exception {        File artifactFile = new File(\"junk\");        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline-1\", 1, \"1\", \"stage-1\", \"2\", \"job-1\", 122l);        when(restfulService.findJob(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122l)).thenReturn(jobIdentifier);        when(artifactService.findArtifact(any(JobIdentifier.class), eq(\"some-path\"))).thenReturn(artifactFile);        when(artifactService.saveFile(any(File.class), any(InputStream.class), eq(false), eq(1))).thenReturn(true);        when(artifactService.saveOrAppendFile(any(File.class), any(InputStream.class))).thenReturn(false);        MockMultipartHttpServletRequest mockMultipartHttpServletRequest = new MockMultipartHttpServletRequest();        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(REGULAR_MULTIPART_FILENAME, \"content\".getBytes()));        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(CHECKSUM_MULTIPART_FILENAME, \"checksum-content\".getBytes()));        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122L, \"some-path\", 1, mockMultipartHttpServletRequest);        ResponseCodeView view = (ResponseCodeView) modelAndView.getView();        assertThat(view.getStatusCode(), is(SC_INTERNAL_SERVER_ERROR));        assertThat(view.getContent(), is(\"Error saving checksum file for the artifact at path 'some-path'\"));    }    @Test    void shouldFailToPostAndPutWhenStageCounterIsNotAPositiveInteger() throws Exception {        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", 1, null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", 1, null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", \"1\", null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", \"1\", null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));    }    @Test    public void shouldFunnelAll_GET_calls() throws Exception {        final ModelAndView returnVal = new ModelAndView();        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {            @Override            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,                                     String buildName, String sha, String serverAlias) throws Exception {                return returnVal;            }        };        assertThat(controller.getArtifactAsHtml(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\", null), sameInstance(returnVal));        assertThat(controller.getArtifactAsZip(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));        assertThat(controller.getArtifactAsJson(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));    }    @Test    public void shouldReturnBadRequestIfRequiredHeadersAreMissingOnACreateArtifactRequest() throws Exception {        MultipartHttpServletRequest multipartHttpServletRequest = new MockMultipartHttpServletRequest();        when(systemEnvironment.isApiSafeModeEnabled()).thenReturn(true);        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline\", \"invalid-label\", \"stage\", \"stage-counter\", \"job-name\", 3L, \"file-path\", 3, multipartHttpServletRequest);        ResponseCodeView codeView = (ResponseCodeView) modelAndView.getView();        assertThat(codeView.getStatusCode(), is(HttpServletResponse.SC_BAD_REQUEST));        assertThat(codeView.getContent(), is(\"Missing required header 'Confirm'\"));    }}", "nl": "import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.SystemEnvironment;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.mock.web.MockMultipartFile;import org.springframework.mock.web.MockMultipartHttpServletRequest;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.InputStream;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;import static org.hamcrest.Matchers.*;import static org.hamcrest.MatcherAssert.assertThat;import static org.mockito.Mockito.any;import static org.mockito.Mockito.*;public class ArtifactsControllerTest {    private ArtifactsController artifactsController;    private MockHttpServletRequest request;    private ConsoleActivityMonitor consoleActivityMonitor;    private RestfulService restfulService;    private ArtifactsService artifactService;    private ConsoleService consoleService;    private SystemEnvironment systemEnvironment;    private JobInstanceDao jobInstanceDao;    @BeforeEach    public void setUp() {        consoleActivityMonitor = mock(ConsoleActivityMonitor.class);        restfulService = mock(RestfulService.class);        artifactService = mock(ArtifactsService.class);        consoleService = mock(ConsoleService.class);        jobInstanceDao = mock(JobInstanceDao.class);        systemEnvironment = mock(SystemEnvironment.class);        artifactsController = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment);        request = new MockHttpServletRequest();    }    @Test    public void shouldUpdateLastConsoleActivityOnConsoleLogPut() throws Exception {        String content = \"Testing:\";        request.setContent(content.getBytes());        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l)).thenReturn(jobIdentifier);        String path = \"cruise-output/console.log\";        File artifactFile = new File(\"junk\");        when(consoleService.consoleLogFile(jobIdentifier)).thenReturn(artifactFile);        when(consoleService.updateConsoleLog(eq(artifactFile), any(InputStream.class))).thenReturn(true);        assertThat(((ResponseCodeView) artifactsController.putArtifact(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l, path, \"agent-id\", request).getView()).getStatusCode(), is(HttpServletResponse.SC_OK));        verify(consoleActivityMonitor).consoleUpdatedFor(jobIdentifier);    }    @Test    public void testConsoleOutShouldReturnErrorWhenJobHasBeenCompletedAndLogsNotFound() throws Exception {        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\")).thenReturn(jobIdentifier);        when(jobInstanceDao.isJobCompleted(jobIdentifier)).thenReturn(true);        when(consoleService.doesLogExist(jobIdentifier)).thenReturn(false);        ModelAndView view = artifactsController.consoleout(\"pipeline\", \"10\", \"stage\", \"build\", \"2\", 1L);        assertThat(view.getView().getContentType(), is(RESPONSE_CHARSET));        assertThat(view.getView(), is(instanceOf((ResponseCodeView.class))));        assertThat(((ResponseCodeView) view.getView()).getContent(), containsString(\"Console log for Build [pipeline/10/stage/2/build/103] is unavailable as it may have been purged by Go or deleted externally\"));    }    @Test    public void shouldReturnHttpErrorCodeWhenChecksumFileSaveFails() throws Exception {        File artifactFile = new File(\"junk\");        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline-1\", 1, \"1\", \"stage-1\", \"2\", \"job-1\", 122l);        when(restfulService.findJob(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122l)).thenReturn(jobIdentifier);        when(artifactService.findArtifact(any(JobIdentifier.class), eq(\"some-path\"))).thenReturn(artifactFile);        when(artifactService.saveFile(any(File.class), any(InputStream.class), eq(false), eq(1))).thenReturn(true);        when(artifactService.saveOrAppendFile(any(File.class), any(InputStream.class))).thenReturn(false);        MockMultipartHttpServletRequest mockMultipartHttpServletRequest = new MockMultipartHttpServletRequest();        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(REGULAR_MULTIPART_FILENAME, \"content\".getBytes()));        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(CHECKSUM_MULTIPART_FILENAME, \"checksum-content\".getBytes()));        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122L, \"some-path\", 1, mockMultipartHttpServletRequest);        ResponseCodeView view = (ResponseCodeView) modelAndView.getView();        assertThat(view.getStatusCode(), is(SC_INTERNAL_SERVER_ERROR));        assertThat(view.getContent(), is(\"Error saving checksum file for the artifact at path 'some-path'\"));    }    @Test    public void shouldFunnelAll_GET_calls() throws Exception {        final ModelAndView returnVal = new ModelAndView();        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {            @Override            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,                                     String buildName, String sha, String serverAlias) throws Exception {                return returnVal;            }        };        assertThat(controller.getArtifactAsHtml(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\", null), sameInstance(returnVal));        assertThat(controller.getArtifactAsZip(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));        assertThat(controller.getArtifactAsJson(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));    }    @Test    public void shouldReturnBadRequestIfRequiredHeadersAreMissingOnACreateArtifactRequest() throws Exception {        MultipartHttpServletRequest multipartHttpServletRequest = new MockMultipartHttpServletRequest();        when(systemEnvironment.isApiSafeModeEnabled()).thenReturn(true);        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline\", \"invalid-label\", \"stage\", \"stage-counter\", \"job-name\", 3L, \"file-path\", 3, multipartHttpServletRequest);        ResponseCodeView codeView = (ResponseCodeView) modelAndView.getView();        assertThat(codeView.getStatusCode(), is(HttpServletResponse.SC_BAD_REQUEST));        assertThat(codeView.getContent(), is(\"Missing required header 'Confirm'\"));    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.preprocessor.SkipParameterResolution;import com.thoughtworks.go.config.validation.FilePathTypeValidator;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.FilenameUtil;import com.thoughtworks.go.util.command.UrlArgument;import com.thoughtworks.go.util.command.UrlUserInfo;import javax.annotation.PostConstruct;import java.io.File;import java.util.Map;import static com.thoughtworks.go.util.ExceptionUtils.bomb;import static java.lang.String.format;import static org.apache.commons.lang3.StringUtils.*;public abstract class ScmMaterialConfig extends AbstractMaterialConfig implements ParamsAttributeAware {    public static final String URL = \"url\";    public static final String USERNAME = \"username\";    protected GoCipher goCipher;    @ConfigSubtag    private Filter filter;    @ConfigAttribute(value = \"invertFilter\", optional = true)    private boolean invertFilter = false;    @ConfigAttribute(value = \"dest\", allowNull = true)    protected String folder;    @ConfigAttribute(value = \"autoUpdate\", optional = true)    private boolean autoUpdate = true;    @ConfigAttribute(value = \"username\", allowNull = true)    protected String userName;    @SkipParameterResolution    @ConfigAttribute(value = \"password\", allowNull = true)    protected String password;    @ConfigAttribute(value = \"encryptedPassword\", allowNull = true)    protected String encryptedPassword;    public static final String PASSWORD = \"password\";    public static final String ENCRYPTED_PASSWORD = \"encryptedPassword\";    public static final String PASSWORD_CHANGED = \"passwordChanged\";    public static final String AUTO_UPDATE = \"autoUpdate\";    public static final String FOLDER = \"folder\";    public static final String FILTER = \"filterAsString\";    public static final String INVERT_FILTER = \"invertFilter\";    public ScmMaterialConfig(String typeName) {        super(typeName);        this.goCipher = new GoCipher();    }    @Override    protected void appendPipelineUniqueCriteria(Map<String, Object> basicCriteria) {        basicCriteria.put(\"dest\", folder);    }    public File workingdir(File baseFolder) {        if (getFolder() == null) {            return baseFolder;        }        return new File(baseFolder, getFolder());    }    @Override    public boolean matches(String name, String regex) {        if (regex.startsWith(\"/\")) {            regex = regex.substring(1);        }        return name.matches(regex);    }    public final GoCipher getGoCipher() {        return goCipher;    }    public final void setUserName(String userName) {        this.userName = userName;    }    public final String getUserName() {        return userName;    }    @Deprecated    public String getUsername() {        return getUserName();    }    public final String getPassword() {        return currentPassword();    }    public final void setPassword(String password) {        resetPassword(password);    }    protected void resetPassword(String passwordToSet) {        if (isBlank(passwordToSet)) {            encryptedPassword = null;        }        setPasswordIfNotBlank(passwordToSet);    }    @PostConstruct    public final void ensureEncrypted() {        this.userName = stripToNull(this.userName);        setPasswordIfNotBlank(password);    }    private void setPasswordIfNotBlank(String password) {        this.password = stripToNull(password);        this.encryptedPassword = stripToNull(encryptedPassword);        if (this.password == null) {            return;        }        try {            this.encryptedPassword = this.goCipher.encrypt(password);        } catch (Exception e) {            bomb(\"Password encryption failed. Please verify your cipher key.\", e);        }        this.password = null;    }    public final String currentPassword() {        try {            return isBlank(encryptedPassword) ? null : this.goCipher.decrypt(encryptedPassword);        } catch (Exception e) {            throw new RuntimeException(\"Could not decrypt the password to get the real password\", e);        }    }    public final void setEncryptedPassword(String encryptedPassword) {        this.encryptedPassword = encryptedPassword;    }    public final String getEncryptedPassword() {        return encryptedPassword;    }    public abstract boolean isCheckExternals();    public abstract String getUrl();    public abstract void setUrl(String url);    protected abstract String getLocation();    @Override    public Filter filter() {        if (filter == null) {            return new Filter();        }        return filter;    }    public String getFilterAsString() {        return filter().getStringForDisplay();    }    public Filter rawFilter() {        return filter;    }    public void setFilter(Filter filter) {        this.filter = filter;    }    @Override    public boolean isInvertFilter() {        return invertFilter;    }    public boolean getInvertFilter() {        return invertFilter;    }    public void setInvertFilter(boolean value) {        invertFilter = value;    }    @Override    public String getDescription() {        return getUriForDisplay();    }    @Override    public abstract String getUriForDisplay();    @Override    public String getFolder() {        return folder;    }    @Override    public String getDisplayName() {        return name == null ? getUriForDisplay() : CaseInsensitiveString.str(name);    }    @Override    public boolean isAutoUpdate() {        return autoUpdate;    }    public boolean getAutoUpdate() {        return autoUpdate;    }    @Override    public void setAutoUpdate(boolean value) {        autoUpdate = value;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        if (!super.equals(o)) {            return false;        }        ScmMaterialConfig that = (ScmMaterialConfig) o;        if (folder != null ? !folder.equals(that.folder) : that.folder != null) {            return false;        }        return super.equals(that);    }    @Override    public int hashCode() {        int result = super.hashCode();        result = 31 * result + (folder != null ? folder.hashCode() : 0);        return result;    }    @Override    protected final void validateConcreteMaterial(ValidationContext validationContext) {        validateNotOutsideSandbox();        validateDestFolderPath();        validateConcreteScmMaterial(validationContext);    }    public abstract void validateConcreteScmMaterial(ValidationContext validationContext);    private void validateDestFolderPath() {        if (isBlank(folder)) {            return;        }        if (!new FilePathTypeValidator().isPathValid(folder)) {            errors().add(FOLDER, FilePathTypeValidator.errorMessage(\"directory\", getFolder()));        }    }    @Override    public void setConfigAttributes(Object attributes) {        super.setConfigAttributes(attributes);        Map map = (Map) attributes;        if (map.containsKey(FOLDER)) {            String folder = (String) map.get(FOLDER);            if (isBlank(folder)) {                folder = null;            }            this.folder = folder;        }        this.setAutoUpdate(\"true\".equals(map.get(AUTO_UPDATE)));        this.setInvertFilter(\"true\".equals(map.get(INVERT_FILTER)));        if (map.containsKey(FILTER)) {            String pattern = (String) map.get(FILTER);            if (!isBlank(pattern)) {                this.setFilter(Filter.fromDisplayString(pattern));            } else {                this.setFilter(null);            }        }    }    public boolean isAutoUpdateStateMismatch(MaterialConfigs materialAutoUpdateMap) {        if (materialAutoUpdateMap.size() > 1) {            for (MaterialConfig otherMaterial : materialAutoUpdateMap) {                if (otherMaterial.isAutoUpdate() != this.autoUpdate) {                    return true;                }            }        }        return false;    }    public void setAutoUpdateMismatchErrorWithPipelines(Map<CaseInsensitiveString, Boolean> pipelinesWithThisMaterial) {        String message = format(\"The material of type %s (%s) is used elsewhere with a different value for autoUpdate (\\\"Poll for changes\\\"). Those values should be the same. Pipelines: %s\", getTypeForDisplay(), getDescription(), join(pipelinesWithThisMaterial));        addError(AUTO_UPDATE, message);    }    private String getAutoUpdateStatus(boolean autoUpdate) {        return autoUpdate ? \"auto update enabled\" : \"auto update disabled\";    }    private String join(Map<CaseInsensitiveString, Boolean> pipelinesWithThisMaterial) {        if (pipelinesWithThisMaterial == null || pipelinesWithThisMaterial.isEmpty()) {            return \"\";        }        StringBuilder builder = new StringBuilder();        pipelinesWithThisMaterial.forEach((key, value) -> {            builder.append(format(\"%s (%s),\\n \", key, getAutoUpdateStatus(value)));        });        return builder.delete(builder.lastIndexOf(\",\"), builder.length()).toString();    }    public void setDestinationFolderError(String message) {        addError(FOLDER, message);    }    public void validateNotSubdirectoryOf(String otherSCMMaterialFolder) {        String myDirPath = this.getFolder();        if (myDirPath == null || otherSCMMaterialFolder == null) {            return;        }        if (FilenameUtil.isNormalizedDirectoryPathInsideNormalizedParentDirectory(myDirPath, otherSCMMaterialFolder)) {            addError(FOLDER, \"Invalid Destination Directory. Every material needs a different destination directory and the directories should not be nested.\");        }    }    public void validateDestinationDirectoryName(String otherSCMMaterialFolder) {        if (folder != null && folder.equalsIgnoreCase(otherSCMMaterialFolder)) {            addError(FOLDER, \"The destination directory must be unique across materials.\");        }    }    private void validateNotOutsideSandbox() {        String dest = this.getFolder();        if (dest == null) {            return;        }        if (!(FilenameUtil.isNormalizedPathOutsideWorkingDir(dest))) {            setDestinationFolderError(format(\"Dest folder '%s' is not valid. It must be a sub-directory of the working folder.\", dest));        }    }    @Override    public Boolean isUsedInFetchArtifact(PipelineConfig pipelineConfig) {        return false;    }    public void setFolder(String folder) {        this.folder = folder;    }    protected void validateMaterialUrl(UrlArgument url) {        if (url == null || isBlank(url.forDisplay())) {            errors().add(URL, \"URL cannot be blank\");            return;        }        if (System.getProperty(\"gocd.verify.url.correctness\", \"y\").equalsIgnoreCase(\"y\") && !url.isValidURLOrLocalPath()) {            errors().add(URL, \"URL does not seem to be valid.\");        }    }    protected void validateCredentials() {        try {            if (isBlank(getUrl()) || isAllBlank(userName, getPassword())) {                return;            }            if (UrlUserInfo.hasUserInfo(getUrl())) {                errors().add(URL, \"Ambiguous credentials, must be provided either in URL or as attributes.\");            }        } catch (Exception e) {        }    }    protected void validateEncryptedPassword() {        if (isNotEmpty(getEncryptedPassword())) {            try {                getPassword();            } catch (Exception e) {                addError(\"encryptedPassword\", format(\"Encrypted password value for %s with url '%s' is invalid. This usually happens when the cipher text is modified to have an invalid value.\", this.getType(), this.getUriForDisplay()));            }        }    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.preprocessor.SkipParameterResolution;import com.thoughtworks.go.config.validation.FilePathTypeValidator;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.FilenameUtil;import com.thoughtworks.go.util.command.UrlArgument;import com.thoughtworks.go.util.command.UrlUserInfo;import javax.annotation.PostConstruct;import java.io.File;import java.util.Map;import static com.thoughtworks.go.util.ExceptionUtils.bomb;import static java.lang.String.format;import static org.apache.commons.lang3.StringUtils.*;public abstract class ScmMaterialConfig extends AbstractMaterialConfig implements ParamsAttributeAware {    public static final String URL = \"url\";    public static final String USERNAME = \"username\";    protected GoCipher goCipher;    @ConfigSubtag    private Filter filter;    @ConfigAttribute(value = \"invertFilter\", optional = true)    private boolean invertFilter = false;    @ConfigAttribute(value = \"dest\", allowNull = true)    protected String folder;    @ConfigAttribute(value = \"autoUpdate\", optional = true)    private boolean autoUpdate = true;    @ConfigAttribute(value = \"username\", allowNull = true)    protected String userName;    @SkipParameterResolution    @ConfigAttribute(value = \"password\", allowNull = true)    protected String password;    @ConfigAttribute(value = \"encryptedPassword\", allowNull = true)    protected String encryptedPassword;    public static final String PASSWORD = \"password\";    public static final String ENCRYPTED_PASSWORD = \"encryptedPassword\";    public static final String PASSWORD_CHANGED = \"passwordChanged\";    public static final String AUTO_UPDATE = \"autoUpdate\";    public static final String FOLDER = \"folder\";    public static final String FILTER = \"filterAsString\";    public static final String INVERT_FILTER = \"invertFilter\";    public ScmMaterialConfig(String typeName) {        super(typeName);        this.goCipher = new GoCipher();    }    @Override    protected void appendPipelineUniqueCriteria(Map<String, Object> basicCriteria) {        basicCriteria.put(\"dest\", folder);    }    public File workingdir(File baseFolder) {        if (getFolder() == null) {            return baseFolder;        }        return new File(baseFolder, getFolder());    }    @Override    public boolean matches(String name, String regex) {        if (regex.startsWith(\"/\")) {            regex = regex.substring(1);        }        return name.matches(regex);    }    public final GoCipher getGoCipher() {        return goCipher;    }    public final void setUserName(String userName) {        this.userName = userName;    }    public final String getUserName() {        return userName;    }    @Deprecated    public String getUsername() {        return getUserName();    }    public final String getPassword() {        return currentPassword();    }    public final void setPassword(String password) {        resetPassword(password);    }    protected void resetPassword(String passwordToSet) {        if (isBlank(passwordToSet)) {            encryptedPassword = null;        }        setPasswordIfNotBlank(passwordToSet);    }    @PostConstruct    public final void ensureEncrypted() {        this.userName = stripToNull(this.userName);        setPasswordIfNotBlank(password);    }    private void setPasswordIfNotBlank(String password) {        this.password = stripToNull(password);        this.encryptedPassword = stripToNull(encryptedPassword);        if (this.password == null) {            return;        }        try {            this.encryptedPassword = this.goCipher.encrypt(password);        } catch (Exception e) {            bomb(\"Password encryption failed. Please verify your cipher key.\", e);        }        this.password = null;    }    public final String currentPassword() {        try {            return isBlank(encryptedPassword) ? null : this.goCipher.decrypt(encryptedPassword);        } catch (Exception e) {            throw new RuntimeException(\"Could not decrypt the password to get the real password\", e);        }    }    public final void setEncryptedPassword(String encryptedPassword) {        this.encryptedPassword = encryptedPassword;    }    public final String getEncryptedPassword() {        return encryptedPassword;    }    public abstract boolean isCheckExternals();    public abstract String getUrl();    public abstract void setUrl(String url);    protected abstract String getLocation();    @Override    public Filter filter() {        if (filter == null) {            return new Filter();        }        return filter;    }    public String getFilterAsString() {        return filter().getStringForDisplay();    }    public Filter rawFilter() {        return filter;    }    public void setFilter(Filter filter) {        this.filter = filter;    }    @Override    public boolean isInvertFilter() {        return invertFilter;    }    public boolean getInvertFilter() {        return invertFilter;    }    public void setInvertFilter(boolean value) {        invertFilter = value;    }    @Override    public String getDescription() {        return getUriForDisplay();    }    @Override    public abstract String getUriForDisplay();    @Override    public String getFolder() {        return folder;    }    @Override    public String getDisplayName() {        return name == null ? getUriForDisplay() : CaseInsensitiveString.str(name);    }    @Override    public boolean isAutoUpdate() {        return autoUpdate;    }    public boolean getAutoUpdate() {        return autoUpdate;    }    @Override    public void setAutoUpdate(boolean value) {        autoUpdate = value;    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        if (!super.equals(o)) {            return false;        }        ScmMaterialConfig that = (ScmMaterialConfig) o;        if (folder != null ? !folder.equals(that.folder) : that.folder != null) {            return false;        }        return super.equals(that);    }    @Override    public int hashCode() {        int result = super.hashCode();        result = 31 * result + (folder != null ? folder.hashCode() : 0);        return result;    }    @Override    protected final void validateConcreteMaterial(ValidationContext validationContext) {        validateNotOutsideSandbox();        validateDestFolderPath();        validateConcreteScmMaterial(validationContext);    }    public abstract void validateConcreteScmMaterial(ValidationContext validationContext);    private void validateDestFolderPath() {        if (isBlank(folder)) {            return;        }        if (!new FilePathTypeValidator().isPathValid(folder)) {            errors().add(FOLDER, FilePathTypeValidator.errorMessage(\"directory\", getFolder()));        }    }    @Override    public void setConfigAttributes(Object attributes) {        super.setConfigAttributes(attributes);        Map map = (Map) attributes;        if (map.containsKey(FOLDER)) {            String folder = (String) map.get(FOLDER);            if (isBlank(folder)) {                folder = null;            }            this.folder = folder;        }        this.setAutoUpdate(\"true\".equals(map.get(AUTO_UPDATE)));        this.setInvertFilter(\"true\".equals(map.get(INVERT_FILTER)));        if (map.containsKey(FILTER)) {            String pattern = (String) map.get(FILTER);            if (!isBlank(pattern)) {                this.setFilter(Filter.fromDisplayString(pattern));            } else {                this.setFilter(null);            }        }    }    public boolean isAutoUpdateStateMismatch(MaterialConfigs materialAutoUpdateMap) {        if (materialAutoUpdateMap.size() > 1) {            for (MaterialConfig otherMaterial : materialAutoUpdateMap) {                if (otherMaterial.isAutoUpdate() != this.autoUpdate) {                    return true;                }            }        }        return false;    }    public void setAutoUpdateMismatchErrorWithPipelines(Map<CaseInsensitiveString, Boolean> pipelinesWithThisMaterial) {        String message = format(\"The material of type %s (%s) is used elsewhere with a different value for autoUpdate (\\\"Poll for changes\\\"). Those values should be the same. Pipelines: %s\", getTypeForDisplay(), getDescription(), join(pipelinesWithThisMaterial));        addError(AUTO_UPDATE, message);    }    private String getAutoUpdateStatus(boolean autoUpdate) {        return autoUpdate ? \"auto update enabled\" : \"auto update disabled\";    }    private String join(Map<CaseInsensitiveString, Boolean> pipelinesWithThisMaterial) {        if (pipelinesWithThisMaterial == null || pipelinesWithThisMaterial.isEmpty()) {            return \"\";        }        StringBuilder builder = new StringBuilder();        pipelinesWithThisMaterial.forEach((key, value) -> {            builder.append(format(\"%s (%s),\\n \", key, getAutoUpdateStatus(value)));        });        return builder.delete(builder.lastIndexOf(\",\"), builder.length()).toString();    }    public void setDestinationFolderError(String message) {        addError(FOLDER, message);    }    public void validateNotSubdirectoryOf(String otherSCMMaterialFolder) {        String myDirPath = this.getFolder();        if (myDirPath == null || otherSCMMaterialFolder == null) {            return;        }        if (FilenameUtil.isNormalizedDirectoryPathInsideNormalizedParentDirectory(myDirPath, otherSCMMaterialFolder)) {            addError(FOLDER, \"Invalid Destination Directory. Every material needs a different destination directory and the directories should not be nested.\");        }    }    public void validateDestinationDirectoryName(String otherSCMMaterialFolder) {        if (folder != null && folder.equalsIgnoreCase(otherSCMMaterialFolder)) {            addError(FOLDER, \"The destination directory must be unique across materials.\");        }    }    private void validateNotOutsideSandbox() {        String dest = this.getFolder();        if (dest == null) {            return;        }        if (!(FilenameUtil.isNormalizedPathOutsideWorkingDir(dest))) {            setDestinationFolderError(format(\"Dest folder '%s' is not valid. It must be a sub-directory of the working folder.\", dest));        }    }    @Override    public Boolean isUsedInFetchArtifact(PipelineConfig pipelineConfig) {        return false;    }    public void setFolder(String folder) {        this.folder = folder;    }    protected void validateMaterialUrl(UrlArgument url) {        if (url == null || isBlank(url.forDisplay())) {            errors().add(URL, \"URL cannot be blank\");            return;        }    }    protected void validateCredentials() {        try {            if (isBlank(getUrl()) || isAllBlank(userName, getPassword())) {                return;            }            if (UrlUserInfo.hasUserInfo(getUrl())) {                errors().add(URL, \"Ambiguous credentials, must be provided either in URL or as attributes.\");            }        } catch (Exception e) {        }    }    protected void validateEncryptedPassword() {        if (isNotEmpty(getEncryptedPassword())) {            try {                getPassword();            } catch (Exception e) {                addError(\"encryptedPassword\", format(\"Encrypted password value for %s with url '%s' is invalid. This usually happens when the cipher text is modified to have an invalid value.\", this.getType(), this.getUriForDisplay()));            }        }    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.PasswordAwareMaterial;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.util.command.UrlArgument;import org.apache.commons.lang3.StringUtils;import java.util.Map;@ConfigTag(value = \"p4\", label = \"Perforce\")public class P4MaterialConfig extends ScmMaterialConfig implements ParamsAttributeAware, PasswordAwareMaterial {    @ConfigAttribute(value = \"port\")    private String serverAndPort;    @ConfigAttribute(value = \"useTickets\")    private Boolean useTickets = false;    @ConfigSubtag(optional = false)    private P4MaterialViewConfig view;    public static final String TYPE = \"P4Material\";    public static final String USERNAME = \"userName\";    public static final String VIEW = \"view\";    public static final String SERVER_AND_PORT = \"serverAndPort\";    public static final String USE_TICKETS = \"useTickets\";    public P4MaterialConfig() {        super(TYPE);    }    @Override    protected void appendCriteria(Map<String, Object> parameters) {        parameters.put(ScmMaterialConfig.URL, serverAndPort);        parameters.put(ScmMaterialConfig.USERNAME, userName);        parameters.put(\"view\", view.getValue());    }    @Override    protected void appendAttributes(Map<String, Object> parameters) {        appendCriteria(parameters);    }    public String getServerAndPort() {        return serverAndPort;    }    public void setServerAndPort(String serverAndPort) {        this.serverAndPort = serverAndPort;    }    public String getView() {        return view == null ? null : view.getValue();    }    public P4MaterialViewConfig getP4MaterialView() {        return view;    }    public void setP4MaterialView(P4MaterialViewConfig view) {        resetCachedIdentityAttributes();        this.view = view;    }    @Override    public boolean isCheckExternals() {        return false;    }    @Override    public String getUrl() {        return serverAndPort;    }    @Override    public void setUrl(String serverAndPort) {        this.serverAndPort = serverAndPort;    }    @Override    public String getLongDescription() {        return String.format(\"URL: %s, View: %s, Username: %s\", serverAndPort, view.getValue(), userName);    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        if (!super.equals(o)) {            return false;        }        P4MaterialConfig that = (P4MaterialConfig) o;        if (serverAndPort != null ? !serverAndPort.equals(that.serverAndPort) : that.serverAndPort != null) {            return false;        }        if (useTickets != null ? !useTickets.equals(that.useTickets) : that.useTickets != null) {            return false;        }        if (view != null ? !view.equals(that.view) : that.view != null) {            return false;        }        if (userName != null ? !userName.equals(that.userName) : that.userName != null) {            return false;        }        return true;    }    @Override    public int hashCode() {        int result = super.hashCode();        result = 31 * result + (serverAndPort != null ? serverAndPort.hashCode() : 0);        result = 31 * result + (userName != null ? userName.hashCode() : 0);        result = 31 * result + (useTickets != null ? useTickets.hashCode() : 0);        result = 31 * result + (view != null ? view.hashCode() : 0);        return result;    }    @Override    public void validateConcreteScmMaterial(ValidationContext validationContext) {        if (getView() == null || getView().trim().isEmpty()) {            errors.add(VIEW, \"P4 view cannot be empty.\");        }        if (StringUtils.isBlank(getServerAndPort())) {            errors.add(SERVER_AND_PORT, \"P4 port cannot be empty.\");        }        if (!new UrlArgument(getUrl()).isValidURLOrLocalPath()) {            errors.add(SERVER_AND_PORT, \"P4 port seems to be invalid.\");        }        view.validate(validationContext);    }    @Override    protected String getLocation() {        return getServerAndPort();    }    @Override    public String getUriForDisplay() {        return new UrlArgument(serverAndPort).forDisplay();    }    @Override    public String getTypeForDisplay() {        return \"Perforce\";    }    @Override    public String toString() {        return \"P4MaterialConfig{\" +                \"serverAndPort='\" + serverAndPort + '\\'' +                \", userName='\" + userName + '\\'' +                \", view=\" + view.getValue() +                '}';    }    @Override    public void setConfigAttributes(Object attributes) {        if (attributes == null) {            return;        }        super.setConfigAttributes(attributes);        Map map = (Map) attributes;        if (map.containsKey(SERVER_AND_PORT)) {            this.serverAndPort = (String) map.get(SERVER_AND_PORT);        }        if (map.containsKey(VIEW)) {            setView((String) map.get(VIEW));        }        if (map.containsKey(USERNAME)) {            this.userName = (String) map.get(USERNAME);        }        if (map.containsKey(PASSWORD_CHANGED) && \"1\".equals(map.get(PASSWORD_CHANGED))) {            String passwordToSet = (String) map.get(PASSWORD);            resetPassword(passwordToSet);        }        setUseTickets(\"true\".equals(map.get(USE_TICKETS)));    }    public void setView(String viewStr) {        this.view = new P4MaterialViewConfig(viewStr);    }    public boolean getUseTickets() {        return this.useTickets;    }    public void setUseTickets(boolean useTickets) {        this.useTickets = useTickets;    }    @Override    public String getFolder() {        return folder;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.PasswordAwareMaterial;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.util.command.UrlArgument;import org.apache.commons.lang3.StringUtils;import java.util.Map;@ConfigTag(value = \"p4\", label = \"Perforce\")public class P4MaterialConfig extends ScmMaterialConfig implements ParamsAttributeAware, PasswordAwareMaterial {    @ConfigAttribute(value = \"port\")    private String serverAndPort;    @ConfigAttribute(value = \"useTickets\")    private Boolean useTickets = false;    @ConfigSubtag(optional = false)    private P4MaterialViewConfig view;    public static final String TYPE = \"P4Material\";    public static final String USERNAME = \"userName\";    public static final String VIEW = \"view\";    public static final String SERVER_AND_PORT = \"serverAndPort\";    public static final String USE_TICKETS = \"useTickets\";    public P4MaterialConfig() {        super(TYPE);    }    @Override    protected void appendCriteria(Map<String, Object> parameters) {        parameters.put(ScmMaterialConfig.URL, serverAndPort);        parameters.put(ScmMaterialConfig.USERNAME, userName);        parameters.put(\"view\", view.getValue());    }    @Override    protected void appendAttributes(Map<String, Object> parameters) {        appendCriteria(parameters);    }    public String getServerAndPort() {        return serverAndPort;    }    public void setServerAndPort(String serverAndPort) {        this.serverAndPort = serverAndPort;    }    public String getView() {        return view == null ? null : view.getValue();    }    public P4MaterialViewConfig getP4MaterialView() {        return view;    }    public void setP4MaterialView(P4MaterialViewConfig view) {        resetCachedIdentityAttributes();        this.view = view;    }    @Override    public boolean isCheckExternals() {        return false;    }    @Override    public String getUrl() {        return serverAndPort;    }    @Override    public void setUrl(String serverAndPort) {        this.serverAndPort = serverAndPort;    }    @Override    public String getLongDescription() {        return String.format(\"URL: %s, View: %s, Username: %s\", serverAndPort, view.getValue(), userName);    }    @Override    public boolean equals(Object o) {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        if (!super.equals(o)) {            return false;        }        P4MaterialConfig that = (P4MaterialConfig) o;        if (serverAndPort != null ? !serverAndPort.equals(that.serverAndPort) : that.serverAndPort != null) {            return false;        }        if (useTickets != null ? !useTickets.equals(that.useTickets) : that.useTickets != null) {            return false;        }        if (view != null ? !view.equals(that.view) : that.view != null) {            return false;        }        if (userName != null ? !userName.equals(that.userName) : that.userName != null) {            return false;        }        return true;    }    @Override    public int hashCode() {        int result = super.hashCode();        result = 31 * result + (serverAndPort != null ? serverAndPort.hashCode() : 0);        result = 31 * result + (userName != null ? userName.hashCode() : 0);        result = 31 * result + (useTickets != null ? useTickets.hashCode() : 0);        result = 31 * result + (view != null ? view.hashCode() : 0);        return result;    }    @Override    public void validateConcreteScmMaterial(ValidationContext validationContext) {        if (getView() == null || getView().trim().isEmpty()) {            errors.add(VIEW, \"P4 view cannot be empty.\");        }        if (StringUtils.isBlank(getServerAndPort())) {            errors.add(SERVER_AND_PORT, \"P4 port cannot be empty.\");        }        validateEncryptedPassword();    }    @Override    protected String getLocation() {        return getServerAndPort();    }    @Override    public String getUriForDisplay() {        return new UrlArgument(serverAndPort).forDisplay();    }    @Override    public String getTypeForDisplay() {        return \"Perforce\";    }    @Override    public String toString() {        return \"P4MaterialConfig{\" +                \"serverAndPort='\" + serverAndPort + '\\'' +                \", userName='\" + userName + '\\'' +                \", view=\" + view.getValue() +                '}';    }    @Override    public void setConfigAttributes(Object attributes) {        if (attributes == null) {            return;        }        super.setConfigAttributes(attributes);        Map map = (Map) attributes;        if (map.containsKey(SERVER_AND_PORT)) {            this.serverAndPort = (String) map.get(SERVER_AND_PORT);        }        if (map.containsKey(VIEW)) {            setView((String) map.get(VIEW));        }        if (map.containsKey(USERNAME)) {            this.userName = (String) map.get(USERNAME);        }        if (map.containsKey(PASSWORD_CHANGED) && \"1\".equals(map.get(PASSWORD_CHANGED))) {            String passwordToSet = (String) map.get(PASSWORD);            resetPassword(passwordToSet);        }        setUseTickets(\"true\".equals(map.get(USE_TICKETS)));    }    public void setView(String viewStr) {        this.view = new P4MaterialViewConfig(viewStr);    }    public boolean getUseTickets() {        return this.useTickets;    }    public void setUseTickets(boolean useTickets) {        this.useTickets = useTickets;    }    @Override    public String getFolder() {        return folder;    }}"}
{"code": "import com.thoughtworks.go.config.ConfigAttributeValue;import org.apache.commons.lang3.StringUtils;import org.apache.http.client.utils.URIBuilder;import java.net.URI;import java.net.URISyntaxException;import java.util.regex.Pattern;import static com.thoughtworks.go.util.ExceptionUtils.bombIfNull;import static org.apache.commons.lang3.StringUtils.isBlank;@ConfigAttributeValue(fieldName = \"url\")public class UrlArgument extends CommandArgument {    private static final String URL_DUMB_VALIDATION_REGEX = \"^[a-zA-Z0-9/].*\";    private static final Pattern pattern = Pattern.compile(URL_DUMB_VALIDATION_REGEX);    protected String url;    public UrlArgument(String url) {        bombIfNull(url, \"Url cannot be null.\");        this.url = url;    }    @Override    public String originalArgument() {        return url;    }    @Override    public String forDisplay() {        try {            URI uri = new URI(sanitizeUrl());            if (uri.getUserInfo() != null) {                uri = new URI(uri.getScheme(), clean(uri.getScheme(), uri.getUserInfo()), uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());            }            return uri.toString();        } catch (URISyntaxException e) {            return url;        }    }    private String clean(String scheme, String userInfo) {        if (userInfo.contains(\":\")) {            return userInfo.replaceFirst(\":.*\", \":******\");        } else if (\"ssh\".equals(scheme) || \"svn+ssh\".equals(scheme)) {            return userInfo;        }        return \"******\";    }    @Override    public String forCommandLine() {        return this.url;    }    protected String sanitizeUrl() {        return this.url;    }    public static UrlArgument create(String url) {        return new UrlArgument(url);    }    @Override    public String replaceSecretInfo(String line) {        if (StringUtils.isBlank(line)) {            return line;        }        if (isBlank(this.url)) {            return line;        }        try {            final URIBuilder uriBuilder = new URIBuilder(this.url).setPath(null).setCustomQuery(null).setFragment(null);            final UrlUserInfo urlUserInfo = new UrlUserInfo(uriBuilder.getUserInfo());            if (uriBuilder.getUserInfo() != null) {                line = line.replace(uriBuilder.getUserInfo(), urlUserInfo.maskedUserInfo());            }        } catch (URISyntaxException e) {        }        return line;    }    @Override    public boolean equal(CommandArgument that) {        if (url.startsWith(\"svn+ssh\")) {            return this.originalArgument().equals(that.originalArgument());        }        return cleanPath(this).equals(cleanPath(that));    }    private String cleanPath(CommandArgument commandArgument) {        String path = commandArgument.originalArgument();        if (path.endsWith(\"/\")) {            path = path.substring(0, path.length() - 1);        }        return path;    }    public String withoutCredentials() {        try {            return new URIBuilder(this.sanitizeUrl()).setUserInfo(null).build().toString();        } catch (URISyntaxException e) {            return url;        }    }    public boolean isValidURLOrLocalPath() {        return pattern.matcher(url).matches();    }}", "nl": "import com.thoughtworks.go.config.ConfigAttributeValue;import org.apache.commons.lang3.StringUtils;import org.apache.http.client.utils.URIBuilder;import java.net.URI;import java.net.URISyntaxException;import static com.thoughtworks.go.util.ExceptionUtils.bombIfNull;import static org.apache.commons.lang3.StringUtils.isBlank;@ConfigAttributeValue(fieldName = \"url\")public class UrlArgument extends CommandArgument {    protected String url;    public UrlArgument(String url) {        bombIfNull(url, \"Url cannot be null.\");        this.url = url;    }    @Override    public String originalArgument() {        return url;    }    @Override    public String forDisplay() {        try {            URI uri = new URI(sanitizeUrl());            if (uri.getUserInfo() != null) {                uri = new URI(uri.getScheme(), clean(uri.getScheme(), uri.getUserInfo()), uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());            }            return uri.toString();        } catch (URISyntaxException e) {            return url;        }    }    private String clean(String scheme, String userInfo) {        if (userInfo.contains(\":\")) {            return userInfo.replaceFirst(\":.*\", \":******\");        } else if (\"ssh\".equals(scheme) || \"svn+ssh\".equals(scheme)) {            return userInfo;        }        return \"******\";    }    @Override    public String forCommandLine() {        return this.url;    }    protected String sanitizeUrl() {        return this.url;    }    public static UrlArgument create(String url) {        return new UrlArgument(url);    }    @Override    public String replaceSecretInfo(String line) {        if (StringUtils.isBlank(line)) {            return line;        }        if (isBlank(this.url)) {            return line;        }        try {            final URIBuilder uriBuilder = new URIBuilder(this.url).setPath(null).setCustomQuery(null).setFragment(null);            final UrlUserInfo urlUserInfo = new UrlUserInfo(uriBuilder.getUserInfo());            if (uriBuilder.getUserInfo() != null) {                line = line.replace(uriBuilder.getUserInfo(), urlUserInfo.maskedUserInfo());            }        } catch (URISyntaxException e) {        }        return line;    }    @Override    public boolean equal(CommandArgument that) {        if (url.startsWith(\"svn+ssh\")) {            return this.originalArgument().equals(that.originalArgument());        }        return cleanPath(this).equals(cleanPath(that));    }    private String cleanPath(CommandArgument commandArgument) {        String path = commandArgument.originalArgument();        if (path.endsWith(\"/\")) {            path = path.substring(0, path.length() - 1);        }        return path;    }    public String withoutCredentials() {        try {            return new URIBuilder(this.sanitizeUrl()).setUserInfo(null).build().toString();        } catch (URISyntaxException e) {            return url;        }    }}"}
{"code": "import com.thoughtworks.go.config.ConfigSaveValidationContext;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Collections;import java.util.HashMap;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.*;import static org.assertj.core.api.Assertions.assertThat;class ScmMaterialConfigTest {    private DummyMaterialConfig material;    @BeforeEach    void setUp() {        material = new DummyMaterialConfig();    }    @Test    void shouldSetFilterToNullWhenBlank() {        material.setFilter(new Filter(new IgnoredFiles(\"*.*\")));        material.setConfigAttributes(Collections.singletonMap(ScmMaterialConfig.FILTER, \"\"));        assertThat(material.filter()).isEqualTo(new Filter());        assertThat(material.getFilterAsString()).isEqualTo(\"\");    }    @Test    void shouldReturnFilterForDisplay() {        material.setFilter(new Filter(new IgnoredFiles(\"/foo/**.*\"), new IgnoredFiles(\"/another/**.*\"), new IgnoredFiles(\"bar\")));        assertThat(material.getFilterAsString()).isEqualTo(\"/foo/**.*,/another/**.*,bar\");    }    @Test    void shouldSetFolderToNullWhenBlank() {        material.setConfigAttributes(Collections.singletonMap(FOLDER, \"foo\"));        assertThat(material.getFolder()).isNotNull();        material.setConfigAttributes(Collections.singletonMap(FOLDER, \"\"));        assertThat(material.getFolder()).isNull();    }    @Test    void shouldUpdateAutoUpdateFieldFromConfigAttributes() {        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, \"false\"));        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, null));        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, \"true\"));        assertThat(material.isAutoUpdate()).isTrue();        material.setConfigAttributes(new HashMap());        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, null));        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, \"random-stuff\"));        assertThat(material.isAutoUpdate()).isFalse();    }    @Nested    class validate {        @Test        void shouldNotValidateEmptyDestinationFolder() {            material.setConfigAttributes(Collections.singletonMap(FOLDER, \"\"));            material.validate(new ConfigSaveValidationContext(null));            assertThat(material.errors.isEmpty()).isTrue();        }        @Test        void shouldFailValidationIfDestinationDirectoryIsNested() {            material.setFolder(\"f1\");            material.validateNotSubdirectoryOf(\"f1/f2\");            assertThat(material.errors().isEmpty()).isFalse();            assertThat(material.errors().on(FOLDER)).isEqualTo(\"Invalid Destination Directory. Every material needs a different destination directory and the directories should not be nested.\");        }        @Test        void shouldNotFailValidationIfDestinationDirectoryIsMultilevelButNotNested() {            material.setFolder(\"f1/f2/f3\");            material.validateNotSubdirectoryOf(\"f1/f2/f\");            assertThat(material.errors().getAllOn(FOLDER)).isEmpty();        }        @Test        void shouldFailValidationIfDestinationDirectoryIsOutsideCurrentWorkingDirectoryAfterNormalization() {            material.setFolder(\"f1/../../f3\");            material.validateConcreteMaterial(null);            assertThat(material.errors().on(FOLDER)).isEqualTo(\"Dest folder 'f1/../../f3' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldFailValidationIfDestinationDirectoryIsNestedAfterNormalization() {            material.setFolder(\"f1/f2/../../f3\");            material.validateNotSubdirectoryOf(\"f3/f4\");            assertThat(material.errors().on(FOLDER)).isEqualTo(\"Invalid Destination Directory. Every material needs a different destination directory and the directories should not be nested.\");        }        @Test        void shouldNotValidateNestingOfMaterialDirectoriesBasedOnServerSideFileSystem(@TempDir File workingDir) throws IOException {            final File material1 = new File(workingDir, \"material1\");            material1.mkdirs();            final Path material2 = Files.createSymbolicLink(Paths.get(new File(workingDir, \"material2\").getPath()), Paths.get(material1.getPath()));            material.setFolder(material1.getAbsolutePath());            material.validateNotSubdirectoryOf(material2.toAbsolutePath().toString());            assertThat(material.errors().getAllOn(FOLDER)).isEmpty();        }    }}", "nl": "import com.thoughtworks.go.config.ConfigSaveValidationContext;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Collections;import java.util.HashMap;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.AUTO_UPDATE;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static org.assertj.core.api.Assertions.assertThat;class ScmMaterialConfigTest {    private DummyMaterialConfig material;    @BeforeEach    void setUp() {        material = new DummyMaterialConfig();    }    @Test    void shouldSetFilterToNullWhenBlank() {        material.setFilter(new Filter(new IgnoredFiles(\"*.*\")));        material.setConfigAttributes(Collections.singletonMap(ScmMaterialConfig.FILTER, \"\"));        assertThat(material.filter()).isEqualTo(new Filter());        assertThat(material.getFilterAsString()).isEqualTo(\"\");    }    @Test    void shouldReturnFilterForDisplay() {        material.setFilter(new Filter(new IgnoredFiles(\"/foo/**.*\"), new IgnoredFiles(\"/another/**.*\"), new IgnoredFiles(\"bar\")));        assertThat(material.getFilterAsString()).isEqualTo(\"/foo/**.*,/another/**.*,bar\");    }    @Test    void shouldSetFolderToNullWhenBlank() {        material.setConfigAttributes(Collections.singletonMap(FOLDER, \"foo\"));        assertThat(material.getFolder()).isNotNull();        material.setConfigAttributes(Collections.singletonMap(FOLDER, \"\"));        assertThat(material.getFolder()).isNull();    }    @Test    void shouldUpdateAutoUpdateFieldFromConfigAttributes() {        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, \"false\"));        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, null));        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, \"true\"));        assertThat(material.isAutoUpdate()).isTrue();        material.setConfigAttributes(new HashMap());        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, null));        assertThat(material.isAutoUpdate()).isFalse();        material.setConfigAttributes(Collections.singletonMap(AUTO_UPDATE, \"random-stuff\"));        assertThat(material.isAutoUpdate()).isFalse();    }    @Nested    class validate {        @Test        void shouldNotValidateEmptyDestinationFolder() {            material.setConfigAttributes(Collections.singletonMap(FOLDER, \"\"));            material.validate(new ConfigSaveValidationContext(null));            assertThat(material.errors.isEmpty()).isTrue();        }        @Test        void shouldFailValidationIfDestinationDirectoryIsNested() {            material.setFolder(\"f1\");            material.validateNotSubdirectoryOf(\"f1/f2\");            assertThat(material.errors().isEmpty()).isFalse();            assertThat(material.errors().on(FOLDER)).isEqualTo(\"Invalid Destination Directory. Every material needs a different destination directory and the directories should not be nested.\");        }        @Test        void shouldNotFailValidationIfDestinationDirectoryIsMultilevelButNotNested() {            material.setFolder(\"f1/f2/f3\");            material.validateNotSubdirectoryOf(\"f1/f2/f\");            assertThat(material.errors().getAllOn(FOLDER)).isEmpty();        }        @Test        void shouldFailValidationIfDestinationDirectoryIsOutsideCurrentWorkingDirectoryAfterNormalization() {            material.setFolder(\"f1/../../f3\");            material.validateConcreteMaterial(null);            assertThat(material.errors().on(FOLDER)).isEqualTo(\"Dest folder 'f1/../../f3' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldFailValidationIfDestinationDirectoryIsNestedAfterNormalization() {            material.setFolder(\"f1/f2/../../f3\");            material.validateNotSubdirectoryOf(\"f3/f4\");            assertThat(material.errors().on(FOLDER)).isEqualTo(\"Invalid Destination Directory. Every material needs a different destination directory and the directories should not be nested.\");        }        @Test        void shouldNotValidateNestingOfMaterialDirectoriesBasedOnServerSideFileSystem(@TempDir File workingDir) throws IOException {            final File material1 = new File(workingDir, \"material1\");            material1.mkdirs();            final Path material2 = Files.createSymbolicLink(Paths.get(new File(workingDir, \"material2\").getPath()), Paths.get(material1.getPath()));            material.setFolder(material1.getAbsolutePath());            material.validateNotSubdirectoryOf(material2.toAbsolutePath().toString());            assertThat(material.errors().getAllOn(FOLDER)).isEmpty();        }    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.git;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.Mockito.*;class GitMaterialConfigTest {    @Test    void shouldBePasswordAwareMaterial() {        assertTrue(PasswordAwareMaterial.class.isAssignableFrom(GitMaterialConfig.class));    }    @Test    void shouldSetConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.URL, \"url\");        map.put(GitMaterialConfig.BRANCH, \"some-branch\");        map.put(GitMaterialConfig.SHALLOW_CLONE, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, null);        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        gitMaterialConfig.setConfigAttributes(map);        assertEquals(\"url\", gitMaterialConfig.getUrl());        assertEquals(\"folder\", gitMaterialConfig.getFolder());        assertEquals(\"some-branch\", gitMaterialConfig.getBranch());        assertEquals(new CaseInsensitiveString(\"material-name\"), gitMaterialConfig.getName());        assertFalse(gitMaterialConfig.isAutoUpdate());        assertTrue(gitMaterialConfig.isShallowClone());        assertEquals(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")), gitMaterialConfig.filter());    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.PASSWORD, \"secret\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"Hehehe\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"0\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(gitMaterialConfig.getPassword());        assertNull(gitMaterialConfig.getEncryptedPassword());    }    @Test    void byDefaultShallowCloneShouldBeOff() {        assertFalse(git(\"http:        assertFalse(git(\"http:        assertFalse(git(\"http:        assertTrue(git(\"http:    }    @Test    void shouldReturnIfAttributeMapIsNull() {        GitMaterialConfig gitMaterialConfig = git(\"\");        gitMaterialConfig.setConfigAttributes(null);        assertEquals(git(\"\"), gitMaterialConfig);    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        GitMaterialConfig config = git();        assertNull(config.getUrl());    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git();        config.setUrl(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        GitMaterialConfig config = git();        config.setUrl(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullUrlAtTheTimeOfGitMaterialConfigCreation() {        GitMaterialConfig config = git(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, null));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Test    void shouldHandleEmptyBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, \"     \"));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Nested    class Validate {        @Test        void allowsBlankBranch() {            assertFalse(validating(git(\"/my/repo\", null)).errors().present());            assertFalse(validating(git(\"/my/repo\", \"\")).errors().present());            assertFalse(validating(git(\"/my/repo\", \" \")).errors().present());        }        @Test        void rejectsBranchWithWildcard() {            assertEquals(\"Branch names may not contain '*'\", validating(git(\"/foo\", \"branch-*\")).                    errors().on(GitMaterialConfig.BRANCH));        }        @Test        void rejectsMalformedRefSpec() {            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \":a\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \"   :b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/foo: \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/bar:\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \":\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \" : \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec source must be an absolute ref (must start with `refs/`)\",                    String.join(\";\", validating(git(\"/foo\", \"a:b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:my-branch\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/foo:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));        }        @Test        void acceptsValidRefSpecs() {            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:pr-123\")).errors().isEmpty());            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:refs/my-prs/123\")).errors().isEmpty());        }        @Test        void shouldEnsureUrlIsNotBlank() {            assertEquals(\"URL cannot be blank\", validating(git(\"\")).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setPassword(\"pass\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            gitMaterialConfig.setPassword(\"password\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            assertFalse(validating(git(\"http:        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"bob\");            gitMaterialConfig.setPassword(\"badger\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(git(\"-url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertTrue(validating(git(\"_url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertTrue(validating(git(\"@url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertFalse(validating(git(\"url-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));        }        private GitMaterialConfig validating(GitMaterialConfig git) {            git.validate(new ConfigSaveValidationContext(null));            return git;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(git(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = gitMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertFalse(validationResult);            assertEquals(\"Encrypted password value for GitMaterial with url 'http:                            \"invalid. This usually happens when the cipher text is modified to have an invalid value.\",                    gitMaterialConfig.errors().on(\"encryptedPassword\"));        }    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranchAndSubModuleFolder() {            final GitMaterialConfig material_1 = git(\"http:            material_1.setUserName(\"bob\");            material_1.setSubmoduleFolder(\"/var/lib/git\");            final GitMaterialConfig material_2 = git(\"http:            material_2.setUserName(\"alice\");            material_2.setSubmoduleFolder(\"/var/lib/git\");            assertTrue(material_1.equals(material_2));        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrlAndBranch() {            GitMaterialConfig gitMaterialConfig = git(\"https:            assertEquals(\"755da7fb7415c8674bdf5f8a4ba48fc3e071e5de429b1308ccf8949d215bdb08\", gitMaterialConfig.getFingerprint());        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.git;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.Mockito.*;class GitMaterialConfigTest {    @Test    void shouldBePasswordAwareMaterial() {        assertTrue(PasswordAwareMaterial.class.isAssignableFrom(GitMaterialConfig.class));    }    @Test    void shouldSetConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.URL, \"url\");        map.put(GitMaterialConfig.BRANCH, \"some-branch\");        map.put(GitMaterialConfig.SHALLOW_CLONE, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, null);        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        gitMaterialConfig.setConfigAttributes(map);        assertEquals(\"url\", gitMaterialConfig.getUrl());        assertEquals(\"folder\", gitMaterialConfig.getFolder());        assertEquals(\"some-branch\", gitMaterialConfig.getBranch());        assertEquals(new CaseInsensitiveString(\"material-name\"), gitMaterialConfig.getName());        assertFalse(gitMaterialConfig.isAutoUpdate());        assertTrue(gitMaterialConfig.isShallowClone());        assertEquals(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")), gitMaterialConfig.filter());    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.PASSWORD, \"secret\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"Hehehe\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"0\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(gitMaterialConfig.getPassword());        assertNull(gitMaterialConfig.getEncryptedPassword());    }    @Test    void byDefaultShallowCloneShouldBeOff() {        assertFalse(git(\"http:        assertFalse(git(\"http:        assertFalse(git(\"http:        assertTrue(git(\"http:    }    @Test    void shouldReturnIfAttributeMapIsNull() {        GitMaterialConfig gitMaterialConfig = git(\"\");        gitMaterialConfig.setConfigAttributes(null);        assertEquals(git(\"\"), gitMaterialConfig);    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        GitMaterialConfig config = git();        assertNull(config.getUrl());    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git();        config.setUrl(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        GitMaterialConfig config = git();        config.setUrl(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullUrlAtTheTimeOfGitMaterialConfigCreation() {        GitMaterialConfig config = git(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, null));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Test    void shouldHandleEmptyBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, \"     \"));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Nested    class Validate {        @Test        void allowsBlankBranch() {            assertFalse(validating(git(\"/my/repo\", null)).errors().present());            assertFalse(validating(git(\"/my/repo\", \"\")).errors().present());            assertFalse(validating(git(\"/my/repo\", \" \")).errors().present());        }        @Test        void rejectsBranchWithWildcard() {            assertEquals(\"Branch names may not contain '*'\", validating(git(\"/foo\", \"branch-*\")).                    errors().on(GitMaterialConfig.BRANCH));        }        @Test        void rejectsMalformedRefSpec() {            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \":a\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \"   :b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/foo: \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/bar:\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \":\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \" : \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec source must be an absolute ref (must start with `refs/`)\",                    String.join(\";\", validating(git(\"/foo\", \"a:b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:my-branch\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/foo:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));        }        @Test        void acceptsValidRefSpecs() {            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:pr-123\")).errors().isEmpty());            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:refs/my-prs/123\")).errors().isEmpty());        }        @Test        void shouldEnsureUrlIsNotBlank() {            assertEquals(\"URL cannot be blank\", validating(git(\"\")).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setPassword(\"pass\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            gitMaterialConfig.setPassword(\"password\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            assertFalse(validating(git(\"http:        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"bob\");            gitMaterialConfig.setPassword(\"badger\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        private GitMaterialConfig validating(GitMaterialConfig git) {            git.validate(new ConfigSaveValidationContext(null));            return git;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(git(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = gitMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertFalse(validationResult);            assertEquals(\"Encrypted password value for GitMaterial with url 'http:                            \"invalid. This usually happens when the cipher text is modified to have an invalid value.\",                    gitMaterialConfig.errors().on(\"encryptedPassword\"));        }    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranchAndSubModuleFolder() {            final GitMaterialConfig material_1 = git(\"http:            material_1.setUserName(\"bob\");            material_1.setSubmoduleFolder(\"/var/lib/git\");            final GitMaterialConfig material_2 = git(\"http:            material_2.setUserName(\"alice\");            material_2.setSubmoduleFolder(\"/var/lib/git\");            assertTrue(material_1.equals(material_2));        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrlAndBranch() {            GitMaterialConfig gitMaterialConfig = git(\"https:            assertEquals(\"755da7fb7415c8674bdf5f8a4ba48fc3e071e5de429b1308ccf8949d215bdb08\", gitMaterialConfig.getFingerprint());        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.git;import static com.thoughtworks.go.helper.MaterialConfigsMother.hg;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class HgMaterialConfigTest {    private HgMaterialConfig hgMaterialConfig;    @BeforeEach    void setUp() {        hgMaterialConfig = hg(\"\", null);    }    @Test    void shouldBePasswordAwareMaterial() {        assertThat(hgMaterialConfig).isInstanceOf(PasswordAwareMaterial.class);    }    @Test    void shouldSetConfigAttributes() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.URL, \"url\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(hgMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(hgMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(hgMaterialConfig.isAutoUpdate()).isFalse();        assertThat(hgMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        HgMaterialConfig hgMaterialConfig = hg();        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.PASSWORD, \"secret\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"Hehehe\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"0\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getPassword()).isNull();        assertThat(hgMaterialConfig.getEncryptedPassword()).isNull();    }    @Test    void validate_shouldEnsureUrlIsNotBlank() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");    }    @Test    void shouldReturnIfAttributeMapIsNull() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.setConfigAttributes(null);        assertThat(hgMaterialConfig).isEqualTo(hg(\"\", null));    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg(url, null);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        HgMaterialConfig config = hg();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        HgMaterialConfig config = hg();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranch() {            final HgMaterialConfig material_1 = hg(\"http:            material_1.setUserName(\"bob\");            material_1.setBranchAttribute(\"feature\");            final HgMaterialConfig material_2 = hg(\"http:            material_2.setUserName(\"alice\");            material_2.setBranchAttribute(\"feature\");            assertThat(material_1.equals(material_2)).isTrue();        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"d84d91f37da0367a9bd89fff0d48638f5c1bf993d637735ec26f13c21c23da19\");        }        @Test        void shouldConsiderBranchWhileGeneratingFingerprint_IfBranchSpecifiedAsAnAttribute() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            hgMaterialConfig.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"db13278ed2b804fc5664361103bcea3d7f5106879683085caed4311aa4d2f888\");        }        @Test        void branchInUrlShouldGenerateFingerprintWhichIsOtherFromBranchInAttribute() {            HgMaterialConfig hgMaterialConfigWithBranchInUrl = hg(\"https:            HgMaterialConfig hgMaterialConfigWithBranchAsAttribute = hg(\"https:            hgMaterialConfigWithBranchAsAttribute.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfigWithBranchInUrl.getFingerprint())                    .isNotEqualTo(hgMaterialConfigWithBranchAsAttribute.getFingerprint());        }    }    @Nested    class validate {        @Test        void shouldEnsureUrlIsNotBlank() {            hgMaterialConfig.setUrl(\"\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            hgMaterialConfig.setUrl(null);            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            hgMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            hgMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setPassword(\"pass\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.setPassword(\"password\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"bob\");            hgMaterialConfig.setPassword(\"badger\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldEnsureBranchIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setBranchAttribute(\"branch-in-attribute\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous branch, must be provided either in URL or as an attribute.\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(hg(\"-url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertTrue(validating(hg(\"_url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertTrue(validating(hg(\"@url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertFalse(validating(hg(\"url-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));        }        private HgMaterialConfig validating(HgMaterialConfig hg) {            hg.validate(new ConfigSaveValidationContext(null));            return hg;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(hg(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = hgMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(hgMaterialConfig.errors().on(\"encryptedPassword\"))                    .isEqualTo(\"Encrypted password value for HgMaterial with url 'http:        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.hg;import static org.assertj.core.api.Assertions.assertThat;import static org.mockito.Mockito.*;class HgMaterialConfigTest {    private HgMaterialConfig hgMaterialConfig;    @BeforeEach    void setUp() {        hgMaterialConfig = hg(\"\", null);    }    @Test    void shouldBePasswordAwareMaterial() {        assertThat(hgMaterialConfig).isInstanceOf(PasswordAwareMaterial.class);    }    @Test    void shouldSetConfigAttributes() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.URL, \"url\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(hgMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(hgMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(hgMaterialConfig.isAutoUpdate()).isFalse();        assertThat(hgMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        HgMaterialConfig hgMaterialConfig = hg();        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.PASSWORD, \"secret\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"Hehehe\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"0\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getPassword()).isNull();        assertThat(hgMaterialConfig.getEncryptedPassword()).isNull();    }    @Test    void validate_shouldEnsureUrlIsNotBlank() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");    }    @Test    void shouldReturnIfAttributeMapIsNull() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.setConfigAttributes(null);        assertThat(hgMaterialConfig).isEqualTo(hg(\"\", null));    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg(url, null);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        HgMaterialConfig config = hg();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        HgMaterialConfig config = hg();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranch() {            final HgMaterialConfig material_1 = hg(\"http:            material_1.setUserName(\"bob\");            material_1.setBranchAttribute(\"feature\");            final HgMaterialConfig material_2 = hg(\"http:            material_2.setUserName(\"alice\");            material_2.setBranchAttribute(\"feature\");            assertThat(material_1.equals(material_2)).isTrue();        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"d84d91f37da0367a9bd89fff0d48638f5c1bf993d637735ec26f13c21c23da19\");        }        @Test        void shouldConsiderBranchWhileGeneratingFingerprint_IfBranchSpecifiedAsAnAttribute() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            hgMaterialConfig.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"db13278ed2b804fc5664361103bcea3d7f5106879683085caed4311aa4d2f888\");        }        @Test        void branchInUrlShouldGenerateFingerprintWhichIsOtherFromBranchInAttribute() {            HgMaterialConfig hgMaterialConfigWithBranchInUrl = hg(\"https:            HgMaterialConfig hgMaterialConfigWithBranchAsAttribute = hg(\"https:            hgMaterialConfigWithBranchAsAttribute.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfigWithBranchInUrl.getFingerprint())                    .isNotEqualTo(hgMaterialConfigWithBranchAsAttribute.getFingerprint());        }    }    @Nested    class validate {        @Test        void shouldEnsureUrlIsNotBlank() {            hgMaterialConfig.setUrl(\"\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            hgMaterialConfig.setUrl(null);            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            hgMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            hgMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setPassword(\"pass\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.setPassword(\"password\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"bob\");            hgMaterialConfig.setPassword(\"badger\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldEnsureBranchIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setBranchAttribute(\"branch-in-attribute\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous branch, must be provided either in URL or as an attribute.\");        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(hg(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = hgMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(hgMaterialConfig.errors().on(\"encryptedPassword\"))                    .isEqualTo(\"Encrypted password value for HgMaterial with url 'http:        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.AbstractMaterialConfig;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.p4;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class P4MaterialConfigTest {    private P4MaterialConfig p4MaterialConfig;    @BeforeEach    void setUp() {        p4MaterialConfig = p4(\"/foo/bar\", \"some-view\");    }    @Test    void shouldSetConfigAttributes() {        P4MaterialConfig p4MaterialConfig = p4(\"\", \"\");        Map<String, String> map = new HashMap<>();        map.put(P4MaterialConfig.SERVER_AND_PORT, \"serverAndPort\");        map.put(P4MaterialConfig.USERNAME, \"username\");        map.put(P4MaterialConfig.PASSWORD, \"password\");        map.put(P4MaterialConfig.USE_TICKETS, \"true\");        map.put(P4MaterialConfig.VIEW, \"some-view\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"false\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        p4MaterialConfig.setConfigAttributes(map);        assertThat(p4MaterialConfig.getServerAndPort()).isEqualTo(\"serverAndPort\");        assertThat(p4MaterialConfig.getUserName()).isEqualTo(\"username\");        assertThat(p4MaterialConfig.getView()).isEqualTo(\"some-view\");        assertThat(p4MaterialConfig.getUseTickets()).isTrue();        assertThat(p4MaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(p4MaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(p4MaterialConfig.isAutoUpdate()).isFalse();        assertThat(p4MaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void validate_shouldEnsureThatViewIsNotBlank() {        assertError(\"example.com:1233\", \"\", P4MaterialConfig.VIEW, \"P4 view cannot be empty.\");    }    @Test    void shouldNotDoAnyValidationOnP4PortExceptToEnsureThatItIsNotEmpty() {        assertError(\"\", \"view\", P4MaterialConfig.SERVER_AND_PORT, \"P4 port cannot be empty.\");        assertError(\" \", \"view\", P4MaterialConfig.SERVER_AND_PORT, \"P4 port cannot be empty.\");        assertNoError(\"example.com:1818\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"ssl:host:1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"ssl:host:non_numerical_port\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"complete_junk:::abc:::123:::def\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\":1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\":abc\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"tcp:abc:1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);    }    @Test    void shouldReturnIfAttributeMapIsNull() {        P4MaterialConfig p4MaterialConfig = p4(\"\", \"\");        p4MaterialConfig.setConfigAttributes(null);        assertThat(p4MaterialConfig).isEqualTo(p4(\"\", \"\"));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        P4MaterialConfig materialConfig = p4(\"\", \"\");        materialConfig.setPassword(\"notSecret\");        Map<String, String> map = new HashMap<>();        map.put(P4MaterialConfig.PASSWORD, \"secret\");        map.put(P4MaterialConfig.PASSWORD_CHANGED, \"1\");        materialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(materialConfig, \"password\")).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(P4MaterialConfig.PASSWORD, \"Hehehe\");        map.put(P4MaterialConfig.PASSWORD_CHANGED, \"0\");        materialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(materialConfig, \"password\")).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(P4MaterialConfig.PASSWORD, \"\");        map.put(P4MaterialConfig.PASSWORD_CHANGED, \"1\");        materialConfig.setConfigAttributes(map);        assertThat(materialConfig.getPassword()).isNull();        assertThat(materialConfig.getEncryptedPassword()).isNull();    }    @Test    void shouldNotSetUseTicketsIfNotInConfigAttributesMap() {        P4MaterialConfig p4MaterialConfig = p4(\"\", \"\");        HashMap<String, String> map = new HashMap<>();        map.put(P4MaterialConfig.USE_TICKETS, \"true\");        p4MaterialConfig.setConfigAttributes(map);        assertThat(p4MaterialConfig.getUseTickets()).isTrue();        p4MaterialConfig.setConfigAttributes(new HashMap());        assertThat(p4MaterialConfig.getUseTickets()).isFalse();    }    @Nested    class Validate {        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(p4(\"-url-not-starting-with-an-alphanumeric-character\", \"view\")).errors().containsKey(P4MaterialConfig.SERVER_AND_PORT));            assertTrue(validating(p4(\"_url-not-starting-with-an-alphanumeric-character\", \"view\")).errors().containsKey(P4MaterialConfig.SERVER_AND_PORT));            assertTrue(validating(p4(\"@url-not-starting-with-an-alphanumeric-character\", \"view\")).errors().containsKey(P4MaterialConfig.SERVER_AND_PORT));            assertFalse(validating(p4(\"url-starting-with-an-alphanumeric-character\", \"view\")).errors().containsKey(P4MaterialConfig.SERVER_AND_PORT));        }        private P4MaterialConfig validating(P4MaterialConfig p4) {            p4.validate(new ConfigSaveValidationContext(null));            return p4;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(new P4MaterialConfig());            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            p4MaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = p4MaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(p4MaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for P4Material with url '/foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            p4MaterialConfig.setPassword(\"badger\");            assertThat(p4MaterialConfig.validateTree(null)).isTrue();            assertThat(p4MaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }    private void assertNoError(String port, String view, String expectedKeyForError) {        P4MaterialConfig p4MaterialConfig = p4(port, view);        p4MaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(p4MaterialConfig.errors().on(expectedKeyForError)).isNull();    }    private void assertError(String port, String view, String expectedKeyForError, String expectedErrorMessage) {        P4MaterialConfig p4MaterialConfig = p4(port, view);        p4MaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(p4MaterialConfig.errors().on(expectedKeyForError)).isEqualTo(expectedErrorMessage);    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.AbstractMaterialConfig;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.config.materials.svn.SvnMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.p4;import static org.assertj.core.api.Assertions.assertThat;import static org.mockito.Mockito.*;class P4MaterialConfigTest {    private P4MaterialConfig p4MaterialConfig;    @BeforeEach    void setUp() {        p4MaterialConfig = p4(\"/foo/bar\", \"some-view\");    }    @Test    void shouldSetConfigAttributes() {        P4MaterialConfig p4MaterialConfig = p4(\"\", \"\");        Map<String, String> map = new HashMap<>();        map.put(P4MaterialConfig.SERVER_AND_PORT, \"serverAndPort\");        map.put(P4MaterialConfig.USERNAME, \"username\");        map.put(P4MaterialConfig.PASSWORD, \"password\");        map.put(P4MaterialConfig.USE_TICKETS, \"true\");        map.put(P4MaterialConfig.VIEW, \"some-view\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"false\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        p4MaterialConfig.setConfigAttributes(map);        assertThat(p4MaterialConfig.getServerAndPort()).isEqualTo(\"serverAndPort\");        assertThat(p4MaterialConfig.getUserName()).isEqualTo(\"username\");        assertThat(p4MaterialConfig.getView()).isEqualTo(\"some-view\");        assertThat(p4MaterialConfig.getUseTickets()).isTrue();        assertThat(p4MaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(p4MaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(p4MaterialConfig.isAutoUpdate()).isFalse();        assertThat(p4MaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void validate_shouldEnsureThatViewIsNotBlank() {        assertError(\"example.com:1233\", \"\", P4MaterialConfig.VIEW, \"P4 view cannot be empty.\");    }    @Test    void shouldNotDoAnyValidationOnP4PortExceptToEnsureThatItIsNotEmpty() {        assertError(\"\", \"view\", P4MaterialConfig.SERVER_AND_PORT, \"P4 port cannot be empty.\");        assertError(\" \", \"view\", P4MaterialConfig.SERVER_AND_PORT, \"P4 port cannot be empty.\");        assertNoError(\"example.com:1818\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"ssl:host:1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"ssl:host:non_numerical_port\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"complete_junk:::abc:::123:::def\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\":1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\":abc\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);        assertNoError(\"tcp:abc:1234\", \"view\", P4MaterialConfig.SERVER_AND_PORT);    }    @Test    void shouldReturnIfAttributeMapIsNull() {        P4MaterialConfig p4MaterialConfig = p4(\"\", \"\");        p4MaterialConfig.setConfigAttributes(null);        assertThat(p4MaterialConfig).isEqualTo(p4(\"\", \"\"));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        P4MaterialConfig materialConfig = p4(\"\", \"\");        materialConfig.setPassword(\"notSecret\");        Map<String, String> map = new HashMap<>();        map.put(P4MaterialConfig.PASSWORD, \"secret\");        map.put(P4MaterialConfig.PASSWORD_CHANGED, \"1\");        materialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(materialConfig, \"password\")).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"Hehehe\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"0\");        materialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(materialConfig, \"password\")).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        materialConfig.setConfigAttributes(map);        assertThat(materialConfig.getPassword()).isNull();        assertThat(materialConfig.getEncryptedPassword()).isNull();    }    @Test    void shouldNotSetUseTicketsIfNotInConfigAttributesMap() {        P4MaterialConfig p4MaterialConfig = p4(\"\", \"\");        HashMap<String, String> map = new HashMap<>();        map.put(P4MaterialConfig.USE_TICKETS, \"true\");        p4MaterialConfig.setConfigAttributes(map);        assertThat(p4MaterialConfig.getUseTickets()).isTrue();        p4MaterialConfig.setConfigAttributes(new HashMap());        assertThat(p4MaterialConfig.getUseTickets()).isFalse();    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(new P4MaterialConfig());            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            p4MaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = p4MaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(p4MaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for P4Material with url '/foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            p4MaterialConfig.setPassword(\"badger\");            assertThat(p4MaterialConfig.validateTree(null)).isTrue();            assertThat(p4MaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }    private void assertNoError(String port, String view, String expectedKeyForError) {        P4MaterialConfig p4MaterialConfig = p4(port, view);        p4MaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(p4MaterialConfig.errors().on(expectedKeyForError)).isNull();    }    private void assertError(String port, String view, String expectedKeyForError, String expectedErrorMessage) {        P4MaterialConfig p4MaterialConfig = p4(port, view);        p4MaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(p4MaterialConfig.errors().on(expectedKeyForError)).isEqualTo(expectedErrorMessage);    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.AbstractMaterialConfig;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.svn;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class SvnMaterialConfigTest {    private SvnMaterialConfig svnMaterialConfig;    @BeforeEach    void setUp() {        svnMaterialConfig = svn();    }    @Test    void shouldSetConfigAttributes() {        SvnMaterialConfig svnMaterialConfig = svn(\"\", \"\", \"\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.URL, \"url\");        map.put(SvnMaterialConfig.USERNAME, \"username\");        map.put(SvnMaterialConfig.CHECK_EXTERNALS, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        svnMaterialConfig.setConfigAttributes(map);        assertThat(svnMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(svnMaterialConfig.getUserName()).isEqualTo(\"username\");        assertThat(svnMaterialConfig.isCheckExternals()).isTrue();        assertThat(svnMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(svnMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(svnMaterialConfig.isAutoUpdate()).isFalse();        assertThat(svnMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        SvnMaterialConfig svnMaterial = svn(\"\", \"\", \"notSoSecret\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.PASSWORD, \"secret\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"Hehehe\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"0\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(svnMaterial.getPassword()).isNull();        assertThat(svnMaterial.getEncryptedPassword()).isNull();    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        SvnMaterialConfig config = svn();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        SvnMaterialConfig config = svn();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        SvnMaterialConfig config = svn();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateURL {        @Test        void shouldEnsureUrlIsNotBlank() {            svnMaterialConfig.setUrl(\"\");            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(GitMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isNull();            svnMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            svnMaterialConfig.setConfigAttributes(Collections.singletonMap(ScmMaterialConfig.FOLDER, \"../a\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(svn(\"-url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertTrue(validating(svn(\"_url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertTrue(validating(svn(\"@url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertFalse(validating(svn(\"url-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));        }        private SvnMaterialConfig validating(SvnMaterialConfig svn) {            svn.validate(new ConfigSaveValidationContext(null));            return svn;        }    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            svnMaterialConfig.setUrl(\"foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(svnMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            svnMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = svnMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(svnMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for SvnMaterial with url 'foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            svnMaterialConfig.setPassword(\"badger\");            assertThat(svnMaterialConfig.validateTree(null)).isTrue();            assertThat(svnMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.AbstractMaterialConfig;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.svn;import static org.assertj.core.api.Assertions.assertThat;import static org.mockito.Mockito.*;class SvnMaterialConfigTest {    private SvnMaterialConfig svnMaterialConfig;    @BeforeEach    void setUp() {        svnMaterialConfig = svn();    }    @Test    void shouldSetConfigAttributes() {        SvnMaterialConfig svnMaterialConfig = svn(\"\", \"\", \"\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.URL, \"url\");        map.put(SvnMaterialConfig.USERNAME, \"username\");        map.put(SvnMaterialConfig.CHECK_EXTERNALS, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        svnMaterialConfig.setConfigAttributes(map);        assertThat(svnMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(svnMaterialConfig.getUserName()).isEqualTo(\"username\");        assertThat(svnMaterialConfig.isCheckExternals()).isTrue();        assertThat(svnMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(svnMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(svnMaterialConfig.isAutoUpdate()).isFalse();        assertThat(svnMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        SvnMaterialConfig svnMaterial = svn(\"\", \"\", \"notSoSecret\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.PASSWORD, \"secret\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"Hehehe\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"0\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(svnMaterial.getPassword()).isNull();        assertThat(svnMaterial.getEncryptedPassword()).isNull();    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        SvnMaterialConfig config = svn();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        SvnMaterialConfig config = svn();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        SvnMaterialConfig config = svn();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateURL {        @Test        void shouldEnsureUrlIsNotBlank() {            svnMaterialConfig.setUrl(\"\");            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(GitMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isNull();            svnMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            svnMaterialConfig.setConfigAttributes(Collections.singletonMap(ScmMaterialConfig.FOLDER, \"../a\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            svnMaterialConfig.setUrl(\"foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(svnMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            svnMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = svnMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(svnMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for SvnMaterial with url 'foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            svnMaterialConfig.setPassword(\"badger\");            assertThat(svnMaterialConfig.validateTree(null)).isTrue();            assertThat(svnMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.CryptoException;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import com.thoughtworks.go.util.command.UrlArgument;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.tfs;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.api.Assertions.fail;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class TfsMaterialConfigTest {    private TfsMaterialConfig tfsMaterialConfig;    @BeforeEach    void setUp() {        tfsMaterialConfig = tfs(new GoCipher(), null, \"loser\", \"some_domain\", \"passwd\", \"walk_this_path\");    }    @Test    void shouldSetConfigAttributes() {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(URL, \"http:        map.put(ScmMaterialConfig.USERNAME, \"boozer\");        map.put(ScmMaterialConfig.PASSWORD, \"secret\");        map.put(FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(MATERIAL_NAME, \"my-tfs-material-name\");        map.put(TfsMaterialConfig.PROJECT_PATH, \"/useless/project\");        map.put(TfsMaterialConfig.DOMAIN, \"CORPORATE\");        tfsMaterialConfig.setConfigAttributes(map);        TfsMaterialConfig newTfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        newTfsMaterialConfig.setName(new CaseInsensitiveString(\"my-tfs-material-name\"));        newTfsMaterialConfig.setFolder(\"folder\");        assertThat(tfsMaterialConfig).isEqualTo(newTfsMaterialConfig);        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"passwd\");        assertThat(tfsMaterialConfig.isAutoUpdate()).isFalse();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"CORPORATE\");        assertThat(tfsMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"my-tfs-material-name\"));        assertThat(tfsMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void shouldDefaultDomainToEmptyStringWhenNothingIsSet() {        TfsMaterialConfig tfsMaterialConfig = tfs();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"\");    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(TfsMaterialConfig.PASSWORD, \"secret\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"Hehehe\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"0\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(tfsMaterialConfig.getPassword()).isNull();        assertThat(tfsMaterialConfig.getEncryptedPassword()).isNull();    }    @Nested    class Validate {        @Test        void shouldEnsureMandatoryFieldsAreNotBlank() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"\"), \"\", \"CORPORATE\", \"\", \"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.USERNAME)).isEqualTo(\"Username cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.PROJECT_PATH)).isEqualTo(\"Project Path cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            tfsMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUrlIsNotBlank() {            tfsMaterialConfig.setUrl(\"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            tfsMaterialConfig.setUrl(null);            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(tfs(\"-url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertTrue(validating(tfs(\"_url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertTrue(validating(tfs(\"@url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertFalse(validating(tfs(\"url-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));        }        private TfsMaterialConfig validating(TfsMaterialConfig tfs) {            tfs.validate(new ConfigSaveValidationContext(null));            return tfs;        }    }    @Test    void shouldEncryptTfsPasswordAndMarkPasswordAsNull() throws Exception {        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        Object passwordFieldValue = ReflectionUtil.getField(materialConfig, \"password\");        assertThat(passwordFieldValue).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"password\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"password\"));    }    @Test    void shouldDecryptTfsPassword() throws Exception {        String encryptedPassword = new GoCipher().encrypt(\"plain-text-password\");        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", encryptedPassword);        materialConfig.ensureEncrypted();        assertThat(materialConfig.getPassword()).isEqualTo(\"plain-text-password\");    }    @Test    void shouldNotDecryptTfsPasswordIfPasswordIsNotNull() throws Exception {        GoCipher mockGoCipher = mock(GoCipher.class);        when(mockGoCipher.encrypt(\"password\")).thenReturn(\"encrypted\");        when(mockGoCipher.decrypt(\"encrypted\")).thenReturn(\"password\");        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        when(mockGoCipher.encrypt(\"new_password\")).thenReturn(\"new_encrypted\");        materialConfig.setPassword(\"new_password\");        when(mockGoCipher.decrypt(\"new_encrypted\")).thenReturn(\"new_password\");        assertThat(materialConfig.getPassword()).isEqualTo(\"new_password\");    }    @Test    void shouldErrorOutIfDecryptionFails() throws CryptoException {        GoCipher mockGoCipher = mock(GoCipher.class);        String fakeCipherText = \"fake cipher text\";        when(mockGoCipher.decrypt(fakeCipherText)).thenThrow(new CryptoException(\"exception\"));        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", fakeCipherText);        try {            materialConfig.getPassword();            fail(\"Should have thrown up\");        } catch (Exception e) {            assertThat(e.getMessage()).isEqualTo(\"Could not decrypt the password to get the real password\");        }    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        TfsMaterialConfig config = tfs();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        TfsMaterialConfig config = tfs();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        TfsMaterialConfig config = tfs();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            tfsMaterialConfig.setUrl(\"/foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(tfsMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            tfsMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = tfsMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(tfsMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for TfsMaterial with url '/foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            tfsMaterialConfig.setPassword(\"badger\");            assertThat(tfsMaterialConfig.validateTree(null)).isTrue();            assertThat(tfsMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.CryptoException;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import com.thoughtworks.go.util.command.UrlArgument;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.tfs;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.api.Assertions.fail;import static org.mockito.Mockito.*;class TfsMaterialConfigTest {    private TfsMaterialConfig tfsMaterialConfig;    @BeforeEach    void setUp() {        tfsMaterialConfig = tfs(new GoCipher(), null, \"loser\", \"some_domain\", \"passwd\", \"walk_this_path\");    }    @Test    void shouldSetConfigAttributes() {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(URL, \"http:        map.put(ScmMaterialConfig.USERNAME, \"boozer\");        map.put(ScmMaterialConfig.PASSWORD, \"secret\");        map.put(FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(MATERIAL_NAME, \"my-tfs-material-name\");        map.put(TfsMaterialConfig.PROJECT_PATH, \"/useless/project\");        map.put(TfsMaterialConfig.DOMAIN, \"CORPORATE\");        tfsMaterialConfig.setConfigAttributes(map);        TfsMaterialConfig newTfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        newTfsMaterialConfig.setName(new CaseInsensitiveString(\"my-tfs-material-name\"));        newTfsMaterialConfig.setFolder(\"folder\");        assertThat(tfsMaterialConfig).isEqualTo(newTfsMaterialConfig);        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"passwd\");        assertThat(tfsMaterialConfig.isAutoUpdate()).isFalse();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"CORPORATE\");        assertThat(tfsMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"my-tfs-material-name\"));        assertThat(tfsMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void shouldDefaultDomainToEmptyStringWhenNothingIsSet() {        TfsMaterialConfig tfsMaterialConfig = tfs();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"\");    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(TfsMaterialConfig.PASSWORD, \"secret\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"Hehehe\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"0\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(tfsMaterialConfig.getPassword()).isNull();        assertThat(tfsMaterialConfig.getEncryptedPassword()).isNull();    }    @Nested    class Validate {        @Test        void shouldEnsureMandatoryFieldsAreNotBlank() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"\"), \"\", \"CORPORATE\", \"\", \"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.USERNAME)).isEqualTo(\"Username cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.PROJECT_PATH)).isEqualTo(\"Project Path cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            tfsMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUrlIsNotBlank() {            tfsMaterialConfig.setUrl(\"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            tfsMaterialConfig.setUrl(null);            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }    }    @Test    void shouldEncryptTfsPasswordAndMarkPasswordAsNull() throws Exception {        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        Object passwordFieldValue = ReflectionUtil.getField(materialConfig, \"password\");        assertThat(passwordFieldValue).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"password\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"password\"));    }    @Test    void shouldDecryptTfsPassword() throws Exception {        String encryptedPassword = new GoCipher().encrypt(\"plain-text-password\");        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", encryptedPassword);        materialConfig.ensureEncrypted();        assertThat(materialConfig.getPassword()).isEqualTo(\"plain-text-password\");    }    @Test    void shouldNotDecryptTfsPasswordIfPasswordIsNotNull() throws Exception {        GoCipher mockGoCipher = mock(GoCipher.class);        when(mockGoCipher.encrypt(\"password\")).thenReturn(\"encrypted\");        when(mockGoCipher.decrypt(\"encrypted\")).thenReturn(\"password\");        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        when(mockGoCipher.encrypt(\"new_password\")).thenReturn(\"new_encrypted\");        materialConfig.setPassword(\"new_password\");        when(mockGoCipher.decrypt(\"new_encrypted\")).thenReturn(\"new_password\");        assertThat(materialConfig.getPassword()).isEqualTo(\"new_password\");    }    @Test    void shouldErrorOutIfDecryptionFails() throws CryptoException {        GoCipher mockGoCipher = mock(GoCipher.class);        String fakeCipherText = \"fake cipher text\";        when(mockGoCipher.decrypt(fakeCipherText)).thenThrow(new CryptoException(\"exception\"));        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", fakeCipherText);        try {            materialConfig.getPassword();            fail(\"Should have thrown up\");        } catch (Exception e) {            assertThat(e.getMessage()).isEqualTo(\"Could not decrypt the password to get the real password\");        }    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        TfsMaterialConfig config = tfs();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        TfsMaterialConfig config = tfs();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        TfsMaterialConfig config = tfs();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            tfsMaterialConfig.setUrl(\"/foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(tfsMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            tfsMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = tfsMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(tfsMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for TfsMaterial with url '/foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            tfsMaterialConfig.setPassword(\"badger\");            assertThat(tfsMaterialConfig.validateTree(null)).isTrue();            assertThat(tfsMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.config.CaseInsensitiveString;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.config.materials.dependency.DependencyMaterialConfig;import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.config.materials.mercurial.HgMaterialConfig;import com.thoughtworks.go.config.materials.perforce.P4MaterialConfig;import com.thoughtworks.go.config.materials.svn.SvnMaterialConfig;import com.thoughtworks.go.config.materials.tfs.TfsMaterialConfig;import com.thoughtworks.go.domain.config.Configuration;import com.thoughtworks.go.domain.config.ConfigurationKey;import com.thoughtworks.go.domain.config.ConfigurationProperty;import com.thoughtworks.go.domain.config.ConfigurationValue;import com.thoughtworks.go.domain.packagerepository.*;import com.thoughtworks.go.domain.scm.SCM;import com.thoughtworks.go.domain.scm.SCMMother;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.command.HgUrlArgument;import com.thoughtworks.go.util.command.UrlArgument;import static com.thoughtworks.go.util.DataStructureUtils.m;public class MaterialConfigsMother {    public static GitMaterialConfig git() {        return new GitMaterialConfig();    }    public static GitMaterialConfig git(String url) {        GitMaterialConfig gitMaterialConfig = git();        gitMaterialConfig.setUrl(url);        return gitMaterialConfig;    }    public static GitMaterialConfig git(String url, String branch) {        GitMaterialConfig gitMaterialConfig = git(url);        gitMaterialConfig.setBranch(branch);        return gitMaterialConfig;    }    public static GitMaterialConfig git(String url, boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url);        gitMaterialConfig.setShallowClone(shallowClone);        return gitMaterialConfig;    }    public static GitMaterialConfig git(String url, String branch, boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url, branch);        gitMaterialConfig.setShallowClone(shallowClone);        return gitMaterialConfig;    }    public static GitMaterialConfig git(UrlArgument url, String userName, String password, String branch, String submoduleFolder,                                        boolean autoUpdate, Filter filter, boolean invertFilter, String folder,                                        CaseInsensitiveString name, Boolean shallowClone) {        return git(url.originalArgument(), userName, password, branch, submoduleFolder, autoUpdate, filter, invertFilter, folder, name, shallowClone);    }    public static GitMaterialConfig git(String url, String userName, String password, String branch, String submoduleFolder,                                        boolean autoUpdate, Filter filter, boolean invertFilter, String folder,                                        CaseInsensitiveString name, Boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url, branch, shallowClone);        gitMaterialConfig.setUserName(userName);        gitMaterialConfig.setPassword(password);        gitMaterialConfig.setSubmoduleFolder(submoduleFolder);        gitMaterialConfig.setAutoUpdate(autoUpdate);        gitMaterialConfig.setFilter(filter);        gitMaterialConfig.setInvertFilter(invertFilter);        gitMaterialConfig.setFolder(folder);        gitMaterialConfig.setName(name);        return gitMaterialConfig;    }    public static HgMaterialConfig hg() {        return new HgMaterialConfig();    }    public static HgMaterialConfig hg(String url, String folder) {        HgMaterialConfig config = hg();        config.setUrl(url);        config.setFolder(folder);        return config;    }    public static HgMaterialConfig hg(HgUrlArgument url, String userName, String password, String branch, boolean autoUpdate,                                      Filter filter, boolean invertFilter, String folder, CaseInsensitiveString name) {        return hg(url.originalArgument(), userName, password, branch, autoUpdate, filter, invertFilter, folder, name);    }    public static HgMaterialConfig hg(String url, String userName, String password, String branch, boolean autoUpdate,                                      Filter filter, boolean invertFilter, String folder, CaseInsensitiveString name) {        HgMaterialConfig config = hg(url, folder);        config.setUserName(userName);        config.setPassword(password);        config.setBranchAttribute(branch);        config.setAutoUpdate(autoUpdate);        config.setFilter(filter);        config.setInvertFilter(invertFilter);        config.setName(name);        return config;    }    public static SvnMaterialConfig svn() {        return new SvnMaterialConfig();    }    public static SvnMaterialConfig svn(String url, boolean checkExternals) {        return svn(url, null, null, checkExternals);    }    public static SvnMaterialConfig svn(String url, String userName, String password, boolean checkExternals) {        return svn(url, userName, password, checkExternals, new GoCipher());    }    public static SvnMaterialConfig svn(String url, String userName, String password, boolean checkExternals, String folder) {        SvnMaterialConfig svnMaterialConfig = svn(url, userName, password, checkExternals);        svnMaterialConfig.setFolder(folder);        return svnMaterialConfig;    }    public static SvnMaterialConfig svn(String url, String userName, String password, boolean checkExternals, GoCipher goCipher) {        SvnMaterialConfig svnMaterialConfig = svn();        svnMaterialConfig.setUrl(url);        svnMaterialConfig.setUserName(userName);        svnMaterialConfig.setPassword(password);        svnMaterialConfig.setCheckExternals(checkExternals);        return svnMaterialConfig;    }    public static SvnMaterialConfig svn(UrlArgument url, String userName, String password, boolean checkExternals,                                        GoCipher goCipher, boolean autoUpdate, Filter filter, boolean invertFilter,                                        String folder, CaseInsensitiveString name) {        SvnMaterialConfig svnMaterialConfig = svn();        svnMaterialConfig.setUrl(url.originalArgument());        svnMaterialConfig.setUserName(userName);        svnMaterialConfig.setPassword(password);        svnMaterialConfig.setCheckExternals(checkExternals);        svnMaterialConfig.setAutoUpdate(autoUpdate);        svnMaterialConfig.setFilter(filter);        svnMaterialConfig.setInvertFilter(invertFilter);        svnMaterialConfig.setFolder(folder);        svnMaterialConfig.setName(name);        return svnMaterialConfig;    }    public static TfsMaterialConfig tfs() {        return new TfsMaterialConfig();    }    public static TfsMaterialConfig tfs(GoCipher goCipher, String url, String userName, String domain, String projectPath) {        return tfs(goCipher, new UrlArgument(url), userName, domain, null, projectPath);    }    public static TfsMaterialConfig tfs(String url) {        return tfs(new GoCipher(), new UrlArgument(url), null, null, \"password\");    }    public static TfsMaterialConfig tfs(UrlArgument urlArgument, String password, String encryptedPassword, GoCipher goCipher) {        TfsMaterialConfig tfsMaterialConfig = tfs(goCipher, urlArgument, null, null, password);        tfsMaterialConfig.setEncryptedPassword(encryptedPassword);        return tfsMaterialConfig;    }    public static TfsMaterialConfig tfs(GoCipher goCipher, UrlArgument url, String userName, String domain, String projectPath) {        return tfs(goCipher, url.originalArgument(), userName, domain, projectPath);    }    public static TfsMaterialConfig tfs(GoCipher goCipher, UrlArgument url, String userName, String domain, String password, String projectPath) {        return tfs(url, userName, domain, password, projectPath, goCipher, true, null, false, null, null);    }    public static TfsMaterialConfig tfs(UrlArgument url, String userName, String domain, String password, String projectPath,                                        GoCipher goCipher, boolean autoUpdate, Filter filter, boolean invertFilter,                                        String folder, CaseInsensitiveString name) {        TfsMaterialConfig tfsMaterialConfig = new TfsMaterialConfig();        tfsMaterialConfig.setUrl(url == null ? null : url.originalArgument());        tfsMaterialConfig.setUserName(userName);        tfsMaterialConfig.setDomain(domain);        tfsMaterialConfig.setPassword(password);        tfsMaterialConfig.setProjectPath(projectPath);        tfsMaterialConfig.setAutoUpdate(autoUpdate);        tfsMaterialConfig.setFilter(filter);        tfsMaterialConfig.setInvertFilter(invertFilter);        tfsMaterialConfig.setFolder(folder);        tfsMaterialConfig.setName(name);        return tfsMaterialConfig;    }    public static P4MaterialConfig p4() {        return new P4MaterialConfig();    }    public static P4MaterialConfig p4(String serverAndPort, String view, GoCipher goCipher) {        P4MaterialConfig p4MaterialConfig = p4();        p4MaterialConfig.setUrl(serverAndPort);        p4MaterialConfig.setView(view);        return p4MaterialConfig;    }    public static P4MaterialConfig p4(String serverAndPort, String view) {        return p4(serverAndPort, view, new GoCipher());    }    public static P4MaterialConfig p4(String url, String view, String userName) {        P4MaterialConfig p4MaterialConfig = p4(url, view);        p4MaterialConfig.setUserName(userName);        return p4MaterialConfig;    }    public static P4MaterialConfig p4(String serverAndPort, String password, String encryptedPassword, GoCipher goCipher) {        P4MaterialConfig p4MaterialConfig = p4();        p4MaterialConfig.setUrl(serverAndPort);        p4MaterialConfig.setPassword(password);        p4MaterialConfig.setEncryptedPassword(encryptedPassword);        return p4MaterialConfig;    }    public static P4MaterialConfig p4(String serverAndPort, String userName, String password, Boolean useTickets, String viewStr,                                      GoCipher goCipher, CaseInsensitiveString name, boolean autoUpdate, Filter filter,                                      boolean invertFilter, String folder) {        P4MaterialConfig p4MaterialConfig = p4();        p4MaterialConfig.setUrl(serverAndPort);        p4MaterialConfig.setUserName(userName);        p4MaterialConfig.setPassword(password);        p4MaterialConfig.setUseTickets(useTickets);        p4MaterialConfig.setView(viewStr);        p4MaterialConfig.setAutoUpdate(autoUpdate);        p4MaterialConfig.setFilter(filter);        p4MaterialConfig.setInvertFilter(invertFilter);        p4MaterialConfig.setFolder(folder);        p4MaterialConfig.setName(name);        return p4MaterialConfig;    }    public static MaterialConfigs defaultMaterialConfigs() {        return defaultSvnMaterialConfigsWithUrl(\"http:    }    public static MaterialConfigs defaultSvnMaterialConfigsWithUrl(String svnUrl) {        return new MaterialConfigs(svnMaterialConfig(svnUrl, \"svnDir\", null, null, false, null));    }    public static MaterialConfigs multipleMaterialConfigs() {        MaterialConfigs materialConfigs = new MaterialConfigs();        materialConfigs.add(svnMaterialConfig(\"http:        materialConfigs.add(hgMaterialConfig(\"http:        materialConfigs.add(dependencyMaterialConfig(\"cruise\", \"dev\"));        return materialConfigs;    }    public static PackageMaterialConfig packageMaterialConfig() {        return packageMaterialConfig(\"repo-name\", \"package-name\");    }    public static PackageMaterialConfig packageMaterialConfig(String repoName, String packageName) {        PackageMaterialConfig material = new PackageMaterialConfig(\"p-id\");        PackageRepository repository = PackageRepositoryMother.create(\"repo-id\", repoName, \"pluginid\", \"version\",                new Configuration(ConfigurationPropertyMother.create(\"k1\", false, \"repo-v1\"), ConfigurationPropertyMother.create(\"k2\", false, \"repo-v2\")));        PackageDefinition packageDefinition = PackageDefinitionMother.create(\"p-id\", packageName, new Configuration(ConfigurationPropertyMother.create(\"k3\", false, \"package-v1\")), repository);        material.setPackageDefinition(packageDefinition);        repository.getPackages().add(packageDefinition);        return material;    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfig() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return pluggableSCMMaterialConfig(\"scm-id\", \"des-folder\", filter);    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfigWithConfigProperties(String... properties) {        SCM scmConfig = SCMMother.create(\"scm-id\");        Configuration configuration = new Configuration();        for (String property : properties) {            ConfigurationProperty configurationProperty = new ConfigurationProperty(new ConfigurationKey(property), new ConfigurationValue(property + \"-value\"));            configuration.add(configurationProperty);        }        scmConfig.setConfiguration(configuration);        return new PluggableSCMMaterialConfig(null, scmConfig, \"des-folder\", null, false);    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfig(String scmId, String... properties) {        return new PluggableSCMMaterialConfig(null, SCMMother.create(scmId, properties), \"des-folder\", null, false);    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfig(String scmId, String destinationFolder, Filter filter) {        return new PluggableSCMMaterialConfig(null, SCMMother.create(scmId), destinationFolder, filter, false);    }    public static DependencyMaterialConfig dependencyMaterialConfig(String pipelineName, String stageName) {        return new DependencyMaterialConfig(new CaseInsensitiveString(pipelineName), new CaseInsensitiveString(stageName));    }    public static DependencyMaterialConfig dependencyMaterialConfig() {        return new DependencyMaterialConfig(new CaseInsensitiveString(\"pipeline-name\"), new CaseInsensitiveString(\"stage-name\"), true);    }    public static HgMaterialConfig hgMaterialConfigFull() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return hg(new HgUrlArgument(\"http:    }    public static HgMaterialConfig hgMaterialConfigFull(String url) {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return hg(new HgUrlArgument(url), null, null, null, true, filter, false, \"dest-folder\", new CaseInsensitiveString(\"hg-material\"));    }    public static HgMaterialConfig hgMaterialConfig() {        return hgMaterialConfig(\"hg-url\");    }    public static HgMaterialConfig hgMaterialConfig(String url) {        return hgMaterialConfig(url, null);    }    public static HgMaterialConfig hgMaterialConfig(String url, String folder) {        return hg(url, folder);    }    public static GitMaterialConfig gitMaterialConfig(String url, String submoduleFolder, String branch, boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url, branch);        gitMaterialConfig.setShallowClone(shallowClone);        gitMaterialConfig.setSubmoduleFolder(submoduleFolder);        return gitMaterialConfig;    }    public static GitMaterialConfig gitMaterialConfig() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return git(new UrlArgument(\"http:    }    public static GitMaterialConfig gitMaterialConfig(String url) {        return git(url);    }    public static P4MaterialConfig p4MaterialConfig() {        return p4MaterialConfig(\"serverAndPort\", null, null, \"view\", false);    }    public static P4MaterialConfig p4MaterialConfigFull() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        P4MaterialConfig config = p4MaterialConfig(\"host:9876\", \"user\", \"password\", \"view\", true);        config.setFolder(\"dest-folder\");        config.setFilter(filter);        config.setName(new CaseInsensitiveString(\"p4-material\"));        return config;    }    public static P4MaterialConfig p4MaterialConfig(String serverAndPort, String userName, String password, String view, boolean useTickets) {        final P4MaterialConfig material = p4(serverAndPort, view);        material.setConfigAttributes(m(P4MaterialConfig.USERNAME, userName, P4MaterialConfig.AUTO_UPDATE, \"true\"));        material.setPassword(password);        material.setUseTickets(useTickets);        return material;    }    public static SvnMaterialConfig svnMaterialConfig() {        return svnMaterialConfig(\"url\", \"svnDir\");    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder, CaseInsensitiveString name) {        SvnMaterialConfig svnMaterialConfig = svnMaterialConfig(svnUrl, folder);        svnMaterialConfig.setName(name);        return svnMaterialConfig;    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder) {        return svnMaterialConfig(svnUrl, folder, false);    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder, boolean autoUpdate) {        SvnMaterialConfig materialConfig = svn(new UrlArgument(svnUrl), \"user\", \"pass\", true, new GoCipher(), autoUpdate, new Filter(new IgnoredFiles(\"*.doc\")), false,                folder, new CaseInsensitiveString(\"svn-material\"));        materialConfig.setPassword(\"pass\");        return materialConfig;    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder, String userName, String password, boolean checkExternals, String filterPattern) {        SvnMaterialConfig svnMaterial = svn(svnUrl, userName, password, checkExternals, folder);        if (filterPattern != null)            svnMaterial.setFilter(new Filter(new IgnoredFiles(filterPattern)));        String name = svnUrl.replaceAll(\"/\", \"_\");        name = name.replaceAll(\":\", \"_\");        svnMaterial.setName(new CaseInsensitiveString(name));        return svnMaterial;    }    public static HgMaterialConfig filteredHgMaterialConfig(String pattern) {        HgMaterialConfig materialConfig = hgMaterialConfig();        materialConfig.setFilter(new Filter(new IgnoredFiles(pattern)));        return materialConfig;    }    public static MaterialConfigs mockMaterialConfigs(String url) {        return new MaterialConfigs(svn(url, null, null, false));    }    public static TfsMaterialConfig tfsMaterialConfig() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        tfsMaterialConfig.setFilter(filter);        tfsMaterialConfig.setName(new CaseInsensitiveString(\"tfs-material\"));        tfsMaterialConfig.setFolder(\"dest-folder\");        return tfsMaterialConfig;    }    public static GitMaterialConfig git(String url, String username, String password) {        GitMaterialConfig gitMaterialConfig = git(url);        gitMaterialConfig.setUserName(username);        gitMaterialConfig.setPassword(password);        return gitMaterialConfig;    }    public static HgMaterialConfig hg(String url, String username, String password) {        HgMaterialConfig materialConfig = hg(url, null);        materialConfig.setUserName(username);        materialConfig.setPassword(password);        return materialConfig;    }}", "nl": "import com.thoughtworks.go.config.CaseInsensitiveString;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.config.materials.dependency.DependencyMaterialConfig;import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.config.materials.mercurial.HgMaterialConfig;import com.thoughtworks.go.config.materials.perforce.P4MaterialConfig;import com.thoughtworks.go.config.materials.svn.SvnMaterialConfig;import com.thoughtworks.go.config.materials.tfs.TfsMaterialConfig;import com.thoughtworks.go.domain.config.Configuration;import com.thoughtworks.go.domain.config.ConfigurationKey;import com.thoughtworks.go.domain.config.ConfigurationProperty;import com.thoughtworks.go.domain.config.ConfigurationValue;import com.thoughtworks.go.domain.packagerepository.*;import com.thoughtworks.go.domain.scm.SCM;import com.thoughtworks.go.domain.scm.SCMMother;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.command.HgUrlArgument;import com.thoughtworks.go.util.command.UrlArgument;import static com.thoughtworks.go.util.DataStructureUtils.m;public class MaterialConfigsMother {    public static GitMaterialConfig git() {        return new GitMaterialConfig();    }    public static GitMaterialConfig git(String url) {        GitMaterialConfig gitMaterialConfig = git();        gitMaterialConfig.setUrl(url);        return gitMaterialConfig;    }    public static GitMaterialConfig git(String url, String branch) {        GitMaterialConfig gitMaterialConfig = git(url);        gitMaterialConfig.setBranch(branch);        return gitMaterialConfig;    }    public static GitMaterialConfig git(String url, boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url);        gitMaterialConfig.setShallowClone(shallowClone);        return gitMaterialConfig;    }    public static GitMaterialConfig git(String url, String branch, boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url, branch);        gitMaterialConfig.setShallowClone(shallowClone);        return gitMaterialConfig;    }    public static GitMaterialConfig git(UrlArgument url, String userName, String password, String branch, String submoduleFolder,                                        boolean autoUpdate, Filter filter, boolean invertFilter, String folder,                                        CaseInsensitiveString name, Boolean shallowClone) {        return git(url.originalArgument(), userName, password, branch, submoduleFolder, autoUpdate, filter, invertFilter, folder, name, shallowClone);    }    public static GitMaterialConfig git(String url, String userName, String password, String branch, String submoduleFolder,                                        boolean autoUpdate, Filter filter, boolean invertFilter, String folder,                                        CaseInsensitiveString name, Boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url, branch, shallowClone);        gitMaterialConfig.setUserName(userName);        gitMaterialConfig.setPassword(password);        gitMaterialConfig.setSubmoduleFolder(submoduleFolder);        gitMaterialConfig.setAutoUpdate(autoUpdate);        gitMaterialConfig.setFilter(filter);        gitMaterialConfig.setInvertFilter(invertFilter);        gitMaterialConfig.setFolder(folder);        gitMaterialConfig.setName(name);        return gitMaterialConfig;    }    public static HgMaterialConfig hg() {        return new HgMaterialConfig();    }    public static HgMaterialConfig hg(String url, String folder) {        HgMaterialConfig config = hg();        config.setUrl(url);        config.setFolder(folder);        return config;    }    public static HgMaterialConfig hg(HgUrlArgument url, String userName, String password, String branch, boolean autoUpdate,                                      Filter filter, boolean invertFilter, String folder, CaseInsensitiveString name) {        return hg(url.originalArgument(), userName, password, branch, autoUpdate, filter, invertFilter, folder, name);    }    public static HgMaterialConfig hg(String url, String userName, String password, String branch, boolean autoUpdate,                                      Filter filter, boolean invertFilter, String folder, CaseInsensitiveString name) {        HgMaterialConfig config = hg(url, folder);        config.setUserName(userName);        config.setPassword(password);        config.setBranchAttribute(branch);        config.setAutoUpdate(autoUpdate);        config.setFilter(filter);        config.setInvertFilter(invertFilter);        config.setName(name);        return config;    }    public static SvnMaterialConfig svn() {        return new SvnMaterialConfig();    }    public static SvnMaterialConfig svn(String url, boolean checkExternals) {        return svn(url, null, null, checkExternals);    }    public static SvnMaterialConfig svn(String url, String userName, String password, boolean checkExternals) {        return svn(url, userName, password, checkExternals, new GoCipher());    }    public static SvnMaterialConfig svn(String url, String userName, String password, boolean checkExternals, String folder) {        SvnMaterialConfig svnMaterialConfig = svn(url, userName, password, checkExternals);        svnMaterialConfig.setFolder(folder);        return svnMaterialConfig;    }    public static SvnMaterialConfig svn(String url, String userName, String password, boolean checkExternals, GoCipher goCipher) {        SvnMaterialConfig svnMaterialConfig = svn();        svnMaterialConfig.setUrl(url);        svnMaterialConfig.setUserName(userName);        svnMaterialConfig.setPassword(password);        svnMaterialConfig.setCheckExternals(checkExternals);        return svnMaterialConfig;    }    public static SvnMaterialConfig svn(UrlArgument url, String userName, String password, boolean checkExternals,                                        GoCipher goCipher, boolean autoUpdate, Filter filter, boolean invertFilter,                                        String folder, CaseInsensitiveString name) {        SvnMaterialConfig svnMaterialConfig = svn();        svnMaterialConfig.setUrl(url.originalArgument());        svnMaterialConfig.setUserName(userName);        svnMaterialConfig.setPassword(password);        svnMaterialConfig.setCheckExternals(checkExternals);        svnMaterialConfig.setAutoUpdate(autoUpdate);        svnMaterialConfig.setFilter(filter);        svnMaterialConfig.setInvertFilter(invertFilter);        svnMaterialConfig.setFolder(folder);        svnMaterialConfig.setName(name);        return svnMaterialConfig;    }    public static TfsMaterialConfig tfs() {        return new TfsMaterialConfig();    }    public static TfsMaterialConfig tfs(GoCipher goCipher, String url, String userName, String domain, String projectPath) {        return tfs(goCipher, new UrlArgument(url), userName, domain, null, projectPath);    }    public static TfsMaterialConfig tfs(UrlArgument urlArgument, String password, String encryptedPassword, GoCipher goCipher) {        TfsMaterialConfig tfsMaterialConfig = tfs(goCipher, urlArgument, null, null, password);        tfsMaterialConfig.setEncryptedPassword(encryptedPassword);        return tfsMaterialConfig;    }    public static TfsMaterialConfig tfs(GoCipher goCipher, UrlArgument url, String userName, String domain, String projectPath) {        return tfs(goCipher, url.originalArgument(), userName, domain, projectPath);    }    public static TfsMaterialConfig tfs(GoCipher goCipher, UrlArgument url, String userName, String domain, String password, String projectPath) {        return tfs(url, userName, domain, password, projectPath, goCipher, true, null, false, null, null);    }    public static TfsMaterialConfig tfs(UrlArgument url, String userName, String domain, String password, String projectPath,                                        GoCipher goCipher, boolean autoUpdate, Filter filter, boolean invertFilter,                                        String folder, CaseInsensitiveString name) {        TfsMaterialConfig tfsMaterialConfig = new TfsMaterialConfig();        tfsMaterialConfig.setUrl(url == null ? null : url.originalArgument());        tfsMaterialConfig.setUserName(userName);        tfsMaterialConfig.setDomain(domain);        tfsMaterialConfig.setPassword(password);        tfsMaterialConfig.setProjectPath(projectPath);        tfsMaterialConfig.setAutoUpdate(autoUpdate);        tfsMaterialConfig.setFilter(filter);        tfsMaterialConfig.setInvertFilter(invertFilter);        tfsMaterialConfig.setFolder(folder);        tfsMaterialConfig.setName(name);        return tfsMaterialConfig;    }    public static P4MaterialConfig p4() {        return new P4MaterialConfig();    }    public static P4MaterialConfig p4(String serverAndPort, String view, GoCipher goCipher) {        P4MaterialConfig p4MaterialConfig = p4();        p4MaterialConfig.setUrl(serverAndPort);        p4MaterialConfig.setView(view);        return p4MaterialConfig;    }    public static P4MaterialConfig p4(String serverAndPort, String view) {        return p4(serverAndPort, view, new GoCipher());    }    public static P4MaterialConfig p4(String url, String view, String userName) {        P4MaterialConfig p4MaterialConfig = p4(url, view);        p4MaterialConfig.setUserName(userName);        return p4MaterialConfig;    }    public static P4MaterialConfig p4(String serverAndPort, String password, String encryptedPassword, GoCipher goCipher) {        P4MaterialConfig p4MaterialConfig = p4();        p4MaterialConfig.setUrl(serverAndPort);        p4MaterialConfig.setPassword(password);        p4MaterialConfig.setEncryptedPassword(encryptedPassword);        return p4MaterialConfig;    }    public static P4MaterialConfig p4(String serverAndPort, String userName, String password, Boolean useTickets, String viewStr,                                      GoCipher goCipher, CaseInsensitiveString name, boolean autoUpdate, Filter filter,                                      boolean invertFilter, String folder) {        P4MaterialConfig p4MaterialConfig = p4();        p4MaterialConfig.setUrl(serverAndPort);        p4MaterialConfig.setUserName(userName);        p4MaterialConfig.setPassword(password);        p4MaterialConfig.setUseTickets(useTickets);        p4MaterialConfig.setView(viewStr);        p4MaterialConfig.setAutoUpdate(autoUpdate);        p4MaterialConfig.setFilter(filter);        p4MaterialConfig.setInvertFilter(invertFilter);        p4MaterialConfig.setFolder(folder);        p4MaterialConfig.setName(name);        return p4MaterialConfig;    }    public static MaterialConfigs defaultMaterialConfigs() {        return defaultSvnMaterialConfigsWithUrl(\"http:    }    public static MaterialConfigs defaultSvnMaterialConfigsWithUrl(String svnUrl) {        return new MaterialConfigs(svnMaterialConfig(svnUrl, \"svnDir\", null, null, false, null));    }    public static MaterialConfigs multipleMaterialConfigs() {        MaterialConfigs materialConfigs = new MaterialConfigs();        materialConfigs.add(svnMaterialConfig(\"http:        materialConfigs.add(hgMaterialConfig(\"http:        materialConfigs.add(dependencyMaterialConfig(\"cruise\", \"dev\"));        return materialConfigs;    }    public static PackageMaterialConfig packageMaterialConfig() {        return packageMaterialConfig(\"repo-name\", \"package-name\");    }    public static PackageMaterialConfig packageMaterialConfig(String repoName, String packageName) {        PackageMaterialConfig material = new PackageMaterialConfig(\"p-id\");        PackageRepository repository = PackageRepositoryMother.create(\"repo-id\", repoName, \"pluginid\", \"version\",                new Configuration(ConfigurationPropertyMother.create(\"k1\", false, \"repo-v1\"), ConfigurationPropertyMother.create(\"k2\", false, \"repo-v2\")));        PackageDefinition packageDefinition = PackageDefinitionMother.create(\"p-id\", packageName, new Configuration(ConfigurationPropertyMother.create(\"k3\", false, \"package-v1\")), repository);        material.setPackageDefinition(packageDefinition);        repository.getPackages().add(packageDefinition);        return material;    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfig() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return pluggableSCMMaterialConfig(\"scm-id\", \"des-folder\", filter);    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfigWithConfigProperties(String... properties) {        SCM scmConfig = SCMMother.create(\"scm-id\");        Configuration configuration = new Configuration();        for (String property : properties) {            ConfigurationProperty configurationProperty = new ConfigurationProperty(new ConfigurationKey(property), new ConfigurationValue(property + \"-value\"));            configuration.add(configurationProperty);        }        scmConfig.setConfiguration(configuration);        return new PluggableSCMMaterialConfig(null, scmConfig, \"des-folder\", null, false);    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfig(String scmId, String... properties) {        return new PluggableSCMMaterialConfig(null, SCMMother.create(scmId, properties), \"des-folder\", null, false);    }    public static PluggableSCMMaterialConfig pluggableSCMMaterialConfig(String scmId, String destinationFolder, Filter filter) {        return new PluggableSCMMaterialConfig(null, SCMMother.create(scmId), destinationFolder, filter, false);    }    public static DependencyMaterialConfig dependencyMaterialConfig(String pipelineName, String stageName) {        return new DependencyMaterialConfig(new CaseInsensitiveString(pipelineName), new CaseInsensitiveString(stageName));    }    public static DependencyMaterialConfig dependencyMaterialConfig() {        return new DependencyMaterialConfig(new CaseInsensitiveString(\"pipeline-name\"), new CaseInsensitiveString(\"stage-name\"), true);    }    public static HgMaterialConfig hgMaterialConfigFull() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return hg(new HgUrlArgument(\"http:    }    public static HgMaterialConfig hgMaterialConfigFull(String url) {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return hg(new HgUrlArgument(url), null, null, null, true, filter, false, \"dest-folder\", new CaseInsensitiveString(\"hg-material\"));    }    public static HgMaterialConfig hgMaterialConfig() {        return hgMaterialConfig(\"hg-url\");    }    public static HgMaterialConfig hgMaterialConfig(String url) {        return hgMaterialConfig(url, null);    }    public static HgMaterialConfig hgMaterialConfig(String url, String folder) {        return hg(url, folder);    }    public static GitMaterialConfig gitMaterialConfig(String url, String submoduleFolder, String branch, boolean shallowClone) {        GitMaterialConfig gitMaterialConfig = git(url, branch);        gitMaterialConfig.setShallowClone(shallowClone);        gitMaterialConfig.setSubmoduleFolder(submoduleFolder);        return gitMaterialConfig;    }    public static GitMaterialConfig gitMaterialConfig() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        return git(new UrlArgument(\"http:    }    public static GitMaterialConfig gitMaterialConfig(String url) {        return git(url);    }    public static P4MaterialConfig p4MaterialConfig() {        return p4MaterialConfig(\"serverAndPort\", null, null, \"view\", false);    }    public static P4MaterialConfig p4MaterialConfigFull() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        P4MaterialConfig config = p4MaterialConfig(\"host:9876\", \"user\", \"password\", \"view\", true);        config.setFolder(\"dest-folder\");        config.setFilter(filter);        config.setName(new CaseInsensitiveString(\"p4-material\"));        return config;    }    public static P4MaterialConfig p4MaterialConfig(String serverAndPort, String userName, String password, String view, boolean useTickets) {        final P4MaterialConfig material = p4(serverAndPort, view);        material.setConfigAttributes(m(P4MaterialConfig.USERNAME, userName, P4MaterialConfig.AUTO_UPDATE, \"true\"));        material.setPassword(password);        material.setUseTickets(useTickets);        return material;    }    public static SvnMaterialConfig svnMaterialConfig() {        return svnMaterialConfig(\"url\", \"svnDir\");    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder, CaseInsensitiveString name) {        SvnMaterialConfig svnMaterialConfig = svnMaterialConfig(svnUrl, folder);        svnMaterialConfig.setName(name);        return svnMaterialConfig;    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder) {        return svnMaterialConfig(svnUrl, folder, false);    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder, boolean autoUpdate) {        SvnMaterialConfig materialConfig = svn(new UrlArgument(svnUrl), \"user\", \"pass\", true, new GoCipher(), autoUpdate, new Filter(new IgnoredFiles(\"*.doc\")), false,                folder, new CaseInsensitiveString(\"svn-material\"));        materialConfig.setPassword(\"pass\");        return materialConfig;    }    public static SvnMaterialConfig svnMaterialConfig(String svnUrl, String folder, String userName, String password, boolean checkExternals, String filterPattern) {        SvnMaterialConfig svnMaterial = svn(svnUrl, userName, password, checkExternals, folder);        if (filterPattern != null)            svnMaterial.setFilter(new Filter(new IgnoredFiles(filterPattern)));        String name = svnUrl.replaceAll(\"/\", \"_\");        name = name.replaceAll(\":\", \"_\");        svnMaterial.setName(new CaseInsensitiveString(name));        return svnMaterial;    }    public static HgMaterialConfig filteredHgMaterialConfig(String pattern) {        HgMaterialConfig materialConfig = hgMaterialConfig();        materialConfig.setFilter(new Filter(new IgnoredFiles(pattern)));        return materialConfig;    }    public static MaterialConfigs mockMaterialConfigs(String url) {        return new MaterialConfigs(svn(url, null, null, false));    }    public static TfsMaterialConfig tfsMaterialConfig() {        Filter filter = new Filter(new IgnoredFiles(\"**foobar/\"));        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        tfsMaterialConfig.setFilter(filter);        tfsMaterialConfig.setName(new CaseInsensitiveString(\"tfs-material\"));        tfsMaterialConfig.setFolder(\"dest-folder\");        return tfsMaterialConfig;    }    public static GitMaterialConfig git(String url, String username, String password) {        GitMaterialConfig gitMaterialConfig = git(url);        gitMaterialConfig.setUserName(username);        gitMaterialConfig.setPassword(password);        return gitMaterialConfig;    }    public static HgMaterialConfig hg(String url, String username, String password) {        HgMaterialConfig materialConfig = hg(url, null);        materialConfig.setUserName(username);        materialConfig.setPassword(password);        return materialConfig;    }}"}
{"code": "import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.TestInstance;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.MethodSource;import java.util.stream.Stream;import static java.lang.String.format;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.api.Assertions.assertThatCode;import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;class UrlArgumentTest {    private static final String URL_WITH_PASSWORD = \"http:    private CommandArgument argument;    @BeforeEach    void setup() {        argument = new UrlArgument(URL_WITH_PASSWORD);    }    @Test    void shouldBeTypeOfCommandArgument() {        assertThat(new UrlArgument(\"foo\")).isInstanceOf(CommandArgument.class);    }    @Test    void shouldErrorOutIfGivenUrlIsNull() {        assertThatCode(() -> new UrlArgument(null))                .isInstanceOf(RuntimeException.class)                .hasMessage(\"Url cannot be null.\");    }    @Nested    class originalArgument {        @Test        void shouldReturnGivenUrlAsItIs() {            assertThat(argument.originalArgument()).isEqualTo(URL_WITH_PASSWORD);        }    }    @Nested    class forCommandLine {        @Test        void shouldReturnGivenUrlAsItIs() {            final UrlArgument url = new UrlArgument(\"https:            assertThat(url.forCommandLine()).isEqualTo(\"https:        }    }    @Nested    @TestInstance(PER_CLASS)    class forDisplay {        Stream<Arguments> urls() {            return Stream.of(                    Arguments.of(\"\", \"\"),                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:            );        }        @ParameterizedTest        @MethodSource(\"urls\")        void shouldMaskPasswordInGivenUrl(String input, String expectedMaskedUrl) {            final UrlArgument simpleUrlArgument = new UrlArgument(input);            assertThat(simpleUrlArgument.forDisplay()).isEqualTo(expectedMaskedUrl);        }        @Test        void shouldNotMaskWithJustUserForSvnSshProtocol() {            String normal = \"svn+ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.forDisplay()).isEqualTo(\"svn+ssh:        }        @Test        void shouldNotMaskWithJustUserForSshProtocol() {            String normal = \"ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.forDisplay()).isEqualTo(\"ssh:        }        @Test        void shouldMaskWithUsernameAndPasswordForSshProtocol() {            String normal = \"ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.forDisplay()).isEqualTo(\"ssh:        }        @Test        void shouldMaskAuthTokenInUrl() {            UrlArgument url = new UrlArgument(\"https:            assertThat(url.forDisplay()).isEqualTo(\"https:        }    }    @Nested    class toString {        @Test        void shouldReturnValueForToString() {            assertThat(argument.toString()).isEqualTo(\"http:        }        @Test        void shouldNotChangeNormalURL() {            String normal = \"http:            UrlArgument url = new UrlArgument(normal);            assertThat(url.toString()).isEqualTo(normal);        }        @Test        void shouldWorkWithSvnSshUrl() {            String normal = \"svn+ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.toString()).isEqualTo(\"svn+ssh:        }        @Test        void shouldIgnoreArgumentsThatAreNotRecognisedUrls() {            String notAUrl = \"C:\\\\foo\\\\bar\\\\baz\";            UrlArgument url = new UrlArgument(notAUrl);            assertThat(url.toString()).isEqualTo(notAUrl);        }    }    @Nested    class Equals {        @Test        void shouldBeEqualBasedOnRawUrl() {            UrlArgument url1 = new UrlArgument(\"svn+ssh:            UrlArgument url3 = new UrlArgument(\"svn+ssh:            assertThat(url1).isEqualTo(url3);        }        @Test        void shouldBeEqualBasedOnRawUrl1() {            UrlArgument url1 = new UrlArgument(\"svn+ssh:            UrlArgument url3 = new UrlArgument(\"svn+ssh:            assertThat(url1).isEqualTo(url3);        }        @Test        void shouldBeEqualBasedOnRawUrlForHttpUrls() {            UrlArgument url1 = new UrlArgument(\"http:            UrlArgument url2 = new UrlArgument(\"http:            UrlArgument url3 = new UrlArgument(\"http:            assertThat(url1).isEqualTo(url3);            assertThat(url1).isNotEqualTo(url2);        }        @Test        void shouldIgnoreTrailingSlashesOnURIs() {            UrlArgument url1 = new UrlArgument(\"file:            UrlArgument url2 = new UrlArgument(\"file:            assertThat(url1).isEqualTo(url2);        }    }    @Nested    class withoutCredentials {        @Test        void shouldRemoveCredentials() {            final UrlArgument url = new UrlArgument(\"https:            assertThat(url.withoutCredentials()).isEqualTo(\"https:        }    }    @Nested    @TestInstance(PER_CLASS)    class replaceSecretInfo {        Stream<Arguments> urls() {            return Stream.of(                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:            );        }        @Test        void shouldReturnLineAsItIsIfLineIsBlank() {            final UrlArgument urlArgument = new UrlArgument(\"http:            assertThat(urlArgument.replaceSecretInfo(\"\")).isEqualTo(\"\");        }        @Test        void shouldReturnLineAsItIsIfLineIsNull() {            final UrlArgument urlArgument = new UrlArgument(\"http:            assertThat(urlArgument.replaceSecretInfo(null)).isEqualTo(null);        }        @Test        void shouldReturnLineAsItIsIfUrlIsBlank() {            final UrlArgument urlArgument = new UrlArgument(\"\");            assertThat(urlArgument.replaceSecretInfo(\"some-content\")).isEqualTo(\"some-content\");        }        @ParameterizedTest        @MethodSource(\"urls\")        void shouldMaskPasswordInGivenConsoleOutput(String input, String maskedUrl) {            final UrlArgument urlArgument = new UrlArgument(input);            final String originalLine = format(\"[go] Start updating repo at revision 08e7cc03 from %s\", input);            final String expectedLine = format(\"[go] Start updating repo at revision 08e7cc03 from %s\", maskedUrl);            assertThat(urlArgument.replaceSecretInfo(originalLine)).isEqualTo(expectedLine);        }        @Test        void shouldMaskMultipleOccurrencesOfUserInfo() {            final String url = \"http:            final String originalLine = format(\"[go] echoing same url twice: %s and %s\", url, url);            final UrlArgument urlArgument = new UrlArgument(url);            final String actual = urlArgument.replaceSecretInfo(originalLine);            final String maskedUrl = \"http:            final String expectedLine = format(\"[go] echoing same url twice: %s and %s\", maskedUrl, maskedUrl);            assertThat(actual).isEqualTo(expectedLine);        }        @Test        void shouldReplaceAllThePasswordsInSvnInfo() {            String output = \"<?xml version=\\\"1.0\\\"?>\\n\"                    + \"<info>\\n\"                    + \"<entry\\n\"                    + \"   kind=\\\"dir\\\"\\n\"                    + \"   path=\\\".\\\"\\n\"                    + \"   revision=\\\"294\\\">\\n\"                    + \"<url>http:                    + \"<repository>\\n\"                    + \"<root>http:                    + \"<uuid>b7cc39fa-2f96-0d44-9079-2001927d4b22</uuid>\\n\"                    + \"</repository>\\n\"                    + \"<wc-info>\\n\"                    + \"<schedule>normal</schedule>\\n\"                    + \"<depth>infinity</depth>\\n\"                    + \"</wc-info>\\n\"                    + \"<commit\\n\"                    + \"   revision=\\\"294\\\">\\n\"                    + \"<author>cce</author>\\n\"                    + \"<date>2009-06-09T06:13:05.109375Z</date>\\n\"                    + \"</commit>\\n\"                    + \"</entry>\\n\"                    + \"</info>\";            UrlArgument url = new UrlArgument(\"http:            String result = url.replaceSecretInfo(output);            assertThat(result).contains(\"<url>http:            assertThat(result).contains(\"<root>http:            assertThat(result).doesNotContain(\"cce:password\");        }    }    @Nested    @TestInstance(PER_CLASS)    class isValidURL {        Stream<Arguments> urls() {            return Stream.of(                    Arguments.of(\"http:                    Arguments.of(\"svn+ssh:                    Arguments.of(\"file:                    Arguments.of(\"/path/in/file/system\", true),                    Arguments.of(\"git@github.com:org/repo.git\", true),                    Arguments.of(\"user@my-site.com:org/repo.git\", true),                    Arguments.of(\"1a2b3c:                    Arguments.of(\"-xyz\", false),                    Arguments.of(\"_xyz\", false),                    Arguments.of(\"@xyz\", false)            );        }        @ParameterizedTest        @MethodSource(\"urls\")        void shouldValidateURLs(String input, boolean expectedValidity) {            final UrlArgument url = new UrlArgument(input);            assertThat(url.isValidURLOrLocalPath()).as(\"Verify validity of '%s' as a URL\", url.originalArgument()).isEqualTo(expectedValidity);        }    }}", "nl": "import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.TestInstance;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.MethodSource;import java.util.stream.Stream;import static java.lang.String.format;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.api.Assertions.assertThatCode;import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;class UrlArgumentTest {    private static final String URL_WITH_PASSWORD = \"http:    private CommandArgument argument;    @BeforeEach    void setup() {        argument = new UrlArgument(URL_WITH_PASSWORD);    }    @Test    void shouldBeTypeOfCommandArgument() {        assertThat(new UrlArgument(\"foo\")).isInstanceOf(CommandArgument.class);    }    @Test    void shouldErrorOutIfGivenUrlIsNull() {        assertThatCode(() -> new UrlArgument(null))                .isInstanceOf(RuntimeException.class)                .hasMessage(\"Url cannot be null.\");    }    @Nested    class originalArgument {        @Test        void shouldReturnGivenUrlAsItIs() {            assertThat(argument.originalArgument()).isEqualTo(URL_WITH_PASSWORD);        }    }    @Nested    class forCommandLine {        @Test        void shouldReturnGivenUrlAsItIs() {            final UrlArgument url = new UrlArgument(\"https:            assertThat(url.forCommandLine()).isEqualTo(\"https:        }    }    @Nested    @TestInstance(PER_CLASS)    class forDisplay {        Stream<Arguments> urls() {            return Stream.of(                    Arguments.of(\"\", \"\"),                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:            );        }        @ParameterizedTest        @MethodSource(\"urls\")        void shouldMaskPasswordInGivenUrl(String input, String expectedMaskedUrl) {            final UrlArgument simpleUrlArgument = new UrlArgument(input);            assertThat(simpleUrlArgument.forDisplay()).isEqualTo(expectedMaskedUrl);        }        @Test        void shouldNotMaskWithJustUserForSvnSshProtocol() {            String normal = \"svn+ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.forDisplay()).isEqualTo(\"svn+ssh:        }        @Test        void shouldNotMaskWithJustUserForSshProtocol() {            String normal = \"ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.forDisplay()).isEqualTo(\"ssh:        }        @Test        void shouldMaskWithUsernameAndPasswordForSshProtocol() {            String normal = \"ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.forDisplay()).isEqualTo(\"ssh:        }        @Test        void shouldMaskAuthTokenInUrl() {            UrlArgument url = new UrlArgument(\"https:            assertThat(url.forDisplay()).isEqualTo(\"https:        }    }    @Nested    class toString {        @Test        void shouldReturnValueForToString() {            assertThat(argument.toString()).isEqualTo(\"http:        }        @Test        void shouldNotChangeNormalURL() {            String normal = \"http:            UrlArgument url = new UrlArgument(normal);            assertThat(url.toString()).isEqualTo(normal);        }        @Test        void shouldWorkWithSvnSshUrl() {            String normal = \"svn+ssh:            UrlArgument url = new UrlArgument(normal);            assertThat(url.toString()).isEqualTo(\"svn+ssh:        }        @Test        void shouldIgnoreArgumentsThatAreNotRecognisedUrls() {            String notAUrl = \"C:\\\\foo\\\\bar\\\\baz\";            UrlArgument url = new UrlArgument(notAUrl);            assertThat(url.toString()).isEqualTo(notAUrl);        }    }    @Nested    class Equals {        @Test        void shouldBeEqualBasedOnRawUrl() {            UrlArgument url1 = new UrlArgument(\"svn+ssh:            UrlArgument url3 = new UrlArgument(\"svn+ssh:            assertThat(url1).isEqualTo(url3);        }        @Test        void shouldBeEqualBasedOnRawUrl1() {            UrlArgument url1 = new UrlArgument(\"svn+ssh:            UrlArgument url3 = new UrlArgument(\"svn+ssh:            assertThat(url1).isEqualTo(url3);        }        @Test        void shouldBeEqualBasedOnRawUrlForHttpUrls() {            UrlArgument url1 = new UrlArgument(\"http:            UrlArgument url2 = new UrlArgument(\"http:            UrlArgument url3 = new UrlArgument(\"http:            assertThat(url1).isEqualTo(url3);            assertThat(url1).isNotEqualTo(url2);        }        @Test        void shouldIgnoreTrailingSlashesOnURIs() {            UrlArgument url1 = new UrlArgument(\"file:            UrlArgument url2 = new UrlArgument(\"file:            assertThat(url1).isEqualTo(url2);        }    }    @Nested    class withoutCredentials {        @Test        void shouldRemoveCredentials() {            final UrlArgument url = new UrlArgument(\"https:            assertThat(url.withoutCredentials()).isEqualTo(\"https:        }    }    @Nested    @TestInstance(PER_CLASS)    class replaceSecretInfo {        Stream<Arguments> urls() {            return Stream.of(                    Arguments.of(\"http:                    Arguments.of(\"http:                    Arguments.of(\"http:            );        }        @Test        void shouldReturnLineAsItIsIfLineIsBlank() {            final UrlArgument urlArgument = new UrlArgument(\"http:            assertThat(urlArgument.replaceSecretInfo(\"\")).isEqualTo(\"\");        }        @Test        void shouldReturnLineAsItIsIfLineIsNull() {            final UrlArgument urlArgument = new UrlArgument(\"http:            assertThat(urlArgument.replaceSecretInfo(null)).isEqualTo(null);        }        @Test        void shouldReturnLineAsItIsIfUrlIsBlank() {            final UrlArgument urlArgument = new UrlArgument(\"\");            assertThat(urlArgument.replaceSecretInfo(\"some-content\")).isEqualTo(\"some-content\");        }        @ParameterizedTest        @MethodSource(\"urls\")        void shouldMaskPasswordInGivenConsoleOutput(String input, String maskedUrl) {            final UrlArgument urlArgument = new UrlArgument(input);            final String originalLine = format(\"[go] Start updating repo at revision 08e7cc03 from %s\", input);            final String expectedLine = format(\"[go] Start updating repo at revision 08e7cc03 from %s\", maskedUrl);            assertThat(urlArgument.replaceSecretInfo(originalLine)).isEqualTo(expectedLine);        }        @Test        void shouldMaskMultipleOccurrencesOfUserInfo() {            final String url = \"http:            final String originalLine = format(\"[go] echoing same url twice: %s and %s\", url, url);            final UrlArgument urlArgument = new UrlArgument(url);            final String actual = urlArgument.replaceSecretInfo(originalLine);            final String maskedUrl = \"http:            final String expectedLine = format(\"[go] echoing same url twice: %s and %s\", maskedUrl, maskedUrl);            assertThat(actual).isEqualTo(expectedLine);        }        @Test        void shouldReplaceAllThePasswordsInSvnInfo() {            String output = \"<?xml version=\\\"1.0\\\"?>\\n\"                    + \"<info>\\n\"                    + \"<entry\\n\"                    + \"   kind=\\\"dir\\\"\\n\"                    + \"   path=\\\".\\\"\\n\"                    + \"   revision=\\\"294\\\">\\n\"                    + \"<url>http:                    + \"<repository>\\n\"                    + \"<root>http:                    + \"<uuid>b7cc39fa-2f96-0d44-9079-2001927d4b22</uuid>\\n\"                    + \"</repository>\\n\"                    + \"<wc-info>\\n\"                    + \"<schedule>normal</schedule>\\n\"                    + \"<depth>infinity</depth>\\n\"                    + \"</wc-info>\\n\"                    + \"<commit\\n\"                    + \"   revision=\\\"294\\\">\\n\"                    + \"<author>cce</author>\\n\"                    + \"<date>2009-06-09T06:13:05.109375Z</date>\\n\"                    + \"</commit>\\n\"                    + \"</entry>\\n\"                    + \"</info>\";            UrlArgument url = new UrlArgument(\"http:            String result = url.replaceSecretInfo(output);            assertThat(result).contains(\"<url>http:            assertThat(result).contains(\"<root>http:            assertThat(result).doesNotContain(\"cce:password\");        }    }}"}
{"code": "import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.config.materials.git.RefSpecHelper;import com.thoughtworks.go.domain.materials.Modification;import com.thoughtworks.go.domain.materials.Revision;import com.thoughtworks.go.domain.materials.SCMCommand;import com.thoughtworks.go.domain.materials.mercurial.StringRevision;import com.thoughtworks.go.util.NamedProcessTag;import com.thoughtworks.go.util.command.*;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.jetbrains.annotations.TestOnly;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;import static com.thoughtworks.go.config.materials.git.GitMaterial.UNSHALLOW_TRYOUT_STEP;import static com.thoughtworks.go.config.materials.git.RefSpecHelper.REFS_HEADS;import static com.thoughtworks.go.domain.materials.ModifiedAction.parseGitAction;import static com.thoughtworks.go.util.DateUtils.formatRFC822;import static com.thoughtworks.go.util.ExceptionUtils.bomb;import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;import static java.lang.String.format;import static java.util.Arrays.asList;public class GitCommand extends SCMCommand {    private static final Logger LOG = LoggerFactory.getLogger(GitCommand.class);    private static final Pattern GIT_SUBMODULE_STATUS_PATTERN = Pattern.compile(\"^.[0-9a-fA-F]{40} (.+?)( \\\\(.+\\\\))?$\");    private static final Pattern GIT_SUBMODULE_URL_PATTERN = Pattern.compile(\"^submodule\\\\.(.+)\\\\.url (.+)$\");    private static final Pattern GIT_DIFF_TREE_PATTERN = Pattern.compile(\"^(.)\\\\s+(.+)$\");    private static final String GIT_CLEAN_KEEP_IGNORED_FILES_FLAG = \"toggle.agent.git.clean.keep.ignored.files\";    private final File workingDir;    private final List<SecretString> secrets;    private final String branch;    private final boolean isSubmodule;    public GitCommand(String materialFingerprint, File workingDir, String branch, boolean isSubmodule, List<SecretString> secrets) {        super(materialFingerprint);        this.workingDir = workingDir;        this.secrets = secrets != null ? secrets : new ArrayList<>();        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);        this.isSubmodule = isSubmodule;    }    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {        return branchList.output().size() == 1;    }    public String localBranch() {        return RefSpecHelper.localBranch(branch);    }    public String remoteBranch() {        return RefSpecHelper.remoteBranch(RefSpecHelper.expandRefSpec(branch));    }    public String fullUpstreamRef() {        return RefSpecHelper.fullUpstreamRef(branch);    }    public String expandRefSpec() {        return RefSpecHelper.expandRefSpec(branch);    }    public boolean hasRefSpec() {        return RefSpecHelper.hasRefSpec(branch);    }    public String getConfigValue(String key) {        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();    }    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {        CommandLine gitClone = cloneCommand().                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).                withArg(\"--no-checkout\").                withArg(new UrlArgument(url)).                withArg(workingDir.getAbsolutePath());        if (!hasRefSpec()) {            return run(gitClone, outputStreamConsumer);        }        final String abbrevBranch = localBranch();        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;        return runCascade(outputStreamConsumer,                gitClone,                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),                git_C().withArgs(\"update-ref\", \"--no-deref\", \"HEAD\", \"HEAD\"),                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)        );    }    @TestOnly    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);    }    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {        CommandLine gitClone = cloneCommand().                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).                when(depth < Integer.MAX_VALUE, git -> git.withArg(format(\"--depth=%s\", depth))).                withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());        if (!hasRefSpec()) {            return run(gitClone, outputStreamConsumer);        }        return runCascade(outputStreamConsumer,                gitClone,                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),                git_C().withArgs(\"checkout\", \"-B\", localBranch(), remoteBranch())        );    }    public List<Modification> latestModification() {        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());    }    public List<Modification> modificationsSince(Revision revision) {        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", format(\"%s..%s\", revision.getRevision(), remoteBranch()));    }    public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {        log(outputStreamConsumer, \"Reset working directory %s\", workingDir);        cleanAllUnversionedFiles(outputStreamConsumer);        removeSubmoduleSectionsFromGitConfig(outputStreamConsumer);        resetHard(outputStreamConsumer, revision);        checkoutAllModifiedFilesInSubmodules(outputStreamConsumer);        updateSubmoduleWithInit(outputStreamConsumer, shallow);        cleanAllUnversionedFiles(outputStreamConsumer);    }    public void resetHard(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision) {        log(outputStreamConsumer, \"Updating working copy to revision \" + revision.getRevision());        String[] args = new String[]{\"reset\", \"--hard\", revision.getRevision()};        CommandLine gitCmd = gitWd().withArgs(args);        int result = run(gitCmd, outputStreamConsumer);        if (result != 0) {            throw new RuntimeException(format(\"git reset failed for [%s]\", this.workingDir));        }    }    @TestOnly    public void fetchAndResetToHead(ConsoleOutputStreamConsumer outputStreamConsumer, boolean shallow) {        fetch(outputStreamConsumer);        resetWorkingDir(outputStreamConsumer, new StringRevision(remoteBranch()), shallow);    }    public void updateSubmoduleWithInit(ConsoleOutputStreamConsumer outputStreamConsumer, boolean shallow) {        if (!gitSubmoduleEnabled()) {            return;        }        log(outputStreamConsumer, \"Updating git sub-modules\");        String[] initArgs = new String[]{\"submodule\", \"init\"};        CommandLine initCmd = gitWd().withArgs(initArgs);        runOrBomb(initCmd);        submoduleSync();        if (shallow && version().supportsSubmoduleDepth()) {            tryToShallowUpdateSubmodules();        } else {            updateSubmodule();        }        log(outputStreamConsumer, \"Cleaning unversioned files and sub-modules\");        printSubmoduleStatus(outputStreamConsumer);    }    public UrlArgument workingRepositoryUrl() {        String[] args = new String[]{\"config\", \"remote.origin.url\"};        CommandLine gitConfig = gitWd().withArgs(args);        return new UrlArgument(runOrBomb(gitConfig).outputForDisplay().get(0));    }    public void checkConnection(UrlArgument repoUrl) {        final String ref = fullUpstreamRef();        final CommandLine commandLine = git().withArgs(\"ls-remote\", \"--\").withArg(repoUrl).withArg(ref);        final ConsoleResult result = commandLine.runOrBomb(new NamedProcessTag(repoUrl.forDisplay()));        if (!hasExactlyOneMatchingBranch(result)) {            throw new CommandLineException(format(\"The ref %s could not be found.\", ref));        }    }    public GitVersion version() {        CommandLine gitVersion = git().withArgs(\"version\");        String gitVersionString = gitVersion.runOrBomb(new NamedProcessTag(\"git version check\")).outputAsString();        return GitVersion.parse(gitVersionString);    }    @TestOnly    public void add(File fileToAdd) {        String[] args = new String[]{\"add\", \"--\", fileToAdd.getName()};        CommandLine gitAdd = gitWd().withArgs(args);        runOrBomb(gitAdd);    }    @TestOnly    public void commit(String message) {        String[] args = new String[]{\"commit\", \"-m\", message};        CommandLine gitCommit = gitWd().withArgs(args);        runOrBomb(gitCommit);    }    @TestOnly    public void commitOnDate(String message, Date commitDate) {        HashMap<String, String> env = new HashMap<>();        env.put(\"GIT_AUTHOR_DATE\", formatRFC822(commitDate));        CommandLine gitCmd = gitWd().withArgs(\"commit\", \"-m\", message).withEnv(env);        runOrBomb(gitCmd);    }    @TestOnly    public void checkoutRemoteBranchToLocal() {        CommandLine gitCmd = gitWd().withArgs(\"checkout\", \"-b\", localBranch(), remoteBranch());        runOrBomb(gitCmd);    }    public void fetch(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Fetching changes\");        CommandLine gitFetch = gitWd().withArgs(\"fetch\", \"origin\", \"--prune\", \"--recurse-submodules=no\");        int result = run(gitFetch, outputStreamConsumer);        if (result != 0) {            throw new RuntimeException(format(\"git fetch failed for [%s]\", this.workingRepositoryUrl()));        }        gc(outputStreamConsumer);    }    public void unshallow(ConsoleOutputStreamConsumer outputStreamConsumer, Integer depth) {        log(outputStreamConsumer, \"Unshallowing repository with depth %d\", depth);        CommandLine gitFetch = gitWd()                .withArgs(\"fetch\", \"origin\")                .withArg(format(\"--depth=%d\", depth));        int result = run(gitFetch, outputStreamConsumer);        if (result != 0) {            throw new RuntimeException(format(\"Unshallow repository failed for [%s]\", this.workingRepositoryUrl()));        }    }    @TestOnly    public void init() {        CommandLine gitCmd = gitWd().withArgs(\"init\");        runOrBomb(gitCmd);    }    @TestOnly    public List<String> submoduleFolders() {        CommandLine gitCmd = gitWd().withArgs(\"submodule\", \"status\");        ConsoleResult result = runOrBomb(gitCmd);        return submoduleFolders(result.output());    }    @TestOnly    public void submoduleAdd(String repoUrl, String submoduleNameToPutInGitSubmodules, String folder) {        String[] addSubmoduleWithSameNameArgs = new String[]{\"submodule\", \"add\", \"--\", repoUrl, folder};        String[] changeSubmoduleNameInGitModules = new String[]{\"config\", \"--file\", \".gitmodules\", \"--rename-section\", \"submodule.\" + folder, \"submodule.\" + submoduleNameToPutInGitSubmodules};        String[] addGitModules = new String[]{\"add\", \".gitmodules\"};        runOrBomb(gitWd().withArgs(addSubmoduleWithSameNameArgs));        runOrBomb(gitWd().withArgs(changeSubmoduleNameInGitModules));        runOrBomb(gitWd().withArgs(addGitModules));    }    @TestOnly    public void submoduleRemove(String folderName) {        configRemoveSection(\"submodule.\" + folderName);        CommandLine gitConfig = gitWd().withArgs(\"config\", \"-f\", \".gitmodules\", \"--remove-section\", \"submodule.\" + folderName);        runOrBomb(gitConfig);        CommandLine gitAdd = gitWd().withArgs(\"add\", \".gitmodules\");        runOrBomb(gitAdd);        CommandLine gitRm = gitWd().withArgs(\"rm\", \"--cached\", folderName);        runOrBomb(gitRm);        FileUtils.deleteQuietly(new File(workingDir, folderName));    }    @TestOnly    public String currentRevision() {        String[] args = new String[]{\"log\", \"-1\", \"--pretty=format:%H\"};        CommandLine gitCmd = gitWd().withArgs(args);        return runOrBomb(gitCmd).outputAsString();    }    public String getCurrentBranch() {        CommandLine getCurrentBranchCommand = gitWd().withArg(\"rev-parse\").withArg(\"--abbrev-ref\").withArg(\"HEAD\");        ConsoleResult consoleResult = runOrBomb(getCurrentBranchCommand);        return consoleResult.outputAsString();    }    @TestOnly    public void changeSubmoduleUrl(String submoduleName, String newUrl) {        String[] args = new String[]{\"config\", \"--file\", \".gitmodules\", \"submodule.\" + submoduleName + \".url\", newUrl};        CommandLine gitConfig = gitWd().withArgs(args);        runOrBomb(gitConfig);    }    public void submoduleSync() {        String[] syncArgs = new String[]{\"submodule\", \"sync\"};        CommandLine syncCmd = gitWd().withArgs(syncArgs);        runOrBomb(syncCmd);        List<String> foreachArgs = submoduleForEachRecursive(asList(\"git\", \"submodule\", \"sync\"));        CommandLine foreachCmd = gitWd().withArgs(foreachArgs);        runOrBomb(foreachCmd);    }    public boolean isShallow() {        return new File(workingDir, \".git/shallow\").exists();    }    public boolean containsRevisionInBranch(Revision revision) {        String[] args = {\"branch\", \"-r\", \"--contains\", revision.getRevision()};        CommandLine gitCommand = gitWd().withArgs(args);        try {            ConsoleResult consoleResult = runOrBomb(gitCommand);            return (consoleResult.outputAsString()).contains(remoteBranch());        } catch (CommandLineException e) {            return false;        }    }    protected Map<String, String> submoduleUrls() {        String[] args = new String[]{\"config\", \"--get-regexp\", \"^submodule\\\\..+\\\\.url\"};        CommandLine gitCmd = gitWd().withArgs(args);        ConsoleResult result = runOrBomb(gitCmd, false);        List<String> submoduleList = result.output();        HashMap<String, String> submoduleUrls = new HashMap<>();        for (String submoduleLine : submoduleList) {            Matcher m = GIT_SUBMODULE_URL_PATTERN.matcher(submoduleLine);            if (!m.find()) {                bomb(\"Unable to parse git-config output line: \" + result.replaceSecretInfo(submoduleLine) + \"\\n\"                        + \"From output:\\n\"                        + result.replaceSecretInfo(StringUtils.join(submoduleList, \"\\n\")));            }            submoduleUrls.put(m.group(1), m.group(2));        }        return submoduleUrls;    }    private CommandLine cloneCommand() {        return git().withArg(\"clone\");    }    private List<Modification> gitLog(String... args) {        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();        try {            if (!isSubmodule) {                fetch(outputStreamConsumer);            }        } catch (Exception e) {            throw new RuntimeException(format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);        }        CommandLine gitCmd = gitWd().withArg(\"log\").withArgs(args);        ConsoleResult result = runOrBomb(gitCmd);        GitModificationParser parser = new GitModificationParser();        List<Modification> mods = parser.parse(result.output());        for (Modification mod : mods) {            addModifiedFiles(mod);        }        return mods;    }    private void addModifiedFiles(Modification mod) {        ConsoleResult consoleResult = diffTree(mod.getRevision());        List<String> result = consoleResult.output();        for (String resultLine : result) {            if (resultLine.equals(mod.getRevision())) {                continue;            }            Matcher m = matchResultLine(resultLine);            if (!m.find()) {                bomb(\"Unable to parse git-diff-tree output line: \" + consoleResult.replaceSecretInfo(resultLine) + \"\\n\"                        + \"From output:\\n\"                        + consoleResult.outputForDisplayAsString());            }            mod.createModifiedFile(m.group(2), null, parseGitAction(m.group(1).charAt(0)));        }    }    private ConsoleResult diffTree(String node) {        CommandLine gitCmd = gitWd().withArgs(\"diff-tree\", \"--name-status\", \"--root\", \"-r\", node);        return runOrBomb(gitCmd);    }    private Matcher matchResultLine(String resultLine) {        return GIT_DIFF_TREE_PATTERN.matcher(resultLine);    }    private void checkoutAllModifiedFilesInSubmodules(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Removing modified files in submodules\");        List<String> submoduleForEachRecursive = submoduleForEachRecursive(asList(\"git\", \"checkout\", \".\"));        runOrBomb(gitWd().withArgs(submoduleForEachRecursive));    }    private String gitCleanArgs() {        if (\"Y\".equalsIgnoreCase(System.getProperty(GIT_CLEAN_KEEP_IGNORED_FILES_FLAG))) {            LOG.info(\"{} = Y. Using old behaviour for clean using `-dff`\", GIT_CLEAN_KEEP_IGNORED_FILES_FLAG);            return \"-dff\";        } else {            return \"-dffx\";        }    }    private void printSubmoduleStatus(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Git sub-module status\");        CommandLine gitCmd = gitWd().withArgs(\"submodule\", \"status\");        run(gitCmd, outputStreamConsumer);    }    private CommandLine git() {        CommandLine git = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\");        return git.withNonArgSecrets(secrets);    }    private CommandLine git_C() {        return git().withArgs(\"-C\", workingDir.getAbsolutePath());    }    private CommandLine gitWd() {        return git().withWorkingDir(workingDir);    }    private void updateSubmodule() {        CommandLine updateCmd = gitWd().withArgs(\"submodule\", \"update\");        runOrBomb(updateCmd);    }    private void tryToShallowUpdateSubmodules() {        if (updateSubmoduleWithDepth(1)) {            return;        }        LOG.warn(\"git submodule update with --depth=1 failed. Attempting again with --depth={}\", UNSHALLOW_TRYOUT_STEP);        if (updateSubmoduleWithDepth(UNSHALLOW_TRYOUT_STEP)) {            return;        }        LOG.warn(\"git submodule update with depth={} failed. Attempting again with --depth=Integer.MAX\", UNSHALLOW_TRYOUT_STEP);        if (!updateSubmoduleWithDepth(Integer.MAX_VALUE)) {            bomb(\"Failed to update submodule\");        }    }    private boolean updateSubmoduleWithDepth(int depth) {        List<String> updateArgs = new ArrayList<>(asList(\"submodule\", \"update\"));        updateArgs.add(\"--depth=\" + depth);        CommandLine commandLine = gitWd().withArgs(updateArgs);        try {            runOrBomb(commandLine);        } catch (Exception e) {            LOG.warn(e.getMessage(), e);            return false;        }        return true;    }    private void cleanAllUnversionedFiles(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Cleaning all unversioned files in working copy\");        cleanUnversionedFilesInAllSubmodules();        cleanUnversionedFiles();    }    private void cleanUnversionedFiles() {        runOrBomb(gitWd().withArgs(\"clean\", gitCleanArgs()));    }    private void cleanUnversionedFilesInAllSubmodules() {        List<String> args = submoduleForEachRecursive(asList(\"git\", \"clean\", gitCleanArgs()));        runOrBomb(gitWd().withArgs(args));    }    private void removeSubmoduleSectionsFromGitConfig(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Cleaning submodule configurations in .git/config\");        for (String submoduleFolder : submoduleUrls().keySet()) {            configRemoveSection(\"submodule.\" + submoduleFolder);        }    }    private void configRemoveSection(String section) {        String[] args = new String[]{\"config\", \"--remove-section\", section};        CommandLine gitCmd = gitWd().withArgs(args);        runOrBomb(gitCmd, false);    }    private boolean gitSubmoduleEnabled() {        return new File(workingDir, \".gitmodules\").exists();    }    private void gc(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Performing git gc\");        CommandLine gitGc = gitWd().withArgs(\"gc\", \"--auto\");        run(gitGc, outputStreamConsumer);    }    @TestOnly    private List<String> submoduleFolders(List<String> submoduleLines) {        ArrayList<String> submoduleFolders = new ArrayList<>();        for (String submoduleLine : submoduleLines) {            Matcher m = GIT_SUBMODULE_STATUS_PATTERN.matcher(submoduleLine);            if (!m.find()) {                bomb(\"Unable to parse git-submodule output line: \" + submoduleLine + \"\\n\"                        + \"From output:\\n\"                        + StringUtils.join(submoduleLines, \"\\n\"));            }            submoduleFolders.add(m.group(1));        }        return submoduleFolders;    }    private void log(ConsoleOutputStreamConsumer outputStreamConsumer, String message, Object... args) {        LOG.debug(format(message, args));        outputStreamConsumer.stdOutput(format(\"[GIT] \" + message, args));    }    private List<String> submoduleForEachRecursive(List<String> args) {        List<String> forEachArgs = new ArrayList<>(asList(\"submodule\", \"foreach\", \"--recursive\"));        if (version().requiresSubmoduleCommandFix()) {            forEachArgs.add(StringUtils.join(args, \" \"));        } else {            forEachArgs.addAll(args);        }        return forEachArgs;    }}", "nl": "import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.config.materials.git.RefSpecHelper;import com.thoughtworks.go.domain.materials.Modification;import com.thoughtworks.go.domain.materials.Revision;import com.thoughtworks.go.domain.materials.SCMCommand;import com.thoughtworks.go.domain.materials.mercurial.StringRevision;import com.thoughtworks.go.util.NamedProcessTag;import com.thoughtworks.go.util.command.*;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.jetbrains.annotations.TestOnly;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;import static com.thoughtworks.go.config.materials.git.GitMaterial.UNSHALLOW_TRYOUT_STEP;import static com.thoughtworks.go.config.materials.git.RefSpecHelper.REFS_HEADS;import static com.thoughtworks.go.domain.materials.ModifiedAction.parseGitAction;import static com.thoughtworks.go.util.DateUtils.formatRFC822;import static com.thoughtworks.go.util.ExceptionUtils.bomb;import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;import static java.lang.String.format;import static java.util.Arrays.asList;public class GitCommand extends SCMCommand {    private static final Logger LOG = LoggerFactory.getLogger(GitCommand.class);    private static final Pattern GIT_SUBMODULE_STATUS_PATTERN = Pattern.compile(\"^.[0-9a-fA-F]{40} (.+?)( \\\\(.+\\\\))?$\");    private static final Pattern GIT_SUBMODULE_URL_PATTERN = Pattern.compile(\"^submodule\\\\.(.+)\\\\.url (.+)$\");    private static final Pattern GIT_DIFF_TREE_PATTERN = Pattern.compile(\"^(.)\\\\s+(.+)$\");    private static final String GIT_CLEAN_KEEP_IGNORED_FILES_FLAG = \"toggle.agent.git.clean.keep.ignored.files\";    private final File workingDir;    private final List<SecretString> secrets;    private final String branch;    private final boolean isSubmodule;    public GitCommand(String materialFingerprint, File workingDir, String branch, boolean isSubmodule, List<SecretString> secrets) {        super(materialFingerprint);        this.workingDir = workingDir;        this.secrets = secrets != null ? secrets : new ArrayList<>();        this.branch = StringUtils.defaultIfBlank(branch, GitMaterialConfig.DEFAULT_BRANCH);        this.isSubmodule = isSubmodule;    }    private static boolean hasExactlyOneMatchingBranch(ConsoleResult branchList) {        return branchList.output().size() == 1;    }    public String localBranch() {        return RefSpecHelper.localBranch(branch);    }    public String remoteBranch() {        return RefSpecHelper.remoteBranch(RefSpecHelper.expandRefSpec(branch));    }    public String fullUpstreamRef() {        return RefSpecHelper.fullUpstreamRef(branch);    }    public String expandRefSpec() {        return RefSpecHelper.expandRefSpec(branch);    }    public boolean hasRefSpec() {        return RefSpecHelper.hasRefSpec(branch);    }    public String getConfigValue(String key) {        return runOrBomb(git_C().withArgs(\"config\", \"--get-all\", key)).outputAsString();    }    public int cloneWithNoCheckout(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {        CommandLine gitClone = cloneCommand().                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).                withArg(\"--no-checkout\").                withArg(new UrlArgument(url)).                withArg(workingDir.getAbsolutePath());        if (!hasRefSpec()) {            return run(gitClone, outputStreamConsumer);        }        final String abbrevBranch = localBranch();        final String fullLocalRef = abbrevBranch.startsWith(\"refs/\") ? abbrevBranch : REFS_HEADS + abbrevBranch;        return runCascade(outputStreamConsumer,                gitClone,                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),                git_C().withArgs(\"update-ref\", \"--no-deref\", \"HEAD\", \"HEAD\"),                git_C().withArgs(\"branch\", \"-f\", abbrevBranch, remoteBranch()),                git_C().withArgs(\"symbolic-ref\", \"HEAD\", fullLocalRef)        );    }    @TestOnly    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);    }    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url, Integer depth) {        CommandLine gitClone = cloneCommand().                when(!hasRefSpec(), git -> git.withArgs(\"--branch\", branch)).                when(depth < Integer.MAX_VALUE, git -> git.withArg(format(\"--depth=%s\", depth))).                withArg(new UrlArgument(url)).withArg(workingDir.getAbsolutePath());        if (!hasRefSpec()) {            return run(gitClone, outputStreamConsumer);        }        return runCascade(outputStreamConsumer,                gitClone,                git_C().withArgs(\"config\", \"--replace-all\", \"remote.origin.fetch\", \"+\" + expandRefSpec()),                git_C().withArgs(\"fetch\", \"--prune\", \"--recurse-submodules=no\"),                git_C().withArgs(\"checkout\", \"-B\", localBranch(), remoteBranch())        );    }    public List<Modification> latestModification() {        return gitLog(\"-1\", \"--date=iso\", \"--no-decorate\", \"--pretty=medium\", \"--no-color\", remoteBranch());    }    public List<Modification> modificationsSince(Revision revision) {        return gitLog(\"--date=iso\", \"--pretty=medium\", \"--no-decorate\", \"--no-color\", format(\"%s..%s\", revision.getRevision(), remoteBranch()));    }    public void resetWorkingDir(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision, boolean shallow) {        log(outputStreamConsumer, \"Reset working directory %s\", workingDir);        cleanAllUnversionedFiles(outputStreamConsumer);        removeSubmoduleSectionsFromGitConfig(outputStreamConsumer);        resetHard(outputStreamConsumer, revision);        checkoutAllModifiedFilesInSubmodules(outputStreamConsumer);        updateSubmoduleWithInit(outputStreamConsumer, shallow);        cleanAllUnversionedFiles(outputStreamConsumer);    }    public void resetHard(ConsoleOutputStreamConsumer outputStreamConsumer, Revision revision) {        log(outputStreamConsumer, \"Updating working copy to revision \" + revision.getRevision());        String[] args = new String[]{\"reset\", \"--hard\", revision.getRevision()};        CommandLine gitCmd = gitWd().withArgs(args);        int result = run(gitCmd, outputStreamConsumer);        if (result != 0) {            throw new RuntimeException(format(\"git reset failed for [%s]\", this.workingDir));        }    }    @TestOnly    public void fetchAndResetToHead(ConsoleOutputStreamConsumer outputStreamConsumer, boolean shallow) {        fetch(outputStreamConsumer);        resetWorkingDir(outputStreamConsumer, new StringRevision(remoteBranch()), shallow);    }    public void updateSubmoduleWithInit(ConsoleOutputStreamConsumer outputStreamConsumer, boolean shallow) {        if (!gitSubmoduleEnabled()) {            return;        }        log(outputStreamConsumer, \"Updating git sub-modules\");        String[] initArgs = new String[]{\"submodule\", \"init\"};        CommandLine initCmd = gitWd().withArgs(initArgs);        runOrBomb(initCmd);        submoduleSync();        if (shallow && version().supportsSubmoduleDepth()) {            tryToShallowUpdateSubmodules();        } else {            updateSubmodule();        }        log(outputStreamConsumer, \"Cleaning unversioned files and sub-modules\");        printSubmoduleStatus(outputStreamConsumer);    }    public UrlArgument workingRepositoryUrl() {        String[] args = new String[]{\"config\", \"remote.origin.url\"};        CommandLine gitConfig = gitWd().withArgs(args);        return new UrlArgument(runOrBomb(gitConfig).outputForDisplay().get(0));    }    public void checkConnection(UrlArgument repoUrl) {        final String ref = fullUpstreamRef();        final CommandLine commandLine = git().withArgs(\"ls-remote\").withArg(repoUrl).withArg(ref);        final ConsoleResult result = commandLine.runOrBomb(new NamedProcessTag(repoUrl.forDisplay()));        if (!hasExactlyOneMatchingBranch(result)) {            throw new CommandLineException(format(\"The ref %s could not be found.\", ref));        }    }    public GitVersion version() {        CommandLine gitVersion = git().withArgs(\"version\");        String gitVersionString = gitVersion.runOrBomb(new NamedProcessTag(\"git version check\")).outputAsString();        return GitVersion.parse(gitVersionString);    }    @TestOnly    public void add(File fileToAdd) {        String[] args = new String[]{\"add\", fileToAdd.getName()};        CommandLine gitAdd = gitWd().withArgs(args);        runOrBomb(gitAdd);    }    @TestOnly    public void commit(String message) {        String[] args = new String[]{\"commit\", \"-m\", message};        CommandLine gitCommit = gitWd().withArgs(args);        runOrBomb(gitCommit);    }    @TestOnly    public void commitOnDate(String message, Date commitDate) {        HashMap<String, String> env = new HashMap<>();        env.put(\"GIT_AUTHOR_DATE\", formatRFC822(commitDate));        CommandLine gitCmd = gitWd().withArgs(\"commit\", \"-m\", message).withEnv(env);        runOrBomb(gitCmd);    }    @TestOnly    public void checkoutRemoteBranchToLocal() {        CommandLine gitCmd = gitWd().withArgs(\"checkout\", \"-b\", localBranch(), remoteBranch());        runOrBomb(gitCmd);    }    public void fetch(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Fetching changes\");        CommandLine gitFetch = gitWd().withArgs(\"fetch\", \"origin\", \"--prune\", \"--recurse-submodules=no\");        int result = run(gitFetch, outputStreamConsumer);        if (result != 0) {            throw new RuntimeException(format(\"git fetch failed for [%s]\", this.workingRepositoryUrl()));        }        gc(outputStreamConsumer);    }    public void unshallow(ConsoleOutputStreamConsumer outputStreamConsumer, Integer depth) {        log(outputStreamConsumer, \"Unshallowing repository with depth %d\", depth);        CommandLine gitFetch = gitWd()                .withArgs(\"fetch\", \"origin\")                .withArg(format(\"--depth=%d\", depth));        int result = run(gitFetch, outputStreamConsumer);        if (result != 0) {            throw new RuntimeException(format(\"Unshallow repository failed for [%s]\", this.workingRepositoryUrl()));        }    }    @TestOnly    public void init() {        CommandLine gitCmd = gitWd().withArgs(\"init\");        runOrBomb(gitCmd);    }    @TestOnly    public List<String> submoduleFolders() {        CommandLine gitCmd = gitWd().withArgs(\"submodule\", \"status\");        ConsoleResult result = runOrBomb(gitCmd);        return submoduleFolders(result.output());    }    @TestOnly    public void submoduleAdd(String repoUrl, String submoduleNameToPutInGitSubmodules, String folder) {        String[] addSubmoduleWithSameNameArgs = new String[]{\"submodule\", \"add\", repoUrl, folder};        String[] changeSubmoduleNameInGitModules = new String[]{\"config\", \"--file\", \".gitmodules\", \"--rename-section\", \"submodule.\" + folder, \"submodule.\" + submoduleNameToPutInGitSubmodules};        String[] addGitModules = new String[]{\"add\", \".gitmodules\"};        runOrBomb(gitWd().withArgs(addSubmoduleWithSameNameArgs));        runOrBomb(gitWd().withArgs(changeSubmoduleNameInGitModules));        runOrBomb(gitWd().withArgs(addGitModules));    }    @TestOnly    public void submoduleRemove(String folderName) {        configRemoveSection(\"submodule.\" + folderName);        CommandLine gitConfig = gitWd().withArgs(\"config\", \"-f\", \".gitmodules\", \"--remove-section\", \"submodule.\" + folderName);        runOrBomb(gitConfig);        CommandLine gitAdd = gitWd().withArgs(\"add\", \".gitmodules\");        runOrBomb(gitAdd);        CommandLine gitRm = gitWd().withArgs(\"rm\", \"--cached\", folderName);        runOrBomb(gitRm);        FileUtils.deleteQuietly(new File(workingDir, folderName));    }    @TestOnly    public String currentRevision() {        String[] args = new String[]{\"log\", \"-1\", \"--pretty=format:%H\"};        CommandLine gitCmd = gitWd().withArgs(args);        return runOrBomb(gitCmd).outputAsString();    }    public String getCurrentBranch() {        CommandLine getCurrentBranchCommand = gitWd().withArg(\"rev-parse\").withArg(\"--abbrev-ref\").withArg(\"HEAD\");        ConsoleResult consoleResult = runOrBomb(getCurrentBranchCommand);        return consoleResult.outputAsString();    }    @TestOnly    public void changeSubmoduleUrl(String submoduleName, String newUrl) {        String[] args = new String[]{\"config\", \"--file\", \".gitmodules\", \"submodule.\" + submoduleName + \".url\", newUrl};        CommandLine gitConfig = gitWd().withArgs(args);        runOrBomb(gitConfig);    }    public void submoduleSync() {        String[] syncArgs = new String[]{\"submodule\", \"sync\"};        CommandLine syncCmd = gitWd().withArgs(syncArgs);        runOrBomb(syncCmd);        List<String> foreachArgs = submoduleForEachRecursive(asList(\"git\", \"submodule\", \"sync\"));        CommandLine foreachCmd = gitWd().withArgs(foreachArgs);        runOrBomb(foreachCmd);    }    public boolean isShallow() {        return new File(workingDir, \".git/shallow\").exists();    }    public boolean containsRevisionInBranch(Revision revision) {        String[] args = {\"branch\", \"-r\", \"--contains\", revision.getRevision()};        CommandLine gitCommand = gitWd().withArgs(args);        try {            ConsoleResult consoleResult = runOrBomb(gitCommand);            return (consoleResult.outputAsString()).contains(remoteBranch());        } catch (CommandLineException e) {            return false;        }    }    protected Map<String, String> submoduleUrls() {        String[] args = new String[]{\"config\", \"--get-regexp\", \"^submodule\\\\..+\\\\.url\"};        CommandLine gitCmd = gitWd().withArgs(args);        ConsoleResult result = runOrBomb(gitCmd, false);        List<String> submoduleList = result.output();        HashMap<String, String> submoduleUrls = new HashMap<>();        for (String submoduleLine : submoduleList) {            Matcher m = GIT_SUBMODULE_URL_PATTERN.matcher(submoduleLine);            if (!m.find()) {                bomb(\"Unable to parse git-config output line: \" + result.replaceSecretInfo(submoduleLine) + \"\\n\"                        + \"From output:\\n\"                        + result.replaceSecretInfo(StringUtils.join(submoduleList, \"\\n\")));            }            submoduleUrls.put(m.group(1), m.group(2));        }        return submoduleUrls;    }    private CommandLine cloneCommand() {        return git().withArg(\"clone\");    }    private List<Modification> gitLog(String... args) {        InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();        try {            if (!isSubmodule) {                fetch(outputStreamConsumer);            }        } catch (Exception e) {            throw new RuntimeException(format(\"Working directory: %s\\n%s\", workingDir, outputStreamConsumer.getStdError()), e);        }        CommandLine gitCmd = gitWd().withArg(\"log\").withArgs(args);        ConsoleResult result = runOrBomb(gitCmd);        GitModificationParser parser = new GitModificationParser();        List<Modification> mods = parser.parse(result.output());        for (Modification mod : mods) {            addModifiedFiles(mod);        }        return mods;    }    private void addModifiedFiles(Modification mod) {        ConsoleResult consoleResult = diffTree(mod.getRevision());        List<String> result = consoleResult.output();        for (String resultLine : result) {            if (resultLine.equals(mod.getRevision())) {                continue;            }            Matcher m = matchResultLine(resultLine);            if (!m.find()) {                bomb(\"Unable to parse git-diff-tree output line: \" + consoleResult.replaceSecretInfo(resultLine) + \"\\n\"                        + \"From output:\\n\"                        + consoleResult.outputForDisplayAsString());            }            mod.createModifiedFile(m.group(2), null, parseGitAction(m.group(1).charAt(0)));        }    }    private ConsoleResult diffTree(String node) {        CommandLine gitCmd = gitWd().withArgs(\"diff-tree\", \"--name-status\", \"--root\", \"-r\", node);        return runOrBomb(gitCmd);    }    private Matcher matchResultLine(String resultLine) {        return GIT_DIFF_TREE_PATTERN.matcher(resultLine);    }    private void checkoutAllModifiedFilesInSubmodules(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Removing modified files in submodules\");        List<String> submoduleForEachRecursive = submoduleForEachRecursive(asList(\"git\", \"checkout\", \".\"));        runOrBomb(gitWd().withArgs(submoduleForEachRecursive));    }    private String gitCleanArgs() {        if (\"Y\".equalsIgnoreCase(System.getProperty(GIT_CLEAN_KEEP_IGNORED_FILES_FLAG))) {            LOG.info(\"{} = Y. Using old behaviour for clean using `-dff`\", GIT_CLEAN_KEEP_IGNORED_FILES_FLAG);            return \"-dff\";        } else {            return \"-dffx\";        }    }    private void printSubmoduleStatus(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Git sub-module status\");        CommandLine gitCmd = gitWd().withArgs(\"submodule\", \"status\");        run(gitCmd, outputStreamConsumer);    }    private CommandLine git() {        CommandLine git = CommandLine.createCommandLine(\"git\").withEncoding(\"UTF-8\");        return git.withNonArgSecrets(secrets);    }    private CommandLine git_C() {        return git().withArgs(\"-C\", workingDir.getAbsolutePath());    }    private CommandLine gitWd() {        return git().withWorkingDir(workingDir);    }    private void updateSubmodule() {        CommandLine updateCmd = gitWd().withArgs(\"submodule\", \"update\");        runOrBomb(updateCmd);    }    private void tryToShallowUpdateSubmodules() {        if (updateSubmoduleWithDepth(1)) {            return;        }        LOG.warn(\"git submodule update with --depth=1 failed. Attempting again with --depth={}\", UNSHALLOW_TRYOUT_STEP);        if (updateSubmoduleWithDepth(UNSHALLOW_TRYOUT_STEP)) {            return;        }        LOG.warn(\"git submodule update with depth={} failed. Attempting again with --depth=Integer.MAX\", UNSHALLOW_TRYOUT_STEP);        if (!updateSubmoduleWithDepth(Integer.MAX_VALUE)) {            bomb(\"Failed to update submodule\");        }    }    private boolean updateSubmoduleWithDepth(int depth) {        List<String> updateArgs = new ArrayList<>(asList(\"submodule\", \"update\"));        updateArgs.add(\"--depth=\" + depth);        CommandLine commandLine = gitWd().withArgs(updateArgs);        try {            runOrBomb(commandLine);        } catch (Exception e) {            LOG.warn(e.getMessage(), e);            return false;        }        return true;    }    private void cleanAllUnversionedFiles(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Cleaning all unversioned files in working copy\");        cleanUnversionedFilesInAllSubmodules();        cleanUnversionedFiles();    }    private void cleanUnversionedFiles() {        runOrBomb(gitWd().withArgs(\"clean\", gitCleanArgs()));    }    private void cleanUnversionedFilesInAllSubmodules() {        List<String> args = submoduleForEachRecursive(asList(\"git\", \"clean\", gitCleanArgs()));        runOrBomb(gitWd().withArgs(args));    }    private void removeSubmoduleSectionsFromGitConfig(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Cleaning submodule configurations in .git/config\");        for (String submoduleFolder : submoduleUrls().keySet()) {            configRemoveSection(\"submodule.\" + submoduleFolder);        }    }    private void configRemoveSection(String section) {        String[] args = new String[]{\"config\", \"--remove-section\", section};        CommandLine gitCmd = gitWd().withArgs(args);        runOrBomb(gitCmd, false);    }    private boolean gitSubmoduleEnabled() {        return new File(workingDir, \".gitmodules\").exists();    }    private void gc(ConsoleOutputStreamConsumer outputStreamConsumer) {        log(outputStreamConsumer, \"Performing git gc\");        CommandLine gitGc = gitWd().withArgs(\"gc\", \"--auto\");        run(gitGc, outputStreamConsumer);    }    @TestOnly    private List<String> submoduleFolders(List<String> submoduleLines) {        ArrayList<String> submoduleFolders = new ArrayList<>();        for (String submoduleLine : submoduleLines) {            Matcher m = GIT_SUBMODULE_STATUS_PATTERN.matcher(submoduleLine);            if (!m.find()) {                bomb(\"Unable to parse git-submodule output line: \" + submoduleLine + \"\\n\"                        + \"From output:\\n\"                        + StringUtils.join(submoduleLines, \"\\n\"));            }            submoduleFolders.add(m.group(1));        }        return submoduleFolders;    }    private void log(ConsoleOutputStreamConsumer outputStreamConsumer, String message, Object... args) {        LOG.debug(format(message, args));        outputStreamConsumer.stdOutput(format(\"[GIT] \" + message, args));    }    private List<String> submoduleForEachRecursive(List<String> args) {        List<String> forEachArgs = new ArrayList<>(asList(\"submodule\", \"foreach\", \"--recursive\"));        if (version().requiresSubmoduleCommandFix()) {            forEachArgs.add(StringUtils.join(args, \" \"));        } else {            forEachArgs.addAll(args);        }        return forEachArgs;    }}"}
{"code": "import com.thoughtworks.go.config.ConfigAttributeValue;import org.apache.commons.lang3.StringUtils;import org.apache.http.client.utils.URIBuilder;import java.net.URI;import java.net.URISyntaxException;import java.util.regex.Pattern;import static com.thoughtworks.go.util.ExceptionUtils.bombIfNull;import static org.apache.commons.lang3.StringUtils.isBlank;@ConfigAttributeValue(fieldName = \"url\")public class UrlArgument extends CommandArgument {    private static final String URL_DUMB_VALIDATION_REGEX = \"^[a-zA-Z0-9/#].*\";    private static final Pattern pattern = Pattern.compile(URL_DUMB_VALIDATION_REGEX);    protected String url;    public UrlArgument(String url) {        bombIfNull(url, \"Url cannot be null.\");        this.url = url;    }    @Override    public String originalArgument() {        return url;    }    @Override    public String forDisplay() {        try {            URI uri = new URI(sanitizeUrl());            if (uri.getUserInfo() != null) {                uri = new URI(uri.getScheme(), clean(uri.getScheme(), uri.getUserInfo()), uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());            }            return uri.toString();        } catch (URISyntaxException e) {            return url;        }    }    private String clean(String scheme, String userInfo) {        if (userInfo.contains(\":\")) {            return userInfo.replaceFirst(\":.*\", \":******\");        } else if (\"ssh\".equals(scheme) || \"svn+ssh\".equals(scheme)) {            return userInfo;        }        return \"******\";    }    @Override    public String forCommandLine() {        return this.url;    }    protected String sanitizeUrl() {        return this.url;    }    public static UrlArgument create(String url) {        return new UrlArgument(url);    }    @Override    public String replaceSecretInfo(String line) {        if (StringUtils.isBlank(line)) {            return line;        }        if (isBlank(this.url)) {            return line;        }        try {            final URIBuilder uriBuilder = new URIBuilder(this.url).setPath(null).setCustomQuery(null).setFragment(null);            final UrlUserInfo urlUserInfo = new UrlUserInfo(uriBuilder.getUserInfo());            if (uriBuilder.getUserInfo() != null) {                line = line.replace(uriBuilder.getUserInfo(), urlUserInfo.maskedUserInfo());            }        } catch (URISyntaxException e) {        }        return line;    }    @Override    public boolean equal(CommandArgument that) {        if (url.startsWith(\"svn+ssh\")) {            return this.originalArgument().equals(that.originalArgument());        }        return cleanPath(this).equals(cleanPath(that));    }    private String cleanPath(CommandArgument commandArgument) {        String path = commandArgument.originalArgument();        if (path.endsWith(\"/\")) {            path = path.substring(0, path.length() - 1);        }        return path;    }    public String withoutCredentials() {        try {            return new URIBuilder(this.sanitizeUrl()).setUserInfo(null).build().toString();        } catch (URISyntaxException e) {            return url;        }    }    public boolean isValidURLOrLocalPath() {        return pattern.matcher(url).matches();    }}", "nl": "import com.thoughtworks.go.config.ConfigAttributeValue;import org.apache.commons.lang3.StringUtils;import org.apache.http.client.utils.URIBuilder;import java.net.URI;import java.net.URISyntaxException;import java.util.regex.Pattern;import static com.thoughtworks.go.util.ExceptionUtils.bombIfNull;import static org.apache.commons.lang3.StringUtils.isBlank;@ConfigAttributeValue(fieldName = \"url\")public class UrlArgument extends CommandArgument {    private static final String URL_DUMB_VALIDATION_REGEX = \"^[a-zA-Z0-9/].*\";    private static final Pattern pattern = Pattern.compile(URL_DUMB_VALIDATION_REGEX);    protected String url;    public UrlArgument(String url) {        bombIfNull(url, \"Url cannot be null.\");        this.url = url;    }    @Override    public String originalArgument() {        return url;    }    @Override    public String forDisplay() {        try {            URI uri = new URI(sanitizeUrl());            if (uri.getUserInfo() != null) {                uri = new URI(uri.getScheme(), clean(uri.getScheme(), uri.getUserInfo()), uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());            }            return uri.toString();        } catch (URISyntaxException e) {            return url;        }    }    private String clean(String scheme, String userInfo) {        if (userInfo.contains(\":\")) {            return userInfo.replaceFirst(\":.*\", \":******\");        } else if (\"ssh\".equals(scheme) || \"svn+ssh\".equals(scheme)) {            return userInfo;        }        return \"******\";    }    @Override    public String forCommandLine() {        return this.url;    }    protected String sanitizeUrl() {        return this.url;    }    public static UrlArgument create(String url) {        return new UrlArgument(url);    }    @Override    public String replaceSecretInfo(String line) {        if (StringUtils.isBlank(line)) {            return line;        }        if (isBlank(this.url)) {            return line;        }        try {            final URIBuilder uriBuilder = new URIBuilder(this.url).setPath(null).setCustomQuery(null).setFragment(null);            final UrlUserInfo urlUserInfo = new UrlUserInfo(uriBuilder.getUserInfo());            if (uriBuilder.getUserInfo() != null) {                line = line.replace(uriBuilder.getUserInfo(), urlUserInfo.maskedUserInfo());            }        } catch (URISyntaxException e) {        }        return line;    }    @Override    public boolean equal(CommandArgument that) {        if (url.startsWith(\"svn+ssh\")) {            return this.originalArgument().equals(that.originalArgument());        }        return cleanPath(this).equals(cleanPath(that));    }    private String cleanPath(CommandArgument commandArgument) {        String path = commandArgument.originalArgument();        if (path.endsWith(\"/\")) {            path = path.substring(0, path.length() - 1);        }        return path;    }    public String withoutCredentials() {        try {            return new URIBuilder(this.sanitizeUrl()).setUserInfo(null).build().toString();        } catch (URISyntaxException e) {            return url;        }    }    public boolean isValidURLOrLocalPath() {        return pattern.matcher(url).matches();    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.git;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.Mockito.*;class GitMaterialConfigTest {    @Test    void shouldBePasswordAwareMaterial() {        assertTrue(PasswordAwareMaterial.class.isAssignableFrom(GitMaterialConfig.class));    }    @Test    void shouldSetConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.URL, \"url\");        map.put(GitMaterialConfig.BRANCH, \"some-branch\");        map.put(GitMaterialConfig.SHALLOW_CLONE, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, null);        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        gitMaterialConfig.setConfigAttributes(map);        assertEquals(\"url\", gitMaterialConfig.getUrl());        assertEquals(\"folder\", gitMaterialConfig.getFolder());        assertEquals(\"some-branch\", gitMaterialConfig.getBranch());        assertEquals(new CaseInsensitiveString(\"material-name\"), gitMaterialConfig.getName());        assertFalse(gitMaterialConfig.isAutoUpdate());        assertTrue(gitMaterialConfig.isShallowClone());        assertEquals(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")), gitMaterialConfig.filter());    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.PASSWORD, \"secret\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"Hehehe\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"0\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(gitMaterialConfig.getPassword());        assertNull(gitMaterialConfig.getEncryptedPassword());    }    @Test    void byDefaultShallowCloneShouldBeOff() {        assertFalse(git(\"http:        assertFalse(git(\"http:        assertFalse(git(\"http:        assertTrue(git(\"http:    }    @Test    void shouldReturnIfAttributeMapIsNull() {        GitMaterialConfig gitMaterialConfig = git(\"\");        gitMaterialConfig.setConfigAttributes(null);        assertEquals(git(\"\"), gitMaterialConfig);    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        GitMaterialConfig config = git();        assertNull(config.getUrl());    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git();        config.setUrl(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        GitMaterialConfig config = git();        config.setUrl(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullUrlAtTheTimeOfGitMaterialConfigCreation() {        GitMaterialConfig config = git(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, null));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Test    void shouldHandleEmptyBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, \"     \"));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Nested    class Validate {        @Test        void allowsBlankBranch() {            assertFalse(validating(git(\"/my/repo\", null)).errors().present());            assertFalse(validating(git(\"/my/repo\", \"\")).errors().present());            assertFalse(validating(git(\"/my/repo\", \" \")).errors().present());        }        @Test        void rejectsBranchWithWildcard() {            assertEquals(\"Branch names may not contain '*'\", validating(git(\"/foo\", \"branch-*\")).                    errors().on(GitMaterialConfig.BRANCH));        }        @Test        void rejectsMalformedRefSpec() {            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \":a\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \"   :b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/foo: \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/bar:\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \":\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \" : \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec source must be an absolute ref (must start with `refs/`)\",                    String.join(\";\", validating(git(\"/foo\", \"a:b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:my-branch\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/foo:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));        }        @Test        void acceptsValidRefSpecs() {            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:pr-123\")).errors().isEmpty());            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:refs/my-prs/123\")).errors().isEmpty());        }        @Test        void shouldEnsureUrlIsNotBlank() {            assertEquals(\"URL cannot be blank\", validating(git(\"\")).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setPassword(\"pass\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            gitMaterialConfig.setPassword(\"password\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            assertFalse(validating(git(\"http:        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"bob\");            gitMaterialConfig.setPassword(\"badger\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(git(\"-url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertTrue(validating(git(\"_url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertTrue(validating(git(\"@url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertFalse(validating(git(\"url-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertFalse(validating(git(\"#{url}\")).errors().containsKey(GitMaterialConfig.URL));        }        private GitMaterialConfig validating(GitMaterialConfig git) {            git.validate(new ConfigSaveValidationContext(null));            return git;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(git(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = gitMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertFalse(validationResult);            assertEquals(\"Encrypted password value for GitMaterial with url 'http:                            \"invalid. This usually happens when the cipher text is modified to have an invalid value.\",                    gitMaterialConfig.errors().on(\"encryptedPassword\"));        }    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranchAndSubModuleFolder() {            final GitMaterialConfig material_1 = git(\"http:            material_1.setUserName(\"bob\");            material_1.setSubmoduleFolder(\"/var/lib/git\");            final GitMaterialConfig material_2 = git(\"http:            material_2.setUserName(\"alice\");            material_2.setSubmoduleFolder(\"/var/lib/git\");            assertTrue(material_1.equals(material_2));        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrlAndBranch() {            GitMaterialConfig gitMaterialConfig = git(\"https:            assertEquals(\"755da7fb7415c8674bdf5f8a4ba48fc3e071e5de429b1308ccf8949d215bdb08\", gitMaterialConfig.getFingerprint());        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.git;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.Mockito.*;class GitMaterialConfigTest {    @Test    void shouldBePasswordAwareMaterial() {        assertTrue(PasswordAwareMaterial.class.isAssignableFrom(GitMaterialConfig.class));    }    @Test    void shouldSetConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.URL, \"url\");        map.put(GitMaterialConfig.BRANCH, \"some-branch\");        map.put(GitMaterialConfig.SHALLOW_CLONE, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, null);        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        gitMaterialConfig.setConfigAttributes(map);        assertEquals(\"url\", gitMaterialConfig.getUrl());        assertEquals(\"folder\", gitMaterialConfig.getFolder());        assertEquals(\"some-branch\", gitMaterialConfig.getBranch());        assertEquals(new CaseInsensitiveString(\"material-name\"), gitMaterialConfig.getName());        assertFalse(gitMaterialConfig.isAutoUpdate());        assertTrue(gitMaterialConfig.isShallowClone());        assertEquals(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")), gitMaterialConfig.filter());    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        GitMaterialConfig gitMaterialConfig = git(\"\");        Map<String, String> map = new HashMap<>();        map.put(GitMaterialConfig.PASSWORD, \"secret\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"Hehehe\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"0\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(ReflectionUtil.getField(gitMaterialConfig, \"password\"));        assertEquals(\"secret\", gitMaterialConfig.getPassword());        assertEquals(new GoCipher().encrypt(\"secret\"), gitMaterialConfig.getEncryptedPassword());        map.put(GitMaterialConfig.PASSWORD, \"\");        map.put(GitMaterialConfig.PASSWORD_CHANGED, \"1\");        gitMaterialConfig.setConfigAttributes(map);        assertNull(gitMaterialConfig.getPassword());        assertNull(gitMaterialConfig.getEncryptedPassword());    }    @Test    void byDefaultShallowCloneShouldBeOff() {        assertFalse(git(\"http:        assertFalse(git(\"http:        assertFalse(git(\"http:        assertTrue(git(\"http:    }    @Test    void shouldReturnIfAttributeMapIsNull() {        GitMaterialConfig gitMaterialConfig = git(\"\");        gitMaterialConfig.setConfigAttributes(null);        assertEquals(git(\"\"), gitMaterialConfig);    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        GitMaterialConfig config = git();        assertNull(config.getUrl());    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        GitMaterialConfig config = git();        config.setUrl(url);        assertEquals(url, config.getUrl());    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        GitMaterialConfig config = git();        config.setUrl(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullUrlAtTheTimeOfGitMaterialConfigCreation() {        GitMaterialConfig config = git(null);        assertNull(config.getUrl());    }    @Test    void shouldHandleNullBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, null));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Test    void shouldHandleEmptyBranchWhileSettingConfigAttributes() {        GitMaterialConfig gitMaterialConfig = git(\"http:        gitMaterialConfig.setConfigAttributes(Collections.singletonMap(GitMaterialConfig.BRANCH, \"     \"));        assertEquals(\"master\", gitMaterialConfig.getBranch());    }    @Nested    class Validate {        @Test        void allowsBlankBranch() {            assertFalse(validating(git(\"/my/repo\", null)).errors().present());            assertFalse(validating(git(\"/my/repo\", \"\")).errors().present());            assertFalse(validating(git(\"/my/repo\", \" \")).errors().present());        }        @Test        void rejectsBranchWithWildcard() {            assertEquals(\"Branch names may not contain '*'\", validating(git(\"/foo\", \"branch-*\")).                    errors().on(GitMaterialConfig.BRANCH));        }        @Test        void rejectsMalformedRefSpec() {            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \":a\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref\",                    String.join(\";\", validating(git(\"/foo\", \"   :b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/foo: \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \"refs/bar:\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \":\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec is missing a source ref;Refspec is missing a destination ref\",                    String.join(\";\", validating(git(\"/foo\", \" : \")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspec source must be an absolute ref (must start with `refs/`)\",                    String.join(\";\", validating(git(\"/foo\", \"a:b\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:my-branch\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/foo:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));            assertEquals(\"Refspecs may not contain wildcards; source and destination refs must be exact\",                    String.join(\";\", validating(git(\"/foo\", \"refs/heads/*:branches/*\")).errors().                            getAllOn(GitMaterialConfig.BRANCH)));        }        @Test        void acceptsValidRefSpecs() {            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:pr-123\")).errors().isEmpty());            assertTrue(validating(git(\"/foo\", \"refs/pull/123/head:refs/my-prs/123\")).errors().isEmpty());        }        @Test        void shouldEnsureUrlIsNotBlank() {            assertEquals(\"URL cannot be blank\", validating(git(\"\")).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setPassword(\"pass\");            assertEquals(\"Ambiguous credentials, must be provided either in URL or as attributes.\", validating(gitMaterialConfig).errors().on(GitMaterialConfig.URL));        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"user\");            gitMaterialConfig.setPassword(\"password\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            assertFalse(validating(git(\"http:        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setUserName(\"bob\");            gitMaterialConfig.setPassword(\"badger\");            assertFalse(validating(gitMaterialConfig).errors().containsKey(GitMaterialConfig.URL));        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(git(\"-url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertTrue(validating(git(\"_url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertTrue(validating(git(\"@url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));            assertFalse(validating(git(\"url-starting-with-an-alphanumeric-character\")).errors().containsKey(GitMaterialConfig.URL));        }        private GitMaterialConfig validating(GitMaterialConfig git) {            git.validate(new ConfigSaveValidationContext(null));            return git;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(git(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            GitMaterialConfig gitMaterialConfig = git(\"http:            gitMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = gitMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertFalse(validationResult);            assertEquals(\"Encrypted password value for GitMaterial with url 'http:                            \"invalid. This usually happens when the cipher text is modified to have an invalid value.\",                    gitMaterialConfig.errors().on(\"encryptedPassword\"));        }    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranchAndSubModuleFolder() {            final GitMaterialConfig material_1 = git(\"http:            material_1.setUserName(\"bob\");            material_1.setSubmoduleFolder(\"/var/lib/git\");            final GitMaterialConfig material_2 = git(\"http:            material_2.setUserName(\"alice\");            material_2.setSubmoduleFolder(\"/var/lib/git\");            assertTrue(material_1.equals(material_2));        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrlAndBranch() {            GitMaterialConfig gitMaterialConfig = git(\"https:            assertEquals(\"755da7fb7415c8674bdf5f8a4ba48fc3e071e5de429b1308ccf8949d215bdb08\", gitMaterialConfig.getFingerprint());        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.git;import static com.thoughtworks.go.helper.MaterialConfigsMother.hg;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class HgMaterialConfigTest {    private HgMaterialConfig hgMaterialConfig;    @BeforeEach    void setUp() {        hgMaterialConfig = hg(\"\", null);    }    @Test    void shouldBePasswordAwareMaterial() {        assertThat(hgMaterialConfig).isInstanceOf(PasswordAwareMaterial.class);    }    @Test    void shouldSetConfigAttributes() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.URL, \"url\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(hgMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(hgMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(hgMaterialConfig.isAutoUpdate()).isFalse();        assertThat(hgMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        HgMaterialConfig hgMaterialConfig = hg();        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.PASSWORD, \"secret\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"Hehehe\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"0\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getPassword()).isNull();        assertThat(hgMaterialConfig.getEncryptedPassword()).isNull();    }    @Test    void validate_shouldEnsureUrlIsNotBlank() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");    }    @Test    void shouldReturnIfAttributeMapIsNull() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.setConfigAttributes(null);        assertThat(hgMaterialConfig).isEqualTo(hg(\"\", null));    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg(url, null);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        HgMaterialConfig config = hg();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        HgMaterialConfig config = hg();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranch() {            final HgMaterialConfig material_1 = hg(\"http:            material_1.setUserName(\"bob\");            material_1.setBranchAttribute(\"feature\");            final HgMaterialConfig material_2 = hg(\"http:            material_2.setUserName(\"alice\");            material_2.setBranchAttribute(\"feature\");            assertThat(material_1.equals(material_2)).isTrue();        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"d84d91f37da0367a9bd89fff0d48638f5c1bf993d637735ec26f13c21c23da19\");        }        @Test        void shouldConsiderBranchWhileGeneratingFingerprint_IfBranchSpecifiedAsAnAttribute() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            hgMaterialConfig.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"db13278ed2b804fc5664361103bcea3d7f5106879683085caed4311aa4d2f888\");        }        @Test        void branchInUrlShouldGenerateFingerprintWhichIsOtherFromBranchInAttribute() {            HgMaterialConfig hgMaterialConfigWithBranchInUrl = hg(\"https:            HgMaterialConfig hgMaterialConfigWithBranchAsAttribute = hg(\"https:            hgMaterialConfigWithBranchAsAttribute.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfigWithBranchInUrl.getFingerprint())                    .isNotEqualTo(hgMaterialConfigWithBranchAsAttribute.getFingerprint());        }    }    @Nested    class validate {        @Test        void shouldEnsureUrlIsNotBlank() {            hgMaterialConfig.setUrl(\"\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            hgMaterialConfig.setUrl(null);            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            hgMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            hgMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setPassword(\"pass\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.setPassword(\"password\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"bob\");            hgMaterialConfig.setPassword(\"badger\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldEnsureBranchIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setBranchAttribute(\"branch-in-attribute\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous branch, must be provided either in URL or as an attribute.\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(hg(\"-url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertTrue(validating(hg(\"_url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertTrue(validating(hg(\"@url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertFalse(validating(hg(\"url-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertFalse(validating(hg(\"#{url}\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));        }        private HgMaterialConfig validating(HgMaterialConfig hg) {            hg.validate(new ConfigSaveValidationContext(null));            return hg;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(hg(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = hgMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(hgMaterialConfig.errors().on(\"encryptedPassword\"))                    .isEqualTo(\"Encrypted password value for HgMaterial with url 'http:        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.*;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.git;import static com.thoughtworks.go.helper.MaterialConfigsMother.hg;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class HgMaterialConfigTest {    private HgMaterialConfig hgMaterialConfig;    @BeforeEach    void setUp() {        hgMaterialConfig = hg(\"\", null);    }    @Test    void shouldBePasswordAwareMaterial() {        assertThat(hgMaterialConfig).isInstanceOf(PasswordAwareMaterial.class);    }    @Test    void shouldSetConfigAttributes() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.URL, \"url\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(hgMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(hgMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(hgMaterialConfig.isAutoUpdate()).isFalse();        assertThat(hgMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        HgMaterialConfig hgMaterialConfig = hg();        Map<String, String> map = new HashMap<>();        map.put(HgMaterialConfig.PASSWORD, \"secret\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"Hehehe\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"0\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(hgMaterialConfig, \"password\")).isNull();        assertThat(hgMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(hgMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(HgMaterialConfig.PASSWORD, \"\");        map.put(HgMaterialConfig.PASSWORD_CHANGED, \"1\");        hgMaterialConfig.setConfigAttributes(map);        assertThat(hgMaterialConfig.getPassword()).isNull();        assertThat(hgMaterialConfig.getEncryptedPassword()).isNull();    }    @Test    void validate_shouldEnsureUrlIsNotBlank() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.validate(new ConfigSaveValidationContext(null));        assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");    }    @Test    void shouldReturnIfAttributeMapIsNull() {        HgMaterialConfig hgMaterialConfig = hg(\"\", null);        hgMaterialConfig.setConfigAttributes(null);        assertThat(hgMaterialConfig).isEqualTo(hg(\"\", null));    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg(url, null);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        HgMaterialConfig config = hg();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldSetUrlForAMaterial() {        String url = \"git@github.com/my/repo\";        HgMaterialConfig config = hg();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        HgMaterialConfig config = hg();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class Equals {        @Test        void shouldBeEqualIfObjectsHaveSameUrlBranch() {            final HgMaterialConfig material_1 = hg(\"http:            material_1.setUserName(\"bob\");            material_1.setBranchAttribute(\"feature\");            final HgMaterialConfig material_2 = hg(\"http:            material_2.setUserName(\"alice\");            material_2.setBranchAttribute(\"feature\");            assertThat(material_1.equals(material_2)).isTrue();        }    }    @Nested    class Fingerprint {        @Test        void shouldGenerateFingerprintForGivenMaterialUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"d84d91f37da0367a9bd89fff0d48638f5c1bf993d637735ec26f13c21c23da19\");        }        @Test        void shouldConsiderBranchWhileGeneratingFingerprint_IfBranchSpecifiedAsAnAttribute() {            HgMaterialConfig hgMaterialConfig = hg(\"https:            hgMaterialConfig.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfig.getFingerprint()).isEqualTo(\"db13278ed2b804fc5664361103bcea3d7f5106879683085caed4311aa4d2f888\");        }        @Test        void branchInUrlShouldGenerateFingerprintWhichIsOtherFromBranchInAttribute() {            HgMaterialConfig hgMaterialConfigWithBranchInUrl = hg(\"https:            HgMaterialConfig hgMaterialConfigWithBranchAsAttribute = hg(\"https:            hgMaterialConfigWithBranchAsAttribute.setBranchAttribute(\"feature\");            assertThat(hgMaterialConfigWithBranchInUrl.getFingerprint())                    .isNotEqualTo(hgMaterialConfigWithBranchAsAttribute.getFingerprint());        }    }    @Nested    class validate {        @Test        void shouldEnsureUrlIsNotBlank() {            hgMaterialConfig.setUrl(\"\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            hgMaterialConfig.setUrl(null);            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            hgMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            hgMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUserNameIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldEnsurePasswordIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setPassword(\"pass\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous credentials, must be provided either in URL or as attributes.\");        }        @Test        void shouldIgnoreInvalidUrlForCredentialValidation() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"user\");            hgMaterialConfig.setPassword(\"password\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyInUrl() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldBeValidWhenCredentialsAreProvidedOnlyAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setUserName(\"bob\");            hgMaterialConfig.setPassword(\"badger\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isNull();        }        @Test        void shouldEnsureBranchIsNotProvidedInBothUrlAsWellAsAttributes() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setBranchAttribute(\"branch-in-attribute\");            hgMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(hgMaterialConfig.errors().on(HgMaterialConfig.URL)).isEqualTo(\"Ambiguous branch, must be provided either in URL or as an attribute.\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(hg(\"-url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertTrue(validating(hg(\"_url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertTrue(validating(hg(\"@url-not-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));            assertFalse(validating(hg(\"url-starting-with-an-alphanumeric-character\", \"folder\")).errors().containsKey(HgMaterialConfig.URL));        }        private HgMaterialConfig validating(HgMaterialConfig hg) {            hg.validate(new ConfigSaveValidationContext(null));            return hg;        }    }    @Nested    class ValidateTree {        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(hg(\"https:            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            HgMaterialConfig hgMaterialConfig = hg(\"http:            hgMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = hgMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(hgMaterialConfig.errors().on(\"encryptedPassword\"))                    .isEqualTo(\"Encrypted password value for HgMaterial with url 'http:        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.AbstractMaterialConfig;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.svn;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class SvnMaterialConfigTest {    private SvnMaterialConfig svnMaterialConfig;    @BeforeEach    void setUp() {        svnMaterialConfig = svn();    }    @Test    void shouldSetConfigAttributes() {        SvnMaterialConfig svnMaterialConfig = svn(\"\", \"\", \"\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.URL, \"url\");        map.put(SvnMaterialConfig.USERNAME, \"username\");        map.put(SvnMaterialConfig.CHECK_EXTERNALS, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        svnMaterialConfig.setConfigAttributes(map);        assertThat(svnMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(svnMaterialConfig.getUserName()).isEqualTo(\"username\");        assertThat(svnMaterialConfig.isCheckExternals()).isTrue();        assertThat(svnMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(svnMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(svnMaterialConfig.isAutoUpdate()).isFalse();        assertThat(svnMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        SvnMaterialConfig svnMaterial = svn(\"\", \"\", \"notSoSecret\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.PASSWORD, \"secret\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"Hehehe\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"0\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(svnMaterial.getPassword()).isNull();        assertThat(svnMaterial.getEncryptedPassword()).isNull();    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        SvnMaterialConfig config = svn();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        SvnMaterialConfig config = svn();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        SvnMaterialConfig config = svn();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateURL {        @Test        void shouldEnsureUrlIsNotBlank() {            svnMaterialConfig.setUrl(\"\");            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(GitMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isNull();            svnMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            svnMaterialConfig.setConfigAttributes(Collections.singletonMap(ScmMaterialConfig.FOLDER, \"../a\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(svn(\"-url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertTrue(validating(svn(\"_url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertTrue(validating(svn(\"@url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertFalse(validating(svn(\"url-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertFalse(validating(svn(\"#{url}\", false)).errors().containsKey(SvnMaterialConfig.URL));        }        private SvnMaterialConfig validating(SvnMaterialConfig svn) {            svn.validate(new ConfigSaveValidationContext(null));            return svn;        }    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            svnMaterialConfig.setUrl(\"foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(svnMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            svnMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = svnMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(svnMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for SvnMaterial with url 'foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            svnMaterialConfig.setPassword(\"badger\");            assertThat(svnMaterialConfig.validateTree(null)).isTrue();            assertThat(svnMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.AbstractMaterialConfig;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.config.materials.git.GitMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.helper.MaterialConfigsMother.svn;import static org.assertj.core.api.Assertions.assertThat;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class SvnMaterialConfigTest {    private SvnMaterialConfig svnMaterialConfig;    @BeforeEach    void setUp() {        svnMaterialConfig = svn();    }    @Test    void shouldSetConfigAttributes() {        SvnMaterialConfig svnMaterialConfig = svn(\"\", \"\", \"\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.URL, \"url\");        map.put(SvnMaterialConfig.USERNAME, \"username\");        map.put(SvnMaterialConfig.CHECK_EXTERNALS, \"true\");        map.put(ScmMaterialConfig.FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(AbstractMaterialConfig.MATERIAL_NAME, \"material-name\");        svnMaterialConfig.setConfigAttributes(map);        assertThat(svnMaterialConfig.getUrl()).isEqualTo(\"url\");        assertThat(svnMaterialConfig.getUserName()).isEqualTo(\"username\");        assertThat(svnMaterialConfig.isCheckExternals()).isTrue();        assertThat(svnMaterialConfig.getFolder()).isEqualTo(\"folder\");        assertThat(svnMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"material-name\"));        assertThat(svnMaterialConfig.isAutoUpdate()).isFalse();        assertThat(svnMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        SvnMaterialConfig svnMaterial = svn(\"\", \"\", \"notSoSecret\", false);        Map<String, String> map = new HashMap<>();        map.put(SvnMaterialConfig.PASSWORD, \"secret\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"Hehehe\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"0\");        svnMaterial.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(svnMaterial, \"password\")).isNull();        assertThat(svnMaterial.getPassword()).isEqualTo(\"secret\");        assertThat(svnMaterial.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(SvnMaterialConfig.PASSWORD, \"\");        map.put(SvnMaterialConfig.PASSWORD_CHANGED, \"1\");        svnMaterial.setConfigAttributes(map);        assertThat(svnMaterial.getPassword()).isNull();        assertThat(svnMaterial.getEncryptedPassword()).isNull();    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        SvnMaterialConfig config = svn();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        SvnMaterialConfig config = svn();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        SvnMaterialConfig config = svn();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateURL {        @Test        void shouldEnsureUrlIsNotBlank() {            svnMaterialConfig.setUrl(\"\");            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(GitMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isNull();            svnMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            svnMaterialConfig.setConfigAttributes(Collections.singletonMap(ScmMaterialConfig.FOLDER, \"../a\"));            svnMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(svnMaterialConfig.errors().on(SvnMaterialConfig.FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(svn(\"-url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertTrue(validating(svn(\"_url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertTrue(validating(svn(\"@url-not-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));            assertFalse(validating(svn(\"url-starting-with-an-alphanumeric-character\", false)).errors().containsKey(SvnMaterialConfig.URL));        }        private SvnMaterialConfig validating(SvnMaterialConfig svn) {            svn.validate(new ConfigSaveValidationContext(null));            return svn;        }    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            svnMaterialConfig.setUrl(\"foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(svnMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            svnMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = svnMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(svnMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for SvnMaterial with url 'foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            svnMaterialConfig.setPassword(\"badger\");            assertThat(svnMaterialConfig.validateTree(null)).isTrue();            assertThat(svnMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.CryptoException;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import com.thoughtworks.go.util.command.UrlArgument;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.tfs;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.api.Assertions.fail;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class TfsMaterialConfigTest {    private TfsMaterialConfig tfsMaterialConfig;    @BeforeEach    void setUp() {        tfsMaterialConfig = tfs(new GoCipher(), null, \"loser\", \"some_domain\", \"passwd\", \"walk_this_path\");    }    @Test    void shouldSetConfigAttributes() {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(URL, \"http:        map.put(ScmMaterialConfig.USERNAME, \"boozer\");        map.put(ScmMaterialConfig.PASSWORD, \"secret\");        map.put(FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(MATERIAL_NAME, \"my-tfs-material-name\");        map.put(TfsMaterialConfig.PROJECT_PATH, \"/useless/project\");        map.put(TfsMaterialConfig.DOMAIN, \"CORPORATE\");        tfsMaterialConfig.setConfigAttributes(map);        TfsMaterialConfig newTfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        newTfsMaterialConfig.setName(new CaseInsensitiveString(\"my-tfs-material-name\"));        newTfsMaterialConfig.setFolder(\"folder\");        assertThat(tfsMaterialConfig).isEqualTo(newTfsMaterialConfig);        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"passwd\");        assertThat(tfsMaterialConfig.isAutoUpdate()).isFalse();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"CORPORATE\");        assertThat(tfsMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"my-tfs-material-name\"));        assertThat(tfsMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void shouldDefaultDomainToEmptyStringWhenNothingIsSet() {        TfsMaterialConfig tfsMaterialConfig = tfs();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"\");    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(TfsMaterialConfig.PASSWORD, \"secret\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"Hehehe\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"0\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(tfsMaterialConfig.getPassword()).isNull();        assertThat(tfsMaterialConfig.getEncryptedPassword()).isNull();    }    @Nested    class Validate {        @Test        void shouldEnsureMandatoryFieldsAreNotBlank() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"\"), \"\", \"CORPORATE\", \"\", \"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.USERNAME)).isEqualTo(\"Username cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.PROJECT_PATH)).isEqualTo(\"Project Path cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            tfsMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUrlIsNotBlank() {            tfsMaterialConfig.setUrl(\"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            tfsMaterialConfig.setUrl(null);            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(tfs(\"-url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertTrue(validating(tfs(\"_url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertTrue(validating(tfs(\"@url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertFalse(validating(tfs(\"url-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertFalse(validating(tfs(\"#{url}\")).errors().containsKey(TfsMaterialConfig.URL));        }        private TfsMaterialConfig validating(TfsMaterialConfig tfs) {            tfs.validate(new ConfigSaveValidationContext(null));            return tfs;        }    }    @Test    void shouldEncryptTfsPasswordAndMarkPasswordAsNull() throws Exception {        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        Object passwordFieldValue = ReflectionUtil.getField(materialConfig, \"password\");        assertThat(passwordFieldValue).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"password\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"password\"));    }    @Test    void shouldDecryptTfsPassword() throws Exception {        String encryptedPassword = new GoCipher().encrypt(\"plain-text-password\");        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", encryptedPassword);        materialConfig.ensureEncrypted();        assertThat(materialConfig.getPassword()).isEqualTo(\"plain-text-password\");    }    @Test    void shouldNotDecryptTfsPasswordIfPasswordIsNotNull() throws Exception {        GoCipher mockGoCipher = mock(GoCipher.class);        when(mockGoCipher.encrypt(\"password\")).thenReturn(\"encrypted\");        when(mockGoCipher.decrypt(\"encrypted\")).thenReturn(\"password\");        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        when(mockGoCipher.encrypt(\"new_password\")).thenReturn(\"new_encrypted\");        materialConfig.setPassword(\"new_password\");        when(mockGoCipher.decrypt(\"new_encrypted\")).thenReturn(\"new_password\");        assertThat(materialConfig.getPassword()).isEqualTo(\"new_password\");    }    @Test    void shouldErrorOutIfDecryptionFails() throws CryptoException {        GoCipher mockGoCipher = mock(GoCipher.class);        String fakeCipherText = \"fake cipher text\";        when(mockGoCipher.decrypt(fakeCipherText)).thenThrow(new CryptoException(\"exception\"));        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", fakeCipherText);        try {            materialConfig.getPassword();            fail(\"Should have thrown up\");        } catch (Exception e) {            assertThat(e.getMessage()).isEqualTo(\"Could not decrypt the password to get the real password\");        }    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        TfsMaterialConfig config = tfs();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        TfsMaterialConfig config = tfs();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        TfsMaterialConfig config = tfs();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            tfsMaterialConfig.setUrl(\"/foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(tfsMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            tfsMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = tfsMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(tfsMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for TfsMaterial with url '/foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            tfsMaterialConfig.setPassword(\"badger\");            assertThat(tfsMaterialConfig.validateTree(null)).isTrue();            assertThat(tfsMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}", "nl": "import com.thoughtworks.go.config.*;import com.thoughtworks.go.config.materials.Filter;import com.thoughtworks.go.config.materials.IgnoredFiles;import com.thoughtworks.go.config.materials.ScmMaterialConfig;import com.thoughtworks.go.domain.materials.MaterialConfig;import com.thoughtworks.go.security.CryptoException;import com.thoughtworks.go.security.GoCipher;import com.thoughtworks.go.util.ReflectionUtil;import com.thoughtworks.go.util.command.UrlArgument;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;import java.util.Collections;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.config.materials.AbstractMaterialConfig.MATERIAL_NAME;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.FOLDER;import static com.thoughtworks.go.config.materials.ScmMaterialConfig.URL;import static com.thoughtworks.go.helper.MaterialConfigsMother.tfs;import static org.assertj.core.api.Assertions.assertThat;import static org.assertj.core.api.Assertions.fail;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.Mockito.*;class TfsMaterialConfigTest {    private TfsMaterialConfig tfsMaterialConfig;    @BeforeEach    void setUp() {        tfsMaterialConfig = tfs(new GoCipher(), null, \"loser\", \"some_domain\", \"passwd\", \"walk_this_path\");    }    @Test    void shouldSetConfigAttributes() {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(URL, \"http:        map.put(ScmMaterialConfig.USERNAME, \"boozer\");        map.put(ScmMaterialConfig.PASSWORD, \"secret\");        map.put(FOLDER, \"folder\");        map.put(ScmMaterialConfig.AUTO_UPDATE, \"0\");        map.put(ScmMaterialConfig.FILTER, \"/root,*.help\");        map.put(MATERIAL_NAME, \"my-tfs-material-name\");        map.put(TfsMaterialConfig.PROJECT_PATH, \"/useless/project\");        map.put(TfsMaterialConfig.DOMAIN, \"CORPORATE\");        tfsMaterialConfig.setConfigAttributes(map);        TfsMaterialConfig newTfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        newTfsMaterialConfig.setName(new CaseInsensitiveString(\"my-tfs-material-name\"));        newTfsMaterialConfig.setFolder(\"folder\");        assertThat(tfsMaterialConfig).isEqualTo(newTfsMaterialConfig);        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"passwd\");        assertThat(tfsMaterialConfig.isAutoUpdate()).isFalse();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"CORPORATE\");        assertThat(tfsMaterialConfig.getName()).isEqualTo(new CaseInsensitiveString(\"my-tfs-material-name\"));        assertThat(tfsMaterialConfig.filter()).isEqualTo(new Filter(new IgnoredFiles(\"/root\"), new IgnoredFiles(\"*.help\")));    }    @Test    void shouldDefaultDomainToEmptyStringWhenNothingIsSet() {        TfsMaterialConfig tfsMaterialConfig = tfs();        assertThat(tfsMaterialConfig.getDomain()).isEqualTo(\"\");    }    @Test    void setConfigAttributes_shouldUpdatePasswordWhenPasswordChangedBooleanChanged() throws Exception {        TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:        Map<String, String> map = new HashMap<>();        map.put(TfsMaterialConfig.PASSWORD, \"secret\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"Hehehe\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"0\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(ReflectionUtil.getField(tfsMaterialConfig, \"password\")).isNull();        assertThat(tfsMaterialConfig.getPassword()).isEqualTo(\"secret\");        assertThat(tfsMaterialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"secret\"));        map.put(TfsMaterialConfig.PASSWORD, \"\");        map.put(TfsMaterialConfig.PASSWORD_CHANGED, \"1\");        tfsMaterialConfig.setConfigAttributes(map);        assertThat(tfsMaterialConfig.getPassword()).isNull();        assertThat(tfsMaterialConfig.getEncryptedPassword()).isNull();    }    @Nested    class Validate {        @Test        void shouldEnsureMandatoryFieldsAreNotBlank() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"\"), \"\", \"CORPORATE\", \"\", \"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.USERNAME)).isEqualTo(\"Username cannot be blank\");            assertThat(tfsMaterialConfig.errors().on(TfsMaterialConfig.PROJECT_PATH)).isEqualTo(\"Project Path cannot be blank\");        }        @Test        void shouldEnsureMaterialNameIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isNull();            tfsMaterialConfig.setName(new CaseInsensitiveString(\".bad-name-with-dot\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(MATERIAL_NAME)).isEqualTo(\"Invalid material name '.bad-name-with-dot'. This must be alphanumeric and can contain underscores, hyphens and periods (however, it cannot start with a period). The maximum allowed length is 255 characters.\");        }        @Test        void shouldEnsureDestFilePathIsValid() {            TfsMaterialConfig tfsMaterialConfig = tfs(new GoCipher(), new UrlArgument(\"http:            tfsMaterialConfig.setConfigAttributes(Collections.singletonMap(FOLDER, \"../a\"));            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(FOLDER)).isEqualTo(\"Dest folder '../a' is not valid. It must be a sub-directory of the working folder.\");        }        @Test        void shouldEnsureUrlIsNotBlank() {            tfsMaterialConfig.setUrl(\"\");            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(ScmMaterialConfig.URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void shouldEnsureUrlIsNotNull() {            tfsMaterialConfig.setUrl(null);            tfsMaterialConfig.validate(new ConfigSaveValidationContext(null));            assertThat(tfsMaterialConfig.errors().on(URL)).isEqualTo(\"URL cannot be blank\");        }        @Test        void rejectsObviouslyWrongURL() {            assertTrue(validating(tfs(\"-url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertTrue(validating(tfs(\"_url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertTrue(validating(tfs(\"@url-not-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));            assertFalse(validating(tfs(\"url-starting-with-an-alphanumeric-character\")).errors().containsKey(TfsMaterialConfig.URL));        }        private TfsMaterialConfig validating(TfsMaterialConfig tfs) {            tfs.validate(new ConfigSaveValidationContext(null));            return tfs;        }    }    @Test    void shouldEncryptTfsPasswordAndMarkPasswordAsNull() throws Exception {        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        Object passwordFieldValue = ReflectionUtil.getField(materialConfig, \"password\");        assertThat(passwordFieldValue).isNull();        assertThat(materialConfig.getPassword()).isEqualTo(\"password\");        assertThat(materialConfig.getEncryptedPassword()).isEqualTo(new GoCipher().encrypt(\"password\"));    }    @Test    void shouldDecryptTfsPassword() throws Exception {        String encryptedPassword = new GoCipher().encrypt(\"plain-text-password\");        TfsMaterialConfig materialConfig = tfs(null, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", encryptedPassword);        materialConfig.ensureEncrypted();        assertThat(materialConfig.getPassword()).isEqualTo(\"plain-text-password\");    }    @Test    void shouldNotDecryptTfsPasswordIfPasswordIsNotNull() throws Exception {        GoCipher mockGoCipher = mock(GoCipher.class);        when(mockGoCipher.encrypt(\"password\")).thenReturn(\"encrypted\");        when(mockGoCipher.decrypt(\"encrypted\")).thenReturn(\"password\");        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        materialConfig.ensureEncrypted();        when(mockGoCipher.encrypt(\"new_password\")).thenReturn(\"new_encrypted\");        materialConfig.setPassword(\"new_password\");        when(mockGoCipher.decrypt(\"new_encrypted\")).thenReturn(\"new_password\");        assertThat(materialConfig.getPassword()).isEqualTo(\"new_password\");    }    @Test    void shouldErrorOutIfDecryptionFails() throws CryptoException {        GoCipher mockGoCipher = mock(GoCipher.class);        String fakeCipherText = \"fake cipher text\";        when(mockGoCipher.decrypt(fakeCipherText)).thenThrow(new CryptoException(\"exception\"));        TfsMaterialConfig materialConfig = tfs(mockGoCipher, new UrlArgument(\"http:        ReflectionUtil.setField(materialConfig, \"encryptedPassword\", fakeCipherText);        try {            materialConfig.getPassword();            fail(\"Should have thrown up\");        } catch (Exception e) {            assertThat(e.getMessage()).isEqualTo(\"Could not decrypt the password to get the real password\");        }    }    @Test    void shouldReturnTheUrl() {        String url = \"git@github.com/my/repo\";        TfsMaterialConfig config = tfs();        config.setUrl(url);        assertThat(config.getUrl()).isEqualTo(url);    }    @Test    void shouldReturnNullIfUrlForMaterialNotSpecified() {        TfsMaterialConfig config = tfs();        assertThat(config.getUrl()).isNull();    }    @Test    void shouldHandleNullWhenSettingUrlForAMaterial() {        TfsMaterialConfig config = tfs();        config.setUrl(null);        assertThat(config.getUrl()).isNull();    }    @Nested    class ValidateTree {        @BeforeEach        void setUp() {            tfsMaterialConfig.setUrl(\"/foo/bar\");        }        @Test        void shouldCallValidate() {            final MaterialConfig materialConfig = spy(tfsMaterialConfig);            final ValidationContext validationContext = mockValidationContextForSecretParams();            materialConfig.validateTree(validationContext);            verify(materialConfig).validate(validationContext);        }        @Test        void shouldFailIfEncryptedPasswordIsIncorrect() {            tfsMaterialConfig.setEncryptedPassword(\"encryptedPassword\");            final boolean validationResult = tfsMaterialConfig.validateTree(new ConfigSaveValidationContext(null));            assertThat(validationResult).isFalse();            assertThat(tfsMaterialConfig.errors().on(\"encryptedPassword\")).isEqualTo(\"Encrypted password value for TfsMaterial with url '/foo/bar' is invalid. This usually happens when the cipher text is modified to have an invalid value.\");        }        @Test        void shouldPassIfPasswordIsNotSpecifiedAsSecretParams() {            tfsMaterialConfig.setPassword(\"badger\");            assertThat(tfsMaterialConfig.validateTree(null)).isTrue();            assertThat(tfsMaterialConfig.errors().getAll()).isEmpty();        }    }    private ValidationContext mockValidationContextForSecretParams(SecretConfig... secretConfigs) {        final ValidationContext validationContext = mock(ValidationContext.class);        final CruiseConfig cruiseConfig = mock(CruiseConfig.class);        when(validationContext.getCruiseConfig()).thenReturn(cruiseConfig);        when(cruiseConfig.getSecretConfigs()).thenReturn(new SecretConfigs(secretConfigs));        return validationContext;    }}"}
{"code": "import com.thoughtworks.go.domain.ConsoleConsumer;import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.domain.StageIdentifier;import com.thoughtworks.go.domain.exception.IllegalArtifactLocationException;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.security.HeaderConstraint;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.util.ErrorHandler;import com.thoughtworks.go.server.view.artifacts.ArtifactsView;import com.thoughtworks.go.server.view.artifacts.LocalArtifactsView;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.FileModelAndView;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.ArtifactLogUtil;import com.thoughtworks.go.util.SystemEnvironment;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.server.web.ZipArtifactFolderViewFactory.zipViewFactory;import static com.thoughtworks.go.util.ArtifactLogUtil.isConsoleOutput;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;@Controllerpublic class ArtifactsController {    private static final Logger LOGGER = LoggerFactory.getLogger(ArtifactsController.class);    private final JobInstanceDao jobInstanceDao;    private final ConsoleActivityMonitor consoleActivityMonitor;    private final ArtifactFolderViewFactory folderViewFactory;    private final ArtifactFolderViewFactory jsonViewFactory;    private final ArtifactFolderViewFactory zipViewFactory;    private final Charset consoleLogCharset;    private ArtifactsService artifactsService;    private RestfulService restfulService;    private ConsoleService consoleService;    private HeaderConstraint headerConstraint;    @Autowired    ArtifactsController(ArtifactsService artifactsService, RestfulService restfulService, ZipArtifactCache zipArtifactCache, JobInstanceDao jobInstanceDao,                        ConsoleActivityMonitor consoleActivityMonitor, ConsoleService consoleService, SystemEnvironment systemEnvironment) {        this.artifactsService = artifactsService;        this.restfulService = restfulService;        this.jobInstanceDao = jobInstanceDao;        this.consoleActivityMonitor = consoleActivityMonitor;        this.consoleService = consoleService;        this.folderViewFactory = FileModelAndView.htmlViewFactory();        this.jsonViewFactory = FileModelAndView.jsonViewfactory();        this.zipViewFactory = zipViewFactory(zipArtifactCache);        this.headerConstraint = new HeaderConstraint(systemEnvironment);        this.consoleLogCharset = systemEnvironment.consoleLogCharsetAsCharset();    }    @RequestMapping(value = \"/repository/restful/artifact/GET/html\", method = RequestMethod.GET)    public ModelAndView getArtifactAsHtml(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha,                                          @RequestParam(value = \"serverAlias\", required = false) String serverAlias) throws Exception {        return getArtifact(filePath, folderViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, serverAlias);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/json\", method = RequestMethod.GET)    public ModelAndView getArtifactAsJson(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        return getArtifact(filePath, jsonViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/zip\", method = RequestMethod.GET)    public ModelAndView getArtifactAsZip(@RequestParam(\"pipelineName\") String pipelineName,                                         @RequestParam(\"pipelineCounter\") String pipelineCounter,                                         @RequestParam(\"stageName\") String stageName,                                         @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                         @RequestParam(\"buildName\") String buildName,                                         @RequestParam(\"filePath\") String filePath,                                         @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        if (filePath.equals(\".zip\")) {            filePath = \"./.zip\";        }        return getArtifact(filePath, zipViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET    @RequestMapping(value = \"consoleout.json\", method = RequestMethod.GET)    public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName,                                   @RequestParam(\"pipelineCounter\") String pipelineCounter,                                   @RequestParam(\"stageName\") String stageName,                                   @RequestParam(\"buildName\") String buildName,                                   @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                   @RequestParam(value = \"startLineNumber\", required = false) Long start    ) {        start = start == null ? 0L : start;        if (!isValidStageCounter(stageCounter)) {            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);        }        try {            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {                return logsNotFound(identifier);            }            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));        } catch (Exception e) {            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);        }    }    @ErrorHandler    public ModelAndView handleError(HttpServletRequest request, HttpServletResponse response, Exception e) {        LOGGER.error(\"Error loading artifacts: \", e);        Map model = new HashMap();        model.put(ERROR_FOR_PAGE, \"Artifact does not exist.\");        return new ModelAndView(\"exceptions_page\", model);    }    ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);        if (!isValidStageCounter(stageCounter)) {            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        }        long before = System.currentTimeMillis();        ArtifactsView view;        JobIdentifier translatedId;        try {            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        } catch (Exception e) {            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        }        if (filePath.contains(\"..\")) {            return FileModelAndView.forbiddenUrl(filePath);        }        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);        ModelAndView createdView = view.createView(filePath, sha);        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);        return createdView;    }    private boolean shouldUnzipStream(MultipartFile multipartFile) {        return multipartFile.getName().equals(ZIP_MULTIPART_FILENAME);    }    private MultipartFile multipartFile(MultipartHttpServletRequest request) {        MultipartFile multipartFile = request.getFile(REGULAR_MULTIPART_FILENAME);        if (multipartFile == null) {            multipartFile = request.getFile(ZIP_MULTIPART_FILENAME);        }        return multipartFile;    }    private MultipartFile getChecksumFile(MultipartHttpServletRequest request) {        return request.getFile(CHECKSUM_MULTIPART_FILENAME);    }    private ModelAndView putConsoleOutput(final JobIdentifier jobIdentifier, final InputStream inputStream) throws Exception {        File consoleLogFile = consoleService.consoleLogFile(jobIdentifier);        boolean updated = consoleService.updateConsoleLog(consoleLogFile, inputStream);        if (updated) {            consoleActivityMonitor.consoleUpdatedFor(jobIdentifier);            return FileModelAndView.fileAppended(consoleLogFile.getPath());        } else {            return FileModelAndView.errorSavingFile(consoleLogFile.getPath());        }    }    private ModelAndView putArtifact(JobIdentifier jobIdentifier, String filePath,                                     InputStream inputStream) throws Exception {        File artifact = artifactsService.findArtifact(jobIdentifier, filePath);        if (artifactsService.saveOrAppendFile(artifact, inputStream)) {            return FileModelAndView.fileAppended(filePath);        } else {            return FileModelAndView.errorSavingFile(filePath);        }    }    private ModelAndView buildNotFound(String pipelineName, String counterOrLabel, String stageName,                                       String stageCounter,                                       String buildName) {        return ResponseCodeView.create(SC_NOT_FOUND, String.format(\"Job %s/%s/%s/%s/%s not found.\", pipelineName,                counterOrLabel, stageName, stageCounter, buildName));    }    private ModelAndView logsNotFound(JobIdentifier identifier) {        String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());        return ResponseCodeView.create(SC_NOT_FOUND, notFound);    }    private boolean isValidStageCounter(String stageCounter) {        if (StringUtils.isEmpty(stageCounter) || StageIdentifier.LATEST.equalsIgnoreCase(stageCounter)) {            return true;        }        try {            int value = Integer.parseInt(stageCounter);            return value > 0;        } catch (Exception e) {            return false;        }    }}", "nl": "import com.thoughtworks.go.domain.ConsoleConsumer;import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.domain.StageIdentifier;import com.thoughtworks.go.domain.exception.IllegalArtifactLocationException;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.security.HeaderConstraint;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.util.ErrorHandler;import com.thoughtworks.go.server.view.artifacts.ArtifactsView;import com.thoughtworks.go.server.view.artifacts.LocalArtifactsView;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.FileModelAndView;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.ArtifactLogUtil;import com.thoughtworks.go.util.SystemEnvironment;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Map;import static com.thoughtworks.go.server.web.ZipArtifactFolderViewFactory.zipViewFactory;import static com.thoughtworks.go.util.ArtifactLogUtil.isConsoleOutput;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;@Controllerpublic class ArtifactsController {    private static final Logger LOGGER = LoggerFactory.getLogger(ArtifactsController.class);    private final JobInstanceDao jobInstanceDao;    private final ConsoleActivityMonitor consoleActivityMonitor;    private final ArtifactFolderViewFactory folderViewFactory;    private final ArtifactFolderViewFactory jsonViewFactory;    private final ArtifactFolderViewFactory zipViewFactory;    private final Charset consoleLogCharset;    private ArtifactsService artifactsService;    private RestfulService restfulService;    private ConsoleService consoleService;    private HeaderConstraint headerConstraint;    @Autowired    ArtifactsController(ArtifactsService artifactsService, RestfulService restfulService, ZipArtifactCache zipArtifactCache, JobInstanceDao jobInstanceDao,                        ConsoleActivityMonitor consoleActivityMonitor, ConsoleService consoleService, SystemEnvironment systemEnvironment) {        this.artifactsService = artifactsService;        this.restfulService = restfulService;        this.jobInstanceDao = jobInstanceDao;        this.consoleActivityMonitor = consoleActivityMonitor;        this.consoleService = consoleService;        this.folderViewFactory = FileModelAndView.htmlViewFactory();        this.jsonViewFactory = FileModelAndView.jsonViewfactory();        this.zipViewFactory = zipViewFactory(zipArtifactCache);        this.headerConstraint = new HeaderConstraint(systemEnvironment);        this.consoleLogCharset = systemEnvironment.consoleLogCharsetAsCharset();    }    @RequestMapping(value = \"/repository/restful/artifact/GET/html\", method = RequestMethod.GET)    public ModelAndView getArtifactAsHtml(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha,                                          @RequestParam(value = \"serverAlias\", required = false) String serverAlias) throws Exception {        return getArtifact(filePath, folderViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, serverAlias);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/json\", method = RequestMethod.GET)    public ModelAndView getArtifactAsJson(@RequestParam(\"pipelineName\") String pipelineName,                                          @RequestParam(\"pipelineCounter\") String pipelineCounter,                                          @RequestParam(\"stageName\") String stageName,                                          @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                          @RequestParam(\"buildName\") String buildName,                                          @RequestParam(\"filePath\") String filePath,                                          @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        return getArtifact(filePath, jsonViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET/zip\", method = RequestMethod.GET)    public ModelAndView getArtifactAsZip(@RequestParam(\"pipelineName\") String pipelineName,                                         @RequestParam(\"pipelineCounter\") String pipelineCounter,                                         @RequestParam(\"stageName\") String stageName,                                         @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                         @RequestParam(\"buildName\") String buildName,                                         @RequestParam(\"filePath\") String filePath,                                         @RequestParam(value = \"sha1\", required = false) String sha    ) throws Exception {        if (filePath.equals(\".zip\")) {            filePath = \"./.zip\";        }        return getArtifact(filePath, zipViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, null);    }    @RequestMapping(value = \"/repository/restful/artifact/GET    @RequestMapping(value = \"consoleout.json\", method = RequestMethod.GET)    public ModelAndView consoleout(@RequestParam(\"pipelineName\") String pipelineName,                                   @RequestParam(\"pipelineCounter\") String pipelineCounter,                                   @RequestParam(\"stageName\") String stageName,                                   @RequestParam(\"buildName\") String buildName,                                   @RequestParam(value = \"stageCounter\", required = false) String stageCounter,                                   @RequestParam(value = \"startLineNumber\", required = false) Long start    ) {        start = start == null ? 0L : start;        try {            JobIdentifier identifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName);            if (jobInstanceDao.isJobCompleted(identifier) && !consoleService.doesLogExist(identifier)) {                return logsNotFound(identifier);            }            ConsoleConsumer streamer = consoleService.getStreamer(start, identifier);            return new ModelAndView(new ConsoleOutView(streamer, consoleLogCharset));        } catch (Exception e) {            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);        }    }    @ErrorHandler    public ModelAndView handleError(HttpServletRequest request, HttpServletResponse response, Exception e) {        LOGGER.error(\"Error loading artifacts: \", e);        Map model = new HashMap();        model.put(ERROR_FOR_PAGE, \"Artifact does not exist.\");        return new ModelAndView(\"exceptions_page\", model);    }    ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter, String buildName, String sha, String serverAlias) throws Exception {        LOGGER.info(\"[Artifact Download] Trying to resolve '{}' for '{}/{}/{}/{}/{}'\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName);        long before = System.currentTimeMillis();        ArtifactsView view;        JobIdentifier translatedId;        try {            translatedId = restfulService.findJob(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        } catch (Exception e) {            return buildNotFound(pipelineName, counterOrLabel, stageName, stageCounter, buildName);        }        if (filePath.contains(\"..\")) {            return FileModelAndView.forbiddenUrl(filePath);        }        view = new LocalArtifactsView(folderViewFactory, artifactsService, translatedId, consoleService);        ModelAndView createdView = view.createView(filePath, sha);        LOGGER.info(\"[Artifact Download] Successfully resolved '{}' for '{}/{}/{}/{}/{}'. It took: {}ms\", filePath, pipelineName, counterOrLabel, stageName, stageCounter, buildName, System.currentTimeMillis() - before);        return createdView;    }    private boolean shouldUnzipStream(MultipartFile multipartFile) {        return multipartFile.getName().equals(ZIP_MULTIPART_FILENAME);    }    private MultipartFile multipartFile(MultipartHttpServletRequest request) {        MultipartFile multipartFile = request.getFile(REGULAR_MULTIPART_FILENAME);        if (multipartFile == null) {            multipartFile = request.getFile(ZIP_MULTIPART_FILENAME);        }        return multipartFile;    }    private MultipartFile getChecksumFile(MultipartHttpServletRequest request) {        return request.getFile(CHECKSUM_MULTIPART_FILENAME);    }    private ModelAndView putConsoleOutput(final JobIdentifier jobIdentifier, final InputStream inputStream) throws Exception {        File consoleLogFile = consoleService.consoleLogFile(jobIdentifier);        boolean updated = consoleService.updateConsoleLog(consoleLogFile, inputStream);        if (updated) {            consoleActivityMonitor.consoleUpdatedFor(jobIdentifier);            return FileModelAndView.fileAppended(consoleLogFile.getPath());        } else {            return FileModelAndView.errorSavingFile(consoleLogFile.getPath());        }    }    private ModelAndView putArtifact(JobIdentifier jobIdentifier, String filePath,                                     InputStream inputStream) throws Exception {        File artifact = artifactsService.findArtifact(jobIdentifier, filePath);        if (artifactsService.saveOrAppendFile(artifact, inputStream)) {            return FileModelAndView.fileAppended(filePath);        } else {            return FileModelAndView.errorSavingFile(filePath);        }    }    private ModelAndView buildNotFound(String pipelineName, String counterOrLabel, String stageName,                                       String stageCounter,                                       String buildName) {        return ResponseCodeView.create(SC_NOT_FOUND, String.format(\"Job %s/%s/%s/%s/%s not found.\", pipelineName,                counterOrLabel, stageName, stageCounter, buildName));    }    private ModelAndView logsNotFound(JobIdentifier identifier) {        String notFound = String.format(\"Console log for %s is unavailable as it may have been purged by Go or deleted externally.\", identifier.toFullString());        return ResponseCodeView.create(SC_NOT_FOUND, notFound);    }    private boolean isValidStageCounter(String stageCounter) {        if (StringUtils.isEmpty(stageCounter) || StageIdentifier.LATEST.equalsIgnoreCase(stageCounter)) {            return true;        }        try {            int value = Integer.parseInt(stageCounter);            return value > 0;        } catch (Exception e) {            return false;        }    }}"}
{"code": "import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.SystemEnvironment;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.mock.web.MockMultipartFile;import org.springframework.mock.web.MockMultipartHttpServletRequest;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.InputStream;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;import static org.hamcrest.Matchers.*;import static org.hamcrest.MatcherAssert.assertThat;import static org.mockito.Mockito.any;import static org.mockito.Mockito.*;public class ArtifactsControllerTest {    private ArtifactsController artifactsController;    private MockHttpServletRequest request;    private ConsoleActivityMonitor consoleActivityMonitor;    private RestfulService restfulService;    private ArtifactsService artifactService;    private ConsoleService consoleService;    private SystemEnvironment systemEnvironment;    private JobInstanceDao jobInstanceDao;    @BeforeEach    public void setUp() {        consoleActivityMonitor = mock(ConsoleActivityMonitor.class);        restfulService = mock(RestfulService.class);        artifactService = mock(ArtifactsService.class);        consoleService = mock(ConsoleService.class);        jobInstanceDao = mock(JobInstanceDao.class);        systemEnvironment = mock(SystemEnvironment.class);        artifactsController = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment);        request = new MockHttpServletRequest();    }    @Test    public void shouldUpdateLastConsoleActivityOnConsoleLogPut() throws Exception {        String content = \"Testing:\";        request.setContent(content.getBytes());        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l)).thenReturn(jobIdentifier);        String path = \"cruise-output/console.log\";        File artifactFile = new File(\"junk\");        when(consoleService.consoleLogFile(jobIdentifier)).thenReturn(artifactFile);        when(consoleService.updateConsoleLog(eq(artifactFile), any(InputStream.class))).thenReturn(true);        assertThat(((ResponseCodeView) artifactsController.putArtifact(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l, path, \"agent-id\", request).getView()).getStatusCode(), is(HttpServletResponse.SC_OK));        verify(consoleActivityMonitor).consoleUpdatedFor(jobIdentifier);    }    @Test    public void testConsoleOutShouldReturnErrorWhenJobHasBeenCompletedAndLogsNotFound() throws Exception {        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\")).thenReturn(jobIdentifier);        when(jobInstanceDao.isJobCompleted(jobIdentifier)).thenReturn(true);        when(consoleService.doesLogExist(jobIdentifier)).thenReturn(false);        ModelAndView view = artifactsController.consoleout(\"pipeline\", \"10\", \"stage\", \"build\", \"2\", 1L);        assertThat(view.getView().getContentType(), is(RESPONSE_CHARSET));        assertThat(view.getView(), is(instanceOf((ResponseCodeView.class))));        assertThat(((ResponseCodeView) view.getView()).getContent(), containsString(\"Console log for Build [pipeline/10/stage/2/build/103] is unavailable as it may have been purged by Go or deleted externally\"));    }    @Test    public void shouldReturnHttpErrorCodeWhenChecksumFileSaveFails() throws Exception {        File artifactFile = new File(\"junk\");        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline-1\", 1, \"1\", \"stage-1\", \"2\", \"job-1\", 122l);        when(restfulService.findJob(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122l)).thenReturn(jobIdentifier);        when(artifactService.findArtifact(any(JobIdentifier.class), eq(\"some-path\"))).thenReturn(artifactFile);        when(artifactService.saveFile(any(File.class), any(InputStream.class), eq(false), eq(1))).thenReturn(true);        when(artifactService.saveOrAppendFile(any(File.class), any(InputStream.class))).thenReturn(false);        MockMultipartHttpServletRequest mockMultipartHttpServletRequest = new MockMultipartHttpServletRequest();        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(REGULAR_MULTIPART_FILENAME, \"content\".getBytes()));        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(CHECKSUM_MULTIPART_FILENAME, \"checksum-content\".getBytes()));        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122L, \"some-path\", 1, mockMultipartHttpServletRequest);        ResponseCodeView view = (ResponseCodeView) modelAndView.getView();        assertThat(view.getStatusCode(), is(SC_INTERNAL_SERVER_ERROR));        assertThat(view.getContent(), is(\"Error saving checksum file for the artifact at path 'some-path'\"));    }    @Test    void shouldFailToPostAndPutWhenStageCounterIsNotAPositiveInteger() throws Exception {        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", 1, null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", 1, null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", \"1\", null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", \"1\", null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));    }    @Test    void shouldFailToGetConsoleOutWhenStageCounterIsNotAPositiveInteger() throws Exception {        ModelAndView modelAndView = artifactsController.consoleout(\"pipeline-1\", \"1\", \"stage-1\", \"job-1\", \"NOT_AN_INTEGER\", 122L);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));    }    @Test    void shouldFailToGetArtifactWhenStageCounterIsNotAPositiveInteger() throws Exception {        ModelAndView modelAndView = artifactsController.getArtifactAsHtml(\"pipeline-1\", \"1\", \"stage-1\",  \"NOT_AN_INTEGER\", \"job-1\", \"some-path\", \"sha1\", \"alias\");        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));    }    @Test    public void shouldFunnelAll_GET_calls() throws Exception {        final ModelAndView returnVal = new ModelAndView();        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {            @Override            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,                                     String buildName, String sha, String serverAlias) throws Exception {                return returnVal;            }        };        assertThat(controller.getArtifactAsHtml(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\", null), sameInstance(returnVal));        assertThat(controller.getArtifactAsZip(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));        assertThat(controller.getArtifactAsJson(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));    }    @Test    public void shouldReturnBadRequestIfRequiredHeadersAreMissingOnACreateArtifactRequest() throws Exception {        MultipartHttpServletRequest multipartHttpServletRequest = new MockMultipartHttpServletRequest();        when(systemEnvironment.isApiSafeModeEnabled()).thenReturn(true);        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline\", \"invalid-label\", \"stage\", \"stage-counter\", \"job-name\", 3L, \"file-path\", 3, multipartHttpServletRequest);        ResponseCodeView codeView = (ResponseCodeView) modelAndView.getView();        assertThat(codeView.getStatusCode(), is(HttpServletResponse.SC_BAD_REQUEST));        assertThat(codeView.getContent(), is(\"Missing required header 'Confirm'\"));    }}", "nl": "import com.thoughtworks.go.domain.JobIdentifier;import com.thoughtworks.go.server.cache.ZipArtifactCache;import com.thoughtworks.go.server.dao.JobInstanceDao;import com.thoughtworks.go.server.service.ArtifactsService;import com.thoughtworks.go.server.service.ConsoleActivityMonitor;import com.thoughtworks.go.server.service.ConsoleService;import com.thoughtworks.go.server.service.RestfulService;import com.thoughtworks.go.server.web.ArtifactFolderViewFactory;import com.thoughtworks.go.server.web.ResponseCodeView;import com.thoughtworks.go.util.SystemEnvironment;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.mock.web.MockHttpServletRequest;import org.springframework.mock.web.MockMultipartFile;import org.springframework.mock.web.MockMultipartHttpServletRequest;import org.springframework.web.multipart.MultipartHttpServletRequest;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.InputStream;import static com.thoughtworks.go.util.GoConstants.*;import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;import static org.hamcrest.Matchers.*;import static org.hamcrest.MatcherAssert.assertThat;import static org.mockito.Mockito.any;import static org.mockito.Mockito.*;public class ArtifactsControllerTest {    private ArtifactsController artifactsController;    private MockHttpServletRequest request;    private ConsoleActivityMonitor consoleActivityMonitor;    private RestfulService restfulService;    private ArtifactsService artifactService;    private ConsoleService consoleService;    private SystemEnvironment systemEnvironment;    private JobInstanceDao jobInstanceDao;    @BeforeEach    public void setUp() {        consoleActivityMonitor = mock(ConsoleActivityMonitor.class);        restfulService = mock(RestfulService.class);        artifactService = mock(ArtifactsService.class);        consoleService = mock(ConsoleService.class);        jobInstanceDao = mock(JobInstanceDao.class);        systemEnvironment = mock(SystemEnvironment.class);        artifactsController = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment);        request = new MockHttpServletRequest();    }    @Test    public void shouldUpdateLastConsoleActivityOnConsoleLogPut() throws Exception {        String content = \"Testing:\";        request.setContent(content.getBytes());        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l)).thenReturn(jobIdentifier);        String path = \"cruise-output/console.log\";        File artifactFile = new File(\"junk\");        when(consoleService.consoleLogFile(jobIdentifier)).thenReturn(artifactFile);        when(consoleService.updateConsoleLog(eq(artifactFile), any(InputStream.class))).thenReturn(true);        assertThat(((ResponseCodeView) artifactsController.putArtifact(\"pipeline\", \"10\", \"stage\", \"2\", \"build\", 103l, path, \"agent-id\", request).getView()).getStatusCode(), is(HttpServletResponse.SC_OK));        verify(consoleActivityMonitor).consoleUpdatedFor(jobIdentifier);    }    @Test    public void testConsoleOutShouldReturnErrorWhenJobHasBeenCompletedAndLogsNotFound() throws Exception {        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline\", 10, \"label-10\", \"stage\", \"2\", \"build\", 103l);        when(restfulService.findJob(\"pipeline\", \"10\", \"stage\", \"2\", \"build\")).thenReturn(jobIdentifier);        when(jobInstanceDao.isJobCompleted(jobIdentifier)).thenReturn(true);        when(consoleService.doesLogExist(jobIdentifier)).thenReturn(false);        ModelAndView view = artifactsController.consoleout(\"pipeline\", \"10\", \"stage\", \"build\", \"2\", 1L);        assertThat(view.getView().getContentType(), is(RESPONSE_CHARSET));        assertThat(view.getView(), is(instanceOf((ResponseCodeView.class))));        assertThat(((ResponseCodeView) view.getView()).getContent(), containsString(\"Console log for Build [pipeline/10/stage/2/build/103] is unavailable as it may have been purged by Go or deleted externally\"));    }    @Test    public void shouldReturnHttpErrorCodeWhenChecksumFileSaveFails() throws Exception {        File artifactFile = new File(\"junk\");        JobIdentifier jobIdentifier = new JobIdentifier(\"pipeline-1\", 1, \"1\", \"stage-1\", \"2\", \"job-1\", 122l);        when(restfulService.findJob(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122l)).thenReturn(jobIdentifier);        when(artifactService.findArtifact(any(JobIdentifier.class), eq(\"some-path\"))).thenReturn(artifactFile);        when(artifactService.saveFile(any(File.class), any(InputStream.class), eq(false), eq(1))).thenReturn(true);        when(artifactService.saveOrAppendFile(any(File.class), any(InputStream.class))).thenReturn(false);        MockMultipartHttpServletRequest mockMultipartHttpServletRequest = new MockMultipartHttpServletRequest();        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(REGULAR_MULTIPART_FILENAME, \"content\".getBytes()));        mockMultipartHttpServletRequest.addFile(new MockMultipartFile(CHECKSUM_MULTIPART_FILENAME, \"checksum-content\".getBytes()));        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"2\", \"job-1\", 122L, \"some-path\", 1, mockMultipartHttpServletRequest);        ResponseCodeView view = (ResponseCodeView) modelAndView.getView();        assertThat(view.getStatusCode(), is(SC_INTERNAL_SERVER_ERROR));        assertThat(view.getContent(), is(\"Error saving checksum file for the artifact at path 'some-path'\"));    }    @Test    void shouldFailToPostAndPutWhenStageCounterIsNotAPositiveInteger() throws Exception {        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", 1, null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.postArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", 1, null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"NOT_AN_INTEGER\", \"job-1\", 122L, \"some-path\", \"1\", null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));        modelAndView = artifactsController.putArtifact(\"pipeline-1\", \"1\", \"stage-1\", \"-123\", \"job-1\", 122L, \"some-path\", \"1\", null);        assertThat(((ResponseCodeView) modelAndView.getView()).getStatusCode(), is(SC_NOT_FOUND));    }    @Test    public void shouldFunnelAll_GET_calls() throws Exception {        final ModelAndView returnVal = new ModelAndView();        ArtifactsController controller = new ArtifactsController(artifactService, restfulService, mock(ZipArtifactCache.class), jobInstanceDao, consoleActivityMonitor, consoleService, systemEnvironment) {            @Override            ModelAndView getArtifact(String filePath, ArtifactFolderViewFactory folderViewFactory, String pipelineName, String counterOrLabel, String stageName, String stageCounter,                                     String buildName, String sha, String serverAlias) throws Exception {                return returnVal;            }        };        assertThat(controller.getArtifactAsHtml(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\", null), sameInstance(returnVal));        assertThat(controller.getArtifactAsZip(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));        assertThat(controller.getArtifactAsJson(\"pipeline\", \"counter\", \"stage\", \"2\", \"job\", \"file_name\", \"sha1\"), sameInstance(returnVal));    }    @Test    public void shouldReturnBadRequestIfRequiredHeadersAreMissingOnACreateArtifactRequest() throws Exception {        MultipartHttpServletRequest multipartHttpServletRequest = new MockMultipartHttpServletRequest();        when(systemEnvironment.isApiSafeModeEnabled()).thenReturn(true);        ModelAndView modelAndView = artifactsController.postArtifact(\"pipeline\", \"invalid-label\", \"stage\", \"stage-counter\", \"job-name\", 3L, \"file-path\", 3, multipartHttpServletRequest);        ResponseCodeView codeView = (ResponseCodeView) modelAndView.getView();        assertThat(codeView.getStatusCode(), is(HttpServletResponse.SC_BAD_REQUEST));        assertThat(codeView.getContent(), is(\"Missing required header 'Confirm'\"));    }}"}
{"code": "import com.thoughtworks.go.domain.materials.Modification;import com.thoughtworks.go.domain.materials.Revision;import com.thoughtworks.go.util.TempDirUtils;import com.thoughtworks.go.util.command.*;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.nio.file.Path;import java.util.ArrayList;import java.util.List;import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;import static org.assertj.core.api.Assertions.assertThatThrownBy;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;public class HgCommandTest {    private static final String REVISION_0 = \"b61d12de515d82d3a377ae3aae6e8abe516a2651\";    private static final String REVISION_1 = \"35ff2159f303ecf986b3650fc4299a6ffe5a14e1\";    private static final String REVISION_2 = \"ca3ebb67f527c0ad7ed26b789056823d8b9af23f\";    private File serverRepo;    private File clientRepo;    private HgCommand hgCommand;    private InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();    private File workingDirectory;    private File secondBranchWorkingCopy;    @BeforeEach    public void setUp(@TempDir Path tempDir) throws IOException {        serverRepo = TempDirUtils.createTempDirectoryIn(tempDir, \"testHgServerRepo\").toFile();        clientRepo = TempDirUtils.createTempDirectoryIn(tempDir, \"testHgClientRepo\").toFile();        secondBranchWorkingCopy = TempDirUtils.createTempDirectoryIn(tempDir, \"second\").toFile();        setUpServerRepoFromHgBundle(serverRepo, new File(\"../common/src/test/resources/data/hgrepo.hgbundle\"));        workingDirectory = new File(clientRepo.getPath());        hgCommand = new HgCommand(null, workingDirectory, \"default\", serverRepo.getAbsolutePath(), null);        hgCommand.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));    }    @Test    public void shouldCloneFromRemoteRepo() {        assertThat(clientRepo.listFiles().length, is(2));    }    @Test    public void shouldCloneWithEscapedRepoUrl() {        hgCommand.clone(outputStreamConsumer, new UrlArgument(echoingAliasFor(\"clone\")));        assertNoUnescapedEcho();    }    @Test    public void shouldCloneWithEscapedBranch() {        hgCommand = new HgCommand(null, workingDirectory, echoingAliasFor(\"clone\"), serverRepo.getAbsolutePath(), null);        hgCommand.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));        assertNoUnescapedEcho();    }    private String echoingAliasFor(String command) {        return String.format(\"--config=alias.%s=!echo hello world\", command);    }    private void assertNoUnescapedEcho() {        assertThat(outputStreamConsumer.getAllOutput(), not(containsString(\"\\nhello world\\n\")));    }    @Test    public void shouldGetLatestModifications() {        List<Modification> actual = hgCommand.latestOneModificationAsModifications();        assertThat(actual.size(), is(1));        final Modification modification = actual.get(0);        assertThat(modification.getComment(), is(\"test\"));        assertThat(modification.getUserName(), is(\"cruise\"));        assertThat(modification.getModifiedFiles().size(), is(1));    }    @Test    public void shouldNotIncludeCommitFromAnotherBranchInGetLatestModifications() {        Modification lastCommit = hgCommand.latestOneModificationAsModifications().get(0);        makeACommitToSecondBranch();        hg(workingDirectory, \"pull\").runOrBomb(null);        Modification actual = hgCommand.latestOneModificationAsModifications().get(0);        assertThat(actual, is(lastCommit));        assertThat(actual.getComment(), is(lastCommit.getComment()));    }    @Test    public void shouldGetModifications() throws Exception {        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));        assertThat(actual.size(), is(2));        assertThat(actual.get(0).getRevision(), is(REVISION_2));        assertThat(actual.get(1).getRevision(), is(REVISION_1));    }    @Test    public void shouldNotGetModificationsFromOtherBranches() {        makeACommitToSecondBranch();        hg(workingDirectory, \"pull\").runOrBomb(null);        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));        assertThat(actual.size(), is(2));        assertThat(actual.get(0).getRevision(), is(REVISION_2));        assertThat(actual.get(1).getRevision(), is(REVISION_1));    }    @Test    public void shouldUpdateToSpecificRevision() {        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();        assertThat(output.getStdOut(), is(\"\"));        File newFile = new File(clientRepo, \"test.txt\");        assertThat(newFile.exists(), is(false));        Revision revision = createNewFileAndCheckIn(serverRepo);        hgCommand.updateTo(revision, output);        assertThat(output.getStdOut(), is(not(\"\")));        assertThat(newFile.exists(), is(true));    }    @Test    public void shouldUpdateToSpecificRevisionOnGivenBranch() {        makeACommitToSecondBranch();        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();        File newFile = new File(workingDirectory, \"test.txt\");        hgCommand.updateTo(new StringRevision(\"tip\"), output);        assertThat(newFile.exists(), is(false));    }    @Test    public void shouldThrowExceptionIfUpdateFails() {        InMemoryStreamConsumer output =                ProcessOutputStreamConsumer.inMemoryConsumer();        assertThat(FileUtils.deleteQuietly(serverRepo), is(true));        assertThatThrownBy(() -> hgCommand.updateTo(new StringRevision(\"tip\"), output))                .isExactlyInstanceOf(RuntimeException.class)                .hasMessageContaining(\"Unable to update to revision [StringRevision[tip]]\");    }    @Test    public void shouldGetWorkingUrl() {        String workingUrl = hgCommand.workingRepositoryUrl().outputAsString();        assertThat(workingUrl, is(serverRepo.getAbsolutePath()));    }    @Test    public void shouldCheckConnection() {        hgCommand.checkConnection(new UrlArgument(serverRepo.getAbsolutePath()));    }    @Test    public void shouldCheckConnectionWithEscapedRepoUrl() {        assertThatThrownBy(() -> hgCommand.checkConnection(new UrlArgument(echoingAliasFor(\"id\"))))                .isExactlyInstanceOf(CommandLineException.class)                .hasMessageContaining(\"repository --config\")                .hasMessageContaining(\"not found\");    }    @Test    public void shouldThrowExceptionForBadConnection() {        String url = \"http:        HgCommand hgCommand = new HgCommand(null, null, null, null, null);        assertThatThrownBy(() -> hgCommand.checkConnection(new UrlArgument(url)))                .isExactlyInstanceOf(CommandLineException.class);    }    @Test    public void shouldCloneOnlyTheSpecifiedBranchAndPointToIt() {        String branchName = \"second\";        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, branchName, serverRepo.getAbsolutePath(), null);        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath() + \"#\" + branchName));        String currentBranch = hg(secondBranchWorkingCopy, \"branch\").runOrBomb(null).outputAsString();        assertThat(currentBranch, is(branchName));        List<String> branches = hg(secondBranchWorkingCopy, \"branches\").runOrBomb(null).output();        ArrayList<String> branchNames = new ArrayList<>();        for (String branchDetails : branches) {            branchNames.add(StringUtils.split(branchDetails, \" \")[0]);        }        assertThat(branchNames.size(), is(2));        assertThat(branchNames.contains(branchName), is(true));        assertThat(branchNames.contains(\"default\"), is(true));    }    private CommandLine hg(File workingDir, String... arguments) {        CommandLine hg = CommandLine.createCommandLine(\"hg\").withArgs(arguments).withEncoding(\"utf-8\");        hg.setWorkingDir(workingDir);        return hg;    }    private void commit(String message, File workingDir) {        CommandLine hg = hg(workingDir, \"ci\", \"-u\", \"cruise-test\", \"-m\", message);        String[] input = new String[]{};        hg.runOrBomb(null, input);    }    private Revision latestRevisionOf() {        CommandLine hg = hg(serverRepo, \"log\", \"--limit\", \"1\", \"--template\", \"{node}\");        String[] input = new String[]{};        return new StringRevision(hg.runOrBomb(null, input).outputAsString());    }    private void addremove(File workingDir) {        CommandLine hg = hg(workingDir, \"addremove\");        String[] input = new String[]{};        hg.runOrBomb(null, input);    }    private void createNewFileAndPushUpstream(File workingDir) {        createNewFileAndCheckIn(workingDir);        String branchName = hg(workingDir, \"branch\").runOrBomb(null).outputAsString();        hg(workingDir, \"push\", \"--rev\", branchName).runOrBomb(null);    }    private Revision createNewFileAndCheckIn(File directory) {        try {            new FileOutputStream(new File(directory, \"test.txt\")).close();            addremove(directory);            commit(\"created test.txt\", directory);        } catch (IOException e) {            e.printStackTrace();        }        return latestRevisionOf();    }    private void setUpServerRepoFromHgBundle(File serverRepo, File hgBundleFile) {        String[] input = new String[]{};        CommandLine.createCommandLine(\"hg\")                .withArgs(\"clone\", hgBundleFile.getAbsolutePath(), serverRepo.getAbsolutePath()).withEncoding(\"utf-8\").runOrBomb(null, input);    }    private void makeACommitToSecondBranch() {        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, \"second\", serverRepo.getAbsolutePath(), null);        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));        createNewFileAndPushUpstream(secondBranchWorkingCopy);    }}", "nl": "import com.thoughtworks.go.domain.materials.Modification;import com.thoughtworks.go.domain.materials.Revision;import com.thoughtworks.go.util.TempDirUtils;import com.thoughtworks.go.util.command.*;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.nio.file.Path;import java.util.ArrayList;import java.util.List;import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;import static org.assertj.core.api.Assertions.assertThatThrownBy;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.is;import static org.hamcrest.Matchers.not;public class HgCommandTest {    private File serverRepo;    private File clientRepo;    private HgCommand hgCommand;    private InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();    private File workingDirectory;    private static final String REVISION_0 = \"b61d12de515d82d3a377ae3aae6e8abe516a2651\";    private static final String REVISION_1 = \"35ff2159f303ecf986b3650fc4299a6ffe5a14e1\";    private static final String REVISION_2 = \"ca3ebb67f527c0ad7ed26b789056823d8b9af23f\";    private File secondBranchWorkingCopy;    @BeforeEach    public void setUp(@TempDir Path tempDir) throws IOException {        serverRepo = TempDirUtils.createTempDirectoryIn(tempDir, \"testHgServerRepo\").toFile();        clientRepo =  TempDirUtils.createTempDirectoryIn(tempDir, \"testHgClientRepo\").toFile();        secondBranchWorkingCopy =  TempDirUtils.createTempDirectoryIn(tempDir, \"second\").toFile();        setUpServerRepoFromHgBundle(serverRepo, new File(\"../common/src/test/resources/data/hgrepo.hgbundle\"));        workingDirectory = new File(clientRepo.getPath());        hgCommand = new HgCommand(null, workingDirectory, \"default\", serverRepo.getAbsolutePath(), null);        hgCommand.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));    }    @Test    public void shouldCloneFromRemoteRepo() {        assertThat(clientRepo.listFiles().length > 0, is(true));    }    @Test    public void shouldGetLatestModifications() throws Exception {        List<Modification> actual = hgCommand.latestOneModificationAsModifications();        assertThat(actual.size(), is(1));        final Modification modification = actual.get(0);        assertThat(modification.getComment(), is(\"test\"));        assertThat(modification.getUserName(), is(\"cruise\"));        assertThat(modification.getModifiedFiles().size(), is(1));    }    @Test    public void shouldNotIncludeCommitFromAnotherBranchInGetLatestModifications() throws Exception {        Modification lastCommit = hgCommand.latestOneModificationAsModifications().get(0);        makeACommitToSecondBranch();        hg(workingDirectory, \"pull\").runOrBomb(null);        Modification actual = hgCommand.latestOneModificationAsModifications().get(0);        assertThat(actual, is(lastCommit));        assertThat(actual.getComment(), is(lastCommit.getComment()));    }    @Test    public void shouldGetModifications() throws Exception {        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));        assertThat(actual.size(), is(2));        assertThat(actual.get(0).getRevision(), is(REVISION_2));        assertThat(actual.get(1).getRevision(), is(REVISION_1));    }    @Test    public void shouldNotGetModificationsFromOtherBranches() throws Exception {        makeACommitToSecondBranch();        hg(workingDirectory, \"pull\").runOrBomb(null);        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));        assertThat(actual.size(), is(2));        assertThat(actual.get(0).getRevision(), is(REVISION_2));        assertThat(actual.get(1).getRevision(), is(REVISION_1));    }    @Test    public void shouldUpdateToSpecificRevision() {        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();        assertThat(output.getStdOut(), is(\"\"));        File newFile = new File(clientRepo, \"test.txt\");        assertThat(newFile.exists(), is(false));        Revision revision = createNewFileAndCheckIn(serverRepo);        hgCommand.updateTo(revision, output);        assertThat(output.getStdOut(), is(not(\"\")));        assertThat(newFile.exists(), is(true));    }    @Test    public void shouldUpdateToSpecificRevisionOnGivenBranch() {        makeACommitToSecondBranch();        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();        File newFile = new File(workingDirectory, \"test.txt\");        hgCommand.updateTo(new StringRevision(\"tip\"), output);        assertThat(newFile.exists(), is(false));    }    @Test    public void shouldThrowExceptionIfUpdateFails() throws Exception {        InMemoryStreamConsumer output =                ProcessOutputStreamConsumer.inMemoryConsumer();        assertThat(FileUtils.deleteQuietly(serverRepo), is(true));        assertThatThrownBy(() -> hgCommand.updateTo(new StringRevision(\"tip\"), output))                .isExactlyInstanceOf(RuntimeException.class);    }    @Test    public void shouldGetWorkingUrl() {        String workingUrl = hgCommand.workingRepositoryUrl().outputAsString();        assertThat(workingUrl, is(serverRepo.getAbsolutePath()));    }    @Test    public void shouldThrowExceptionForBadConnection() throws Exception {        String url = \"http:        HgCommand hgCommand = new HgCommand(null, null, null, null, null);        assertThatThrownBy(() -> hgCommand.checkConnection(new UrlArgument(url)))                .isExactlyInstanceOf(CommandLineException.class);    }    @Test    public void shouldCloneOnlyTheSpecifiedBranchAndPointToIt() {        String branchName = \"second\";        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, branchName, serverRepo.getAbsolutePath(), null);        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath() + \"#\" + branchName));        String currentBranch = hg(secondBranchWorkingCopy, \"branch\").runOrBomb(null).outputAsString();        assertThat(currentBranch, is(branchName));        List<String> branches = hg(secondBranchWorkingCopy, \"branches\").runOrBomb(null).output();        ArrayList<String> branchNames = new ArrayList<>();        for (String branchDetails : branches) {            branchNames.add(StringUtils.split(branchDetails, \" \")[0]);        }        assertThat(branchNames.size(), is(2));        assertThat(branchNames.contains(branchName), is(true));        assertThat(branchNames.contains(\"default\"), is(true));    }    private CommandLine hg(File workingDir, String... arguments) {        CommandLine hg = CommandLine.createCommandLine(\"hg\").withArgs(arguments).withEncoding(\"utf-8\");        hg.setWorkingDir(workingDir);        return hg;    }    private void commit(String message, File workingDir) {        CommandLine hg = hg(workingDir, \"ci\", \"-u\", \"cruise-test\", \"-m\", message);        String[] input = new String[]{};        hg.runOrBomb(null, input);    }    private Revision latestRevisionOf() {        CommandLine hg = hg(serverRepo, \"log\", \"--limit\", \"1\", \"--template\", \"{node}\");        String[] input = new String[]{};        return new StringRevision(hg.runOrBomb(null, input).outputAsString());    }    private void addremove(File workingDir) {        CommandLine hg = hg(workingDir, \"addremove\");        String[] input = new String[]{};        hg.runOrBomb(null, input);    }    private void createNewFileAndPushUpstream(File workingDir) {        createNewFileAndCheckIn(workingDir);        String branchName = hg(workingDir, \"branch\").runOrBomb(null).outputAsString();        hg(workingDir, \"push\", \"--rev\", branchName).runOrBomb(null);    }    private Revision createNewFileAndCheckIn(File directory) {        try {            new FileOutputStream(new File(directory, \"test.txt\")).close();            addremove(directory);            commit(\"created test.txt\", directory);        } catch (IOException e) {            e.printStackTrace();        }        return latestRevisionOf();    }    private void setUpServerRepoFromHgBundle(File serverRepo, File hgBundleFile) {        String[] input = new String[]{};        CommandLine.createCommandLine(\"hg\")                .withArgs(\"clone\", hgBundleFile.getAbsolutePath(), serverRepo.getAbsolutePath()).withEncoding(\"utf-8\").runOrBomb(null, input);    }    private void makeACommitToSecondBranch() {        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, \"second\", serverRepo.getAbsolutePath(), null);        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));        createNewFileAndPushUpstream(secondBranchWorkingCopy);    }}"}
{"code": "import com.thoughtworks.go.domain.materials.Modification;import com.thoughtworks.go.domain.materials.Revision;import com.thoughtworks.go.domain.materials.SCMCommand;import com.thoughtworks.go.util.NamedProcessTag;import com.thoughtworks.go.util.command.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import static com.thoughtworks.go.util.ExceptionUtils.bomb;import static com.thoughtworks.go.util.ExceptionUtils.bombUnless;import static com.thoughtworks.go.util.command.CommandLine.createCommandLine;import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;import static java.lang.String.format;public class HgCommand extends SCMCommand {    private static final Logger LOGGER = LoggerFactory.getLogger(HgCommand.class);    private final File workingDir;    private static String templatePath;    private final String branch;    private final String url;    private final List<SecretString> secrets;    public HgCommand(String materialFingerprint, File workingDir, String branch, String url, List<SecretString> secrets) {        super(materialFingerprint);        this.workingDir = workingDir;        this.branch = branch;        this.url = url;        this.secrets = secrets != null ? secrets : new ArrayList<>();    }    public HgVersion version() {        CommandLine hg = createCommandLine(\"hg\").withArgs(\"version\").withEncoding(\"UTF-8\");        String hgOut = execute(hg, new NamedProcessTag(\"hg version check\")).outputAsString();        return HgVersion.parse(hgOut);    }    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, UrlArgument repositoryUrl) {        CommandLine hg = createCommandLine(\"hg\")                .withArgs(\"clone\")                .withArg(branchArg())                .withArg(\"--\")                .withArg(repositoryUrl)                .withArg(workingDir.getAbsolutePath())                .withNonArgSecrets(secrets)                .withEncoding(\"UTF-8\");        return execute(hg, outputStreamConsumer);    }    public void checkConnection(UrlArgument repositoryURL) {        CommandLine hg = createCommandLine(\"hg\")                .withArgs(\"id\", \"--id\", \"--\")                .withArg(repositoryURL)                .withNonArgSecrets(secrets)                .withEncoding(\"UTF-8\");        execute(hg, new NamedProcessTag(repositoryURL.forDisplay()));    }    public void updateTo(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {        if (!pull(outputStreamConsumer) || !update(revision, outputStreamConsumer)) {            bomb(format(\"Unable to update to revision [%s]\", revision));        }    }    private boolean pull(ConsoleOutputStreamConsumer outputStreamConsumer) {        CommandLine hg = hg(\"pull\", branchArg(), \"--config\", String.format(\"paths.default=%s\", url));        return execute(hg, outputStreamConsumer) == 0;    }    private boolean update(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {        CommandLine hg = hg(\"update\", \"--clean\", \"-r\", revision.getRevision());        return execute(hg, outputStreamConsumer) == 0;    }    public void add(ConsoleOutputStreamConsumer outputStreamConsumer, File file) {        CommandLine hg = hg(\"add\", file.getAbsolutePath());        execute(hg, outputStreamConsumer);    }    public void commit(ConsoleOutputStreamConsumer consumer, String comment, String username) {        CommandLine hg = hg(\"commit\", \"-m\", comment, \"-u\", username);        execute(hg, consumer);    }    public void push(ConsoleOutputStreamConsumer consumer) {        CommandLine hg = hg(\"push\");        execute(hg, consumer);    }    public List<Modification> latestOneModificationAsModifications() {        return findRecentModifications(1);    }    private List<Modification> findRecentModifications(int count) {        InMemoryStreamConsumer consumer = inMemoryConsumer();        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());        CommandLine hg = hg(\"log\", \"--limit\", String.valueOf(count), branchArg(), \"--style\", templatePath());        return new HgModificationSplitter(execute(hg)).modifications();    }    public List<Modification> modificationsSince(Revision revision) {        InMemoryStreamConsumer consumer = inMemoryConsumer();        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());        CommandLine hg = hg(\"log\", \"-r\", \"tip:\" + revision.getRevision(), branchArg(), \"--style\", templatePath());        return new HgModificationSplitter(execute(hg)).filterOutRevision(revision);    }    private String templatePath() {        if (templatePath == null) {            String file = HgCommand.class.getResource(\"/hg.template\").getFile();            templatePath = URLDecoder.decode(new File(file).getAbsolutePath(), StandardCharsets.UTF_8);        }        return templatePath;    }    public ConsoleResult workingRepositoryUrl() {        CommandLine hg = hg(\"showconfig\", \"paths.default\");        final ConsoleResult result = execute(hg);        LOGGER.trace(\"Current repository url of [{}]: {}\", workingDir, result.outputForDisplayAsString());        LOGGER.trace(\"Target repository url: {}\", url);        return result;    }    private String branchArg() {        return \"--branch=\" + branch;    }    private CommandLine hg(String... arguments) {        return createCommandLine(\"hg\").withArgs(arguments).withNonArgSecrets(secrets).withWorkingDir(workingDir).withEncoding(\"UTF-8\");    }    private static ConsoleResult execute(CommandLine hgCmd, NamedProcessTag processTag) {        return hgCmd.runOrBomb(processTag);    }    private ConsoleResult execute(CommandLine hgCmd) {        return runOrBomb(hgCmd);    }    private int execute(CommandLine hgCmd, ConsoleOutputStreamConsumer outputStreamConsumer) {        return run(hgCmd, outputStreamConsumer);    }}", "nl": "import com.thoughtworks.go.domain.materials.Modification;import com.thoughtworks.go.domain.materials.Revision;import com.thoughtworks.go.domain.materials.SCMCommand;import com.thoughtworks.go.util.NamedProcessTag;import com.thoughtworks.go.util.command.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.util.ArrayList;import java.util.List;import static com.thoughtworks.go.util.ExceptionUtils.bomb;import static com.thoughtworks.go.util.ExceptionUtils.bombUnless;import static com.thoughtworks.go.util.command.CommandLine.createCommandLine;import static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;import static java.lang.String.format;public class HgCommand extends SCMCommand {    private static final Logger LOGGER = LoggerFactory.getLogger(HgCommand.class);    private final File workingDir;    private static String templatePath;    private final String branch;    private final String url;    private final List<SecretString> secrets;    public HgCommand(String materialFingerprint, File workingDir, String branch, String url, List<SecretString> secrets) {        super(materialFingerprint);        this.workingDir = workingDir;        this.branch = branch;        this.url = url;        this.secrets = secrets != null ? secrets : new ArrayList<>();    }    private boolean pull(ConsoleOutputStreamConsumer outputStreamConsumer) {        CommandLine hg = hg(\"pull\", \"-b\", branch, \"--config\", String.format(\"paths.default=%s\", url));        return execute(hg, outputStreamConsumer) == 0;    }    public HgVersion version() {        CommandLine hg = createCommandLine(\"hg\").withArgs(\"version\").withEncoding(\"utf-8\");        String hgOut = execute(hg, new NamedProcessTag(\"hg version check\")).outputAsString();        return HgVersion.parse(hgOut);    }    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, UrlArgument repositoryUrl) {        CommandLine hg = createCommandLine(\"hg\").withArgs(\"clone\").withArg(\"-b\").withArg(branch).withArg(repositoryUrl)                .withArg(workingDir.getAbsolutePath()).withNonArgSecrets(secrets).withEncoding(\"utf-8\");        return execute(hg, outputStreamConsumer);    }    public void checkConnection(UrlArgument repositoryURL) {        execute(createCommandLine(\"hg\").withArgs(\"id\", \"--id\").withArg(repositoryURL).withNonArgSecrets(secrets).withEncoding(\"utf-8\"), new NamedProcessTag(repositoryURL.forDisplay()));    }    public void updateTo(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {        if (!pull(outputStreamConsumer) || !update(revision, outputStreamConsumer)) {            bomb(format(\"Unable to update to revision [%s]\", revision));        }    }    private boolean update(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {        CommandLine hg = hg(\"update\", \"--clean\", \"-r\", revision.getRevision());        return execute(hg, outputStreamConsumer) == 0;    }    public void add(ConsoleOutputStreamConsumer outputStreamConsumer, File file) {        CommandLine hg = hg(\"add\", file.getAbsolutePath());        execute(hg, outputStreamConsumer);    }    public void commit(ConsoleOutputStreamConsumer consumer, String comment, String username) {        CommandLine hg = hg(\"commit\", \"-m\", comment, \"-u\", username);        execute(hg, consumer);    }    public void push(ConsoleOutputStreamConsumer consumer) {        CommandLine hg = hg(\"push\");        execute(hg, consumer);    }    public List<Modification> latestOneModificationAsModifications() {        return findRecentModifications(1);    }    private String templatePath() {        if (templatePath == null) {            String file = HgCommand.class.getResource(\"/hg.template\").getFile();            try {                templatePath = URLDecoder.decode(new File(file).getAbsolutePath(), \"UTF-8\");            } catch (UnsupportedEncodingException e) {                templatePath = URLDecoder.decode(new File(file).getAbsolutePath());            }        }        return templatePath;    }    List<Modification> findRecentModifications(int count) {        InMemoryStreamConsumer consumer = inMemoryConsumer();        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());        CommandLine hg = hg(\"log\", \"--limit\", String.valueOf(count), \"-b\", branch, \"--style\", templatePath());        return new HgModificationSplitter(execute(hg)).modifications();    }    public List<Modification> modificationsSince(Revision revision) {        InMemoryStreamConsumer consumer = inMemoryConsumer();        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());        CommandLine hg = hg(\"log\",                \"-r\", \"tip:\" + revision.getRevision(),                \"-b\", branch,                \"--style\", templatePath());        return new HgModificationSplitter(execute(hg)).filterOutRevision(revision);    }    public ConsoleResult workingRepositoryUrl() {        CommandLine hg = hg(\"showconfig\", \"paths.default\");        final ConsoleResult result = execute(hg);        LOGGER.trace(\"Current repository url of [{}]: {}\", workingDir, result.outputForDisplayAsString());        LOGGER.trace(\"Target repository url: {}\", url);        return result;    }    private CommandLine hg(String... arguments) {        return createCommandLine(\"hg\").withArgs(arguments).withNonArgSecrets(secrets).withWorkingDir(workingDir).withEncoding(\"UTF-8\");    }    private static ConsoleResult execute(CommandLine hgCmd, NamedProcessTag processTag) {        return hgCmd.runOrBomb(processTag);    }    private ConsoleResult execute(CommandLine hgCmd) {        return runOrBomb(hgCmd);    }    private int execute(CommandLine hgCmd, ConsoleOutputStreamConsumer outputStreamConsumer) {        return run(hgCmd, outputStreamConsumer);    }}"}
{"code": "import java.sql.Timestamp;import java.util.LinkedHashMap;import java.util.LinkedList;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.transaction.Transaction;import org.apache.ofbiz.base.crypto.HashCrypt;import org.apache.ofbiz.base.util.Debug;import org.apache.ofbiz.base.util.UtilDateTime;import org.apache.ofbiz.base.util.UtilMisc;import org.apache.ofbiz.base.util.UtilProperties;import org.apache.ofbiz.base.util.UtilValidate;import org.apache.ofbiz.common.authentication.AuthHelper;import org.apache.ofbiz.common.authentication.api.AuthenticatorException;import org.apache.ofbiz.entity.Delegator;import org.apache.ofbiz.entity.GenericEntityException;import org.apache.ofbiz.entity.GenericValue;import org.apache.ofbiz.entity.condition.EntityCondition;import org.apache.ofbiz.entity.condition.EntityFunction;import org.apache.ofbiz.entity.condition.EntityOperator;import org.apache.ofbiz.entity.model.ModelEntity;import org.apache.ofbiz.entity.model.ModelField;import org.apache.ofbiz.entity.transaction.GenericTransactionException;import org.apache.ofbiz.entity.transaction.TransactionUtil;import org.apache.ofbiz.entity.util.EntityListIterator;import org.apache.ofbiz.entity.util.EntityQuery;import org.apache.ofbiz.entity.util.EntityUtilProperties;import org.apache.ofbiz.security.Security;import org.apache.ofbiz.service.DispatchContext;import org.apache.ofbiz.service.GenericServiceException;import org.apache.ofbiz.service.LocalDispatcher;import org.apache.ofbiz.service.ModelService;import org.apache.ofbiz.service.ServiceUtil;import org.apache.ofbiz.webapp.control.LoginWorker;import org.apache.tomcat.util.res.StringManager;public class LoginServices {    public static final String module = LoginServices.class.getName();    public static final String resource = \"SecurityextUiLabels\";    public static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {        LocalDispatcher dispatcher = ctx.getDispatcher();        Locale locale = (Locale) context.get(\"locale\");        Delegator delegator = ctx.getDelegator();        if (!AuthHelper.authenticatorsLoaded()) {            AuthHelper.loadAuthenticators(dispatcher);        }        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {            if (!LdapAuthenticationServices.userLogin(ctx, context)) {                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {                    return ServiceUtil.returnError(errMsg);                }                Debug.logInfo(errMsg, module);            }        }        Map<String, Object> result =  new LinkedHashMap<>();        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();        String username = (String) context.get(\"login.username\");        if (username == null) {            username = (String) context.get(\"username\");        }        String password = (String) context.get(\"login.password\");        if (password == null) {            password = (String) context.get(\"password\");        }        String visitId = (String) context.get(\"visitId\");        String errMsg = \"\";        if (UtilValidate.isEmpty(username)) {            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);        } else if (UtilValidate.isEmpty(password)) {            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);        } else {            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {                username = username.toLowerCase(Locale.getDefault());            }            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {                password = password.toLowerCase(Locale.getDefault());            }            boolean repeat = true;            int passNumber = 0;            while (repeat) {                repeat = false;                passNumber++;                GenericValue userLogin = null;                try {                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();                } catch (GenericEntityException e) {                    Debug.logWarning(e, \"\", module);                }                if (userLogin == null) {                    try {                        AuthHelper.syncUser(username);                    } catch (AuthenticatorException e) {                        Debug.logWarning(e, module);                    }                    try {                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();                    } catch (GenericEntityException e) {                        Debug.logWarning(e, \"\", module);                    }                }                if (userLogin != null) {                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);                    long loginDisableMinutes;                    try {                        loginDisableMinutes = Long.parseLong(ldmStr);                    } catch (Exception e) {                        loginDisableMinutes = 30;                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);                    }                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");                    Timestamp reEnableTime = null;                    if (loginDisableMinutes > 0 && disabledDateTime != null) {                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);                    }                    boolean doStore = true;                    userLogin = GenericValue.create(userLogin);                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {                        String successfulLogin;                        if (!isSystem) {                            userLogin.set(\"enabled\", \"Y\");                            userLogin.set(\"disabledBy\", null);                        }                        boolean authFatalError = false;                        boolean externalAuth = false;                        try {                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);                        } catch (AuthenticatorException e) {                            Debug.logWarning(e, module);                            authFatalError = true;                        }                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");                        useTomcatSSO = useTomcatSSO && (request!=null);                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);                            if (hasLoggedOut == null || hasLoggedOut) {                                userLogin.set(\"hasLoggedOut\", \"N\");                            }                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));                            } else if (hasLoggedOut != null && !hasLoggedOut) {                                doStore = false;                            }                            successfulLogin = \"Y\";                            if (!isServiceAuth) {                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);                                if (userLoginSessionMap != null) {                                    result.put(\"userLoginSession\", userLoginSessionMap);                                }                            }                            result.put(\"userLogin\", userLogin);                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);                        } else {                            if (!authFatalError && isServiceAuth && passNumber <= 1) {                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));                                repeat = true;                                continue;                            }                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");                            if (currentFailedLogins == null) {                                currentFailedLogins = Long.valueOf(1);                            } else {                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);                            }                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);                            long maxFailedLogins = 3;                            try {                                maxFailedLogins = Long.parseLong(mflStr);                            } catch (Exception e) {                                maxFailedLogins = 3;                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);                            }                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {                                userLogin.set(\"enabled\", \"N\");                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());                            }                            successfulLogin = \"N\";                        }                        Transaction parentTx = null;                        boolean beganTransaction = false;                        try {                            try {                                parentTx = TransactionUtil.suspend();                            } catch (GenericTransactionException e) {                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);                            }                            try {                                beganTransaction = TransactionUtil.begin();                                if (doStore) {                                    userLogin.store();                                }                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {                                    boolean createHistory = true;                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {                                        createHistory = false;                                    }                                    if (createHistory) {                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);                                        ModelEntity modelUserLogin = userLogin.getModelEntity();                                        if (modelUserLogin.isField(\"partyId\")) {                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));                                        }                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\",                                                \"store.login.history.incorrect.password\", delegator))) {                                            ulhCreateMap.put(\"passwordUsed\", isGivenPasswordCanBeStored(delegator, password)                                                    ? \" TOO LONG FOR STORAGE \"                                                    : password);                                        }                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);                                    }                                }                            } catch (GenericEntityException e) {                                String geeErrMsg = \"Error saving UserLoginHistory\";                                if (doStore) {                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";                                }                                try {                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);                                } catch (GenericTransactionException e2) {                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);                                }                                if (doStore) {                                    return ServiceUtil.returnError(geeErrMsg);                                }                            } finally {                                try {                                    TransactionUtil.commit(beganTransaction);                                } catch (GenericTransactionException e) {                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);                                }                            }                        } finally {                            if (parentTx != null) {                                try {                                    TransactionUtil.resume(parentTx);                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);                                } catch (GenericTransactionException e) {                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);                                }                            }                        }                    } else {                        if (isServiceAuth && passNumber <= 1) {                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));                            repeat = true;                            continue;                        }                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);                        if (disabledDateTime != null) {                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);                        } else {                            errMsg += \".\";                        }                        if (loginDisableMinutes > 0 && reEnableTime != null) {                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);                        } else {                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);                        }                    }                } else {                    boolean externalAuth = false;                    try {                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);                    } catch (AuthenticatorException e) {                        errMsg = e.getMessage();                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);                    }                    if (externalAuth) {                        userLogin = delegator.makeValue(\"UserLogin\");                        userLogin.set(\"userLoginId\", username);                        userLogin.set(\"enabled\", \"Y\");                        userLogin.set(\"hasLoggedOut\", \"N\");                        result.put(\"userLogin\", userLogin);                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);                    } else {                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);                    }                }            }        }        if (errMsg.length() > 0) {            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);            result.put(ModelService.ERROR_MESSAGE, errMsg);        }        return result;    }    private static boolean isGivenPasswordCanBeStored(Delegator delegator, String password)            throws GenericEntityException {        ModelEntity modelEntityUserLoginHistory = delegator.getModelEntity(\"UserLoginHistory\");        ModelField passwordUsedField = modelEntityUserLoginHistory.getField(\"passwordUsed\");        int maxPasswordSize = delegator.getEntityFieldType(                modelEntityUserLoginHistory,                passwordUsedField.getType()).stringLength();        int passwordUsedCurrentSize = password.length();        ModelField.EncryptMethod encryptMethod = passwordUsedField.getEncryptMethod();        if (encryptMethod.isEncrypted()) {            passwordUsedCurrentSize = delegator.encryptFieldValue(\"UserLoginHistory\", encryptMethod, password).toString().length();        }        return passwordUsedCurrentSize > maxPasswordSize;    }    public static void createUserLoginPasswordHistory(GenericValue userLogin) throws GenericEntityException{        int passwordChangeHistoryLimit = 0;        Delegator delegator = userLogin.getDelegator();        String userLoginId = userLogin.getString(\"userLoginId\");        String currentPassword = userLogin.getString(\"currentPassword\");        try {            passwordChangeHistoryLimit = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.change.history.limit\", 0).intValue();        } catch (NumberFormatException nfe) {            passwordChangeHistoryLimit = 0;        }        if (passwordChangeHistoryLimit == 0 || passwordChangeHistoryLimit < 0) {            return;        }        EntityQuery eq = EntityQuery.use(delegator)                .from(\"UserLoginPasswordHistory\")                .where(\"userLoginId\", userLoginId)                .orderBy(\"-fromDate\")                .cursorScrollInsensitive();        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();        try (EntityListIterator eli = eq.queryIterator()) {            GenericValue pwdHist;            if ((pwdHist = eli.next()) != null) {                pwdHist.set(\"thruDate\", nowTimestamp);                pwdHist.store();                eli.last();                int rowIndex = eli.currentIndex();                if (rowIndex==passwordChangeHistoryLimit) {                    eli.afterLast();                    pwdHist = eli.previous();                    pwdHist.remove();                }            }        }        GenericValue userLoginPwdHistToCreate = delegator.makeValue(\"UserLoginPasswordHistory\", UtilMisc.toMap(\"userLoginId\", userLoginId,\"fromDate\", nowTimestamp));        userLoginPwdHistToCreate.set(\"currentPassword\", currentPassword);        userLoginPwdHistToCreate.create();    }    public static Map<String, Object> createUserLogin(DispatchContext ctx, Map<String, ?> context) {        Map<String, Object> result =  new LinkedHashMap<>();        Delegator delegator = ctx.getDelegator();        LocalDispatcher dispatcher = ctx.getDispatcher();        Security security = ctx.getSecurity();        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");        List<String> errorMessageList = new LinkedList<>();        Locale locale = (Locale) context.get(\"locale\");        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));        String userLoginId = (String) context.get(\"userLoginId\");        String partyId = (String) context.get(\"partyId\");        String currentPassword = (String) context.get(\"currentPassword\");        String currentPasswordVerify = (String) context.get(\"currentPasswordVerify\");        String enabled = (String) context.get(\"enabled\");        String passwordHint = (String) context.get(\"passwordHint\");        String requirePasswordChange = (String) context.get(\"requirePasswordChange\");        String externalAuthId = (String) context.get(\"externalAuthId\");        String errMsg = null;        String questionEnumId = (String) context.get(\"securityQuestion\");        String securityAnswer = (String) context.get(\"securityAnswer\");        if (UtilValidate.isNotEmpty(partyId)) {            GenericValue party = null;            try {                party = EntityQuery.use(delegator).from(\"Party\").where(\"partyId\", partyId).queryOne();            } catch (GenericEntityException e) {                Debug.logWarning(e, \"\", module);            }            if (party != null) {                if (loggedInUserLogin != null) {                    if (!partyId.equals(loggedInUserLogin.getString(\"partyId\"))) {                        if (!security.hasEntityPermission(\"PARTYMGR\", \"_CREATE\", loggedInUserLogin)) {                            errMsg = UtilProperties.getMessage(resource,\"loginservices.party_with_specified_party_ID_exists_not_have_permission\", locale);                            errorMessageList.add(errMsg);                        }                    }                } else {                    errMsg = UtilProperties.getMessage(resource,\"loginservices.must_be_logged_in_and_permission_create_login_party_ID_exists\", locale);                    errorMessageList.add(errMsg);                }            }        }        GenericValue userLoginToCreate = delegator.makeValue(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", userLoginId));        checkNewPassword(userLoginToCreate, null, currentPassword, currentPasswordVerify, passwordHint, errorMessageList, true, locale);        userLoginToCreate.set(\"externalAuthId\", externalAuthId);        userLoginToCreate.set(\"passwordHint\", passwordHint);        userLoginToCreate.set(\"enabled\", enabled);        userLoginToCreate.set(\"requirePasswordChange\", requirePasswordChange);        userLoginToCreate.set(\"currentPassword\", useEncryption ? HashCrypt.cryptUTF8(getHashType(), null, currentPassword) : currentPassword);        try {            userLoginToCreate.set(\"partyId\", partyId);        } catch (Exception e) {            Debug.logInfo(e, \"Exception thrown while setting UserLogin partyId field: \", module);        }        try {            EntityCondition condition = EntityCondition.makeCondition(EntityFunction.UPPER_FIELD(\"userLoginId\"), EntityOperator.EQUALS, EntityFunction.UPPER(userLoginId));            if (UtilValidate.isNotEmpty(EntityQuery.use(delegator).from(\"UserLogin\").where(condition).queryList())) {                Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_with_ID_exists\", messageMap, locale);                errorMessageList.add(errMsg);            }        } catch (GenericEntityException e) {            Debug.logWarning(e, \"\", module);            Map<String, Stri", "nl": "import java.sql.Timestamp;import java.util.LinkedHashMap;import java.util.LinkedList;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.transaction.Transaction;import org.apache.ofbiz.base.crypto.HashCrypt;import org.apache.ofbiz.base.util.Debug;import org.apache.ofbiz.base.util.UtilDateTime;import org.apache.ofbiz.base.util.UtilMisc;import org.apache.ofbiz.base.util.UtilProperties;import org.apache.ofbiz.base.util.UtilValidate;import org.apache.ofbiz.common.authentication.AuthHelper;import org.apache.ofbiz.common.authentication.api.AuthenticatorException;import org.apache.ofbiz.entity.Delegator;import org.apache.ofbiz.entity.GenericEntityException;import org.apache.ofbiz.entity.GenericValue;import org.apache.ofbiz.entity.condition.EntityCondition;import org.apache.ofbiz.entity.condition.EntityFunction;import org.apache.ofbiz.entity.condition.EntityOperator;import org.apache.ofbiz.entity.model.ModelEntity;import org.apache.ofbiz.entity.transaction.GenericTransactionException;import org.apache.ofbiz.entity.transaction.TransactionUtil;import org.apache.ofbiz.entity.util.EntityListIterator;import org.apache.ofbiz.entity.util.EntityQuery;import org.apache.ofbiz.entity.util.EntityUtilProperties;import org.apache.ofbiz.security.Security;import org.apache.ofbiz.service.DispatchContext;import org.apache.ofbiz.service.GenericServiceException;import org.apache.ofbiz.service.LocalDispatcher;import org.apache.ofbiz.service.ModelService;import org.apache.ofbiz.service.ServiceUtil;import org.apache.ofbiz.webapp.control.LoginWorker;import org.apache.tomcat.util.res.StringManager;public class LoginServices {    public static final String module = LoginServices.class.getName();    public static final String resource = \"SecurityextUiLabels\";    public static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {        LocalDispatcher dispatcher = ctx.getDispatcher();        Locale locale = (Locale) context.get(\"locale\");        Delegator delegator = ctx.getDelegator();        if (!AuthHelper.authenticatorsLoaded()) {            AuthHelper.loadAuthenticators(dispatcher);        }        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {            if (!LdapAuthenticationServices.userLogin(ctx, context)) {                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {                    return ServiceUtil.returnError(errMsg);                }                Debug.logInfo(errMsg, module);            }        }        Map<String, Object> result =  new LinkedHashMap<>();        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();        String username = (String) context.get(\"login.username\");        if (username == null) {            username = (String) context.get(\"username\");        }        String password = (String) context.get(\"login.password\");        if (password == null) {            password = (String) context.get(\"password\");        }        String visitId = (String) context.get(\"visitId\");        String errMsg = \"\";        if (UtilValidate.isEmpty(username)) {            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);        } else if (UtilValidate.isEmpty(password)) {            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);        } else {            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {                username = username.toLowerCase(Locale.getDefault());            }            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {                password = password.toLowerCase(Locale.getDefault());            }            boolean repeat = true;            int passNumber = 0;            while (repeat) {                repeat = false;                passNumber++;                GenericValue userLogin = null;                try {                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();                } catch (GenericEntityException e) {                    Debug.logWarning(e, \"\", module);                }                if (userLogin == null) {                    try {                        AuthHelper.syncUser(username);                    } catch (AuthenticatorException e) {                        Debug.logWarning(e, module);                    }                    try {                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();                    } catch (GenericEntityException e) {                        Debug.logWarning(e, \"\", module);                    }                }                if (userLogin != null) {                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);                    long loginDisableMinutes;                    try {                        loginDisableMinutes = Long.parseLong(ldmStr);                    } catch (Exception e) {                        loginDisableMinutes = 30;                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);                    }                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");                    Timestamp reEnableTime = null;                    if (loginDisableMinutes > 0 && disabledDateTime != null) {                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);                    }                    boolean doStore = true;                    userLogin = GenericValue.create(userLogin);                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {                        String successfulLogin;                        if (!isSystem) {                            userLogin.set(\"enabled\", \"Y\");                            userLogin.set(\"disabledBy\", null);                        }                        boolean authFatalError = false;                        boolean externalAuth = false;                        try {                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);                        } catch (AuthenticatorException e) {                            Debug.logWarning(e, module);                            authFatalError = true;                        }                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");                        useTomcatSSO = useTomcatSSO && (request!=null);                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);                            if (hasLoggedOut == null || hasLoggedOut) {                                userLogin.set(\"hasLoggedOut\", \"N\");                            }                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));                            } else if (hasLoggedOut != null && !hasLoggedOut) {                                doStore = false;                            }                            successfulLogin = \"Y\";                            if (!isServiceAuth) {                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);                                if (userLoginSessionMap != null) {                                    result.put(\"userLoginSession\", userLoginSessionMap);                                }                            }                            result.put(\"userLogin\", userLogin);                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);                        } else {                            if (!authFatalError && isServiceAuth && passNumber <= 1) {                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));                                repeat = true;                                continue;                            }                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");                            if (currentFailedLogins == null) {                                currentFailedLogins = Long.valueOf(1);                            } else {                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);                            }                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);                            long maxFailedLogins = 3;                            try {                                maxFailedLogins = Long.parseLong(mflStr);                            } catch (Exception e) {                                maxFailedLogins = 3;                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);                            }                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {                                userLogin.set(\"enabled\", \"N\");                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());                            }                            successfulLogin = \"N\";                        }                        Transaction parentTx = null;                        boolean beganTransaction = false;                        try {                            try {                                parentTx = TransactionUtil.suspend();                            } catch (GenericTransactionException e) {                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);                            }                            try {                                beganTransaction = TransactionUtil.begin();                                if (doStore) {                                    userLogin.store();                                }                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {                                    boolean createHistory = true;                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {                                        createHistory = false;                                    }                                    if (createHistory) {                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);                                        ModelEntity modelUserLogin = userLogin.getModelEntity();                                        if (modelUserLogin.isField(\"partyId\")) {                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));                                        }                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.incorrect.password\", delegator))) {                                            ulhCreateMap.put(\"passwordUsed\", password);                                        }                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);                                    }                                }                            } catch (GenericEntityException e) {                                String geeErrMsg = \"Error saving UserLoginHistory\";                                if (doStore) {                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";                                }                                geeErrMsg += \": \" + e.toString();                                try {                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);                                } catch (GenericTransactionException e2) {                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);                                }                                if (doStore) {                                    return ServiceUtil.returnError(geeErrMsg);                                }                            } finally {                                try {                                    TransactionUtil.commit(beganTransaction);                                } catch (GenericTransactionException e) {                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);                                }                            }                        } finally {                            if (parentTx != null) {                                try {                                    TransactionUtil.resume(parentTx);                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);                                } catch (GenericTransactionException e) {                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);                                }                            }                        }                    } else {                        if (isServiceAuth && passNumber <= 1) {                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));                            repeat = true;                            continue;                        }                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);                        if (disabledDateTime != null) {                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);                        } else {                            errMsg += \".\";                        }                        if (loginDisableMinutes > 0 && reEnableTime != null) {                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);                        } else {                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);                        }                    }                } else {                    boolean externalAuth = false;                    try {                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);                    } catch (AuthenticatorException e) {                        errMsg = e.getMessage();                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);                    }                    if (externalAuth) {                        userLogin = delegator.makeValue(\"UserLogin\");                        userLogin.set(\"userLoginId\", username);                        userLogin.set(\"enabled\", \"Y\");                        userLogin.set(\"hasLoggedOut\", \"N\");                        result.put(\"userLogin\", userLogin);                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);                    } else {                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);                    }                }            }        }        if (errMsg.length() > 0) {            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);            result.put(ModelService.ERROR_MESSAGE, errMsg);        }        return result;    }    public static void createUserLoginPasswordHistory(GenericValue userLogin) throws GenericEntityException{        int passwordChangeHistoryLimit = 0;        Delegator delegator = userLogin.getDelegator();        String userLoginId = userLogin.getString(\"userLoginId\");        String currentPassword = userLogin.getString(\"currentPassword\");        try {            passwordChangeHistoryLimit = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.change.history.limit\", 0).intValue();        } catch (NumberFormatException nfe) {            passwordChangeHistoryLimit = 0;        }        if (passwordChangeHistoryLimit == 0 || passwordChangeHistoryLimit < 0) {            return;        }        EntityQuery eq = EntityQuery.use(delegator)                .from(\"UserLoginPasswordHistory\")                .where(\"userLoginId\", userLoginId)                .orderBy(\"-fromDate\")                .cursorScrollInsensitive();        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();        try (EntityListIterator eli = eq.queryIterator()) {            GenericValue pwdHist;            if ((pwdHist = eli.next()) != null) {                pwdHist.set(\"thruDate\", nowTimestamp);                pwdHist.store();                eli.last();                int rowIndex = eli.currentIndex();                if (rowIndex==passwordChangeHistoryLimit) {                    eli.afterLast();                    pwdHist = eli.previous();                    pwdHist.remove();                }            }        }        GenericValue userLoginPwdHistToCreate = delegator.makeValue(\"UserLoginPasswordHistory\", UtilMisc.toMap(\"userLoginId\", userLoginId,\"fromDate\", nowTimestamp));        userLoginPwdHistToCreate.set(\"currentPassword\", currentPassword);        userLoginPwdHistToCreate.create();    }    public static Map<String, Object> createUserLogin(DispatchContext ctx, Map<String, ?> context) {        Map<String, Object> result =  new LinkedHashMap<>();        Delegator delegator = ctx.getDelegator();        LocalDispatcher dispatcher = ctx.getDispatcher();        Security security = ctx.getSecurity();        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");        List<String> errorMessageList = new LinkedList<>();        Locale locale = (Locale) context.get(\"locale\");        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));        String userLoginId = (String) context.get(\"userLoginId\");        String partyId = (String) context.get(\"partyId\");        String currentPassword = (String) context.get(\"currentPassword\");        String currentPasswordVerify = (String) context.get(\"currentPasswordVerify\");        String enabled = (String) context.get(\"enabled\");        String passwordHint = (String) context.get(\"passwordHint\");        String requirePasswordChange = (String) context.get(\"requirePasswordChange\");        String externalAuthId = (String) context.get(\"externalAuthId\");        String errMsg = null;        String questionEnumId = (String) context.get(\"securityQuestion\");        String securityAnswer = (String) context.get(\"securityAnswer\");        if (UtilValidate.isNotEmpty(partyId)) {            GenericValue party = null;            try {                party = EntityQuery.use(delegator).from(\"Party\").where(\"partyId\", partyId).queryOne();            } catch (GenericEntityException e) {                Debug.logWarning(e, \"\", module);            }            if (party != null) {                if (loggedInUserLogin != null) {                    if (!partyId.equals(loggedInUserLogin.getString(\"partyId\"))) {                        if (!security.hasEntityPermission(\"PARTYMGR\", \"_CREATE\", loggedInUserLogin)) {                            errMsg = UtilProperties.getMessage(resource,\"loginservices.party_with_specified_party_ID_exists_not_have_permission\", locale);                            errorMessageList.add(errMsg);                        }                    }                } else {                    errMsg = UtilProperties.getMessage(resource,\"loginservices.must_be_logged_in_and_permission_create_login_party_ID_exists\", locale);                    errorMessageList.add(errMsg);                }            }        }        GenericValue userLoginToCreate = delegator.makeValue(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", userLoginId));        checkNewPassword(userLoginToCreate, null, currentPassword, currentPasswordVerify, passwordHint, errorMessageList, true, locale);        userLoginToCreate.set(\"externalAuthId\", externalAuthId);        userLoginToCreate.set(\"passwordHint\", passwordHint);        userLoginToCreate.set(\"enabled\", enabled);        userLoginToCreate.set(\"requirePasswordChange\", requirePasswordChange);        userLoginToCreate.set(\"currentPassword\", useEncryption ? HashCrypt.cryptUTF8(getHashType(), null, currentPassword) : currentPassword);        try {            userLoginToCreate.set(\"partyId\", partyId);        } catch (Exception e) {            Debug.logInfo(e, \"Exception thrown while setting UserLogin partyId field: \", module);        }        try {            EntityCondition condition = EntityCondition.makeCondition(EntityFunction.UPPER_FIELD(\"userLoginId\"), EntityOperator.EQUALS, EntityFunction.UPPER(userLoginId));            if (UtilValidate.isNotEmpty(EntityQuery.use(delegator).from(\"UserLogin\").where(condition).queryList())) {                Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_with_ID_exists\", messageMap, locale);                errorMessageList.add(errMsg);            }        } catch (GenericEntityException e) {            Debug.logWarning(e, \"\", module);            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_read_failure\", messageMap, locale);            errorMessageList.add(errMsg);        }        if (errorMessageList.size() > 0) {            return ServiceUtil.returnError(errorMessageList);        }        try {            userLoginToCreate.create();            createUserLoginPasswordHistory(userLoginToCreate);        } catch (GenericEntityException e) {            Debug.logWarning(e, \"\", module);            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_write_failure\", messageMap, locale);            return ServiceUtil.returnError(errMsg);        }        try {            if (UtilValidate.isNotEmpty(securityAnswer)) {                Map<String, Object> resultMap = dispatcher.runSync(\"createUserLoginSecurityQuestion\",                        UtilMisc.toMap(\"userLogin\", loggedInUserLogin, \"userLoginId\", userLoginId, \"questionEnumId\", questionEnumId, \"securityAnswer\", securityAnswer));                if (ServiceUtil.isError(resultMap)) {                    errMsg = ServiceUtil.getErrorMessage(resultMap);                    errorMessageList.add(errMsg);                    Debug.logError(errMsg, module);                }            }        } catch (GenericServiceException e1) {            errMsg = UtilProperties.ge"}
{"code": "import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintStream;import java.io.Reader;import java.lang.reflect.Method;import java.math.BigDecimal;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.Properties;import java.util.Set;import org.opencrx.kernel.utils.DbSchemaUtils;import org.opencrx.kernel.utils.Utils;import org.openmdx.base.dataprovider.layer.persistence.jdbc.Database_2;import org.openmdx.base.exception.ServiceException;import org.openmdx.kernel.exception.BasicException;public class CopyDb {private static String getStringFromClob(java.sql.Clob clob) throws IOException, SQLException {Reader reader = clob.getCharacterStream();StringBuilder s = new StringBuilder();int c;while ((c = reader.read()) != -1) {s.append((char) c);}return s.toString();}private static byte[] getBytesFromBlob(java.sql.Blob blob) throws IOException, SQLException {InputStream is = blob.getBinaryStream();ByteArrayOutputStream os = new ByteArrayOutputStream();int b;while ((b = is.read()) != -1) {os.write(b);}os.close();return os.toByteArray();}private static String mapColumnName(Connection conn, String dbObject, String columnName) throws SQLException {String databaseProductName = conn.getMetaData().getDatabaseProductName();if(\"HSQL Database Engine\".equals(databaseProductName)) {String mappedColumnName = columnName.toUpperCase();if(\"POSITION\".equals(mappedColumnName) || mappedColumnName.indexOf(\"$\") > 0) {return \"\\\"\" + mappedColumnName + \"\\\"\";} else {return mappedColumnName;}} else if(\"PostgreSQL\".equals(databaseProductName)) {String mappedColumnName = columnName.toLowerCase();if(\"offset\".equals(mappedColumnName) || \"end\".equals(mappedColumnName) || mappedColumnName.indexOf(\"-\") > 0) {return \"\\\"\" + mappedColumnName + \"\\\"\";} else {return mappedColumnName;}} else {return columnName.toUpperCase();}}private static Object mapColumnValue(Connection conn, String dbObject, String columnName, Object columnValue, List<String> valuePatterns,List<String> valueReplacements) throws ServiceException, SQLException {String databaseProductName = conn.getMetaData().getDatabaseProductName();if(BOOLEAN_COLUMNS.contains(columnName.toUpperCase())) {if(\"PostgreSQL\".equals(databaseProductName)) {return columnValue;} else if(\"MySQL\".equals(databaseProductName)) {return columnValue;} else if(\"Microsoft SQL Server\".equals(databaseProductName)) {return columnValue;} else if(databaseProductName.startsWith(\"DB2/\")) {return Boolean.valueOf(\"Y\".equals(columnValue));} else if(\"HSQL Database Engine\".equals(databaseProductName)) {return columnValue;} else if(\"Oracle\".equals(databaseProductName)) {return Boolean.valueOf(((Number) columnValue).intValue() == 1);} else {throw new ServiceException(BasicException.Code.DEFAULT_DOMAIN, BasicException.Code.NOT_SUPPORTED, \"Database not supported\", new BasicException.Parameter(\"database product name\",    databaseProductName));}} else {if(columnValue instanceof String) {String targetValue = (String)columnValue;for(int i = 0; i < valuePatterns.size(); i++) {String valuePattern = valuePatterns.get(i);String valueReplacment = valueReplacements.get(i);if(valuePattern != null & valuePattern.length() > 0) {targetValue = targetValue.replaceAll(valuePattern, valueReplacment);}}return targetValue;} else {return columnValue;}}}public static void copyDbObject(String dbObject, boolean useSuffix, Connection connSource, Connection connTarget, List<String> valuePatterns,List<String> valueReplacements,PrintStream out) throws SQLException {String currentStatement = null;Database_2 db = new Database_2();try {Database_2[] plugins = Utils.getDatabasePlugIns();db = plugins[0];} catch (Exception e) {out.println(\"Can not activate database plugin: \" + e.getMessage());}try {PreparedStatement s = connTarget.prepareStatement(currentStatement = \"DELETE FROM \" + dbObject + (useSuffix ? \"_\" : \"\"));s.executeUpdate();s.close();s = connSource.prepareStatement(currentStatement = \"SELECT * FROM \" + dbObject + (useSuffix ? \"_\" : \"\"));s.setFetchSize(100);ResultSet rs = s.executeQuery();if(rs != null) {ResultSetMetaData rsm = rs.getMetaData();FastResultSet frs = new FastResultSet(rs);int nRows = 0;while (frs.next()) {String statement = \"INSERT INTO \" + dbObject + (useSuffix ? \"_\" : \"\") + \" \";List<Object> statementParameters = new ArrayList<Object>();List<String> processTargetColumnNames = new ArrayList<String>();for (int j = 0; j < rsm.getColumnCount(); j++) {String columnName = rsm.getColumnName(j + 1);if(frs.getObject(columnName) != null) {String mappedColumnName = CopyDb.mapColumnName(connTarget, dbObject, columnName);if(mappedColumnName != null) {statement += (statementParameters.size() == 0 ? \" (\" : \", \") + mappedColumnName;processTargetColumnNames.add(mappedColumnName);if(frs.getObject(columnName) instanceof java.sql.Clob) {try {statementParameters.add(CopyDb.getStringFromClob((java.sql.Clob) frs.getObject(columnName)));} catch (Exception e) {out.println(\"Reading Clob failed. Reason: \" + e.getMessage());out.println(\"statement=\" + statement);out.println(\"parameters=\" + statementParameters);}} else if(frs.getObject(columnName) instanceof java.sql.Blob) {try {statementParameters.add(CopyDb.getBytesFromBlob((java.sql.Blob) frs.getObject(columnName)));} catch (Exception e) {out.println(\"Reading Blob failed. Reason: \" + e.getMessage());out.println(\"statement=\" + statement);out.println(\"parameters=\" + statementParameters);}} else {statementParameters.add(CopyDb.mapColumnValue(connSource,dbObject,columnName,frs.getObject(columnName),valuePatterns,valueReplacements));}}}}statement += \") VALUES (\";for (int j = 0; j < statementParameters.size(); j++) {statement += j == 0 ? \"?\" : \", ?\";}statement += \")\";try {PreparedStatement t = connTarget.prepareStatement(currentStatement = statement);for (int j = 0; j < statementParameters.size(); j++) {Object parameter = statementParameters.get(j);if(\"oracle.sql.TIMESTAMP\".equals(parameter.getClass().getName())) {Method timestampValueMethod = parameter.getClass().getMethod(\"timestampValue\", new Class[] {});parameter = timestampValueMethod.invoke(parameter, new Object[] {});} else if(\"microsoft.sql.DateTimeOffset\".equals(parameter.getClass().getName())) {Method timestampValueMethod = parameter.getClass().getMethod(\"getTimestamp\", new Class[] {});parameter = timestampValueMethod.invoke(parameter, new Object[] {});}if(parameter instanceof java.sql.Timestamp) {t.setTimestamp(j + 1, (java.sql.Timestamp) parameter);} else if(parameter instanceof java.sql.Date) {t.setDate(j + 1, (java.sql.Date) parameter);} else if(parameter instanceof Double) {t.setBigDecimal(j + 1, new BigDecimal((Double)parameter));} else if(parameter instanceof Float) {t.setBigDecimal(j + 1, new BigDecimal((Float)parameter));} else {db.setPreparedStatementValue(connTarget, t, j + 1, parameter);}}t.executeUpdate();t.close();} catch (Exception e) {new ServiceException(e).log();out.println(\"Insert failed. Reason: \" + e.getMessage());out.println(\"statement=\" + statement);out.println(\"parameters=\" + statementParameters);}nRows++;if(nRows % 1000 == 0) {out.println(nRows + \" rows copied\");}}rs.close();} else {out.println(\"Did not copy table (result set is null). Statement: \" + currentStatement);}s.close();} catch (Exception e) {new ServiceException(e).log();out.println(\"Can not copy table (see log for more info). Statement: \" + currentStatement);}}private static void copyNamespace(    Connection connSource,    Connection connTarget,    List<String> dbObjects,List<String> valuePatterns,List<String> valueReplacements,    PrintStream out) {String currentStatement = null;try {out.println(\"Processing tables:\");int ii = 0;for(String dbObject: dbObjects) {out.println(ii + \": \" + dbObject);ii++;}Set<String> processedDbObjects = new HashSet<String>();for (String dbObject: dbObjects) {if((dbObject != null) && !dbObject.isEmpty() && !processedDbObjects.contains(dbObject)) {out.println(\"Copying table: \" + dbObject);CopyDb.copyDbObject(dbObject, false, connSource, connTarget, valuePatterns, valueReplacements, out);out.println(\"Copying table: \" + dbObject + \"_\");CopyDb.copyDbObject(dbObject, true, connSource, connTarget, valuePatterns, valueReplacements, out);processedDbObjects.add(dbObject);}}} catch (SQLException e) {ServiceException e0 = new ServiceException(e);e0.log();out.println(\"statement: \" + currentStatement + \" (message=\" + e0.getMessage());}}public static void main(String[] args) {try {Properties env = System.getProperties();String includeDbObjects = env.getProperty(\"includeDbObjects\");String excludeDbObjects = env.getProperty(\"excludeDbObjects\");String valuePatterns = env.getProperty(\"valuePatterns\");String valueReplacements = env.getProperty(\"valueReplacements\");copyDb(env.getProperty(\"jdbcDriverSource\"), env.getProperty(\"usernameSource\"), env.getProperty(\"passwordSource\"), env.getProperty(\"jdbcUrlSource\"), env.getProperty(\"jdbcDriverTarget\"),    env.getProperty(\"usernameTarget\"),     env.getProperty(\"passwordTarget\"),     env.getProperty(\"jdbcUrlTarget\"),     includeDbObjects == null ? Collections.<String>emptyList() : Arrays.asList(includeDbObjects.split(\",\")),excludeDbObjects == null ? Collections.<String>emptyList() : Arrays.asList(excludeDbObjects.split(\",\")),valuePatterns == null ? Collections.<String>emptyList() : Arrays.asList(valuePatterns.split(\",\")),valueReplacements == null ? Collections.<String>emptyList() : Arrays.asList(valueReplacements.split(\",\")),    System.out);} catch (Exception e) {new ServiceException(e).log();}}private static List<String> filterDbObjects(List<String> dbObjects,List<String> includeDbObjects,List<String> excludeDbObjects) throws ServiceException {List<String> filteredDbObjects = new ArrayList<String>();for(String dbObject: dbObjects) {if(dbObject != null) {dbObject = dbObject.trim();if(!dbObject.isEmpty()) {for(String includeDbObject: includeDbObjects) {if(dbObject.matches(includeDbObject)) {filteredDbObjects.add(dbObject);}}}}}for(String dbObject: dbObjects) {if(dbObject != null) {dbObject = dbObject.trim();for(String excludeDbObject: excludeDbObjects) {if(dbObject.matches(excludeDbObject)) {filteredDbObjects.remove(dbObject);}}}}return filteredDbObjects;}public static void copyDb(    String jdbcDriverSource,    String usernameSource,    String passwordSource,    String jdbcUrlSource,    String jdbcDriverTarget,    String usernameTarget,    String passwordTarget,    String jdbcUrlTarget,    List<String> includeDbObjects,    List<String> excludeDbObjects,    List<String> valuePatterns,    List<String> valueReplacements,    PrintStream out) throws ServiceException {{DBOBJECTS.clear();List<String> tableNames = new ArrayList<String>();try {tableNames = DbSchemaUtils.getTableNames();} catch (Exception e) {new ServiceException(e).log();}for(String tableName : tableNames) {if(tableName.indexOf(\"_\") > 0 &&tableName.indexOf(\"_TOBJ_\") < 0 &&tableName.indexOf(\"_JOIN_\") < 0 &&!tableName.endsWith(\"_\")) {DBOBJECTS.add(tableName);}}}try {Class.forName(jdbcDriverSource);Properties props = new Properties();props.put(\"user\", usernameSource);props.put(\"password\", passwordSource);Connection connSource = DriverManager.getConnection(jdbcUrlSource, props);connSource.setAutoCommit(false);Class.forName(jdbcDriverTarget);props = new Properties();props.put(\"user\", usernameTarget);props.put(\"password\", passwordTarget);Connection connTarget = DriverManager.getConnection(jdbcUrlTarget, props);connTarget.setAutoCommit(true);CopyDb.copyNamespace(connSource, connTarget,filterDbObjects(DBOBJECTS, includeDbObjects, excludeDbObjects),    valuePatterns,     valueReplacements,     out);} catch (Exception e) {throw new ServiceException(e);}out.println();out.println(\"!!! DONE !!!\");}static final List<String> DBOBJECTS = new ArrayList<String>();static final Set<String> BOOLEAN_COLUMNS = new HashSet<String>(Arrays.asList(    \"DISABLED\", \"USER_BOOLEAN0\", \"USER_BOOLEAN1\", \"USER_BOOLEAN2\", \"USER_BOOLEAN3\", \"USER_BOOLEAN4\", \"DO_NOT_BULK_POSTAL_MAIL\", \"DO_NOT_E_MAIL\", \"DO_NOT_FAX\", \"DO_NOT_PHONE\",    \"DO_NOT_POSTAL_MAIL\", \"EXT_BOOLEAN0\", \"EXT_BOOLEAN1\", \"EXT_BOOLEAN2\", \"EXT_BOOLEAN3\", \"EXT_BOOLEAN4\", \"EXT_BOOLEAN5\", \"EXT_BOOLEAN6\", \"EXT_BOOLEAN7\", \"EXT_BOOLEAN8\", \"EXT_BOOLEAN9\",    \"DISABLED\", \"DISCOUNT_IS_PERCENTAGE\", \"USER_BOOLEAN4\", \"IS_ALL_DAY_EVENT\", \"DELIVERY_RECEIPT_REQUESTED\", \"READ_RECEIPT_REQUESTED\", \"IS_MAIN\", \"RESET_TO_NULL\", \"IS_MAIN\", \"AUTOMATIC_PARSING\",    \"IS_CLOSED\", \"IS_FINAL\", \"CREDIT_FIRST\", \"IS_DEFAULT\", \"IS_WORKING_DAY\", \"IS_LOCKED\", \"IS_GIFT\", \"IS_TEMPLATE\", \"DISCOUNT_IS_PERCENTAGE\", \"IS_GIFT\", \"SALES_COMMISSION_IS_PERCENTAGE\",    \"IS_CREDIT_ON_HOLD\", \"ALLOW_POSITION_AUTO_CREATE\", \"IS_DEFAULT\", \"IS_LOCKED\", \"IS_TEMPLATE\", \"IS_LOCKED\", \"HOLDER_QUALIFIES_POSITION\", \"IS_DRAFT\", \"ALLOW_CREDIT_BOOKINGS\",    \"ALLOW_DEBIT_BOOKINGS\", \"IS_DEFAULT\", \"IS_ACTIVE\", \"BOOLEAN_PARAM\", \"IS_CHANGEABLE\", \"IS_QUERY\", \"IS_DERIVED\", \"IS_ABSTRACT\", \"IS_SINGLETON\", \"IS_CLUSTERED\", \"IS_NAVIGABLE\",    \"WEIGHT_IS_PERCENTAGE\", \"IS_FINAL\", \"DISCOUNT_IS_PERCENTAGE\", \"IS_DEFAULT\", \"ALLOW_MODIFICATION\", \"ALLOW_REMOVAL\", \"DISCOUNT_IS_PERCENTAGE\", \"OVERRIDE_PRICE\", \"IS_STOCK_ITEM\",    \"DISCOUNT_IS_PERCENTAGE\", \"IS_DEFAULT\", \"BOOLEAN_VALUE\", \"IS_ACTIVE\", \"NEW_BOOLEAN\", \"OLD_BOOLEAN\", \"SELECTOR\", \"IS_SCHEDULE_BASE_UOM\", \"STORE_SETTINGS_ON_LOGOFF\", \"IS_SYNCHRONOUS\", \"FAILED\",    \"IS_BILLABLE\", \"IS_REIMBURSABLE\", \"LOCKED\", \"ALLOW_ADD_DELETE\", \"ALLOW_CHANGE\"));}", "nl": "import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintStream;import java.io.Reader;import java.lang.reflect.Method;import java.math.BigDecimal;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.Properties;import java.util.Set;import org.opencrx.kernel.utils.DbSchemaUtils;import org.opencrx.kernel.utils.Utils;import org.openmdx.base.dataprovider.layer.persistence.jdbc.Database_2;import org.openmdx.base.exception.ServiceException;import org.openmdx.kernel.exception.BasicException;public class CopyDb {private static String getStringFromClob(java.sql.Clob clob) throws IOException, SQLException {Reader reader = clob.getCharacterStream();StringBuilder s = new StringBuilder();int c;while ((c = reader.read()) != -1) {s.append((char) c);}return s.toString();}private static byte[] getBytesFromBlob(java.sql.Blob blob) throws IOException, SQLException {InputStream is = blob.getBinaryStream();ByteArrayOutputStream os = new ByteArrayOutputStream();int b;while ((b = is.read()) != -1) {os.write(b);}os.close();return os.toByteArray();}private static String mapColumnName(Connection conn, String dbObject, String columnName) throws SQLException {String databaseProductName = conn.getMetaData().getDatabaseProductName();if(\"HSQL Database Engine\".equals(databaseProductName)) {String mappedColumnName = columnName.toUpperCase();if(\"POSITION\".equals(mappedColumnName) || mappedColumnName.indexOf(\"$\") > 0) {return \"\\\"\" + mappedColumnName + \"\\\"\";} else {return mappedColumnName;}} else if(\"PostgreSQL\".equals(databaseProductName)) {String mappedColumnName = columnName.toLowerCase();if(\"offset\".equals(mappedColumnName) || \"end\".equals(mappedColumnName) || mappedColumnName.indexOf(\"-\") > 0) {return \"\\\"\" + mappedColumnName + \"\\\"\";} else {return mappedColumnName;}} else {return columnName.toUpperCase();}}private static Object mapColumnValue(Connection conn, String dbObject, String columnName, Object columnValue, List<String> valuePatterns,List<String> valueReplacements) throws ServiceException, SQLException {String databaseProductName = conn.getMetaData().getDatabaseProductName();if(BOOLEAN_COLUMNS.contains(columnName.toUpperCase())) {if(\"PostgreSQL\".equals(databaseProductName)) {return columnValue;} else if(\"MySQL\".equals(databaseProductName)) {return columnValue;} else if(\"Microsoft SQL Server\".equals(databaseProductName)) {return columnValue;} else if(databaseProductName.startsWith(\"DB2/\")) {return Boolean.valueOf(\"Y\".equals(columnValue));} else if(\"HSQL Database Engine\".equals(databaseProductName)) {return columnValue;} else if(\"Oracle\".equals(databaseProductName)) {return Boolean.valueOf(((Number) columnValue).intValue() == 1);} else {throw new ServiceException(BasicException.Code.DEFAULT_DOMAIN, BasicException.Code.NOT_SUPPORTED, \"Database not supported\", new BasicException.Parameter(\"database product name\",    databaseProductName));}} else {if(columnValue instanceof String) {String targetValue = (String)columnValue;for(int i = 0; i < valuePatterns.size(); i++) {String valuePattern = valuePatterns.get(i);String valueReplacment = valueReplacements.get(i);if(valuePattern != null & valuePattern.length() > 0) {targetValue = targetValue.replaceAll(valuePattern, valueReplacment);}}return targetValue;} else {return columnValue;}}}public static void copyDbObject(String dbObject, boolean useSuffix, Connection connSource, Connection connTarget, List<String> valuePatterns,List<String> valueReplacements,PrintStream out) throws SQLException {String currentStatement = null;Database_2 db = new Database_2();try {Database_2[] plugins = Utils.getDatabasePlugIns();db = plugins[0];} catch (Exception e) {out.println(\"Can not activate database plugin: \" + e.getMessage());}try {PreparedStatement s = connTarget.prepareStatement(currentStatement = \"DELETE FROM \" + dbObject + (useSuffix ? \"_\" : \"\"));s.executeUpdate();s.close();s = connSource.prepareStatement(currentStatement = \"SELECT * FROM \" + dbObject + (useSuffix ? \"_\" : \"\"));ResultSet rs = s.executeQuery();if(rs != null) {ResultSetMetaData rsm = rs.getMetaData();FastResultSet frs = new FastResultSet(rs);int nRows = 0;while (frs.next()) {String statement = \"INSERT INTO \" + dbObject + (useSuffix ? \"_\" : \"\") + \" \";List<Object> statementParameters = new ArrayList<Object>();List<String> processTargetColumnNames = new ArrayList<String>();for (int j = 0; j < rsm.getColumnCount(); j++) {String columnName = rsm.getColumnName(j + 1);if(frs.getObject(columnName) != null) {String mappedColumnName = CopyDb.mapColumnName(connTarget, dbObject, columnName);if(mappedColumnName != null) {statement += (statementParameters.size() == 0 ? \" (\" : \", \") + mappedColumnName;processTargetColumnNames.add(mappedColumnName);if(frs.getObject(columnName) instanceof java.sql.Clob) {try {statementParameters.add(CopyDb.getStringFromClob((java.sql.Clob) frs.getObject(columnName)));} catch (Exception e) {out.println(\"Reading Clob failed. Reason: \" + e.getMessage());out.println(\"statement=\" + statement);out.println(\"parameters=\" + statementParameters);}} else if(frs.getObject(columnName) instanceof java.sql.Blob) {try {statementParameters.add(CopyDb.getBytesFromBlob((java.sql.Blob) frs.getObject(columnName)));} catch (Exception e) {out.println(\"Reading Blob failed. Reason: \" + e.getMessage());out.println(\"statement=\" + statement);out.println(\"parameters=\" + statementParameters);}} else {statementParameters.add(CopyDb.mapColumnValue(connSource,dbObject,columnName,frs.getObject(columnName),valuePatterns,valueReplacements));}}}}statement += \") VALUES (\";for (int j = 0; j < statementParameters.size(); j++) {statement += j == 0 ? \"?\" : \", ?\";}statement += \")\";try {PreparedStatement t = connTarget.prepareStatement(currentStatement = statement);for (int j = 0; j < statementParameters.size(); j++) {Object parameter = statementParameters.get(j);if(\"oracle.sql.TIMESTAMP\".equals(parameter.getClass().getName())) {Method timestampValueMethod = parameter.getClass().getMethod(\"timestampValue\", new Class[] {});parameter = timestampValueMethod.invoke(parameter, new Object[] {});} else if(\"microsoft.sql.DateTimeOffset\".equals(parameter.getClass().getName())) {Method timestampValueMethod = parameter.getClass().getMethod(\"getTimestamp\", new Class[] {});parameter = timestampValueMethod.invoke(parameter, new Object[] {});}if(parameter instanceof java.sql.Timestamp) {t.setTimestamp(j + 1, (java.sql.Timestamp) parameter);} else if(parameter instanceof java.sql.Date) {t.setDate(j + 1, (java.sql.Date) parameter);} else if(parameter instanceof Double) {t.setBigDecimal(j + 1, new BigDecimal((Double)parameter));} else if(parameter instanceof Float) {t.setBigDecimal(j + 1, new BigDecimal((Float)parameter));} else {db.setPreparedStatementValue(connTarget, t, j + 1, parameter);}}t.executeUpdate();t.close();} catch (Exception e) {new ServiceException(e).log();out.println(\"Insert failed. Reason: \" + e.getMessage());out.println(\"statement=\" + statement);out.println(\"parameters=\" + statementParameters);}nRows++;if(nRows % 1000 == 0) {out.println(nRows + \" rows copied\");}}rs.close();} else {out.println(\"Did not copy table (result set is null). Statement: \" + currentStatement);}s.close();} catch (Exception e) {new ServiceException(e).log();out.println(\"Can not copy table (see log for more info). Statement: \" + currentStatement);}}private static void copyNamespace(    Connection connSource,    Connection connTarget,    List<String> dbObjects,List<String> valuePatterns,List<String> valueReplacements,    PrintStream out) {String currentStatement = null;try {out.println(\"Processing tables:\");int ii = 0;for(String dbObject: dbObjects) {out.println(ii + \": \" + dbObject);ii++;}Set<String> processedDbObjects = new HashSet<String>();for (String dbObject: dbObjects) {if((dbObject != null) && !dbObject.isEmpty() && !processedDbObjects.contains(dbObject)) {out.println(\"Copying table: \" + dbObject);CopyDb.copyDbObject(dbObject, false, connSource, connTarget, valuePatterns, valueReplacements, out);out.println(\"Copying table: \" + dbObject + \"_\");CopyDb.copyDbObject(dbObject, true, connSource, connTarget, valuePatterns, valueReplacements, out);processedDbObjects.add(dbObject);}}} catch (SQLException e) {ServiceException e0 = new ServiceException(e);e0.log();out.println(\"statement: \" + currentStatement + \" (message=\" + e0.getMessage());}}public static void main(String[] args) {try {Properties env = System.getProperties();String includeDbObjects = env.getProperty(\"includeDbObjects\");String excludeDbObjects = env.getProperty(\"excludeDbObjects\");String valuePatterns = env.getProperty(\"valuePatterns\");String valueReplacements = env.getProperty(\"valueReplacements\");copyDb(env.getProperty(\"jdbcDriverSource\"), env.getProperty(\"usernameSource\"), env.getProperty(\"passwordSource\"), env.getProperty(\"jdbcUrlSource\"), env.getProperty(\"jdbcDriverTarget\"),    env.getProperty(\"usernameTarget\"),     env.getProperty(\"passwordTarget\"),     env.getProperty(\"jdbcUrlTarget\"),     includeDbObjects == null ? Collections.<String>emptyList() : Arrays.asList(includeDbObjects.split(\",\")),excludeDbObjects == null ? Collections.<String>emptyList() : Arrays.asList(excludeDbObjects.split(\",\")),valuePatterns == null ? Collections.<String>emptyList() : Arrays.asList(valuePatterns.split(\",\")),valueReplacements == null ? Collections.<String>emptyList() : Arrays.asList(valueReplacements.split(\",\")),    System.out);} catch (Exception e) {new ServiceException(e).log();}}private static List<String> filterDbObjects(List<String> dbObjects,List<String> includeDbObjects,List<String> excludeDbObjects) throws ServiceException {List<String> filteredDbObjects = new ArrayList<String>();for(String dbObject: dbObjects) {if(dbObject != null) {dbObject = dbObject.trim();if(!dbObject.isEmpty()) {for(String includeDbObject: includeDbObjects) {if(dbObject.matches(includeDbObject)) {filteredDbObjects.add(dbObject);}}}}}for(String dbObject: dbObjects) {if(dbObject != null) {dbObject = dbObject.trim();for(String excludeDbObject: excludeDbObjects) {if(dbObject.matches(excludeDbObject)) {filteredDbObjects.remove(dbObject);}}}}return filteredDbObjects;}public static void copyDb(    String jdbcDriverSource,    String usernameSource,    String passwordSource,    String jdbcUrlSource,    String jdbcDriverTarget,    String usernameTarget,    String passwordTarget,    String jdbcUrlTarget,    List<String> includeDbObjects,    List<String> excludeDbObjects,    List<String> valuePatterns,    List<String> valueReplacements,    PrintStream out) throws ServiceException {{DBOBJECTS.clear();List<String> tableNames = new ArrayList<String>();try {tableNames = DbSchemaUtils.getTableNames();} catch (Exception e) {new ServiceException(e).log();}for(String tableName : tableNames) {if(tableName.indexOf(\"_\") > 0 &&tableName.indexOf(\"_TOBJ_\") < 0 &&tableName.indexOf(\"_JOIN_\") < 0 &&!tableName.endsWith(\"_\")) {DBOBJECTS.add(tableName);}}}try {Class.forName(jdbcDriverSource);Properties props = new Properties();props.put(\"user\", usernameSource);props.put(\"password\", passwordSource);Connection connSource = DriverManager.getConnection(jdbcUrlSource, props);connSource.setAutoCommit(true);Class.forName(jdbcDriverTarget);props = new Properties();props.put(\"user\", usernameTarget);props.put(\"password\", passwordTarget);Connection connTarget = DriverManager.getConnection(jdbcUrlTarget, props);connTarget.setAutoCommit(true);CopyDb.copyNamespace(connSource, connTarget,filterDbObjects(DBOBJECTS, includeDbObjects, excludeDbObjects),    valuePatterns,     valueReplacements,     out);} catch (Exception e) {throw new ServiceException(e);}out.println();out.println(\"!!! DONE !!!\");}static final List<String> DBOBJECTS = new ArrayList<String>();static final Set<String> BOOLEAN_COLUMNS = new HashSet<String>(Arrays.asList(    \"DISABLED\", \"USER_BOOLEAN0\", \"USER_BOOLEAN1\", \"USER_BOOLEAN2\", \"USER_BOOLEAN3\", \"USER_BOOLEAN4\", \"DO_NOT_BULK_POSTAL_MAIL\", \"DO_NOT_E_MAIL\", \"DO_NOT_FAX\", \"DO_NOT_PHONE\",    \"DO_NOT_POSTAL_MAIL\", \"EXT_BOOLEAN0\", \"EXT_BOOLEAN1\", \"EXT_BOOLEAN2\", \"EXT_BOOLEAN3\", \"EXT_BOOLEAN4\", \"EXT_BOOLEAN5\", \"EXT_BOOLEAN6\", \"EXT_BOOLEAN7\", \"EXT_BOOLEAN8\", \"EXT_BOOLEAN9\",    \"DISABLED\", \"DISCOUNT_IS_PERCENTAGE\", \"USER_BOOLEAN4\", \"IS_ALL_DAY_EVENT\", \"DELIVERY_RECEIPT_REQUESTED\", \"READ_RECEIPT_REQUESTED\", \"IS_MAIN\", \"RESET_TO_NULL\", \"IS_MAIN\", \"AUTOMATIC_PARSING\",    \"IS_CLOSED\", \"IS_FINAL\", \"CREDIT_FIRST\", \"IS_DEFAULT\", \"IS_WORKING_DAY\", \"IS_LOCKED\", \"IS_GIFT\", \"IS_TEMPLATE\", \"DISCOUNT_IS_PERCENTAGE\", \"IS_GIFT\", \"SALES_COMMISSION_IS_PERCENTAGE\",    \"IS_CREDIT_ON_HOLD\", \"ALLOW_POSITION_AUTO_CREATE\", \"IS_DEFAULT\", \"IS_LOCKED\", \"IS_TEMPLATE\", \"IS_LOCKED\", \"HOLDER_QUALIFIES_POSITION\", \"IS_DRAFT\", \"ALLOW_CREDIT_BOOKINGS\",    \"ALLOW_DEBIT_BOOKINGS\", \"IS_DEFAULT\", \"IS_ACTIVE\", \"BOOLEAN_PARAM\", \"IS_CHANGEABLE\", \"IS_QUERY\", \"IS_DERIVED\", \"IS_ABSTRACT\", \"IS_SINGLETON\", \"IS_CLUSTERED\", \"IS_NAVIGABLE\",    \"WEIGHT_IS_PERCENTAGE\", \"IS_FINAL\", \"DISCOUNT_IS_PERCENTAGE\", \"IS_DEFAULT\", \"ALLOW_MODIFICATION\", \"ALLOW_REMOVAL\", \"DISCOUNT_IS_PERCENTAGE\", \"OVERRIDE_PRICE\", \"IS_STOCK_ITEM\",    \"DISCOUNT_IS_PERCENTAGE\", \"IS_DEFAULT\", \"BOOLEAN_VALUE\", \"IS_ACTIVE\", \"NEW_BOOLEAN\", \"OLD_BOOLEAN\", \"SELECTOR\", \"IS_SCHEDULE_BASE_UOM\", \"STORE_SETTINGS_ON_LOGOFF\", \"IS_SYNCHRONOUS\", \"FAILED\",    \"IS_BILLABLE\", \"IS_REIMBURSABLE\", \"LOCKED\", \"ALLOW_ADD_DELETE\", \"ALLOW_CHANGE\"));}"}
{"code": "import static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT;import static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT_SEPARATOR;import java.net.URISyntaxException;import java.security.Principal;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import org.apache.http.client.utils.URIBuilder;import org.mitre.oauth2.model.ClientDetailsEntity;import org.mitre.oauth2.model.SystemScope;import org.mitre.oauth2.service.ClientDetailsEntityService;import org.mitre.oauth2.service.SystemScopeService;import org.mitre.openid.connect.model.UserInfo;import org.mitre.openid.connect.service.ScopeClaimTranslationService;import org.mitre.openid.connect.service.StatsService;import org.mitre.openid.connect.service.UserInfoService;import org.mitre.openid.connect.view.HttpCodeView;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.security.oauth2.common.exceptions.OAuth2Exception;import org.springframework.security.oauth2.provider.AuthorizationRequest;import org.springframework.security.oauth2.provider.endpoint.RedirectResolver;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;import com.google.common.base.Joiner;import com.google.common.base.Splitter;import com.google.common.base.Strings;import com.google.common.collect.Sets;import com.google.gson.JsonObject;@Controller@SessionAttributes(\"authorizationRequest\")public class OAuthConfirmationController {@Autowiredprivate ClientDetailsEntityService clientService;@Autowiredprivate SystemScopeService scopeService;@Autowiredprivate ScopeClaimTranslationService scopeClaimTranslationService;@Autowiredprivate UserInfoService userInfoService;@Autowiredprivate StatsService statsService;@Autowiredprivate RedirectResolver redirectResolver;private static final Logger logger = LoggerFactory.getLogger(OAuthConfirmationController.class);public OAuthConfirmationController() {}public OAuthConfirmationController(ClientDetailsEntityService clientService) {this.clientService = clientService;}@PreAuthorize(\"hasRole('ROLE_USER')\")@RequestMapping(\"/oauth/confirm_access\")public String confirmAccess(Map<String, Object> model, Principal p) {AuthorizationRequest authRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");String prompt = (String)authRequest.getExtensions().get(PROMPT);List<String> prompts = Splitter.on(PROMPT_SEPARATOR).splitToList(Strings.nullToEmpty(prompt));ClientDetailsEntity client = null;try {client = clientService.loadClientByClientId(authRequest.getClientId());} catch (OAuth2Exception e) {logger.error(\"confirmAccess: OAuth2Exception was thrown when attempting to load client\", e);model.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);return HttpCodeView.VIEWNAME;} catch (IllegalArgumentException e) {logger.error(\"confirmAccess: IllegalArgumentException was thrown when attempting to load client\", e);model.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);return HttpCodeView.VIEWNAME;}if (client == null) {logger.error(\"confirmAccess: could not find client \" + authRequest.getClientId());model.put(HttpCodeView.CODE, HttpStatus.NOT_FOUND);return HttpCodeView.VIEWNAME;}if (prompts.contains(\"none\")) {String url = redirectResolver.resolveRedirect(authRequest.getRedirectUri(), client);try {URIBuilder uriBuilder = new URIBuilder(url);uriBuilder.addParameter(\"error\", \"interaction_required\");if (!Strings.isNullOrEmpty(authRequest.getState())) {uriBuilder.addParameter(\"state\", authRequest.getState()); }return \"redirect:\" + uriBuilder.toString();} catch (URISyntaxException e) {logger.error(\"Can't build redirect URI for prompt=none, sending error instead\", e);model.put(\"code\", HttpStatus.FORBIDDEN);return HttpCodeView.VIEWNAME;}}model.put(\"auth_request\", authRequest);model.put(\"client\", client);String redirect_uri = authRequest.getRedirectUri();model.put(\"redirect_uri\", redirect_uri);Set<SystemScope> scopes = scopeService.fromStrings(authRequest.getScope());Set<SystemScope> sortedScopes = new LinkedHashSet<>(scopes.size());Set<SystemScope> systemScopes = scopeService.getAll();for (SystemScope s : systemScopes) {if (scopes.contains(s)) {sortedScopes.add(s);}}sortedScopes.addAll(Sets.difference(scopes, systemScopes));model.put(\"scopes\", sortedScopes);UserInfo user = userInfoService.getByUsername(p.getName());Map<String, Map<String, String>> claimsForScopes = new HashMap<>();if (user != null) {JsonObject userJson = user.toJson();for (SystemScope systemScope : sortedScopes) {Map<String, String> claimValues = new HashMap<>();Set<String> claims = scopeClaimTranslationService.getClaimsForScope(systemScope.getValue());for (String claim : claims) {if (userJson.has(claim) && userJson.get(claim).isJsonPrimitive()) {claimValues.put(claim, userJson.get(claim).getAsString());}}claimsForScopes.put(systemScope.getValue(), claimValues);}}model.put(\"claims\", claimsForScopes);Integer count = statsService.getCountForClientId(client.getClientId()).getApprovedSiteCount();model.put(\"count\", count);if (client.getContacts() != null) {String contacts = Joiner.on(\", \").join(client.getContacts());model.put(\"contacts\", contacts);}Date lastWeek = new Date(System.currentTimeMillis() - (60 * 60 * 24 * 7 * 1000));if (count > 1 && client.getCreatedAt() != null && client.getCreatedAt().before(lastWeek)) {model.put(\"gras\", true);} else {model.put(\"gras\", false);}return \"approve\";}public ClientDetailsEntityService getClientService() {return clientService;}public void setClientService(ClientDetailsEntityService clientService) {this.clientService = clientService;}}", "nl": "import static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT;import static org.mitre.openid.connect.request.ConnectRequestParameters.PROMPT_SEPARATOR;import java.net.URISyntaxException;import java.security.Principal;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import org.apache.http.client.utils.URIBuilder;import org.mitre.oauth2.model.ClientDetailsEntity;import org.mitre.oauth2.model.SystemScope;import org.mitre.oauth2.service.ClientDetailsEntityService;import org.mitre.oauth2.service.SystemScopeService;import org.mitre.openid.connect.model.UserInfo;import org.mitre.openid.connect.service.ScopeClaimTranslationService;import org.mitre.openid.connect.service.StatsService;import org.mitre.openid.connect.service.UserInfoService;import org.mitre.openid.connect.view.HttpCodeView;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.security.oauth2.common.exceptions.OAuth2Exception;import org.springframework.security.oauth2.provider.AuthorizationRequest;import org.springframework.security.oauth2.provider.endpoint.RedirectResolver;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;import com.google.common.base.Joiner;import com.google.common.base.Splitter;import com.google.common.base.Strings;import com.google.common.collect.Sets;import com.google.gson.JsonObject;@Controller@SessionAttributes(\"authorizationRequest\")public class OAuthConfirmationController {@Autowiredprivate ClientDetailsEntityService clientService;@Autowiredprivate SystemScopeService scopeService;@Autowiredprivate ScopeClaimTranslationService scopeClaimTranslationService;@Autowiredprivate UserInfoService userInfoService;@Autowiredprivate StatsService statsService;@Autowiredprivate RedirectResolver redirectResolver;private static final Logger logger = LoggerFactory.getLogger(OAuthConfirmationController.class);public OAuthConfirmationController() {}public OAuthConfirmationController(ClientDetailsEntityService clientService) {this.clientService = clientService;}@PreAuthorize(\"hasRole('ROLE_USER')\")@RequestMapping(\"/oauth/confirm_access\")public String confimAccess(Map<String, Object> model, @ModelAttribute(\"authorizationRequest\") AuthorizationRequest authRequest,Principal p) {String prompt = (String)authRequest.getExtensions().get(PROMPT);List<String> prompts = Splitter.on(PROMPT_SEPARATOR).splitToList(Strings.nullToEmpty(prompt));ClientDetailsEntity client = null;try {client = clientService.loadClientByClientId(authRequest.getClientId());} catch (OAuth2Exception e) {logger.error(\"confirmAccess: OAuth2Exception was thrown when attempting to load client\", e);model.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);return HttpCodeView.VIEWNAME;} catch (IllegalArgumentException e) {logger.error(\"confirmAccess: IllegalArgumentException was thrown when attempting to load client\", e);model.put(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);return HttpCodeView.VIEWNAME;}if (client == null) {logger.error(\"confirmAccess: could not find client \" + authRequest.getClientId());model.put(HttpCodeView.CODE, HttpStatus.NOT_FOUND);return HttpCodeView.VIEWNAME;}if (prompts.contains(\"none\")) {String url = redirectResolver.resolveRedirect(authRequest.getRedirectUri(), client);try {URIBuilder uriBuilder = new URIBuilder(url);uriBuilder.addParameter(\"error\", \"interaction_required\");if (!Strings.isNullOrEmpty(authRequest.getState())) {uriBuilder.addParameter(\"state\", authRequest.getState()); }return \"redirect:\" + uriBuilder.toString();} catch (URISyntaxException e) {logger.error(\"Can't build redirect URI for prompt=none, sending error instead\", e);model.put(\"code\", HttpStatus.FORBIDDEN);return HttpCodeView.VIEWNAME;}}model.put(\"auth_request\", authRequest);model.put(\"client\", client);String redirect_uri = authRequest.getRedirectUri();model.put(\"redirect_uri\", redirect_uri);Set<SystemScope> scopes = scopeService.fromStrings(authRequest.getScope());Set<SystemScope> sortedScopes = new LinkedHashSet<>(scopes.size());Set<SystemScope> systemScopes = scopeService.getAll();for (SystemScope s : systemScopes) {if (scopes.contains(s)) {sortedScopes.add(s);}}sortedScopes.addAll(Sets.difference(scopes, systemScopes));model.put(\"scopes\", sortedScopes);UserInfo user = userInfoService.getByUsername(p.getName());Map<String, Map<String, String>> claimsForScopes = new HashMap<>();if (user != null) {JsonObject userJson = user.toJson();for (SystemScope systemScope : sortedScopes) {Map<String, String> claimValues = new HashMap<>();Set<String> claims = scopeClaimTranslationService.getClaimsForScope(systemScope.getValue());for (String claim : claims) {if (userJson.has(claim) && userJson.get(claim).isJsonPrimitive()) {claimValues.put(claim, userJson.get(claim).getAsString());}}claimsForScopes.put(systemScope.getValue(), claimValues);}}model.put(\"claims\", claimsForScopes);Integer count = statsService.getCountForClientId(client.getClientId()).getApprovedSiteCount();model.put(\"count\", count);if (client.getContacts() != null) {String contacts = Joiner.on(\", \").join(client.getContacts());model.put(\"contacts\", contacts);}Date lastWeek = new Date(System.currentTimeMillis() - (60 * 60 * 24 * 7 * 1000));if (count > 1 && client.getCreatedAt() != null && client.getCreatedAt().before(lastWeek)) {model.put(\"gras\", true);} else {model.put(\"gras\", false);}return \"approve\";}public ClientDetailsEntityService getClientService() {return clientService;}public void setClientService(ClientDetailsEntityService clientService) {this.clientService = clientService;}}"}
{"code": "import javax.xml.bind.JAXBElement;import javax.xml.crypto.KeySelector;import javax.xml.crypto.MarshalException;import javax.xml.crypto.dsig.CanonicalizationMethod;import javax.xml.crypto.dsig.DigestMethod;import javax.xml.crypto.dsig.Reference;import javax.xml.crypto.dsig.SignedInfo;import javax.xml.crypto.dsig.Transform;import javax.xml.crypto.dsig.XMLSignature;import javax.xml.crypto.dsig.XMLSignatureException;import javax.xml.crypto.dsig.XMLSignatureFactory;import javax.xml.crypto.dsig.dom.DOMSignContext;import javax.xml.crypto.dsig.dom.DOMValidateContext;import javax.xml.crypto.dsig.keyinfo.KeyInfo;import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;import javax.xml.crypto.dsig.keyinfo.X509Data;import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;import javax.xml.crypto.dsig.spec.TransformParameterSpec;import javax.xml.transform.TransformerException;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.InvalidAlgorithmParameterException;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.Signature;import java.security.cert.Certificate;import java.security.cert.X509Certificate;import java.time.ZoneOffset;import java.time.ZonedDateTime;import java.util.ArrayList;import java.util.Arrays;import java.util.Base64;import java.util.Collections;import java.util.GregorianCalendar;import java.util.List;import java.util.Objects;import java.util.Optional;import java.util.UUID;import java.util.function.Function;import java.util.stream.Collectors;import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;import io.fusionauth.samlv2.domain.Algorithm;import io.fusionauth.samlv2.domain.AuthenticationRequest;import io.fusionauth.samlv2.domain.AuthenticationResponse;import io.fusionauth.samlv2.domain.Binding;import io.fusionauth.samlv2.domain.Conditions;import io.fusionauth.samlv2.domain.ConfirmationMethod;import io.fusionauth.samlv2.domain.MetaData;import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;import io.fusionauth.samlv2.domain.MetaData.SPMetaData;import io.fusionauth.samlv2.domain.NameIDFormat;import io.fusionauth.samlv2.domain.ResponseStatus;import io.fusionauth.samlv2.domain.SAMLException;import io.fusionauth.samlv2.domain.SignatureLocation;import io.fusionauth.samlv2.domain.SignatureNotFoundException;import io.fusionauth.samlv2.domain.Subject;import io.fusionauth.samlv2.domain.SubjectConfirmation;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AssertionType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AttributeStatementType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AttributeType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AudienceRestrictionType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AuthnContextType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AuthnStatementType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ConditionAbstractType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ConditionsType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.EncryptedElementType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.NameIDType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.StatementAbstractType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.SubjectConfirmationDataType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.SubjectConfirmationType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.SubjectType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.EndpointType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.EntityDescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.IDPSSODescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.IndexedEndpointType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.KeyDescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.KeyTypes;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.RoleDescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.SPSSODescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.SSODescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.AuthnRequestType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.NameIDPolicyType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.ObjectFactory;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.ResponseType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusCodeType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusType;import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.KeyInfoType;import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;import io.fusionauth.samlv2.util.SAMLTools;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import static io.fusionauth.samlv2.util.SAMLTools.convertToZonedDateTime;import static io.fusionauth.samlv2.util.SAMLTools.decodeAndInflate;import static io.fusionauth.samlv2.util.SAMLTools.marshallToBytes;import static io.fusionauth.samlv2.util.SAMLTools.marshallToDocument;import static io.fusionauth.samlv2.util.SAMLTools.marshallToString;import static io.fusionauth.samlv2.util.SAMLTools.newDocumentFromBytes;import static io.fusionauth.samlv2.util.SAMLTools.parseNameId;import static io.fusionauth.samlv2.util.SAMLTools.toXMLGregorianCalendar;import static io.fusionauth.samlv2.util.SAMLTools.toZonedDateTime;import static io.fusionauth.samlv2.util.SAMLTools.unmarshallFromDocument;public class DefaultSAMLv2Service implements SAMLv2Service {  private static final io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ObjectFactory ASSERTION_OBJECT_FACTORY = new io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ObjectFactory();  private static final io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.ObjectFactory DSIG_OBJECT_FACTORY = new io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.ObjectFactory();  private static final io.fusionauth.samlv2.domain.jaxb.oasis.metadata.ObjectFactory METADATA_OBJECT_FACTORY = new io.fusionauth.samlv2.domain.jaxb.oasis.metadata.ObjectFactory();  private static final ObjectFactory PROTOCOL_OBJECT_FACTORY = new ObjectFactory();  private static final Logger logger = LoggerFactory.getLogger(DefaultSAMLv2Service.class);  static {    String ignoreLineBreaks = System.getProperty(\"com.sun.org.apache.xml.internal.security.ignoreLineBreaks\");    if (!Boolean.parseBoolean(ignoreLineBreaks)) {      throw new IllegalStateException(\"When the fusionauth-samlv2 jar is included in the classpath, you must set the following system property:\\n\" +          \"-Dcom.sun.org.apache.xml.internal.security.ignoreLineBreaks=true\");    }  }  @Override  public String buildAuthnResponse(AuthenticationResponse response, boolean sign, PrivateKey privateKey,                                   X509Certificate certificate, Algorithm algorithm, String xmlSignatureC14nMethod,                                   SignatureLocation signatureOption) throws SAMLException {    ResponseType jaxbResponse = new ResponseType();    StatusType status = new StatusType();    status.setStatusCode(new StatusCodeType());    status.getStatusCode().setValue(response.status.code.toSAMLFormat());    status.setStatusMessage(response.status.message);    jaxbResponse.setStatus(status);    jaxbResponse.setID(response.id);    jaxbResponse.setIssuer(new NameIDType());    jaxbResponse.getIssuer().setValue(response.issuer);    jaxbResponse.setVersion(response.version);    jaxbResponse.setInResponseTo(response.inResponseTo);    jaxbResponse.setIssueInstant(toXMLGregorianCalendar(response.issueInstant));    jaxbResponse.setDestination(response.destination);    AssertionType assertionType = new AssertionType();    if (response.assertion != null && response.status.code == ResponseStatus.Success) {      ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);      String id = \"_\" + UUID.randomUUID().toString();      assertionType.setID(id);      assertionType.setIssuer(jaxbResponse.getIssuer());      assertionType.setIssueInstant(toXMLGregorianCalendar(now));      assertionType.setVersion(response.version);      if (response.assertion.subject != null) {        SubjectType subjectType = new SubjectType();        if (response.assertion.subject.nameID != null) {          NameIDType nameIdType = new NameIDType();          nameIdType.setValue(response.assertion.subject.nameID.id);          nameIdType.setFormat(response.assertion.subject.nameID.format.toSAMLFormat());          subjectType.getContent().add(ASSERTION_OBJECT_FACTORY.createNameID(nameIdType));        }        if (response.assertion.subject.subjectConfirmation != null) {          SubjectConfirmationDataType dataType = new SubjectConfirmationDataType();          dataType.setInResponseTo(response.assertion.subject.subjectConfirmation.inResponseTo);          dataType.setNotBefore(toXMLGregorianCalendar(response.assertion.subject.subjectConfirmation.notBefore));          dataType.setNotOnOrAfter(toXMLGregorianCalendar(response.assertion.subject.subjectConfirmation.notOnOrAfter));          dataType.setRecipient(response.assertion.subject.subjectConfirmation.recipient);          SubjectConfirmationType subjectConfirmationType = new SubjectConfirmationType();          subjectConfirmationType.setSubjectConfirmationData(dataType);          if (response.assertion.subject.subjectConfirmation.method != null) {            subjectConfirmationType.setMethod(response.assertion.subject.subjectConfirmation.method.toSAMLFormat());          }          subjectType.getContent().add(ASSERTION_OBJECT_FACTORY.createSubjectConfirmation(subjectConfirmationType));        }        assertionType.setSubject(subjectType);      }      if (response.assertion.conditions != null) {        ConditionsType conditionsType = new ConditionsType();        conditionsType.setNotBefore(toXMLGregorianCalendar(response.assertion.conditions.notBefore));        conditionsType.setNotOnOrAfter(toXMLGregorianCalendar(response.assertion.conditions.notOnOrAfter));        assertionType.setConditions(conditionsType);        if (response.assertion.conditions.audiences.size() > 0) {          AudienceRestrictionType audienceRestrictionType = new AudienceRestrictionType();          audienceRestrictionType.getAudience().addAll(response.assertion.conditions.audiences);          conditionsType.getConditionOrAudienceRestrictionOrOneTimeUse().add(audienceRestrictionType);        }      }      AttributeStatementType attributeStatementType = new AttributeStatementType();      response.assertion.attributes.forEach((k, v) -> {        AttributeType attributeType = new AttributeType();        attributeType.setName(k);        attributeType.getAttributeValue().addAll(v);        attributeStatementType.getAttributeOrEncryptedAttribute().add(attributeType);      });      assertionType.getStatementOrAuthnStatementOrAuthzDecisionStatement().add(attributeStatementType);      AuthnStatementType authnStatement = new AuthnStatementType();      authnStatement.setAuthnInstant(toXMLGregorianCalendar(now));      authnStatement.setAuthnContext(new AuthnContextType());      authnStatement.getAuthnContext().getContent().add(ASSERTION_OBJECT_FACTORY.createAuthnContextClassRef(\"urn:oasis:names:tc:SAML:2.0:ac:classes:Password\"));      authnStatement.setSessionIndex(response.sessionIndex);      authnStatement.setSessionNotOnOrAfter(toXMLGregorianCalendar(response.sessionExpiry));      assertionType.getStatementOrAuthnStatementOrAuthzDecisionStatement().add(authnStatement);      jaxbResponse.getAssertionOrEncryptedAssertion().add(assertionType);    }    Document document = marshallToDocument(PROTOCOL_OBJECT_FACTORY.createResponse(jaxbResponse), ResponseType.class);    try {      Element toSign;      Node insertBefore = null;      if (response.status.code == ResponseStatus.Success && signatureOption == SignatureLocation.Assertion) {        toSign = (Element) document.getElementsByTagName(\"Assertion\").item(0);        Node issuer = toSign.getElementsByTagName(\"Issuer\").item(0);        insertBefore = issuer.getNextSibling();      } else {        toSign = document.getDocumentElement();        NodeList children = toSign.getChildNodes();        for (int i = 0; i < children.getLength(); i++) {          Node n = children.item(i);          if (n instanceof Element) {            insertBefore = n.getLocalName().equals(\"Issuer\") ? n.getNextSibling() : n;            break;          }        }      }      String xml = signXML(privateKey, certificate, algorithm, xmlSignatureC14nMethod, document, toSign, insertBefore);      return Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8));    } catch (Exception e) {      throw new SAMLException(\"Unable to sign XML SAML response\", e);    }  }  @Override  public String buildInvalidTestingPostAuthnRequest(AuthenticationRequest request, boolean sign, PrivateKey privateKey,                                                    X509Certificate certificate, Algorithm algorithm,                                                    String xmlSignatureC14nMethod) throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"bad\");    return buildPostAuthnRequest(authnRequest, sign, privateKey, certificate, algorithm, xmlSignatureC14nMethod);  }  @Override  public String buildInvalidTestingRedirectAuthnRequest(AuthenticationRequest request, String relayState, boolean sign,                                                        PrivateKey key, Algorithm algorithm) throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"bad\");    return buildRedirectAuthnRequest(authnRequest, relayState, sign, key, algorithm);  }  @Override  public String buildMetadataResponse(MetaData metaData) throws SAMLException {    EntityDescriptorType root = new EntityDescriptorType();    root.setID(\"_\" + metaData.id);    root.setEntityID(metaData.entityId);    if (metaData.idp != null) {      IDPSSODescriptorType idp = new IDPSSODescriptorType();      idp.getProtocolSupportEnumeration().add(\"urn:oasis:names:tc:SAML:2.0:protocol\");      metaData.idp.redirectBindingSignInEndpoints.forEach(endpoint -> {        EndpointType signIn = new EndpointType();        signIn.setBinding(Binding.HTTP_Redirect.toSAMLFormat());        signIn.setLocation(endpoint);        idp.getSingleSignOnService().add(signIn);      });      metaData.idp.postBindingSignInEndpoints.forEach(endpoint -> {        EndpointType signIn = new EndpointType();        signIn.setBinding(Binding.HTTP_POST.toSAMLFormat());        signIn.setLocation(endpoint);        idp.getSingleSignOnService().add(signIn);      });      metaData.idp.redirectBindingLogoutEndpoints.forEach(endpoint -> {        EndpointType logOut = new EndpointType();        logOut.setBinding(Binding.HTTP_Redirect.toSAMLFormat());        logOut.setLocation(endpoint);        idp.getSingleLogoutService().add(logOut);      });      metaData.idp.postBindingLogoutEndpoints.forEach(endpoint -> {        EndpointType logOut = new EndpointType();        logOut.setBinding(Binding.HTTP_POST.toSAMLFormat());        logOut.setLocation(endpoint);        idp.getSingleLogoutService().add(logOut);      });      addKeyDescriptors(idp, metaData.idp.certificates);      root.getRoleDescriptorOrIDPSSODescriptorOrSPSSODescriptor().add(idp);    }    if (metaData.sp != null) {      SPSSODescriptorType sp = new SPSSODescriptorType();      sp.getProtocolSupportEnumeration().add(\"urn:oasis:names:tc:SAML:2.0:protocol\");      sp.setAuthnRequestsSigned(metaData.sp.authnRequestsSigned);      sp.setWantAssertionsSigned(metaData.sp.wantAssertionsSigned);      if (metaData.sp.acsEndpoint != null) {        IndexedEndpointType acs = new IndexedEndpointType();        acs.setBinding(Binding.HTTP_POST.toSAMLFormat());        acs.setLocation(metaData.sp.acsEndpoint);        sp.getAssertionConsumerService().add(acs);      }      if (metaData.sp.nameIDFormat != null) {        sp.getNameIDFormat().add(metaData.sp.nameIDFormat.toSAMLFormat());      }      addKeyDescriptors(sp, metaData.sp.certificates);      root.getRoleDescriptorOrIDPSSODescriptorOrSPSSODescriptor().add(sp);    }    byte[] bytes = marshallToBytes(METADATA_OBJECT_FACTORY.createEntityDescriptor(root), EntityDescriptorType.class);    return new String(bytes, StandardCharsets.UTF_8);  }  @Override  public String buildPostAuthnRequest(AuthenticationRequest request, boolean sign, PrivateKey privateKey,                                      X509Certificate certificate, Algorithm algorithm, String xmlSignatureC14nMethod)      throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"2.0\");    return buildPostAuthnRequest(authnRequest, sign, privateKey, certificate, algorithm, xmlSignatureC14nMethod);  }  @Override  public String buildRedirectAuthnRequest(AuthenticationRequest request, String relayState, boolean sign,                                          PrivateKey key,                                          Algorithm algorithm)      throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"2.0\");    return buildRedirectAuthnRequest(authnRequest, relayState, sign, key, algorithm);  }  @Override  public MetaData parseMetaData(String metaDataXML) throws SAMLException {    Document document = newDocumentFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));    EntityDescriptorType root = unmarshallFromDocument(document, EntityDescriptorType.class);    MetaData metaData = new MetaData();    metaData.id = root.getID();    metaData.entityId = root.getEntityID();    List<RoleDescriptorType> roles = root.getRoleDescriptorOrIDPSSODescriptorOrSPSSODescriptor();    Optional<RoleDescriptorType> idpDescriptor = roles.stream()                                                      .filter(r -> r instanceof IDPSSODescriptorType)                                                      .findFirst();    if (idpDescriptor.isPresent()) {      IDPSSODescriptorType idp = (IDPSSODescriptorType) idpDescriptor.get();      metaData.idp = new IDPMetaData();      for (EndpointType endpoint : idp.getSingleSignOnService()) {        if (Binding.HTTP_Redirect.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.redirectBindingSignInEndpoints.add(endpoint.getLocation());        } else if (Binding.HTTP_POST.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.postBindingSignInEndpoints.add(endpoint.getLocation());        }      }      for (EndpointType endpoint : idp.getSingleLogoutService()) {        if (Binding.HTTP_Redirect.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.redirectBindingLogoutEndpoints.add(endpoint.getLocation());        } else if (Binding.HTTP_POST.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.postBindingLogoutEndpoints.add(endpoint.getLocation());        }      }      try {        metaData.idp.certificates = idp.getKeyDescriptor()                                       .stream()                                       .filter(kd -> kd.getUse() == KeyTypes.SIGNING)                                       .map(SAMLTools::toCertificate)                                       .filter(Objects::nonNull)                                       .collect(Collectors.toList());      } catch (IllegalArgumentException e) {        throw new SAMLException(e.getCause());      }    }    Optional<RoleDescriptorType> spDescriptor = roles.stream()                                                     .filter(r -> r instanceof SPSSODescriptorType)                                                     .findFirst();    if (spDescriptor.isPresent()) {      SPSSODescriptorType sp = (SPSSODescriptorType) spDescriptor.get();      metaData.sp = new SPMetaData();      metaData.sp.acsEndpoint = sp.getAssertionConsumerService().size() > 0 ? sp.getAssertionConsumerService().get(0).getLocation() : null;      try {        metaData.sp.nameIDFormat = sp.getNameIDFormat().size() > 0 ? NameIDFormat.fromSAMLFormat(sp.getNameIDFormat().get(0)) : null;      } catch (Exception e) {        throw new SAMLException(e.getCause());      }    }    return metaData;  }  @Override  public AuthenticationRequest parseRequestPostBinding(String encodedRequest,                                                       Function<AuthenticationRequest, PostBindingSignatureHelper> signatureHelperFunction)      throws SAMLException {    byte[] xml = Base64.getMimeDecoder().decode(encodedRequest);    AuthnRequestParseResult result = parseRequest(xml);    PostBindingSignatureHelper signatureHelper = signatureHelperFunction.apply(result.request);    if (signatureHelper.verifySignature()) {      verifySignature(result.document, signatureHelper.keySelector());    }    return result.request;  }  @Override  public AuthenticationRequest parseRequestRedirectBinding(String encodedRequest, String relayState,                                                           Function<AuthenticationRequest, RedirectBindingSignatureHelper> signatureHelperFunction)      throws SAMLException {    AuthnRequestParseResult result = parseRequest(decodeAndInflate(encodedRequest));    RedirectBindingSignatureHelper signatureHelper = signatureHelperFunction.apply(result.request);    if (signatureHelper.verifySignature()) {      if (signatureHelper.signature() == null || signatureHelper.publicKey() == null || signatureHelper.algorithm() == null) {        throw new SignatureNotFoundException(\"You must specify a signature, key and algorithm if you want to verify the SAML request signature\");      }      try {        String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedRequest, \"UTF-8\");        if (relayState != null) {          parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");        }        parameters += \"&SigAlg=\" + URLEncoder.encode(signatureHelper.algorithm().uri, \"UTF-8\");        Signature sig = Signature.getInstance(signatureHelper.algorithm().name);        sig.initVerify(signatureHelper.publicKey());        sig.update(parameters.getBytes(StandardCharsets.UTF_8));        if (!sig.verify(Base64.getMimeDecoder().decode(signatureHelper.signature()))) {          throw new SAMLException(\"Invalid SAML v2.0 operation. The signature is invalid.\");        }      } catch (GeneralSecurityException | UnsupportedEncodingException e) {        throw new SAMLException(\"Unable to verify signature\", e);      }    }    return result.request;  }  @Override  public AuthenticationResponse parseResponse(String encodedResponse, boolean verifySignature, KeySelector keySelector)      throws SAMLException {    AuthenticationResponse response = new AuthenticationResponse();    byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);    response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);    Document document = newDocumentFromBytes(decodedResponse);    if (verifySignature) {      verifySignature(document, keySelector);    }    ResponseType jaxbResponse = unmarshallFromDocument(document, ResponseType.class);    response.status.code = ResponseStatus.fromSAMLFormat(jaxbResponse.getStatus().getStatusCode().getValue());    response.id = jaxbResponse.getID();    response.inResponseTo = jaxbResponse.getInResponseTo();    response.issuer = jaxbResponse.getIssuer() != null ? jaxbResponse.getIssuer().getValue() : null;    response.issueInstant = toZonedDateTime(jaxbResponse.getIssueInstant());    response.destination = jaxbResponse.getDestination();    response.version = jaxbResponse.getVersion();    List<Object> assertions = jaxbResponse.getAssertionOrEncryptedAssertion();    for (Object assertion : assertions) {      if (assertion instanceof EncryptedElementType) {        logger.warn(\"SAML response contained encrypted attribute. It was ignored.\");        continue;      }      AssertionType assertionType = (AssertionType) assertion;      SubjectType subject = assertionType.getSubject();      if (subject != null) {        response.assertion.subject = new Subject();        List<JAXBElement<?>> elements = subject.getContent();        for (JAXBElement<?> element : elements) {          Class<?> type = element.getDeclaredType();          if (type == NameIDType.class) {            if (response.assertion.subject.nameID != null) {              logger.warn(\"SAML response contained multiple NameID elements. Only the first one was used.\");              continue;            }            response.assertion.subject.nameID = parseNameId((NameIDType) element.getValue());          } else if (type == SubjectConfirmationType.class) {            response.assertion.subject.subjectConfirmation = parseConfirmation((SubjectConfirmationType) element.getValue());          } else if (type == EncryptedElementType.class) {            throw new SAMLException(\"This library currently doesn't handle encrypted assertions\");          }        }      }      ConditionsType conditionsType = assertionType.getConditions();      if (conditionsType != null) {        response.assertion.conditions = new Conditions();        response.assertion.conditions.notBefore = convertToZonedDateTime(conditionsType.getNotBefore());        response.assertion.conditions.notOnOrAfter = convertToZonedDateTime(conditionsType.getNotOnOrAfter());        List<ConditionAbstractType> conditionAbstractTypes = conditionsType.getConditionOrAudienceRestrictionOrOneTimeUse();        for (ConditionAbstractType conditionAbstractType : conditionAbstractTypes) {          if (conditionAbstractType instanceof AudienceRestrictionType) {            AudienceRestrictionType restrictionType = (AudienceRestrictionType) conditionAbstractType;            response.assertion.conditions.audiences.addAll(restrictionType.getAudience());          }        }      }      List<StatementAbstractType> statements = assertionType.getStatementOrAuthnStatementOrAuthzDecisionStatement();      for (StatementAbstractType statement : statements) {        if (statement instanceof AttributeStatementType) {          AttributeStatementType attributeStatementType = (AttributeStatementType) statement;          List<Object> attributeObjects = attributeStatementType.getAttributeOrEncryptedAttribute();          for (Object attributeObject : attributeObjects) {            if (attributeObject instanceof AttributeType) {              AttributeType attributeType = (AttributeType) attributeObject;              String name = attributeType.getName();              List<Object> attributeValues = attributeType.getAttributeValue();              List<String> values = attributeValues.stream().map(SAMLTools::attributeToString).collect(Collectors.toList());              response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);            } else {              throw new SAMLException(\"This library currently doesn't support encrypted attributes\");            }          }        }      }    }    return response;  }  private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> certificates) {    certificates.forEach(cert -> {      KeyDescriptorType key = new KeyDescriptorType();      key.setUse(KeyTypes.SIGNING);      KeyInfoType info = new KeyInfoType();      key.setKeyInfo(info);      X509DataType data = new X509DataType();      info.getContent().add(DSIG_OBJECT_FACTORY.createX509Data(data));      try {        JAXBElement<byte[]> certElement = DSIG_OBJECT_FACTORY.createX509DataTypeX509Certificate(cert.getEncoded());        data.getX509IssuerSerialOrX509SKIOrX509SubjectName().add(certElement);        descriptor.getKeyDescriptor().add(key);      } catch (Exception e) {        throw new IllegalArgumentException(e);      }    });  }  private String buildPostAuthnRequest(AuthnRequestType authnRequest, boolean sign, PrivateKey privateKey,                                       X509Certificate certificate,                                       Algorithm algorithm, String xmlSignatureC14nMethod) throws SAMLException {    Document document = marshallToDocument(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest), AuthnRequestType.class);    try {      Element toSign = document.getDocumentElement();      String xml;      if (sign) {        xml = signXML(privateKey, certificate, algorithm, xmlSignatureC14nMethod, document, toSign, null);      } else {        xml = marshallToString(document);      }      return Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8));    } catch (Exception e) {      throw new SAMLException(\"Unable to sign XML SAML response\", e);    }  }  private String buildRedirectAuthnRequest(AuthnRequestType authnRequest, String relayState, boolean sign,                                           PrivateKey key, Algorithm", "nl": "import javax.xml.bind.JAXBContext;import javax.xml.bind.JAXBElement;import javax.xml.bind.JAXBException;import javax.xml.bind.Marshaller;import javax.xml.bind.Unmarshaller;import javax.xml.crypto.KeySelector;import javax.xml.crypto.MarshalException;import javax.xml.crypto.dsig.CanonicalizationMethod;import javax.xml.crypto.dsig.DigestMethod;import javax.xml.crypto.dsig.Reference;import javax.xml.crypto.dsig.SignedInfo;import javax.xml.crypto.dsig.Transform;import javax.xml.crypto.dsig.XMLSignature;import javax.xml.crypto.dsig.XMLSignatureException;import javax.xml.crypto.dsig.XMLSignatureFactory;import javax.xml.crypto.dsig.dom.DOMSignContext;import javax.xml.crypto.dsig.dom.DOMValidateContext;import javax.xml.crypto.dsig.keyinfo.KeyInfo;import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;import javax.xml.crypto.dsig.keyinfo.X509Data;import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;import javax.xml.crypto.dsig.spec.TransformParameterSpec;import javax.xml.datatype.XMLGregorianCalendar;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.StringWriter;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.InvalidAlgorithmParameterException;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.Signature;import java.security.cert.Certificate;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate;import java.time.ZoneOffset;import java.time.ZonedDateTime;import java.util.ArrayList;import java.util.Arrays;import java.util.Base64;import java.util.Collections;import java.util.GregorianCalendar;import java.util.List;import java.util.Objects;import java.util.Optional;import java.util.UUID;import java.util.function.Function;import java.util.stream.Collectors;import java.util.zip.DataFormatException;import java.util.zip.Deflater;import java.util.zip.Inflater;import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;import io.fusionauth.samlv2.domain.Algorithm;import io.fusionauth.samlv2.domain.AuthenticationRequest;import io.fusionauth.samlv2.domain.AuthenticationResponse;import io.fusionauth.samlv2.domain.Binding;import io.fusionauth.samlv2.domain.Conditions;import io.fusionauth.samlv2.domain.ConfirmationMethod;import io.fusionauth.samlv2.domain.MetaData;import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;import io.fusionauth.samlv2.domain.MetaData.SPMetaData;import io.fusionauth.samlv2.domain.NameID;import io.fusionauth.samlv2.domain.NameIDFormat;import io.fusionauth.samlv2.domain.ResponseStatus;import io.fusionauth.samlv2.domain.SAMLException;import io.fusionauth.samlv2.domain.SignatureLocation;import io.fusionauth.samlv2.domain.SignatureNotFoundException;import io.fusionauth.samlv2.domain.Subject;import io.fusionauth.samlv2.domain.SubjectConfirmation;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AssertionType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AttributeStatementType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AttributeType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AudienceRestrictionType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AuthnContextType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.AuthnStatementType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ConditionAbstractType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ConditionsType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.EncryptedElementType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.NameIDType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.StatementAbstractType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.SubjectConfirmationDataType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.SubjectConfirmationType;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.SubjectType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.EndpointType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.EntityDescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.IDPSSODescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.IndexedEndpointType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.KeyDescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.KeyTypes;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.RoleDescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.SPSSODescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.SSODescriptorType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.AuthnRequestType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.NameIDPolicyType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.ObjectFactory;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.ResponseType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusCodeType;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.StatusType;import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.KeyInfoType;import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;public class DefaultSAMLv2Service implements SAMLv2Service {  private static final io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ObjectFactory ASSERTION_OBJECT_FACTORY = new io.fusionauth.samlv2.domain.jaxb.oasis.assertion.ObjectFactory();  private static final io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.ObjectFactory DSIG_OBJECT_FACTORY = new io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.ObjectFactory();  private static final io.fusionauth.samlv2.domain.jaxb.oasis.metadata.ObjectFactory METADATA_OBJECT_FACTORY = new io.fusionauth.samlv2.domain.jaxb.oasis.metadata.ObjectFactory();  private static final ObjectFactory PROTOCOL_OBJECT_FACTORY = new ObjectFactory();  private static final Logger logger = LoggerFactory.getLogger(DefaultSAMLv2Service.class);  static {    String ignoreLineBreaks = System.getProperty(\"com.sun.org.apache.xml.internal.security.ignoreLineBreaks\");    if (!Boolean.parseBoolean(ignoreLineBreaks)) {      throw new IllegalStateException(\"When the fusionauth-samlv2 jar is included in the classpath, you must set the following system property:\\n\" +          \"-Dcom.sun.org.apache.xml.internal.security.ignoreLineBreaks=true\");    }  }  @Override  public String buildAuthnResponse(AuthenticationResponse response, boolean sign, PrivateKey privateKey,                                   X509Certificate certificate, Algorithm algorithm, String xmlSignatureC14nMethod,                                   SignatureLocation signatureOption) throws SAMLException {    ResponseType jaxbResponse = new ResponseType();    StatusType status = new StatusType();    status.setStatusCode(new StatusCodeType());    status.getStatusCode().setValue(response.status.code.toSAMLFormat());    status.setStatusMessage(response.status.message);    jaxbResponse.setStatus(status);    jaxbResponse.setID(response.id);    jaxbResponse.setIssuer(new NameIDType());    jaxbResponse.getIssuer().setValue(response.issuer);    jaxbResponse.setVersion(response.version);    jaxbResponse.setInResponseTo(response.inResponseTo);    jaxbResponse.setIssueInstant(toXMLGregorianCalendar(response.issueInstant));    jaxbResponse.setDestination(response.destination);    AssertionType assertionType = new AssertionType();    if (response.assertion != null && response.status.code == ResponseStatus.Success) {      ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);      String id = \"_\" + UUID.randomUUID().toString();      assertionType.setID(id);      assertionType.setIssuer(jaxbResponse.getIssuer());      assertionType.setIssueInstant(toXMLGregorianCalendar(now));      assertionType.setVersion(response.version);      if (response.assertion.subject != null) {        SubjectType subjectType = new SubjectType();        if (response.assertion.subject.nameID != null) {          NameIDType nameIdType = new NameIDType();          nameIdType.setValue(response.assertion.subject.nameID.id);          nameIdType.setFormat(response.assertion.subject.nameID.format.toSAMLFormat());          subjectType.getContent().add(ASSERTION_OBJECT_FACTORY.createNameID(nameIdType));        }        if (response.assertion.subject.subjectConfirmation != null) {          SubjectConfirmationDataType dataType = new SubjectConfirmationDataType();          dataType.setInResponseTo(response.assertion.subject.subjectConfirmation.inResponseTo);          dataType.setNotBefore(toXMLGregorianCalendar(response.assertion.subject.subjectConfirmation.notBefore));          dataType.setNotOnOrAfter(toXMLGregorianCalendar(response.assertion.subject.subjectConfirmation.notOnOrAfter));          dataType.setRecipient(response.assertion.subject.subjectConfirmation.recipient);          SubjectConfirmationType subjectConfirmationType = new SubjectConfirmationType();          subjectConfirmationType.setSubjectConfirmationData(dataType);          if (response.assertion.subject.subjectConfirmation.method != null) {            subjectConfirmationType.setMethod(response.assertion.subject.subjectConfirmation.method.toSAMLFormat());          }          subjectType.getContent().add(ASSERTION_OBJECT_FACTORY.createSubjectConfirmation(subjectConfirmationType));        }        assertionType.setSubject(subjectType);      }      if (response.assertion.conditions != null) {        ConditionsType conditionsType = new ConditionsType();        conditionsType.setNotBefore(toXMLGregorianCalendar(response.assertion.conditions.notBefore));        conditionsType.setNotOnOrAfter(toXMLGregorianCalendar(response.assertion.conditions.notOnOrAfter));        assertionType.setConditions(conditionsType);        if (response.assertion.conditions.audiences.size() > 0) {          AudienceRestrictionType audienceRestrictionType = new AudienceRestrictionType();          audienceRestrictionType.getAudience().addAll(response.assertion.conditions.audiences);          conditionsType.getConditionOrAudienceRestrictionOrOneTimeUse().add(audienceRestrictionType);        }      }      AttributeStatementType attributeStatementType = new AttributeStatementType();      response.assertion.attributes.forEach((k, v) -> {        AttributeType attributeType = new AttributeType();        attributeType.setName(k);        attributeType.getAttributeValue().addAll(v);        attributeStatementType.getAttributeOrEncryptedAttribute().add(attributeType);      });      assertionType.getStatementOrAuthnStatementOrAuthzDecisionStatement().add(attributeStatementType);      AuthnStatementType authnStatement = new AuthnStatementType();      authnStatement.setAuthnInstant(toXMLGregorianCalendar(now));      authnStatement.setAuthnContext(new AuthnContextType());      authnStatement.getAuthnContext().getContent().add(ASSERTION_OBJECT_FACTORY.createAuthnContextClassRef(\"urn:oasis:names:tc:SAML:2.0:ac:classes:Password\"));      authnStatement.setSessionIndex(response.sessionIndex);      authnStatement.setSessionNotOnOrAfter(toXMLGregorianCalendar(response.sessionExpiry));      assertionType.getStatementOrAuthnStatementOrAuthzDecisionStatement().add(authnStatement);      jaxbResponse.getAssertionOrEncryptedAssertion().add(assertionType);    }    Document document = marshallToDocument(PROTOCOL_OBJECT_FACTORY.createResponse(jaxbResponse), ResponseType.class);    try {      Element toSign;      Node insertBefore = null;      if (response.status.code == ResponseStatus.Success && signatureOption == SignatureLocation.Assertion) {        toSign = (Element) document.getElementsByTagName(\"Assertion\").item(0);        Node issuer = toSign.getElementsByTagName(\"Issuer\").item(0);        insertBefore = issuer.getNextSibling();      } else {        toSign = document.getDocumentElement();        NodeList children = toSign.getChildNodes();        for (int i = 0; i < children.getLength(); i++) {          Node n = children.item(i);          if (n instanceof Element) {            insertBefore = n.getLocalName().equals(\"Issuer\") ? n.getNextSibling() : n;            break;          }        }      }      String xml = signXML(privateKey, certificate, algorithm, xmlSignatureC14nMethod, document, toSign, insertBefore);      return Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8));    } catch (Exception e) {      throw new SAMLException(\"Unable to sign XML SAML response\", e);    }  }  @Override  public String buildInvalidTestingPostAuthnRequest(AuthenticationRequest request, boolean sign, PrivateKey privateKey,                                                    X509Certificate certificate, Algorithm algorithm,                                                    String xmlSignatureC14nMethod) throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"bad\");    return buildPostAuthnRequest(authnRequest, sign, privateKey, certificate, algorithm, xmlSignatureC14nMethod);  }  @Override  public String buildInvalidTestingRedirectAuthnRequest(AuthenticationRequest request, String relayState, boolean sign,                                                        PrivateKey key, Algorithm algorithm) throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"bad\");    return buildRedirectAuthnRequest(authnRequest, relayState, sign, key, algorithm);  }  @Override  public String buildMetadataResponse(MetaData metaData) throws SAMLException {    EntityDescriptorType root = new EntityDescriptorType();    root.setID(\"_\" + metaData.id);    root.setEntityID(metaData.entityId);    if (metaData.idp != null) {      IDPSSODescriptorType idp = new IDPSSODescriptorType();      idp.getProtocolSupportEnumeration().add(\"urn:oasis:names:tc:SAML:2.0:protocol\");      metaData.idp.redirectBindingSignInEndpoints.forEach(endpoint -> {        EndpointType signIn = new EndpointType();        signIn.setBinding(Binding.HTTP_Redirect.toSAMLFormat());        signIn.setLocation(endpoint);        idp.getSingleSignOnService().add(signIn);      });      metaData.idp.postBindingSignInEndpoints.forEach(endpoint -> {        EndpointType signIn = new EndpointType();        signIn.setBinding(Binding.HTTP_POST.toSAMLFormat());        signIn.setLocation(endpoint);        idp.getSingleSignOnService().add(signIn);      });      metaData.idp.redirectBindingLogoutEndpoints.forEach(endpoint -> {        EndpointType logOut = new EndpointType();        logOut.setBinding(Binding.HTTP_Redirect.toSAMLFormat());        logOut.setLocation(endpoint);        idp.getSingleLogoutService().add(logOut);      });      metaData.idp.postBindingLogoutEndpoints.forEach(endpoint -> {        EndpointType logOut = new EndpointType();        logOut.setBinding(Binding.HTTP_POST.toSAMLFormat());        logOut.setLocation(endpoint);        idp.getSingleLogoutService().add(logOut);      });      addKeyDescriptors(idp, metaData.idp.certificates);      root.getRoleDescriptorOrIDPSSODescriptorOrSPSSODescriptor().add(idp);    }    if (metaData.sp != null) {      SPSSODescriptorType sp = new SPSSODescriptorType();      sp.getProtocolSupportEnumeration().add(\"urn:oasis:names:tc:SAML:2.0:protocol\");      sp.setAuthnRequestsSigned(metaData.sp.authnRequestsSigned);      sp.setWantAssertionsSigned(metaData.sp.wantAssertionsSigned);      if (metaData.sp.acsEndpoint != null) {        IndexedEndpointType acs = new IndexedEndpointType();        acs.setBinding(Binding.HTTP_POST.toSAMLFormat());        acs.setLocation(metaData.sp.acsEndpoint);        sp.getAssertionConsumerService().add(acs);      }      if (metaData.sp.nameIDFormat != null) {        sp.getNameIDFormat().add(metaData.sp.nameIDFormat.toSAMLFormat());      }      addKeyDescriptors(sp, metaData.sp.certificates);      root.getRoleDescriptorOrIDPSSODescriptorOrSPSSODescriptor().add(sp);    }    byte[] bytes = marshallToBytes(METADATA_OBJECT_FACTORY.createEntityDescriptor(root), EntityDescriptorType.class);    return new String(bytes, StandardCharsets.UTF_8);  }  @Override  public String buildPostAuthnRequest(AuthenticationRequest request, boolean sign, PrivateKey privateKey,                                      X509Certificate certificate, Algorithm algorithm, String xmlSignatureC14nMethod)      throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"2.0\");    return buildPostAuthnRequest(authnRequest, sign, privateKey, certificate, algorithm, xmlSignatureC14nMethod);  }  @Override  public String buildRedirectAuthnRequest(AuthenticationRequest request, String relayState, boolean sign,                                          PrivateKey key,                                          Algorithm algorithm)      throws SAMLException {    AuthnRequestType authnRequest = toAuthnRequest(request, \"2.0\");    return buildRedirectAuthnRequest(authnRequest, relayState, sign, key, algorithm);  }  @Override  public MetaData parseMetaData(String metaDataXML) throws SAMLException {    Document document = parseFromBytes(metaDataXML.getBytes(StandardCharsets.UTF_8));    EntityDescriptorType root = unmarshallFromDocument(document, EntityDescriptorType.class);    MetaData metaData = new MetaData();    metaData.id = root.getID();    metaData.entityId = root.getEntityID();    List<RoleDescriptorType> roles = root.getRoleDescriptorOrIDPSSODescriptorOrSPSSODescriptor();    Optional<RoleDescriptorType> idpDescriptor = roles.stream()                                                      .filter(r -> r instanceof IDPSSODescriptorType)                                                      .findFirst();    if (idpDescriptor.isPresent()) {      IDPSSODescriptorType idp = (IDPSSODescriptorType) idpDescriptor.get();      metaData.idp = new IDPMetaData();      for (EndpointType endpoint : idp.getSingleSignOnService()) {        if (Binding.HTTP_Redirect.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.redirectBindingSignInEndpoints.add(endpoint.getLocation());        } else if (Binding.HTTP_POST.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.postBindingSignInEndpoints.add(endpoint.getLocation());        }      }      for (EndpointType endpoint : idp.getSingleLogoutService()) {        if (Binding.HTTP_Redirect.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.redirectBindingLogoutEndpoints.add(endpoint.getLocation());        } else if (Binding.HTTP_POST.toSAMLFormat().equals(endpoint.getBinding())) {          metaData.idp.postBindingLogoutEndpoints.add(endpoint.getLocation());        }      }      try {        metaData.idp.certificates = idp.getKeyDescriptor()                                       .stream()                                       .filter(kd -> kd.getUse() == KeyTypes.SIGNING)                                       .map(this::toCertificate)                                       .filter(Objects::nonNull)                                       .collect(Collectors.toList());      } catch (IllegalArgumentException e) {        throw new SAMLException(e.getCause());      }    }    Optional<RoleDescriptorType> spDescriptor = roles.stream()                                                     .filter(r -> r instanceof SPSSODescriptorType)                                                     .findFirst();    if (spDescriptor.isPresent()) {      SPSSODescriptorType sp = (SPSSODescriptorType) spDescriptor.get();      metaData.sp = new SPMetaData();      metaData.sp.acsEndpoint = sp.getAssertionConsumerService().size() > 0 ? sp.getAssertionConsumerService().get(0).getLocation() : null;      try {        metaData.sp.nameIDFormat = sp.getNameIDFormat().size() > 0 ? NameIDFormat.fromSAMLFormat(sp.getNameIDFormat().get(0)) : null;      } catch (Exception e) {        throw new SAMLException(e.getCause());      }    }    return metaData;  }  @Override  public AuthenticationRequest parseRequestPostBinding(String encodedRequest,                                                       Function<AuthenticationRequest, PostBindingSignatureHelper> signatureHelperFunction)      throws SAMLException {    byte[] xml = Base64.getMimeDecoder().decode(encodedRequest);    AuthnRequestParseResult result = parseRequest(xml);    PostBindingSignatureHelper signatureHelper = signatureHelperFunction.apply(result.request);    if (signatureHelper.verifySignature()) {      verifySignature(result.document, signatureHelper.keySelector());    }    return result.request;  }  @Override  public AuthenticationRequest parseRequestRedirectBinding(String encodedRequest, String relayState,                                                           Function<AuthenticationRequest, RedirectBindingSignatureHelper> signatureHelperFunction)      throws SAMLException {    AuthnRequestParseResult result = parseRequest(decodeAndInflate(encodedRequest));    RedirectBindingSignatureHelper signatureHelper = signatureHelperFunction.apply(result.request);    if (signatureHelper.verifySignature()) {      if (signatureHelper.signature() == null || signatureHelper.publicKey() == null || signatureHelper.algorithm() == null) {        throw new SignatureNotFoundException(\"You must specify a signature, key and algorithm if you want to verify the SAML request signature\");      }      try {        String parameters = \"SAMLRequest=\" + URLEncoder.encode(encodedRequest, \"UTF-8\");        if (relayState != null) {          parameters += \"&RelayState=\" + URLEncoder.encode(relayState, \"UTF-8\");        }        parameters += \"&SigAlg=\" + URLEncoder.encode(signatureHelper.algorithm().uri, \"UTF-8\");        Signature sig = Signature.getInstance(signatureHelper.algorithm().name);        sig.initVerify(signatureHelper.publicKey());        sig.update(parameters.getBytes(StandardCharsets.UTF_8));        if (!sig.verify(Base64.getMimeDecoder().decode(signatureHelper.signature()))) {          throw new SAMLException(\"Invalid SAML v2.0 operation. The signature is invalid.\");        }      } catch (GeneralSecurityException | UnsupportedEncodingException e) {        throw new SAMLException(\"Unable to verify signature\", e);      }    }    return result.request;  }  @Override  public AuthenticationResponse parseResponse(String encodedResponse, boolean verifySignature, KeySelector keySelector)      throws SAMLException {    AuthenticationResponse response = new AuthenticationResponse();    byte[] decodedResponse = Base64.getMimeDecoder().decode(encodedResponse);    response.rawResponse = new String(decodedResponse, StandardCharsets.UTF_8);    Document document = parseFromBytes(decodedResponse);    if (verifySignature) {      verifySignature(document, keySelector);    }    ResponseType jaxbResponse = unmarshallFromDocument(document, ResponseType.class);    response.status.code = ResponseStatus.fromSAMLFormat(jaxbResponse.getStatus().getStatusCode().getValue());    response.id = jaxbResponse.getID();    response.inResponseTo = jaxbResponse.getInResponseTo();    response.issuer = jaxbResponse.getIssuer() != null ? jaxbResponse.getIssuer().getValue() : null;    response.issueInstant = toZonedDateTime(jaxbResponse.getIssueInstant());    response.destination = jaxbResponse.getDestination();    response.version = jaxbResponse.getVersion();    List<Object> assertions = jaxbResponse.getAssertionOrEncryptedAssertion();    for (Object assertion : assertions) {      if (assertion instanceof EncryptedElementType) {        logger.warn(\"SAML response contained encrypted attribute. It was ignored.\");        continue;      }      AssertionType assertionType = (AssertionType) assertion;      SubjectType subject = assertionType.getSubject();      if (subject != null) {        response.assertion.subject = new Subject();        List<JAXBElement<?>> elements = subject.getContent();        for (JAXBElement<?> element : elements) {          Class<?> type = element.getDeclaredType();          if (type == NameIDType.class) {            if (response.assertion.subject.nameID != null) {              logger.warn(\"SAML response contained multiple NameID elements. Only the first one was used.\");              continue;            }            response.assertion.subject.nameID = parseNameId((NameIDType) element.getValue());          } else if (type == SubjectConfirmationType.class) {            response.assertion.subject.subjectConfirmation = parseConfirmation((SubjectConfirmationType) element.getValue());          } else if (type == EncryptedElementType.class) {            throw new SAMLException(\"This library currently doesn't handle encrypted assertions\");          }        }      }      ConditionsType conditionsType = assertionType.getConditions();      if (conditionsType != null) {        response.assertion.conditions = new Conditions();        response.assertion.conditions.notBefore = convertToZonedDateTime(conditionsType.getNotBefore());        response.assertion.conditions.notOnOrAfter = convertToZonedDateTime(conditionsType.getNotOnOrAfter());        List<ConditionAbstractType> conditionAbstractTypes = conditionsType.getConditionOrAudienceRestrictionOrOneTimeUse();        for (ConditionAbstractType conditionAbstractType : conditionAbstractTypes) {          if (conditionAbstractType instanceof AudienceRestrictionType) {            AudienceRestrictionType restrictionType = (AudienceRestrictionType) conditionAbstractType;            response.assertion.conditions.audiences.addAll(restrictionType.getAudience());          }        }      }      List<StatementAbstractType> statements = assertionType.getStatementOrAuthnStatementOrAuthzDecisionStatement();      for (StatementAbstractType statement : statements) {        if (statement instanceof AttributeStatementType) {          AttributeStatementType attributeStatementType = (AttributeStatementType) statement;          List<Object> attributeObjects = attributeStatementType.getAttributeOrEncryptedAttribute();          for (Object attributeObject : attributeObjects) {            if (attributeObject instanceof AttributeType) {              AttributeType attributeType = (AttributeType) attributeObject;              String name = attributeType.getName();              List<Object> attributeValues = attributeType.getAttributeValue();              List<String> values = attributeValues.stream().map(this::attributeToString).collect(Collectors.toList());              response.assertion.attributes.computeIfAbsent(name, k -> new ArrayList<>()).addAll(values);            } else {              throw new SAMLException(\"This library currently doesn't support encrypted attributes\");            }          }        }      }    }    return response;  }  private void addKeyDescriptors(SSODescriptorType descriptor, List<Certificate> certificates) {    certificates.forEach(cert -> {      KeyDescriptorType key = new KeyDescriptorType();      key.setUse(KeyTypes.SIGNING);      KeyInfoType info = new KeyInfoType();      key.setKeyInfo(info);      X509DataType data = new X509DataType();      info.getContent().add(DSIG_OBJECT_FACTORY.createX509Data(data));      try {        JAXBElement<byte[]> certElement = DSIG_OBJECT_FACTORY.createX509DataTypeX509Certificate(cert.getEncoded());        data.getX509IssuerSerialOrX509SKIOrX509SubjectName().add(certElement);        descriptor.getKeyDescriptor().add(key);      } catch (Exception e) {        throw new IllegalArgumentException(e);      }    });  }  private String attributeToString(Object attribute) {    if (attribute == null) {      return null;    }    if (attribute instanceof Number) {      return attribute.toString();    } else if (attribute instanceof String) {      return (String) attribute;    } else if (attribute instanceof Element) {      return ((Element) attribute).getTextContent();    } else {      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");    }    return null;  }  private String buildPostAuthnRequest(AuthnRequestType authnRequest, boolean sign, PrivateKey privateKey,                                       X509Certificate certificate,                                       Algorithm algorithm, String xmlSignatureC14nMethod) throws SAMLException {    Document document = marshallToDocument(PROTOCOL_OBJECT_FACTORY.createAuthnRequest(authnRequest),"}
{"code": "import javax.xml.XMLConstants;import javax.xml.bind.JAXBContext;import javax.xml.bind.JAXBElement;import javax.xml.bind.JAXBException;import javax.xml.bind.Marshaller;import javax.xml.bind.Unmarshaller;import javax.xml.datatype.XMLGregorianCalendar;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.Source;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import javax.xml.validation.Validator;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.StringWriter;import java.net.URL;import java.security.cert.Certificate;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.time.ZonedDateTime;import java.util.ArrayList;import java.util.Arrays;import java.util.Base64;import java.util.GregorianCalendar;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.zip.DataFormatException;import java.util.zip.Deflater;import java.util.zip.Inflater;import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;import io.fusionauth.samlv2.domain.NameID;import io.fusionauth.samlv2.domain.NameIDFormat;import io.fusionauth.samlv2.domain.SAMLException;import io.fusionauth.samlv2.domain.jaxb.oasis.assertion.NameIDType;import io.fusionauth.samlv2.domain.jaxb.oasis.metadata.KeyDescriptorType;import io.fusionauth.samlv2.domain.jaxb.w3c.xmldsig.X509DataType;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.xml.sax.ErrorHandler;import org.xml.sax.SAXException;import org.xml.sax.SAXNotRecognizedException;import org.xml.sax.SAXNotSupportedException;import org.xml.sax.SAXParseException;import static javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING;public class SAMLTools {  private static final Map<String, Boolean> FactoryAttributes = new HashMap<>();  private static final Logger logger = LoggerFactory.getLogger(SAMLTools.class);  static {    FactoryAttributes.put(\"http:    FactoryAttributes.put(\"http:    FactoryAttributes.put(\"http:    FactoryAttributes.put(\"http:    FactoryAttributes.put(\"http:    FactoryAttributes.put(\"http:  }  public static String attributeToString(Object attribute) {    if (attribute == null) {      return null;    }    if (attribute instanceof Number) {      return attribute.toString();    } else if (attribute instanceof String) {      return (String) attribute;    } else if (attribute instanceof Element) {      return ((Element) attribute).getTextContent();    } else {      logger.warn(\"This library currently doesn't handle attributes of type [\" + attribute.getClass() + \"]\");    }    return null;  }  public static ZonedDateTime convertToZonedDateTime(XMLGregorianCalendar cal) {    return cal != null ? cal.toGregorianCalendar().toZonedDateTime() : null;  }  public static byte[] decodeAndInflate(String encodedRequest) throws SAMLException {    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);    Inflater inflater = new Inflater(true);    inflater.setInput(bytes);    inflater.finished();    try {      ByteArrayOutputStream os = new ByteArrayOutputStream();      byte[] result = new byte[bytes.length];      while (!inflater.finished()) {        int length = inflater.inflate(result);        if (length > 0) {          os.write(result, 0, length);        }      }      return os.toByteArray();    } catch (DataFormatException e) {      throw new SAMLException(\"Invalid AuthnRequest. Inflating the bytes failed.\", e);    }  }  public static String deflateAndEncode(byte[] bytes) {    Deflater deflater = new Deflater(Deflater.DEFLATED, true);    deflater.setInput(bytes);    deflater.finish();    byte[] deflatedResult = new byte[bytes.length];    int length = deflater.deflate(deflatedResult);    deflater.end();    byte[] src = Arrays.copyOf(deflatedResult, length);    return Base64.getEncoder().encodeToString(src);  }  public static <T> byte[] marshallToBytes(JAXBElement<T> object, Class<T> type) throws SAMLException {    try {      JAXBContext context = JAXBContext.newInstance(type);      Marshaller marshaller = context.createMarshaller();      ByteArrayOutputStream os = new ByteArrayOutputStream();      marshaller.marshal(object, os);      return os.toByteArray();    } catch (JAXBException e) {      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to bytes.\", e);    }  }  public static <T> Document marshallToDocument(JAXBElement<T> object, Class<T> type) throws SAMLException {    try {      JAXBContext context = JAXBContext.newInstance(type);      Marshaller marshaller = context.createMarshaller();      Document document = newDocumentBuilder().newDocument();      marshaller.marshal(object, document);      return document;    } catch (JAXBException | SAMLException e) {      throw new SAMLException(\"Unable to marshallRequest JAXB SAML object to DOM.\", e);    }  }  public static String marshallToString(Document document) throws TransformerException {    StringWriter sw = new StringWriter();    TransformerFactory tf = TransformerFactory.newInstance();    Transformer transformer = tf.newTransformer();    transformer.transform(new DOMSource(document), new StreamResult(sw));    return sw.toString();  }  public static DocumentBuilder newDocumentBuilder() throws SAMLException {    try {      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();      dbf.setNamespaceAware(true);      dbf.setExpandEntityReferences(false);      for (String key : FactoryAttributes.keySet()) {        try {          dbf.setAttribute(key, FactoryAttributes.get(key));        } catch (IllegalArgumentException e) {          logger.debug(\"Failed to set attribute [\" + key + \"=\" + FactoryAttributes.get(key) + \"]. This may be expected if the parser does not recognize this attribute.\", e);        }      }      dbf.setFeature(FEATURE_SECURE_PROCESSING, true);      return dbf.newDocumentBuilder();    } catch (ParserConfigurationException e) {      throw new SAMLException(\"Unable to configure the DocumentBuilderFactory with feature [\" + FEATURE_SECURE_PROCESSING + \"].\", e);    }  }  public static Document newDocumentFromBytes(byte[] bytes) throws SAMLException {    try {      return newDocumentBuilder().parse(new ByteArrayInputStream(bytes));    } catch (SAXException | IOException e) {      throw new SAMLException(\"Unable to parse SAML v2.0 authentication response\", e);    }  }  public static NameID parseNameId(NameIDType element) {    NameID nameId = new NameID();    nameId.format = NameIDFormat.fromSAMLFormat(element.getFormat());    nameId.id = element.getValue();    return nameId;  }  public static Certificate toCertificate(KeyDescriptorType keyDescriptorType) {    try {      List<Object> keyData = keyDescriptorType.getKeyInfo().getContent();      for (Object keyDatum : keyData) {        if (keyDatum instanceof JAXBElement<?>) {          JAXBElement<?> element = (JAXBElement<?>) keyDatum;          if (element.getDeclaredType() == X509DataType.class) {            X509DataType cert = (X509DataType) element.getValue();            List<Object> certData = cert.getX509IssuerSerialOrX509SKIOrX509SubjectName();            for (Object certDatum : certData) {              element = (JAXBElement<?>) certDatum;              if (element.getName().getLocalPart().equals(\"X509Certificate\")) {                byte[] certBytes = (byte[]) element.getValue();                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");                return cf.generateCertificate(new ByteArrayInputStream(certBytes));              }            }          }        }      }      return null;    } catch (CertificateException e) {      throw new IllegalArgumentException(e);    }  }  public static XMLGregorianCalendar toXMLGregorianCalendar(ZonedDateTime instant) {    if (instant == null) {      return null;    }    return new XMLGregorianCalendarImpl(GregorianCalendar.from(instant));  }  public static ZonedDateTime toZonedDateTime(XMLGregorianCalendar instant) {    if (instant == null) {      return null;    }    return instant.toGregorianCalendar().toZonedDateTime();  }  public static <T> T unmarshallFromDocument(Document document, Class<T> type) throws SAMLException {    try {      JAXBContext context = JAXBContext.newInstance(type);      Unmarshaller unmarshaller = context.createUnmarshaller();      JAXBElement<T> element = unmarshaller.unmarshal(document, type);      return element.getValue();    } catch (JAXBException e) {      throw new SAMLException(\"Unable to unmarshall SAML response\", e);    }  }  public static boolean validate(Document document, URL schemaURI, SchemaValidationErrors errors) throws SAMLException {    Schema schema;    try {      schema = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI).newSchema(schemaURI);    } catch (SAXException e) {      throw new SAMLException(\"An invalid schema was requested. Schema [\" + schemaURI + \"].\", e);    }    Validator validator = schema.newValidator();    validator.setErrorHandler(errors);    try {      validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");    } catch (SAXNotRecognizedException | SAXNotSupportedException ignore) {    }    try {      validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");    } catch (SAXNotRecognizedException | SAXNotSupportedException ignore) {    }    Source source = new DOMSource(document);    try {      validator.validate(source);    } catch (IOException | SAXException e) {      throw new SAMLException(\"Failed to validate the document source.\", e);    }    return errors.error.isEmpty() && errors.fatal.isEmpty() && errors.warning.isEmpty();  }  public static class SchemaValidationErrors implements ErrorHandler {    public final List<SAXParseException> error = new ArrayList<>();    public final List<SAXParseException> fatal = new ArrayList<>();    public final List<SAXParseException> warning = new ArrayList<>();    @Override    public void error(SAXParseException exception) {      error.add(exception);    }    @Override    public void fatalError(SAXParseException exception) {      fatal.add(exception);    }    @Override    public void warning(SAXParseException exception) {      warning.add(exception);    }  }}", "nl": ""}
{"code": "import javax.xml.bind.JAXBContext;import javax.xml.bind.JAXBElement;import javax.xml.bind.Unmarshaller;import javax.xml.crypto.KeySelector;import javax.xml.crypto.dsig.CanonicalizationMethod;import javax.xml.crypto.dsig.XMLSignature;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import java.io.BufferedWriter;import java.io.ByteArrayInputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStream;import java.math.BigInteger;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PublicKey;import java.security.cert.Certificate;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate;import java.security.spec.X509EncodedKeySpec;import java.time.ZonedDateTime;import java.util.ArrayList;import java.util.Base64;import java.util.Date;import java.util.List;import java.util.UUID;import java.util.zip.Inflater;import io.fusionauth.samlv2.domain.Algorithm;import io.fusionauth.samlv2.domain.AuthenticationRequest;import io.fusionauth.samlv2.domain.AuthenticationResponse;import io.fusionauth.samlv2.domain.Binding;import io.fusionauth.samlv2.domain.MetaData;import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;import io.fusionauth.samlv2.domain.MetaData.SPMetaData;import io.fusionauth.samlv2.domain.NameIDFormat;import io.fusionauth.samlv2.domain.ResponseStatus;import io.fusionauth.samlv2.domain.SAMLException;import io.fusionauth.samlv2.domain.SignatureLocation;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.AuthnRequestType;import io.fusionauth.samlv2.util.SAMLTools;import org.testng.annotations.BeforeClass;import org.testng.annotations.DataProvider;import org.testng.annotations.Test;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.xml.sax.SAXException;import sun.security.rsa.RSAPublicKeyImpl;import sun.security.x509.AlgorithmId;import sun.security.x509.CertificateAlgorithmId;import sun.security.x509.CertificateSerialNumber;import sun.security.x509.CertificateValidity;import sun.security.x509.CertificateVersion;import sun.security.x509.CertificateX509Key;import sun.security.x509.X500Name;import sun.security.x509.X509CertImpl;import sun.security.x509.X509CertInfo;import static org.testng.Assert.assertEquals;import static org.testng.Assert.assertFalse;import static org.testng.Assert.assertNull;import static org.testng.Assert.assertTrue;import static org.testng.Assert.fail;@SuppressWarnings({\"unchecked\"})@Test(groups = \"unit\")public class DefaultSAMLv2ServiceTest {  @BeforeClass  public void beforeClass() {    System.setProperty(\"com.sun.org.apache.xml.internal.security.ignoreLineBreaks\", \"true\");  }  @DataProvider(name = \"bindings\")  public Object[][] bindings() {    return new Object[][]{        {Binding.HTTP_Redirect},        {Binding.HTTP_POST}    };  }  @Test  public void buildIdPMetaData() throws Exception {    MetaData metaData = new MetaData();    metaData.id = UUID.randomUUID().toString();    metaData.entityId = \"https:    metaData.idp = new IDPMetaData();    metaData.idp.postBindingSignInEndpoints.add(\"https:    metaData.idp.redirectBindingSignInEndpoints.add(\"https:    metaData.idp.postBindingLogoutEndpoints.add(\"https:    metaData.idp.redirectBindingLogoutEndpoints.add(\"https:    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");    kpg.initialize(2048);    KeyPair kp = kpg.generateKeyPair();    Certificate cert = CertificateTools.fromKeyPair(kp, Algorithm.RS256, \"FusionAuth\");    metaData.idp.certificates.add(cert);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    String xml = service.buildMetadataResponse(metaData);    System.out.println(xml);    assertTrue(xml.contains(\"_\" + metaData.id));    assertTrue(xml.contains(metaData.entityId));    assertTrue(xml.contains(metaData.idp.postBindingSignInEndpoints.get(0)));    assertTrue(xml.contains(metaData.idp.postBindingLogoutEndpoints.get(0)));    assertTrue(xml.contains(metaData.idp.redirectBindingLogoutEndpoints.get(0)));    assertTrue(xml.contains(metaData.idp.redirectBindingLogoutEndpoints.get(0)));    assertTrue(xml.contains(\"<ns2:IDPSSODescriptor protocolSupportEnumeration=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\">\"));    MetaData parsed = service.parseMetaData(xml);    assertEquals(parsed.id, \"_\" + metaData.id);    assertEquals(parsed.entityId, metaData.entityId);    assertEquals(parsed.idp.postBindingSignInEndpoints, metaData.idp.postBindingSignInEndpoints);    assertEquals(parsed.idp.redirectBindingSignInEndpoints, metaData.idp.redirectBindingSignInEndpoints);    assertEquals(parsed.idp.postBindingLogoutEndpoints, metaData.idp.postBindingLogoutEndpoints);    assertEquals(parsed.idp.redirectBindingLogoutEndpoints, metaData.idp.redirectBindingLogoutEndpoints);    assertEquals(parsed.idp.certificates, metaData.idp.certificates);  }  @Test  public void buildRedirectAuthnRequest() throws Exception {    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");    kpg.initialize(2048);    KeyPair kp = kpg.generateKeyPair();    AuthenticationRequest request = new AuthenticationRequest();    request.id = \"foobarbaz\";    request.issuer = \"https:    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    String parameters = service.buildRedirectAuthnRequest(request, \"Relay-State-String\", true, kp.getPrivate(), Algorithm.RS256);    System.out.println(parameters);    int start = parameters.indexOf(\"=\");    int end = parameters.indexOf(\"&\");    String encodedRequest = URLDecoder.decode(parameters.substring(start + 1, end), \"UTF-8\");    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);    byte[] inflatedBytes = new byte[4096];    Inflater inflater = new Inflater(true);    inflater.setInput(bytes);    int length = inflater.inflate(inflatedBytes);    JAXBContext context = JAXBContext.newInstance(AuthnRequestType.class);    Unmarshaller unmarshaller = context.createUnmarshaller();    JAXBElement<AuthnRequestType> fromEncoded = (JAXBElement<AuthnRequestType>) unmarshaller.unmarshal(new ByteArrayInputStream(inflatedBytes, 0, length));    assertEquals(fromEncoded.getValue().getID(), \"foobarbaz\");    assertEquals(fromEncoded.getValue().getIssuer().getValue(), \"https:    assertEquals(fromEncoded.getValue().getVersion(), \"2.0\");    assertFalse(fromEncoded.getValue().getNameIDPolicy().isAllowCreate());    start = parameters.indexOf(\"RelayState=\");    end = parameters.indexOf(\"&\", start);    String relayState = parameters.substring(start + \"RelayState=\".length(), end);    assertEquals(relayState, \"Relay-State-String\");    start = parameters.indexOf(\"SigAlg=\");    end = parameters.indexOf(\"&\", start);    String sigAlg = URLDecoder.decode(parameters.substring(start + \"SigAlg=\".length(), end), \"UTF-8\");    assertEquals(sigAlg, \"http:  }  @Test  public void buildSPMetaData() throws Exception {    MetaData metaData = new MetaData();    metaData.id = UUID.randomUUID().toString();    metaData.entityId = \"https:    metaData.sp = new SPMetaData();    metaData.sp.acsEndpoint = \"https:    metaData.sp.nameIDFormat = NameIDFormat.EmailAddress;    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    String xml = service.buildMetadataResponse(metaData);    System.out.println(xml);    assertTrue(xml.contains(\"_\" + metaData.id));    assertTrue(xml.contains(metaData.entityId));    assertTrue(xml.contains(metaData.sp.acsEndpoint));    assertTrue(xml.contains(metaData.sp.nameIDFormat.toSAMLFormat()));    assertTrue(xml.contains(\"<ns2:SPSSODescriptor AuthnRequestsSigned=\\\"false\\\" WantAssertionsSigned=\\\"false\\\" protocolSupportEnumeration=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\">\"));    MetaData parsed = service.parseMetaData(xml);    assertEquals(parsed.id, \"_\" + metaData.id);    assertEquals(parsed.entityId, metaData.entityId);    assertEquals(parsed.sp.acsEndpoint, metaData.sp.acsEndpoint);    assertEquals(parsed.sp.nameIDFormat, metaData.sp.nameIDFormat);  }  @DataProvider(name = \"maxLineLength\")  public Object[][] maxLineLength() {    return new Object[][]{        {42},        {64},        {76},        {96},        {128}    };  }  @Test  public void parseMetaData() throws Exception {    byte[] buf = Files.readAllBytes(Paths.get(\"src/test/xml/metadata.xml\"));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    MetaData metaData = service.parseMetaData(new String(buf, StandardCharsets.UTF_8));    assertEquals(metaData.idp.certificates.size(), 3);    buf = Files.readAllBytes(Paths.get(\"src/test/xml/metadata-2.xml\"));    metaData = service.parseMetaData(new String(buf, StandardCharsets.UTF_8));    assertEquals(metaData.idp.certificates.size(), 1);  }  @Test(enabled = false)  public void parseRequest_compassSecurity() throws Exception {    String encodedXML = \"PHNhbWxwOkF1dGhuUmVxdWVzdCB4bWxuczpzYW1scD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOnByb3RvY29sIg0KICAgICAgICAgICAgICAgICAgICB4bWxuczpzYW1sPSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6YXNzZXJ0aW9uIiBJRD0iXzdmZTUxMGNjOGU1MWFhNDE1NThhIg0KICAgICAgICAgICAgICAgICAgICBJc3N1ZUluc3RhbnQ9IjIwMjEtMDEtMjFUMTY6NDY6MDVaIiBQcm92aWRlck5hbWU9IlNpbXBsZSBTQU1MIFNlcnZpY2UgUHJvdmlkZXIiDQogICAgICAgICAgICAgICAgICAgIEFzc2VydGlvbkNvbnN1bWVyU2VydmljZVVSTD0iaHR0cDovL2xvY2FsaG9zdDo3MDcwL3NhbWwvc3NvIg0KICAgICAgICAgICAgICAgICAgICBEZXN0aW5hdGlvbj0iaHR0cDovL2xvY2FsaG9zdDo5MDExL3NhbWx2Mi9sb2dpbi81YjJlNDgzZi03NTcyLTQ4NzktODE3ZS0xYTkwYWM0NGU3NTciDQogICAgICAgICAgICAgICAgICAgIFByb3RvY29sQmluZGluZz0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOmJpbmRpbmdzOkhUVFAtUE9TVCIgVmVyc2lvbj0iMi4wIj4NCiAgPHNhbWw6SXNzdWVyPnVybjpleGFtcGxlOnNwPC9zYW1sOklzc3Vlcj4NCiAgPFNpZ25hdHVyZSB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC8wOS94bWxkc2lnIyI+DQogICAgPFNpZ25lZEluZm8+DQogICAgICA8Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMTAveG1sLWV4Yy1jMTRuIyIvPg0KICAgICAgPFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMDQveG1sZHNpZy1tb3JlI3JzYS1zaGEyNTYiLz4NCiAgICAgIDxSZWZlcmVuY2UgVVJJPSIjXzdmZTUxMGNjOGU1MWFhNDE1NThhIj4NCiAgICAgICAgPFRyYW5zZm9ybXM+DQogICAgICAgICAgPFRyYW5zZm9ybSBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyNlbnZlbG9wZWQtc2lnbmF0dXJlIi8+DQogICAgICAgICAgPFRyYW5zZm9ybSBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMTAveG1sLWV4Yy1jMTRuIyIvPg0KICAgICAgICA8L1RyYW5zZm9ybXM+DQogICAgICAgIDxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGVuYyNzaGEyNTYiLz4NCiAgICAgICAgPERpZ2VzdFZhbHVlPjV4V2cvaWRqOGpNV2Z3ZWRmaksyQkVZa2QveUxXY2pNa2ZKK1ZmOHQrRkE9PC9EaWdlc3RWYWx1ZT4NCiAgICAgIDwvUmVmZXJlbmNlPg0KICAgIDwvU2lnbmVkSW5mbz4NCiAgICA8U2lnbmF0dXJlVmFsdWU+DQogICAgICBsZ05CSEZ4UHFueHVKRmVRa0cwN3dNY0JwZll3TkVBc2pMeWpQTTBsQit5Nm8rNEtDSzN0U2padXVSUVlNWTRJb3J6Uk95b3piZGtsRitCT2UxL0tKNFhxRGhFaXFlbUEyTGszcEliakJQbit6NDdGcER0NWdsQUVxY3NmMlI2RDhKTndkNWJxSmgxYnVITXNUQ3dIOFhPVHZpdHlxQXZrZmp4WVhNU290SDFWSWxrRWxjZFF6aXA5ZlhsZW1ZdExCdXoybG5sTHYyS01DSkRpYTlQTzZrSHQySTRBL2s0WXBNRmx2NlF0aGlPcjdlVjROOWIxVk43VUxYRHJlUS9OUDhtZWdtWGVBcWxaMC81VnlXdGRYQ1E0QUlSUVlUeW5mTlZ3TDA1VG5JOXNYZDl5WTdPbXk5WVJwdEYzaHZBWVFqd0t1ak90bjNGUnJNSldKMzRha3c9PQ0KICAgIDwvU2lnbmF0dXJlVmFsdWU+DQogICAgPEtleUluZm8+DQogICAgICA8WDUwOURhdGE+DQogICAgICAgIDxYNTA5Q2VydGlmaWNhdGU+DQogICAgICAgICAgTUlJRFV6Q0NBanVnQXdJQkFnSUpBUEowbUE2V3pPcHZNQTBHQ1NxR1NJYjNEUUVCQ3dVQU1HQXhDekFKQmdOVkJBWVRBbFZUTVJNd0VRWURWUVFJRXdwRFlXeHBabTl5Ym1saE1SWXdGQVlEVlFRSEV3MVRZVzRnUm5KaGJtTnBjMk52TVJBd0RnWURWUVFLRXdkS1lXNXJlVU52TVJJd0VBWURWUVFERXdsc2IyTmhiR2h2YzNRd0hoY05NVFF3TXpFeU1UazBOak16V2hjTk1qY3hNVEU1TVRrME5qTXpXakJnTVFzd0NRWURWUVFHRXdKVlV6RVRNQkVHQTFVRUNCTUtRMkZzYVdadmNtNXBZVEVXTUJRR0ExVUVCeE1OVTJGdUlFWnlZVzVqYVhOamJ6RVFNQTRHQTFVRUNoTUhTbUZ1YTNsRGJ6RVNNQkFHQTFVRUF4TUpiRzlqWVd4b2IzTjBNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXRsTkR5NERSMnRoWjJERGNpSVRvZlVwd1laY25Yay85cHFEdDhWMTZqQkQwMnVPZC9UZHlzZ2lLTGpyWlpiQy9YME9YMUVGZTVkTjY1VXJMT0RRQkJ6WjMvOFBZejY4MTlNS2M5aXJWOCs3MzJINWRHd3pnbVlCWUQrcXFmNEJjUjM2TDdUam1Pd2prZSsxY01jR2crV1hWU1hRTS9kalN4aFFIaldOamtSdDFUL21MZmxxTXFwb3B6Y21BUFFETEVIRXJ0dWFtOVh0dWRqaUZNOHI1anp2bXUvVXBJUGliYndBWThxM3NUUHBFN0pCTHI2SXk0cEJBY2lMbFhhNE5yRFE4YUw4akZwaWhqdm0rdUhWTUhNR215bkdpY0dRTGdyRktPV3M2NTVtVlZXWGZET2U2SjVwaUJYcjFteW5uQnN0ZGRTYWxaNWFMQVdGOGc2c3pmUUlEQVFBQm94QXdEakFNQmdOVkhSTUJBZjhFQWpBQU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQ2xaeStnTVlrTmZvK2RRakV1dmJ2eDYyTU1SM1dka3BmZXk0M1pnUHF4MTh2cEcwUDdhSXFUeWJreFRraGkvQXc4cExEY0l2QVBaSHFsTWZMQ05Cci80K3NucXJMbzNPaUdaSTFobDlRT0czaFFta3JqVDEwaGx5WFJTM29UbmpENWJoRGoraW5iRzFpOVFSSzdQTzBQUXFXaElLZ3J0THlZcDNXdlM2WjljWVh3UXQ1RmNZYmhLcCtDK2t2Q3pxK1RmYlFhbWx2ZWhXakJVTlIyN0NFMTFNLy9XVEYwbmZiT0Z1MzJFQzZrQjBFR2Q2UFRJd2h0eTJ6SHhnKyt1WU1qQVVMK1pOdU5pYU1jMzU1b1h2THRoMXE1cmszR2EzdW5wQmptUTdvYlUyLzQvV2RKblBmdmxEMmt0QVYvUzVkVlNLU0RObWthZzhJWDBuSGIvMUZODQogICAgICAgIDwvWDUwOUNlcnRpZmljYXRlPg0KICAgICAgPC9YNTA5RGF0YT4NCiAgICA8L0tleUluZm8+DQogIDwvU2lnbmF0dXJlPg0KICA8c2FtbHA6TmFtZUlEUG9saWN5IEZvcm1hdD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6MS4xOm5hbWVpZC1mb3JtYXQ6ZW1haWxBZGRyZXNzIiBBbGxvd0NyZWF0ZT0idHJ1ZSIvPg0KICA8c2FtbHA6UmVxdWVzdGVkQXV0aG5Db250ZXh0IENvbXBhcmlzb249ImV4YWN0Ij4NCiAgICA8c2FtbDpBdXRobkNvbnRleHRDbGFzc1JlZj51cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6YWM6Y2xhc3NlczpQYXNzd29yZFByb3RlY3RlZFRyYW5zcG9ydA0KICAgIDwvc2FtbDpBdXRobkNvbnRleHRDbGFzc1JlZj4NCiAgPC9zYW1scDpSZXF1ZXN0ZWRBdXRobkNvbnRleHQ+DQo8L3NhbWxwOkF1dGhuUmVxdWVzdD4=\";    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    PublicKey publicKey = new RSAPublicKeyImpl        (new BigInteger(\"23016430918823899869174537266594866915196701755262955756947374683306171050449785978041642070945082562110926617344211216571596575890159654912559343561454566120924390651417182396241104494630512996615232908509829811443784313485862019497373006302688901954848508137355590138442254765794572625586049567608157223736747587462558785268970406066201827350377828581492579969240135441642716939367190425379788145244337250560138881783025442595121210838086638484878363941229167629103738547784336822433469701246494321129732432091196962736034404069520496182669787723781485938596516343326251546340541402004104537790138422441873446220669\"),            new BigInteger(\"65537\"));    TestPostBindingSignatureHelper signatureHelper = new TestPostBindingSignatureHelper(KeySelector.singletonKeySelector(publicKey), true);    AuthenticationRequest request = service.parseRequestPostBinding(encodedXML, authRequest -> signatureHelper);    assertEquals(request.id, \"_7fe510cc8e51aa41558a\");    assertEquals(request.issuer, \"urn:example:sp\");    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");  }  @Test  public void parseRequest_expandedEntity() throws Exception {    try {      DefaultSAMLv2Service service = new DefaultSAMLv2Service();      byte[] xml = Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-expanded-entity.xml\"));      String deflated = SAMLTools.deflateAndEncode(xml);      AuthenticationRequest request = service.parseRequestRedirectBinding(deflated, null, authRequest -> new TestRedirectBindingSignatureHelper());      fail(\"Expected an exception because we are declaring a DOCTYPE and expanding an entity. The issuer is now set to [\" + request.issuer + \"] which is not good.\");    } catch (SAMLException e) {      assertEquals(e.getMessage(), \"Unable to parse SAML v2.0 authentication response\");      assertEquals(e.getCause().getClass().getCanonicalName(), \"org.xml.sax.SAXParseException\");      assertEquals(e.getCause().getMessage(), \"DOCTYPE is disallowed when the feature \\\"http:    }  }  @Test  public void parseRequest_externalDTD() throws Exception {    Path tempFile = null;    try {      tempFile = Files.createTempFile(\"readThisFile\", \".tmp\");      try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile.toFile()))) {        writer.write(\"You've been pwned.\");      }      DefaultSAMLv2Service service = new DefaultSAMLv2Service();      byte[] xml = Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-external-dtd.xml\"));      String xmlString = new String(xml);      xmlString = xmlString.replace(\"{{tempFile}}\", tempFile.toFile().getAbsolutePath());      xml = xmlString.getBytes(StandardCharsets.UTF_8);      String deflated = SAMLTools.deflateAndEncode(xml);      AuthenticationRequest request = service.parseRequestRedirectBinding(deflated, null, authRequest -> new TestRedirectBindingSignatureHelper());      fail(\"Expected an exception because we are declaring a DOCTYPE. The issuer is now set to [\" + request.issuer + \"] which is not good.\");    } catch (SAMLException e) {      assertEquals(e.getMessage(), \"Unable to parse SAML v2.0 authentication response\");      assertEquals(e.getCause().getClass().getCanonicalName(), \"org.xml.sax.SAXParseException\");      assertEquals(e.getCause().getMessage(), \"DOCTYPE is disallowed when the feature \\\"http:    } finally {      if (tempFile != null) {        Files.deleteIfExists(tempFile);      }    }  }  @Test  public void parseRequest_hasDocType() throws Exception {    try {      DefaultSAMLv2Service service = new DefaultSAMLv2Service();      byte[] xml = Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-has-doctype.xml\"));      String deflated = SAMLTools.deflateAndEncode(xml);      service.parseRequestRedirectBinding(deflated, null, authRequest -> new TestRedirectBindingSignatureHelper());      fail(\"expected an exception because we are declaring a DOCTYPE\");    } catch (SAMLException e) {      assertEquals(e.getMessage(), \"Unable to parse SAML v2.0 authentication response\");      assertEquals(e.getCause().getClass().getCanonicalName(), \"org.xml.sax.SAXParseException\");      assertEquals(e.getCause().getMessage(), \"DOCTYPE is disallowed when the feature \\\"http:    }  }  @Test(dataProvider = \"maxLineLength\")  public void parseRequest_includeLineReturns(int maxLineLength) throws Exception {    String xml = new String(Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-control.xml\")));    String encodedXML = new String(Files.readAllBytes(Paths.get(\"src/test/xml/deflated/authn-request-control.txt\")));    List<String> lines = new ArrayList<>();    for (int i = 0; i < encodedXML.length(); ) {      lines.add(encodedXML.substring(i, Math.min(i + maxLineLength, encodedXML.length())));      i = i + maxLineLength;    }    String withLineReturns = String.join(\"\\n\", lines);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = service.parseRequestRedirectBinding(withLineReturns, null, authRequest -> new TestRedirectBindingSignatureHelper());    assertEquals(request.id, \"_809707f0030a5d00620c9d9df97f627afe9dcc24\");    assertEquals(request.issuer, \"http:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test(dataProvider = \"bindings\")  public void parseRequest_noNameIdPolicy(Binding binding) throws Exception {    String xml = new String(Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-noNameIdPolicy.xml\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-noNameIdPolicy.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-noNameIdPolicy.txt\")));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = binding == Binding.HTTP_Redirect        ? service.parseRequestRedirectBinding(encodedXML, null, authRequest -> new TestRedirectBindingSignatureHelper())        : service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper());    assertEquals(request.id, \"id_4c6e5aa3\");    assertEquals(request.issuer, \"https:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test(dataProvider = \"bindings\")  public void parseRequest_verifySignature(Binding binding) throws Exception {    String xml = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/authn-request-redirect-signed.xml\")        : Paths.get(\"src/test/xml/authn-request-post-signed.xml\")));    String relayState = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/relay-state/authn-request-redirect.txt\")        : Paths.get(\"src/test/xml/relay-state/authn-request-post.txt\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-signed.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-signed.txt\")));    String signature = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/signature/authn-request-redirect.txt\")        : Paths.get(\"src/test/xml/signature/authn-request-post.txt\")));    PublicKey publicKey = KeyFactory.getInstance(\"RSA\")                                    .generatePublic(                                        new X509EncodedKeySpec(                                            Base64.getDecoder()                                                  .decode(                                                      Files.readAllBytes(binding == Binding.HTTP_Redirect                                                          ? Paths.get(\"src/test/xml/public-key/authn-request-redirect.txt\")                                                          : Paths.get(\"src/test/xml/public-key/authn-request-post.txt\"))                                                  )));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = binding == Binding.HTTP_Redirect        ? service.parseRequestRedirectBinding(encodedXML, relayState, authRequest -> new TestRedirectBindingSignatureHelper(Algorithm.RS256, publicKey, signature, true))        : service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper(KeySelector.singletonKeySelector(publicKey), true));    assertEquals(request.id, binding == Binding.HTTP_Redirect ? \"ID_025417c8-50c8-4916-bfe0-e05694f8cea7\" : \"ID_26d69170-fc73-4b62-8bb6-c72769216134\");    assertEquals(request.issuer, \"http:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test(dataProvider = \"bindings\")  public void parseRequest_verifySignature_badSignature(Binding binding) throws Exception {    String relayState = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/relay-state/authn-request-redirect.txt\")        : Paths.get(\"src/test/xml/relay-state/authn-request-post.txt\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-signed.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-signed-badSignature.txt\")));    String signature = new String(Files.readAllBytes(Paths.get(\"src/test/xml/signature/authn-request-redirect-bad.txt\")));     PublicKey publicKey = KeyFactory.getInstance(\"RSA\")                                    .generatePublic(                                        new X509EncodedKeySpec(                                            Base64.getDecoder()                                                  .decode(                                                      Files.readAllBytes(binding == Binding.HTTP_Redirect                                                          ? Paths.get(\"src/test/xml/public-key/authn-request-redirect.txt\")                                                          : Paths.get(\"src/test/xml/public-key/authn-request-post.txt\"))                                                  )));    try {      DefaultSAMLv2Service service = new DefaultSAMLv2Service();      if (binding == Binding.HTTP_Redirect) {        service.parseRequestRedirectBinding(encodedXML, relayState, request -> new TestRedirectBindingSignatureHelper(Algorithm.RS256, publicKey, signature, true));      } else {        service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper(KeySelector.singletonKeySelector(publicKey), true));      }      fail(\"Should have failed signature validation\");    } catch (SAMLException e) {      assertEquals(e.getMessage(), \"Invalid SAML v2.0 operation. The signature is invalid.\");    }  }  @Test(dataProvider = \"bindings\")  public void parseRequest_withNameIdPolicy(Binding binding) throws Exception {    String xml = new String(Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-control.xml\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-control.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-control.txt\")));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = binding == Binding.HTTP_Redirect        ? service.parseRequestRedirectBinding(encodedXML, null, authRequest -> new TestRedirectBindingSignatureHelper())        : service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper());    assertEquals(request.id, \"_809707f0030a5d00620c9d9df97f627afe9dcc24\");    assertEquals(request.issuer, \"http:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test  public void parseResponse() throws Exception {    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");    PublicKey key;    try (InputStream is = Files.newInputStream(Paths.get(\"src/test/certificates/certificate.cer\"))) {      Certificate cert = cf.generateCertificate(is);      key = cert.getPublicKey();    }    byte[] ba = Files.readAllBytes(Paths.get(\"src/test/xml/encodedResponse.txt\"));    String encodedResponse = new String(ba);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationResponse response = service.parseResponse(encodedResponse, true, KeySelector.singletonKeySelector(key));    assertEquals(response.destination, \"https:    assertTrue(response.assertion.conditions.notBefore.isBefore(ZonedDateTime.now()));    assertTrue(ZonedDateTime.now().isAfter(response.assertion.conditions.notOnOrAfter));    assertTrue(response.issueInstant.isBefore(ZonedDateTime.now()));    assertEquals(response.issuer, \"https:    assertEquals(response.status.code, ResponseStatus.Success);    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.subject.nameID.format, NameIDFormat.EmailAddress);  }  @Test  public void parseResponse_handleNilAttribute() throws Exception {    byte[] ba = Files.readAllBytes(Paths.get(\"src/test/xml/deflated/example-response.txt\"));    String encodedResponse = new String(ba);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationResponse response = service.parseResponse(encodedResponse, false, null);    assertEquals(response.destination, \"http:    assertTrue(response.assertion.conditions.notBefore.isBefore(ZonedDateTime.now()));    assertEquals(response.issuer, \"http:    assertEquals(response.status.code, ResponseStatus.Success);    assertEquals(response.assertion.attributes.get(\"uid\").size(), 1);    assertEquals(response.assertion.attributes.get(\"uid\").get(0), \"test\");    assertEquals(response.assertion.attributes.get(\"mail\").size(), 1);    assertEquals(response.assertion.attributes.get(\"mail\").get(0), \"test@example.com\");    assertEquals(response.assertion.attributes.get(\"eduPersonAffiliation\").size(), 2);    assertEquals(response.assertion.attributes.get(\"eduPersonAffiliation\").get(0), \"users\");    assertEquals(response.assertion.attributes.get(\"eduPersonAffiliation\").get(1), \"examplerole1\");    assertEquals(response.assertion.attributes.get(\"memberOf\").size(), 1);    assertEquals(response.assertion.attributes.get(\"memberOf\").get(0), \"\");    assertEquals(response.assertion.attributes.get(\"PersonImmutableID\").size(), 1);    assertNull(response.assertion.attributes.get(\"PersonImmutableID\").get(0));    assertEquals(response.assertion.subject.nameID.format, NameIDFormat.Transient);  }  @Test(dataProvider = \"maxLineLength\")  public void parseResponse_includeLineReturns(int maxLineLength) throws Excep", "nl": "import javax.xml.bind.JAXBContext;import javax.xml.bind.JAXBElement;import javax.xml.bind.Unmarshaller;import javax.xml.crypto.KeySelector;import javax.xml.crypto.dsig.CanonicalizationMethod;import javax.xml.crypto.dsig.XMLSignature;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.math.BigInteger;import java.net.URLDecoder;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PublicKey;import java.security.cert.Certificate;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate;import java.security.spec.X509EncodedKeySpec;import java.time.ZonedDateTime;import java.util.ArrayList;import java.util.Base64;import java.util.Date;import java.util.List;import java.util.UUID;import java.util.zip.Inflater;import io.fusionauth.samlv2.domain.Algorithm;import io.fusionauth.samlv2.domain.AuthenticationRequest;import io.fusionauth.samlv2.domain.AuthenticationResponse;import io.fusionauth.samlv2.domain.Binding;import io.fusionauth.samlv2.domain.MetaData;import io.fusionauth.samlv2.domain.MetaData.IDPMetaData;import io.fusionauth.samlv2.domain.MetaData.SPMetaData;import io.fusionauth.samlv2.domain.NameIDFormat;import io.fusionauth.samlv2.domain.ResponseStatus;import io.fusionauth.samlv2.domain.SAMLException;import io.fusionauth.samlv2.domain.SignatureLocation;import io.fusionauth.samlv2.domain.jaxb.oasis.protocol.AuthnRequestType;import org.testng.annotations.BeforeClass;import org.testng.annotations.DataProvider;import org.testng.annotations.Test;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.xml.sax.SAXException;import sun.security.rsa.RSAPublicKeyImpl;import sun.security.x509.AlgorithmId;import sun.security.x509.CertificateAlgorithmId;import sun.security.x509.CertificateSerialNumber;import sun.security.x509.CertificateValidity;import sun.security.x509.CertificateVersion;import sun.security.x509.CertificateX509Key;import sun.security.x509.X500Name;import sun.security.x509.X509CertImpl;import sun.security.x509.X509CertInfo;import static org.testng.Assert.assertEquals;import static org.testng.Assert.assertFalse;import static org.testng.Assert.assertNull;import static org.testng.Assert.assertTrue;import static org.testng.Assert.fail;@SuppressWarnings({\"unchecked\"})@Test(groups = \"unit\")public class DefaultSAMLv2ServiceTest {  @BeforeClass  public void beforeClass() {    System.setProperty(\"com.sun.org.apache.xml.internal.security.ignoreLineBreaks\", \"true\");  }  @DataProvider(name = \"bindings\")  public Object[][] bindings() {    return new Object[][]{        {Binding.HTTP_Redirect},        {Binding.HTTP_POST}    };  }  @Test  public void buildIdPMetaData() throws Exception {    MetaData metaData = new MetaData();    metaData.id = UUID.randomUUID().toString();    metaData.entityId = \"https:    metaData.idp = new IDPMetaData();    metaData.idp.postBindingSignInEndpoints.add(\"https:    metaData.idp.redirectBindingSignInEndpoints.add(\"https:    metaData.idp.postBindingLogoutEndpoints.add(\"https:    metaData.idp.redirectBindingLogoutEndpoints.add(\"https:    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");    kpg.initialize(2048);    KeyPair kp = kpg.generateKeyPair();    Certificate cert = CertificateTools.fromKeyPair(kp, Algorithm.RS256, \"FusionAuth\");    metaData.idp.certificates.add(cert);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    String xml = service.buildMetadataResponse(metaData);    System.out.println(xml);    assertTrue(xml.contains(\"_\" + metaData.id));    assertTrue(xml.contains(metaData.entityId));    assertTrue(xml.contains(metaData.idp.postBindingSignInEndpoints.get(0)));    assertTrue(xml.contains(metaData.idp.postBindingLogoutEndpoints.get(0)));    assertTrue(xml.contains(metaData.idp.redirectBindingLogoutEndpoints.get(0)));    assertTrue(xml.contains(metaData.idp.redirectBindingLogoutEndpoints.get(0)));    assertTrue(xml.contains(\"<ns2:IDPSSODescriptor protocolSupportEnumeration=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\">\"));    MetaData parsed = service.parseMetaData(xml);    assertEquals(parsed.id, \"_\" + metaData.id);    assertEquals(parsed.entityId, metaData.entityId);    assertEquals(parsed.idp.postBindingSignInEndpoints, metaData.idp.postBindingSignInEndpoints);    assertEquals(parsed.idp.redirectBindingSignInEndpoints, metaData.idp.redirectBindingSignInEndpoints);    assertEquals(parsed.idp.postBindingLogoutEndpoints, metaData.idp.postBindingLogoutEndpoints);    assertEquals(parsed.idp.redirectBindingLogoutEndpoints, metaData.idp.redirectBindingLogoutEndpoints);    assertEquals(parsed.idp.certificates, metaData.idp.certificates);  }  @Test  public void buildRedirectAuthnRequest() throws Exception {    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");    kpg.initialize(2048);    KeyPair kp = kpg.generateKeyPair();    AuthenticationRequest request = new AuthenticationRequest();    request.id = \"foobarbaz\";    request.issuer = \"https:    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    String parameters = service.buildRedirectAuthnRequest(request, \"Relay-State-String\", true, kp.getPrivate(), Algorithm.RS256);    System.out.println(parameters);    int start = parameters.indexOf(\"=\");    int end = parameters.indexOf(\"&\");    String encodedRequest = URLDecoder.decode(parameters.substring(start + 1, end), \"UTF-8\");    byte[] bytes = Base64.getMimeDecoder().decode(encodedRequest);    byte[] inflatedBytes = new byte[4096];    Inflater inflater = new Inflater(true);    inflater.setInput(bytes);    int length = inflater.inflate(inflatedBytes);    JAXBContext context = JAXBContext.newInstance(AuthnRequestType.class);    Unmarshaller unmarshaller = context.createUnmarshaller();    JAXBElement<AuthnRequestType> fromEncoded = (JAXBElement<AuthnRequestType>) unmarshaller.unmarshal(new ByteArrayInputStream(inflatedBytes, 0, length));    assertEquals(fromEncoded.getValue().getID(), \"foobarbaz\");    assertEquals(fromEncoded.getValue().getIssuer().getValue(), \"https:    assertEquals(fromEncoded.getValue().getVersion(), \"2.0\");    assertFalse(fromEncoded.getValue().getNameIDPolicy().isAllowCreate());    start = parameters.indexOf(\"RelayState=\");    end = parameters.indexOf(\"&\", start);    String relayState = parameters.substring(start + \"RelayState=\".length(), end);    assertEquals(relayState, \"Relay-State-String\");    start = parameters.indexOf(\"SigAlg=\");    end = parameters.indexOf(\"&\", start);    String sigAlg = URLDecoder.decode(parameters.substring(start + \"SigAlg=\".length(), end), \"UTF-8\");    assertEquals(sigAlg, \"http:  }  @Test  public void buildSPMetaData() throws Exception {    MetaData metaData = new MetaData();    metaData.id = UUID.randomUUID().toString();    metaData.entityId = \"https:    metaData.sp = new SPMetaData();    metaData.sp.acsEndpoint = \"https:    metaData.sp.nameIDFormat = NameIDFormat.EmailAddress;    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    String xml = service.buildMetadataResponse(metaData);    System.out.println(xml);    assertTrue(xml.contains(\"_\" + metaData.id));    assertTrue(xml.contains(metaData.entityId));    assertTrue(xml.contains(metaData.sp.acsEndpoint));    assertTrue(xml.contains(metaData.sp.nameIDFormat.toSAMLFormat()));    assertTrue(xml.contains(\"<ns2:SPSSODescriptor AuthnRequestsSigned=\\\"false\\\" WantAssertionsSigned=\\\"false\\\" protocolSupportEnumeration=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\">\"));    MetaData parsed = service.parseMetaData(xml);    assertEquals(parsed.id, \"_\" + metaData.id);    assertEquals(parsed.entityId, metaData.entityId);    assertEquals(parsed.sp.acsEndpoint, metaData.sp.acsEndpoint);    assertEquals(parsed.sp.nameIDFormat, metaData.sp.nameIDFormat);  }  @DataProvider(name = \"maxLineLength\")  public Object[][] maxLineLength() {    return new Object[][]{        {42},        {64},        {76},        {96},        {128}    };  }  @Test  public void parseMetaData() throws Exception {    byte[] buf = Files.readAllBytes(Paths.get(\"src/test/xml/metadata.xml\"));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    MetaData metaData = service.parseMetaData(new String(buf, StandardCharsets.UTF_8));    assertEquals(metaData.idp.certificates.size(), 3);    buf = Files.readAllBytes(Paths.get(\"src/test/xml/metadata-2.xml\"));    metaData = service.parseMetaData(new String(buf, StandardCharsets.UTF_8));    assertEquals(metaData.idp.certificates.size(), 1);  }  @Test(enabled = false)  public void parseRequest_compassSecurity() throws Exception {    String encodedXML = \"PHNhbWxwOkF1dGhuUmVxdWVzdCB4bWxuczpzYW1scD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOnByb3RvY29sIg0KICAgICAgICAgICAgICAgICAgICB4bWxuczpzYW1sPSJ1cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6YXNzZXJ0aW9uIiBJRD0iXzdmZTUxMGNjOGU1MWFhNDE1NThhIg0KICAgICAgICAgICAgICAgICAgICBJc3N1ZUluc3RhbnQ9IjIwMjEtMDEtMjFUMTY6NDY6MDVaIiBQcm92aWRlck5hbWU9IlNpbXBsZSBTQU1MIFNlcnZpY2UgUHJvdmlkZXIiDQogICAgICAgICAgICAgICAgICAgIEFzc2VydGlvbkNvbnN1bWVyU2VydmljZVVSTD0iaHR0cDovL2xvY2FsaG9zdDo3MDcwL3NhbWwvc3NvIg0KICAgICAgICAgICAgICAgICAgICBEZXN0aW5hdGlvbj0iaHR0cDovL2xvY2FsaG9zdDo5MDExL3NhbWx2Mi9sb2dpbi81YjJlNDgzZi03NTcyLTQ4NzktODE3ZS0xYTkwYWM0NGU3NTciDQogICAgICAgICAgICAgICAgICAgIFByb3RvY29sQmluZGluZz0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6Mi4wOmJpbmRpbmdzOkhUVFAtUE9TVCIgVmVyc2lvbj0iMi4wIj4NCiAgPHNhbWw6SXNzdWVyPnVybjpleGFtcGxlOnNwPC9zYW1sOklzc3Vlcj4NCiAgPFNpZ25hdHVyZSB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC8wOS94bWxkc2lnIyI+DQogICAgPFNpZ25lZEluZm8+DQogICAgICA8Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMTAveG1sLWV4Yy1jMTRuIyIvPg0KICAgICAgPFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMDQveG1sZHNpZy1tb3JlI3JzYS1zaGEyNTYiLz4NCiAgICAgIDxSZWZlcmVuY2UgVVJJPSIjXzdmZTUxMGNjOGU1MWFhNDE1NThhIj4NCiAgICAgICAgPFRyYW5zZm9ybXM+DQogICAgICAgICAgPFRyYW5zZm9ybSBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyNlbnZlbG9wZWQtc2lnbmF0dXJlIi8+DQogICAgICAgICAgPFRyYW5zZm9ybSBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvMTAveG1sLWV4Yy1jMTRuIyIvPg0KICAgICAgICA8L1RyYW5zZm9ybXM+DQogICAgICAgIDxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGVuYyNzaGEyNTYiLz4NCiAgICAgICAgPERpZ2VzdFZhbHVlPjV4V2cvaWRqOGpNV2Z3ZWRmaksyQkVZa2QveUxXY2pNa2ZKK1ZmOHQrRkE9PC9EaWdlc3RWYWx1ZT4NCiAgICAgIDwvUmVmZXJlbmNlPg0KICAgIDwvU2lnbmVkSW5mbz4NCiAgICA8U2lnbmF0dXJlVmFsdWU+DQogICAgICBsZ05CSEZ4UHFueHVKRmVRa0cwN3dNY0JwZll3TkVBc2pMeWpQTTBsQit5Nm8rNEtDSzN0U2padXVSUVlNWTRJb3J6Uk95b3piZGtsRitCT2UxL0tKNFhxRGhFaXFlbUEyTGszcEliakJQbit6NDdGcER0NWdsQUVxY3NmMlI2RDhKTndkNWJxSmgxYnVITXNUQ3dIOFhPVHZpdHlxQXZrZmp4WVhNU290SDFWSWxrRWxjZFF6aXA5ZlhsZW1ZdExCdXoybG5sTHYyS01DSkRpYTlQTzZrSHQySTRBL2s0WXBNRmx2NlF0aGlPcjdlVjROOWIxVk43VUxYRHJlUS9OUDhtZWdtWGVBcWxaMC81VnlXdGRYQ1E0QUlSUVlUeW5mTlZ3TDA1VG5JOXNYZDl5WTdPbXk5WVJwdEYzaHZBWVFqd0t1ak90bjNGUnJNSldKMzRha3c9PQ0KICAgIDwvU2lnbmF0dXJlVmFsdWU+DQogICAgPEtleUluZm8+DQogICAgICA8WDUwOURhdGE+DQogICAgICAgIDxYNTA5Q2VydGlmaWNhdGU+DQogICAgICAgICAgTUlJRFV6Q0NBanVnQXdJQkFnSUpBUEowbUE2V3pPcHZNQTBHQ1NxR1NJYjNEUUVCQ3dVQU1HQXhDekFKQmdOVkJBWVRBbFZUTVJNd0VRWURWUVFJRXdwRFlXeHBabTl5Ym1saE1SWXdGQVlEVlFRSEV3MVRZVzRnUm5KaGJtTnBjMk52TVJBd0RnWURWUVFLRXdkS1lXNXJlVU52TVJJd0VBWURWUVFERXdsc2IyTmhiR2h2YzNRd0hoY05NVFF3TXpFeU1UazBOak16V2hjTk1qY3hNVEU1TVRrME5qTXpXakJnTVFzd0NRWURWUVFHRXdKVlV6RVRNQkVHQTFVRUNCTUtRMkZzYVdadmNtNXBZVEVXTUJRR0ExVUVCeE1OVTJGdUlFWnlZVzVqYVhOamJ6RVFNQTRHQTFVRUNoTUhTbUZ1YTNsRGJ6RVNNQkFHQTFVRUF4TUpiRzlqWVd4b2IzTjBNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXRsTkR5NERSMnRoWjJERGNpSVRvZlVwd1laY25Yay85cHFEdDhWMTZqQkQwMnVPZC9UZHlzZ2lLTGpyWlpiQy9YME9YMUVGZTVkTjY1VXJMT0RRQkJ6WjMvOFBZejY4MTlNS2M5aXJWOCs3MzJINWRHd3pnbVlCWUQrcXFmNEJjUjM2TDdUam1Pd2prZSsxY01jR2crV1hWU1hRTS9kalN4aFFIaldOamtSdDFUL21MZmxxTXFwb3B6Y21BUFFETEVIRXJ0dWFtOVh0dWRqaUZNOHI1anp2bXUvVXBJUGliYndBWThxM3NUUHBFN0pCTHI2SXk0cEJBY2lMbFhhNE5yRFE4YUw4akZwaWhqdm0rdUhWTUhNR215bkdpY0dRTGdyRktPV3M2NTVtVlZXWGZET2U2SjVwaUJYcjFteW5uQnN0ZGRTYWxaNWFMQVdGOGc2c3pmUUlEQVFBQm94QXdEakFNQmdOVkhSTUJBZjhFQWpBQU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQ2xaeStnTVlrTmZvK2RRakV1dmJ2eDYyTU1SM1dka3BmZXk0M1pnUHF4MTh2cEcwUDdhSXFUeWJreFRraGkvQXc4cExEY0l2QVBaSHFsTWZMQ05Cci80K3NucXJMbzNPaUdaSTFobDlRT0czaFFta3JqVDEwaGx5WFJTM29UbmpENWJoRGoraW5iRzFpOVFSSzdQTzBQUXFXaElLZ3J0THlZcDNXdlM2WjljWVh3UXQ1RmNZYmhLcCtDK2t2Q3pxK1RmYlFhbWx2ZWhXakJVTlIyN0NFMTFNLy9XVEYwbmZiT0Z1MzJFQzZrQjBFR2Q2UFRJd2h0eTJ6SHhnKyt1WU1qQVVMK1pOdU5pYU1jMzU1b1h2THRoMXE1cmszR2EzdW5wQmptUTdvYlUyLzQvV2RKblBmdmxEMmt0QVYvUzVkVlNLU0RObWthZzhJWDBuSGIvMUZODQogICAgICAgIDwvWDUwOUNlcnRpZmljYXRlPg0KICAgICAgPC9YNTA5RGF0YT4NCiAgICA8L0tleUluZm8+DQogIDwvU2lnbmF0dXJlPg0KICA8c2FtbHA6TmFtZUlEUG9saWN5IEZvcm1hdD0idXJuOm9hc2lzOm5hbWVzOnRjOlNBTUw6MS4xOm5hbWVpZC1mb3JtYXQ6ZW1haWxBZGRyZXNzIiBBbGxvd0NyZWF0ZT0idHJ1ZSIvPg0KICA8c2FtbHA6UmVxdWVzdGVkQXV0aG5Db250ZXh0IENvbXBhcmlzb249ImV4YWN0Ij4NCiAgICA8c2FtbDpBdXRobkNvbnRleHRDbGFzc1JlZj51cm46b2FzaXM6bmFtZXM6dGM6U0FNTDoyLjA6YWM6Y2xhc3NlczpQYXNzd29yZFByb3RlY3RlZFRyYW5zcG9ydA0KICAgIDwvc2FtbDpBdXRobkNvbnRleHRDbGFzc1JlZj4NCiAgPC9zYW1scDpSZXF1ZXN0ZWRBdXRobkNvbnRleHQ+DQo8L3NhbWxwOkF1dGhuUmVxdWVzdD4=\";    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    PublicKey publicKey = new RSAPublicKeyImpl        (new BigInteger(\"23016430918823899869174537266594866915196701755262955756947374683306171050449785978041642070945082562110926617344211216571596575890159654912559343561454566120924390651417182396241104494630512996615232908509829811443784313485862019497373006302688901954848508137355590138442254765794572625586049567608157223736747587462558785268970406066201827350377828581492579969240135441642716939367190425379788145244337250560138881783025442595121210838086638484878363941229167629103738547784336822433469701246494321129732432091196962736034404069520496182669787723781485938596516343326251546340541402004104537790138422441873446220669\"),            new BigInteger(\"65537\"));    TestPostBindingSignatureHelper signatureHelper = new TestPostBindingSignatureHelper(KeySelector.singletonKeySelector(publicKey), true);    AuthenticationRequest request = service.parseRequestPostBinding(encodedXML, authRequest -> signatureHelper);    assertEquals(request.id, \"_7fe510cc8e51aa41558a\");    assertEquals(request.issuer, \"urn:example:sp\");    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");  }  @Test(dataProvider = \"maxLineLength\")  public void parseRequest_includeLineReturns(int maxLineLength) throws Exception {    String xml = new String(Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-control.xml\")));    String encodedXML = new String(Files.readAllBytes(Paths.get(\"src/test/xml/deflated/authn-request-control.txt\")));    List<String> lines = new ArrayList<>();    for (int i = 0; i < encodedXML.length(); ) {      lines.add(encodedXML.substring(i, Math.min(i + maxLineLength, encodedXML.length())));      i = i + maxLineLength;    }    String withLineReturns = String.join(\"\\n\", lines);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = service.parseRequestRedirectBinding(withLineReturns, null, authRequest -> new TestRedirectBindingSignatureHelper());    assertEquals(request.id, \"_809707f0030a5d00620c9d9df97f627afe9dcc24\");    assertEquals(request.issuer, \"http:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test(dataProvider = \"bindings\")  public void parseRequest_noNameIdPolicy(Binding binding) throws Exception {    String xml = new String(Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-noNameIdPolicy.xml\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-noNameIdPolicy.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-noNameIdPolicy.txt\")));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = binding == Binding.HTTP_Redirect        ? service.parseRequestRedirectBinding(encodedXML, null, authRequest -> new TestRedirectBindingSignatureHelper())        : service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper());    assertEquals(request.id, \"id_4c6e5aa3\");    assertEquals(request.issuer, \"https:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test(dataProvider = \"bindings\")  public void parseRequest_verifySignature(Binding binding) throws Exception {    String xml = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/authn-request-redirect-signed.xml\")        : Paths.get(\"src/test/xml/authn-request-post-signed.xml\")));    String relayState = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/relay-state/authn-request-redirect.txt\")        : Paths.get(\"src/test/xml/relay-state/authn-request-post.txt\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-signed.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-signed.txt\")));    String signature = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/signature/authn-request-redirect.txt\")        : Paths.get(\"src/test/xml/signature/authn-request-post.txt\")));    PublicKey publicKey = KeyFactory.getInstance(\"RSA\")                                    .generatePublic(                                        new X509EncodedKeySpec(                                            Base64.getDecoder()                                                  .decode(                                                      Files.readAllBytes(binding == Binding.HTTP_Redirect                                                          ? Paths.get(\"src/test/xml/public-key/authn-request-redirect.txt\")                                                          : Paths.get(\"src/test/xml/public-key/authn-request-post.txt\"))                                                  )));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = binding == Binding.HTTP_Redirect        ? service.parseRequestRedirectBinding(encodedXML, relayState, authRequest -> new TestRedirectBindingSignatureHelper(Algorithm.RS256, publicKey, signature, true))        : service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper(KeySelector.singletonKeySelector(publicKey), true));    assertEquals(request.id, binding == Binding.HTTP_Redirect ? \"ID_025417c8-50c8-4916-bfe0-e05694f8cea7\" : \"ID_26d69170-fc73-4b62-8bb6-c72769216134\");    assertEquals(request.issuer, \"http:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test(dataProvider = \"bindings\")  public void parseRequest_verifySignature_badSignature(Binding binding) throws Exception {    String relayState = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/relay-state/authn-request-redirect.txt\")        : Paths.get(\"src/test/xml/relay-state/authn-request-post.txt\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-signed.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-signed-badSignature.txt\")));    String signature = new String(Files.readAllBytes(Paths.get(\"src/test/xml/signature/authn-request-redirect-bad.txt\")));     PublicKey publicKey = KeyFactory.getInstance(\"RSA\")                                    .generatePublic(                                        new X509EncodedKeySpec(                                            Base64.getDecoder()                                                  .decode(                                                      Files.readAllBytes(binding == Binding.HTTP_Redirect                                                          ? Paths.get(\"src/test/xml/public-key/authn-request-redirect.txt\")                                                          : Paths.get(\"src/test/xml/public-key/authn-request-post.txt\"))                                                  )));    try {      DefaultSAMLv2Service service = new DefaultSAMLv2Service();      if (binding == Binding.HTTP_Redirect) {        service.parseRequestRedirectBinding(encodedXML, relayState, request -> new TestRedirectBindingSignatureHelper(Algorithm.RS256, publicKey, signature, true));      } else {        service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper(KeySelector.singletonKeySelector(publicKey), true));      }      fail(\"Should have failed signature validation\");    } catch (SAMLException e) {      assertEquals(e.getMessage(), \"Invalid SAML v2.0 operation. The signature is invalid.\");    }  }  @Test(dataProvider = \"bindings\")  public void parseRequest_withNameIdPolicy(Binding binding) throws Exception {    String xml = new String(Files.readAllBytes(Paths.get(\"src/test/xml/authn-request-control.xml\")));    String encodedXML = new String(Files.readAllBytes(binding == Binding.HTTP_Redirect        ? Paths.get(\"src/test/xml/deflated/authn-request-control.txt\")        : Paths.get(\"src/test/xml/encoded/authn-request-control.txt\")));    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationRequest request = binding == Binding.HTTP_Redirect        ? service.parseRequestRedirectBinding(encodedXML, null, authRequest -> new TestRedirectBindingSignatureHelper())        : service.parseRequestPostBinding(encodedXML, authRequest -> new TestPostBindingSignatureHelper());    assertEquals(request.id, \"_809707f0030a5d00620c9d9df97f627afe9dcc24\");    assertEquals(request.issuer, \"http:    assertEquals(request.nameIdFormat, NameIDFormat.EmailAddress);    assertEquals(request.version, \"2.0\");    assertEquals(request.xml.replace(\"\\r\\n\", \"\\n\"), xml.replace(\"\\r\\n\", \"\\n\"));  }  @Test  public void parseResponse() throws Exception {    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");    PublicKey key;    try (InputStream is = Files.newInputStream(Paths.get(\"src/test/certificates/certificate.cer\"))) {      Certificate cert = cf.generateCertificate(is);      key = cert.getPublicKey();    }    byte[] ba = Files.readAllBytes(Paths.get(\"src/test/xml/encodedResponse.txt\"));    String encodedResponse = new String(ba);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationResponse response = service.parseResponse(encodedResponse, true, KeySelector.singletonKeySelector(key));    assertEquals(response.destination, \"https:    assertTrue(response.assertion.conditions.notBefore.isBefore(ZonedDateTime.now()));    assertTrue(ZonedDateTime.now().isAfter(response.assertion.conditions.notOnOrAfter));    assertTrue(response.issueInstant.isBefore(ZonedDateTime.now()));    assertEquals(response.issuer, \"https:    assertEquals(response.status.code, ResponseStatus.Success);    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.subject.nameID.format, NameIDFormat.EmailAddress);  }  @Test  public void parseResponse_handleNilAttribute() throws Exception {    byte[] ba = Files.readAllBytes(Paths.get(\"src/test/xml/deflated/example-response.txt\"));    String encodedResponse = new String(ba);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationResponse response = service.parseResponse(encodedResponse, false, null);    assertEquals(response.destination, \"http:    assertTrue(response.assertion.conditions.notBefore.isBefore(ZonedDateTime.now()));    assertEquals(response.issuer, \"http:    assertEquals(response.status.code, ResponseStatus.Success);    assertEquals(response.assertion.attributes.get(\"uid\").size(), 1);    assertEquals(response.assertion.attributes.get(\"uid\").get(0), \"test\");    assertEquals(response.assertion.attributes.get(\"mail\").size(), 1);    assertEquals(response.assertion.attributes.get(\"mail\").get(0), \"test@example.com\");    assertEquals(response.assertion.attributes.get(\"eduPersonAffiliation\").size(), 2);    assertEquals(response.assertion.attributes.get(\"eduPersonAffiliation\").get(0), \"users\");    assertEquals(response.assertion.attributes.get(\"eduPersonAffiliation\").get(1), \"examplerole1\");    assertEquals(response.assertion.attributes.get(\"memberOf\").size(), 1);    assertEquals(response.assertion.attributes.get(\"memberOf\").get(0), \"\");    assertEquals(response.assertion.attributes.get(\"PersonImmutableID\").size(), 1);    assertNull(response.assertion.attributes.get(\"PersonImmutableID\").get(0));    assertEquals(response.assertion.subject.nameID.format, NameIDFormat.Transient);  }  @Test(dataProvider = \"maxLineLength\")  public void parseResponse_includeLineReturns(int maxLineLength) throws Exception {    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");    PublicKey key;    try (InputStream is = Files.newInputStream(Paths.get(\"src/test/certificates/certificate.cer\"))) {      Certificate cert = cf.generateCertificate(is);      key = cert.getPublicKey();    }    byte[] ba = Files.readAllBytes(Paths.get(\"src/test/xml/encodedResponse.txt\"));    String encodedResponse = new String(ba);    List<String> lines = new ArrayList<>();    for (int i = 0; i < encodedResponse.length(); ) {      lines.add(encodedResponse.substring(i, Math.min(i + maxLineLength, encodedResponse.length())));      i = i + maxLineLength;    }    String withLineReturns = String.join(\"\\n\", lines);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    AuthenticationResponse response = service.parseResponse(withLineReturns, true, KeySelector.singletonKeySelector(key));    assertEquals(response.destination, \"https:    assertTrue(response.assertion.conditions.notBefore.isBefore(ZonedDateTime.now()));    assertTrue(ZonedDateTime.now().isAfter(response.assertion.conditions.notOnOrAfter));    assertTrue(response.issueInstant.isBefore(ZonedDateTime.now()));    assertEquals(response.issuer, \"https:    assertEquals(response.status.code, ResponseStatus.Success);    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.attributes.get(\"http:    assertEquals(response.assertion.subject.nameID.format, NameIDFormat.EmailAddress);  }  @Test  public void parseResponse_signatureCheck_badSignature() throws Exception {    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");    PublicKey key;    try (InputStream is = Files.newInputStream(Paths.get(\"src/test/certificates/certificate.cer\"))) {      Certificate cert = cf.generateCertificate(is);      key = cert.getPublicKey();    }    byte[] ba = Files.readAllBytes(Paths.get(\"src/test/xml/encodedResponse-badSignature.txt\"));    String encodedResponse = new String(ba);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    try {      service.parseResponse(encodedResponse, true, KeySelector.singletonKeySelector(key));      fail(\"Should have thrown an exception\");    } catch (SAMLException e) {      assertEquals(e.getMessage(), \"Invalid SAML v2.0 operation. The signature is invalid.\");    }  }  @Test  public void parseResponse_signatureCheck_missing() throws Exception {    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");    PublicKey key;    try (InputStream is = Files.newInputStream(Paths.get(\"src/test/certificates/certificate.cer\"))) {      Certificate cert = cf.generateCertificate(is);      key = cert.getPublicKey();    }    byte[] ba = Files.readAllBytes(Paths.get(\"src/test/xml/encodedResponse-signatureRemoved.txt\"));    String encodedResponse = new String(ba);    DefaultSAMLv2Service service = new DefaultSAMLv2Service();    try {      service.parseResponse(encodedResponse, true, KeySelector.singletonKeySelector(key));      fail(\"Should have thrown an exception\");    } catch (SAMLException e) {      assertEquals(e.getMessage(), \"Invalid SAML v2.0 ope"}
{"code": "import java.util.regex.Matcher;import java.util.regex.Pattern;public class VFSURIValidator {private String local_uri, local_protocol, local_user, local_pass;private String local_hostname, local_port, local_file;public boolean assertEquals(String _s1, String _s2) {if ((_s1 == null) || (_s2 == null)) {System.out.println(\"FATAL assertEquals -- _s1 || _s2 == null\");System.out.println(\"_s1=\" + _s1 + \"=\");System.out.println(\"_s2=\" + _s2 + \"=\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}if (_s1.equals(_s2)) {} else {System.out.println(\"FATAL assertEquals -- _s1 != _s2 \");System.out.println(\"_s1=\" + _s1 + \"=\");System.out.println(\"_s2=\" + _s2 + \"=\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}return false;}public boolean assertNull(String _s1) {if (_s1 != null) {System.out.println(\"FATAL assertNull -- _s1  != null\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}return false;}public boolean assertnotNull(String _s1) {if (_s1 == null) {System.out.println(\"FATAL assertnoNull -- _s1  != null\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}return false;}public String getUri() {if (local_uri.equals(\"\"))local_uri = null;return local_uri;}public String getProtocol() {if ((local_protocol != null) && (local_protocol.equals(\"\")))local_protocol = null;return local_protocol;}public String getUser() {if ((local_user != null) && (local_user.equals(\"\")))local_user = null;return local_user;}public String getPassword() {if ((local_pass != null) && (local_pass.equals(\"\")))local_pass = null;return local_pass;}public String getHostname() {if ((local_hostname != null) && (local_hostname.equals(\"\")))local_hostname = null;return local_hostname;}public String getPort() {if (local_port == null) {return local_port;}if (local_port.startsWith(\":\")) {local_port = local_port.substring(1);}if ((local_port != null) && (local_port.equals(\"\")))local_port = null;return local_port;}public String getFile() {if ((local_file != null) && (local_file.equals(\"\")))local_file = null;return local_file;}public boolean isValid(String _uri) {boolean ret = false;boolean ends_with_slash = false;String protocol = null;String user_pass = null;String hostname = null;String port = null;String bad_port = null;String drive = null;String file = null;local_uri = null;local_protocol = null;local_user = null;local_pass = null;local_hostname = null;local_port = null;local_file = null;Pattern p_file1 = Pattern.compile(\"(file|FILE):local_uri = _uri;local_protocol = protocol;local_user = null;local_pass = null;local_hostname = null;local_port = null;if ((drive != null) && (file != null)) {local_file = drive + file;} else if ((path_start != null) && (drive == null) && (file != null)) {local_file = path_start + file;} else if ((drive != null) && (file == null)) {local_file = drive;} else {local_file = file;}return true;}if (_uri.endsWith(\"/\")) {int iend = _uri.length();_uri = _uri.substring(0, iend - 1);ends_with_slash = true;}Pattern p_ftp2 = Pattern.compile(\"(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB):public static void main(String[] args) {String s;s = \"files:VFSURIValidator v = new VFSURIValidator();if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"files:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTPS:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftps:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"files123:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"fiLE:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/a\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/a\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/b\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/b\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/a\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/a\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/b\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/b\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertNull(v.getUser());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertNull(v.getUser());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPassword());v.assertEquals(v.getPort(), \"1\");v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertNull(v.getUser());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPassword());v.assertEquals(v.getPort(), \"12345\");v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"123\");v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:a\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass::\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_dir/\");s = \"ftp: if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:/ /user:pass:@machine/the_file\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:/ /user:pass:@machine\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"1\");v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"12345\");v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"123\");v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_dir/\");s = \"FTP: if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:/ /user:pass:@machine/the_file\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:/ /user:pass:@machine\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"1\");v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"12345\");v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"123\");v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_dir/\");s = \"sftp: if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:/ /user:pass%3A@machine/the_file\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:/ /user:pass%3A@machine\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"SFTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"SFTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"SFTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"SFTP\");v.assertNull(v.getUser());v.assertN", "nl": "import java.util.regex.Matcher;import java.util.regex.Pattern;public class VFSURIValidator {private String local_uri, local_protocol, local_user, local_pass;private String local_hostname, local_port, local_file;public boolean assertEquals(String _s1, String _s2) {if ((_s1 == null) || (_s2 == null)) {System.out.println(\"FATAL assertEquals -- _s1 || _s2 == null\");System.out.println(\"_s1=\" + _s1 + \"=\");System.out.println(\"_s2=\" + _s2 + \"=\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}if (_s1.equals(_s2)) {} else {System.out.println(\"FATAL assertEquals -- _s1 != _s2 \");System.out.println(\"_s1=\" + _s1 + \"=\");System.out.println(\"_s2=\" + _s2 + \"=\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}return false;}public boolean assertNull(String _s1) {if (_s1 != null) {System.out.println(\"FATAL assertNull -- _s1  != null\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}return false;}public boolean assertnotNull(String _s1) {if (_s1 == null) {System.out.println(\"FATAL assertnoNull -- _s1  != null\");Exception e = new Exception(\"\");e.printStackTrace();System.exit(10);}return false;}public String getUri() {if (local_uri.equals(\"\"))local_uri = null;return local_uri;}public String getProtocol() {if ((local_protocol != null) && (local_protocol.equals(\"\")))local_protocol = null;return local_protocol;}public String getUser() {if ((local_user != null) && (local_user.equals(\"\")))local_user = null;return local_user;}public String getPassword() {if ((local_pass != null) && (local_pass.equals(\"\")))local_pass = null;return local_pass;}public String getHostname() {if ((local_hostname != null) && (local_hostname.equals(\"\")))local_hostname = null;return local_hostname;}public String getPort() {if (local_port == null) {return local_port;}if (local_port.startsWith(\":\")) {local_port = local_port.substring(1);}if ((local_port != null) && (local_port.equals(\"\")))local_port = null;return local_port;}public String getFile() {if ((local_file != null) && (local_file.equals(\"\")))local_file = null;return local_file;}public boolean isValid(String _uri) {boolean ret = false;boolean ends_with_slash = false;String protocol = null;String user_pass = null;String hostname = null;String port = null;String bad_port = null;String drive = null;String file = null;local_uri = null;local_protocol = null;local_user = null;local_pass = null;local_hostname = null;local_port = null;local_file = null;Pattern p_file1 = Pattern.compile(\"(file|FILE):local_uri = _uri;local_protocol = protocol;local_user = null;local_pass = null;local_hostname = null;local_port = null;if ((drive != null) && (file != null)) {local_file = drive + file;} else if ((path_start != null) && (drive == null) && (file != null)) {local_file = path_start + file;} else if ((drive != null) && (file == null)) {local_file = drive;} else {local_file = file;}return true;}if (_uri.endsWith(\"/\")) {int iend = _uri.length();_uri = _uri.substring(0, iend - 1);ends_with_slash = true;}Pattern p_ftp2 = Pattern.compile(\"(ftp|FTP|sftp|SFTP|http|HTTP|https|HTTPS|webdav|WEBDAV|smb|SMB):public static void main(String[] args) {String s;s = \"files:VFSURIValidator v = new VFSURIValidator();if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"files:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTPS:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftps:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"files123:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"fiLE:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/a\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/a\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/b\");s = \"file:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"file\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/b\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"c:/a\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"d:/a\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"e:/b\");s = \"FILE:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FILE\");v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"z:/b\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertNull(v.getUser());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertNull(v.getUser());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPassword());v.assertEquals(v.getPort(), \"1\");v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertNull(v.getUser());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPassword());v.assertEquals(v.getPort(), \"12345\");v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"123\");v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"ftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"ftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_dir/\");s = \"ftp: if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:/ /user:pass:@machine/the_file\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:/ /user:pass:@machine\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"ftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"1\");v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"12345\");v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"123\");v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"FTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"FTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_dir/\");s = \"FTP: if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:/ /user:pass:@machine/the_file\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:/ /user:pass:@machine\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"FTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"1\");v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"12345\");v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"123\");v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"sftp:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"sftp\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass:\");v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_dir/\");s = \"sftp: if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:/ /user:pass:@machine/the_file\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:/ /user:pass:@machine\";if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"sftp:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"SFTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"SFTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertNull(v.getPort());v.assertEquals(v.getFile(), \"/the_file\");s = \"SFTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"SFTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"1\");v.assertEquals(v.getFile(), \"/the_file\");s = \"SFTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"SFTP\");v.assertNull(v.getUser());v.assertNull(v.getPassword());v.assertEquals(v.getHostname(), \"machine\");v.assertEquals(v.getPort(), \"12345\");v.assertEquals(v.getFile(), \"/the_file\");s = \"SFTP:if (v.isValid(s)) {v.error_msg(s);}v.assertNull(v.getProtocol());v.assertNull(v.getUser());v.assertNull(v.getHostname());v.assertNull(v.getPassword());v.assertNull(v.getPort());v.assertNull(v.getFile());s = \"SFTP:if (!v.isValid(s)) {v.error_msg(s);}v.assertEquals(v.getProtocol(), \"SFTP\");v.assertEquals(v.getUser(), \"user\");v.assertEquals(v.getPassword(), \"pass\");v.assertEquals(v.getH"}
{"code": "import com.manydesigns.portofino.dispatcher.security.RolesPermission;import io.jsonwebtoken.*;import io.jsonwebtoken.io.Decoders;import org.apache.commons.configuration2.Configuration;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import javax.crypto.spec.SecretKeySpec;import java.io.Serializable;import java.security.Key;import java.util.*;public class JWTRealm extends AuthorizingRealm {    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        Set<String> roles = getRoles(principals);        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(roles);        simpleAuthorizationInfo.addObjectPermission(new RolesPermission(roles));        return simpleAuthorizationInfo;    }    protected Set<String> getRoles(PrincipalCollection principals) {        return getRoles(principals.getPrimaryPrincipal());    }    protected Set<String> getRoles(Object principal) {        HashSet<String> roles = new HashSet<>();        if(principal instanceof Map) {            Object rolesList = ((Map) principal).get(\"roles\");            if(rolesList instanceof Collection) {                roles.addAll((Collection<? extends String>) rolesList);            }        }        return roles;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String secret = getSecret();        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());        Jws<Claims> jwt = Jwts.parser().                setSigningKey(key).                parseClaimsJws((String) token.getPrincipal());        Map<String, Serializable> principal = getPrincipal(jwt);        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());    }    protected SignatureAlgorithm getSignatureAlgorithm() {        return SignatureAlgorithm.HS512;    }    protected Map<String, Serializable> getPrincipal(Jws<Claims> jwt) {        Map<String, Serializable> principal = new HashMap<>();        principal.put(\"jwt\", (Serializable) jwt.getBody());        return principal;    }    protected Configuration getConfiguration() {        return null;     }    protected String getSecret() {        return getConfiguration().getString(\"jwt.secret\");    }    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof JSONWebToken;    }}", "nl": "import com.manydesigns.portofino.dispatcher.security.RolesPermission;import io.jsonwebtoken.Jwt;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import io.jsonwebtoken.io.Decoders;import org.apache.commons.configuration2.Configuration;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import javax.crypto.spec.SecretKeySpec;import java.io.Serializable;import java.security.Key;import java.util.*;public class JWTRealm extends AuthorizingRealm {    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        Set<String> roles = getRoles(principals);        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(roles);        simpleAuthorizationInfo.addObjectPermission(new RolesPermission(roles));        return simpleAuthorizationInfo;    }    protected Set<String> getRoles(PrincipalCollection principals) {        return getRoles(principals.getPrimaryPrincipal());    }    protected Set<String> getRoles(Object principal) {        HashSet<String> roles = new HashSet<>();        if(principal instanceof Map) {            Object rolesList = ((Map) principal).get(\"roles\");            if(rolesList instanceof Collection) {                roles.addAll((Collection<? extends String>) rolesList);            }        }        return roles;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        String secret = getSecret();        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());        Jwt jwt = Jwts.parser().                setSigningKey(key).                parse((String) token.getPrincipal());        Map<String, Serializable> principal = getPrincipal(jwt);        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());    }    protected SignatureAlgorithm getSignatureAlgorithm() {        return SignatureAlgorithm.HS512;    }    protected Map<String, Serializable> getPrincipal(Jwt jwt) {        Map<String, Serializable> principal = new HashMap<>();        principal.put(\"jwt\", (Serializable) jwt.getBody());        return principal;    }    protected Configuration getConfiguration() {        return null;     }    protected String getSecret() {        return getConfiguration().getString(\"jwt.secret\");    }    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof JSONWebToken;    }}"}
{"code": "import com.manydesigns.elements.reflection.ClassAccessor;import com.manydesigns.elements.reflection.JavaClassAccessor;import com.manydesigns.portofino.code.CodeBase;import com.manydesigns.portofino.security.SecurityLogic;import io.jsonwebtoken.*;import io.jsonwebtoken.io.Decoders;import org.apache.commons.configuration2.Configuration;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.credential.PasswordMatcher;import org.apache.shiro.authc.credential.PasswordService;import org.apache.shiro.authz.AuthorizationException;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.codec.Base64;import org.apache.shiro.crypto.hash.HashService;import org.apache.shiro.crypto.hash.format.HashFormat;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.jetbrains.annotations.NotNull;import org.joda.time.DateTime;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import javax.crypto.spec.SecretKeySpec;import java.io.*;import java.security.Key;import java.util.*;import java.util.concurrent.atomic.AtomicBoolean;public abstract class AbstractPortofinoRealm extends AuthorizingRealm implements PortofinoRealm {    public static final String copyright = \"Copyright (C) 2005-2020 ManyDesigns srl\";    public static final String JWT_EXPIRATION_PROPERTY = \"jwt.expiration\";    public static final String JWT_SECRET_PROPERTY = \"jwt.secret\";    @Autowired    protected Configuration portofinoConfiguration;    @Autowired    protected CodeBase codeBase;    protected PasswordService passwordService;    protected boolean legacyHashing = false;    private static final Logger logger = LoggerFactory.getLogger(AbstractPortofinoRealm.class);    protected AbstractPortofinoRealm() {        setup(new PlaintextHashService(), new PlaintextHashFormat());        legacyHashing = true;    }    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof JSONWebToken || super.supports(token);    }    public AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {        Key key = getJWTKey();        Jws<Claims> jwt;        try {            jwt = Jwts.parser().setSigningKey(key).parseClaimsJws(token.getPrincipal());        } catch (JwtException e) {            throw new AuthenticationException(e);        }        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());        Object principal = extractPrincipalFromWebToken(jwt);        return new SimpleAuthenticationInfo(principal, credentials, getName());    }    protected Object extractPrincipalFromWebToken(Jws<Claims> jwt) {        Map<String, Object> body = jwt.getBody();        String base64Principal = (String) body.get(\"serialized-principal\");        byte[] serializedPrincipal = Base64.decode(base64Principal);        Object principal;        ClassLoader loader = Thread.currentThread().getContextClassLoader();        try {            Thread.currentThread().setContextClassLoader(codeBase.asClassLoader());             ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedPrincipal)) {                @Override                protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {                    return codeBase.loadClass(desc.getName());                }            };            principal = objectInputStream.readObject();            objectInputStream.close();        } catch (Exception e) {            throw new AuthenticationException(e);        } finally {            Thread.currentThread().setContextClassLoader(loader);        }        return principal;    }    public String generateWebToken(Object principal) {        Key key = getJWTKey();        Map<String, Object> claims = new HashMap<>();        claims.put(\"principal\", getPrincipalForWebToken(principal));        ByteArrayOutputStream bytes = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream;        try {            objectOutputStream = new ObjectOutputStream(bytes);            objectOutputStream.writeObject(principal);            objectOutputStream.close();        } catch (IOException e) {            throw new RuntimeException(e);        }        claims.put(\"serialized-principal\", bytes.toByteArray());        int expireAfterMinutes = portofinoConfiguration.getInt(JWT_EXPIRATION_PROPERTY, 30);        return Jwts.builder().                setClaims(claims).                setExpiration(new DateTime().plusMinutes(expireAfterMinutes).toDate()).                signWith(key, SignatureAlgorithm.HS512).                compact();    }    protected Object getPrincipalForWebToken(Object principal) {        return cleanUserPrincipal(principal);    }    protected Object cleanUserPrincipal(Object principal) {        if(principal instanceof Map) {            Map cleanUser = new HashMap();            AtomicBoolean skipped = new AtomicBoolean(false);            ((Map<?, ?>) principal).forEach((k, v) -> {                if (v instanceof List || v instanceof Map) {                    logger.debug(\"Skipping {}\", k);                    skipped.set(true);                } else {                    cleanUser.put(k, v);                }            });            if(skipped.get()) {                logger.debug(\"The user entity has potential self-references that make it unusable as a principal, because it must be serializable to JSON. Returning a non-persistent map with no references.\");                return cleanUser;            } else {                return principal;            }        }        return principal;    }    @NotNull    protected Key getJWTKey() {        String secret = portofinoConfiguration.getString(JWT_SECRET_PROPERTY);        return new SecretKeySpec(Decoders.BASE64.decode(secret), SignatureAlgorithm.HS512.getJcaName());    }    public AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        Object principal = principals.getPrimaryPrincipal();        Set<String> groups = getGroups(principal);        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(groups);        if(groups.contains(SecurityLogic.getAdministratorsGroup(portofinoConfiguration))) {            info.addStringPermission(\"*\");        }        Permission permission = new GroupPermission(groups);        info.setObjectPermissions(Collections.singleton(permission));        return info;    }    @Override    @NotNull    public Set<String> getGroups(Object principal) {        Set<String> groups = new HashSet<>();        groups.add(SecurityLogic.getAllGroup(portofinoConfiguration));        if (principal == null) {            groups.add(SecurityLogic.getAnonymousGroup(portofinoConfiguration));        } else if (principal instanceof Serializable) {            groups.add(SecurityLogic.getRegisteredGroup(portofinoConfiguration));            groups.addAll(loadAuthorizationInfo((Serializable) principal));        } else {            throw new AuthorizationException(\"Invalid principal: \" + principal);        }        return groups;    }    protected Collection<String> loadAuthorizationInfo(Serializable principal) {        return Collections.emptySet();    }    public Set<String> getGroups() {        Set<String> groups = new LinkedHashSet<String>();        groups.add(SecurityLogic.getAllGroup(portofinoConfiguration));        groups.add(SecurityLogic.getAnonymousGroup(portofinoConfiguration));        groups.add(SecurityLogic.getRegisteredGroup(portofinoConfiguration));        groups.add(SecurityLogic.getAdministratorsGroup(portofinoConfiguration));        return groups;    }    @Override    public Serializable getUserById(String encodedUserId) {        throw new UnsupportedOperationException();    }    @Override    public Serializable getUserByEmail(String email) {        throw new UnsupportedOperationException();    }    @Override    public boolean supportsSelfRegistration() {        return false;    }    @Override    public ClassAccessor getSelfRegisteredUserClassAccessor() {        return JavaClassAccessor.getClassAccessor(User.class);    }    @Override    public String getUserPrettyName(Serializable user) {        return user.toString();    }    @Override    public void verifyUser(Serializable user) {        throw new UnsupportedOperationException();    }    @Override    public void changePassword(Serializable user, String oldPassword, String newPassword) {        throw new UnsupportedOperationException();    }    @Override    public String generateOneTimeToken(Serializable user) {        throw new UnsupportedOperationException();    }    @Override    public String[] saveSelfRegisteredUser(Object user) {        throw new UnsupportedOperationException();    }    protected void setup(HashService hashService, HashFormat hashFormat) {        PortofinoPasswordService passwordService = new PortofinoPasswordService();        passwordService.setHashService(hashService);        passwordService.setHashFormat(hashFormat);        PasswordMatcher passwordMatcher = new PasswordMatcher();        passwordMatcher.setPasswordService(passwordService);        setCredentialsMatcher(passwordMatcher);        this.passwordService = passwordService;        this.legacyHashing = false;    }}", "nl": "import com.manydesigns.elements.reflection.ClassAccessor;import com.manydesigns.elements.reflection.JavaClassAccessor;import com.manydesigns.portofino.code.CodeBase;import com.manydesigns.portofino.security.SecurityLogic;import io.jsonwebtoken.Jwt;import io.jsonwebtoken.JwtException;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import io.jsonwebtoken.io.Decoders;import org.apache.commons.configuration2.Configuration;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authc.credential.PasswordMatcher;import org.apache.shiro.authc.credential.PasswordService;import org.apache.shiro.authz.AuthorizationException;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.Permission;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.codec.Base64;import org.apache.shiro.crypto.hash.HashService;import org.apache.shiro.crypto.hash.format.HashFormat;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.jetbrains.annotations.NotNull;import org.joda.time.DateTime;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import javax.crypto.spec.SecretKeySpec;import java.io.*;import java.security.Key;import java.util.*;import java.util.concurrent.atomic.AtomicBoolean;public abstract class AbstractPortofinoRealm extends AuthorizingRealm implements PortofinoRealm {    public static final String copyright = \"Copyright (C) 2005-2020 ManyDesigns srl\";    public static final String JWT_EXPIRATION_PROPERTY = \"jwt.expiration\";    public static final String JWT_SECRET_PROPERTY = \"jwt.secret\";    @Autowired    protected Configuration portofinoConfiguration;    @Autowired    protected CodeBase codeBase;    protected PasswordService passwordService;    protected boolean legacyHashing = false;    private static final Logger logger = LoggerFactory.getLogger(AbstractPortofinoRealm.class);    protected AbstractPortofinoRealm() {        setup(new PlaintextHashService(), new PlaintextHashFormat());        legacyHashing = true;    }    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof JSONWebToken || super.supports(token);    }    public AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {        Key key = getJWTKey();        Jwt jwt;        try {            jwt = Jwts.parser().setSigningKey(key).parse(token.getPrincipal());        } catch (JwtException e) {            throw new AuthenticationException(e);        }        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());        Object principal = extractPrincipalFromWebToken(jwt);        return new SimpleAuthenticationInfo(principal, credentials, getName());    }    protected Object extractPrincipalFromWebToken(Jwt jwt) {        Map body = (Map) jwt.getBody();        String base64Principal = (String) body.get(\"serialized-principal\");        byte[] serializedPrincipal = Base64.decode(base64Principal);        Object principal;        ClassLoader loader = Thread.currentThread().getContextClassLoader();        try {            Thread.currentThread().setContextClassLoader(codeBase.asClassLoader());             ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedPrincipal)) {                @Override                protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {                    return codeBase.loadClass(desc.getName());                }            };            principal = objectInputStream.readObject();            objectInputStream.close();        } catch (Exception e) {            throw new AuthenticationException(e);        } finally {            Thread.currentThread().setContextClassLoader(loader);        }        return principal;    }    public String generateWebToken(Object principal) {        Key key = getJWTKey();        Map<String, Object> claims = new HashMap<>();        claims.put(\"principal\", getPrincipalForWebToken(principal));        ByteArrayOutputStream bytes = new ByteArrayOutputStream();        ObjectOutputStream objectOutputStream;        try {            objectOutputStream = new ObjectOutputStream(bytes);            objectOutputStream.writeObject(principal);            objectOutputStream.close();        } catch (IOException e) {            throw new RuntimeException(e);        }        claims.put(\"serialized-principal\", bytes.toByteArray());        int expireAfterMinutes = portofinoConfiguration.getInt(JWT_EXPIRATION_PROPERTY, 30);        return Jwts.builder().                setClaims(claims).                setExpiration(new DateTime().plusMinutes(expireAfterMinutes).toDate()).                signWith(key, SignatureAlgorithm.HS512).                compact();    }    protected Object getPrincipalForWebToken(Object principal) {        return cleanUserPrincipal(principal);    }    protected Object cleanUserPrincipal(Object principal) {        if(principal instanceof Map) {            Map cleanUser = new HashMap();            AtomicBoolean skipped = new AtomicBoolean(false);            ((Map<?, ?>) principal).forEach((k, v) -> {                if (v instanceof List || v instanceof Map) {                    logger.debug(\"Skipping {}\", k);                    skipped.set(true);                } else {                    cleanUser.put(k, v);                }            });            if(skipped.get()) {                logger.debug(\"The user entity has potential self-references that make it unusable as a principal, because it must be serializable to JSON. Returning a non-persistent map with no references.\");                return cleanUser;            } else {                return principal;            }        }        return principal;    }    @NotNull    protected Key getJWTKey() {        String secret = portofinoConfiguration.getString(JWT_SECRET_PROPERTY);        return new SecretKeySpec(Decoders.BASE64.decode(secret), SignatureAlgorithm.HS512.getJcaName());    }    public AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        Object principal = principals.getPrimaryPrincipal();        Set<String> groups = getGroups(principal);        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(groups);        if(groups.contains(SecurityLogic.getAdministratorsGroup(portofinoConfiguration))) {            info.addStringPermission(\"*\");        }        Permission permission = new GroupPermission(groups);        info.setObjectPermissions(Collections.singleton(permission));        return info;    }    @Override    @NotNull    public Set<String> getGroups(Object principal) {        Set<String> groups = new HashSet<>();        groups.add(SecurityLogic.getAllGroup(portofinoConfiguration));        if (principal == null) {            groups.add(SecurityLogic.getAnonymousGroup(portofinoConfiguration));        } else if (principal instanceof Serializable) {            groups.add(SecurityLogic.getRegisteredGroup(portofinoConfiguration));            groups.addAll(loadAuthorizationInfo((Serializable) principal));        } else {            throw new AuthorizationException(\"Invalid principal: \" + principal);        }        return groups;    }    protected Collection<String> loadAuthorizationInfo(Serializable principal) {        return Collections.emptySet();    }    public Set<String> getGroups() {        Set<String> groups = new LinkedHashSet<String>();        groups.add(SecurityLogic.getAllGroup(portofinoConfiguration));        groups.add(SecurityLogic.getAnonymousGroup(portofinoConfiguration));        groups.add(SecurityLogic.getRegisteredGroup(portofinoConfiguration));        groups.add(SecurityLogic.getAdministratorsGroup(portofinoConfiguration));        return groups;    }    @Override    public Serializable getUserById(String encodedUserId) {        throw new UnsupportedOperationException();    }    @Override    public Serializable getUserByEmail(String email) {        throw new UnsupportedOperationException();    }    @Override    public boolean supportsSelfRegistration() {        return false;    }    @Override    public ClassAccessor getSelfRegisteredUserClassAccessor() {        return JavaClassAccessor.getClassAccessor(User.class);    }    @Override    public String getUserPrettyName(Serializable user) {        return user.toString();    }    @Override    public void verifyUser(Serializable user) {        throw new UnsupportedOperationException();    }    @Override    public void changePassword(Serializable user, String oldPassword, String newPassword) {        throw new UnsupportedOperationException();    }    @Override    public String generateOneTimeToken(Serializable user) {        throw new UnsupportedOperationException();    }    @Override    public String[] saveSelfRegisteredUser(Object user) {        throw new UnsupportedOperationException();    }    protected void setup(HashService hashService, HashFormat hashFormat) {        PortofinoPasswordService passwordService = new PortofinoPasswordService();        passwordService.setHashService(hashService);        passwordService.setHashFormat(hashFormat);        PasswordMatcher passwordMatcher = new PasswordMatcher();        passwordMatcher.setPasswordService(passwordService);        setCredentialsMatcher(passwordMatcher);        this.passwordService = passwordService;        this.legacyHashing = false;    }}"}
{"code": "import com.graphhopper.GHRequest;import com.graphhopper.GHResponse;import com.graphhopper.GraphHopperAPI;import com.graphhopper.GraphHopperConfig;import com.graphhopper.util.Helper;import com.graphhopper.util.Parameters;import com.graphhopper.util.StopWatch;import com.graphhopper.util.TranslationMap;import com.graphhopper.util.shapes.GHPoint;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.inject.Inject;import javax.servlet.http.HttpServletRequest;import javax.ws.rs.*;import javax.ws.rs.container.ContainerRequestContext;import javax.ws.rs.core.Context;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import javax.ws.rs.core.UriInfo;import java.util.*;import static com.graphhopper.util.Parameters.Routing.*;@Path(\"navigate/directions/v5/gh\")public class NavigateResource {    private static final Logger logger = LoggerFactory.getLogger(NavigateResource.class);    private final GraphHopperAPI graphHopper;    private final TranslationMap translationMap;    private final Map<String, String> resolverMap;    @Inject    public NavigateResource(GraphHopperAPI graphHopper, TranslationMap translationMap, GraphHopperConfig config) {        this.graphHopper = graphHopper;        resolverMap = config.asPMap().getObject(\"profiles_mapbox\", new HashMap<>());        if (resolverMap.isEmpty()) {            resolverMap.put(\"driving\", \"car\");            resolverMap.put(\"driving-traffic\", \"car\");            resolverMap.put(\"walking\", \"foot\");            resolverMap.put(\"cycling\", \"bike\");        }        this.translationMap = translationMap;    }    @GET    @Path(\"/{profile}/{coordinatesArray : .+}\")    @Produces({MediaType.APPLICATION_JSON})    public Response doGet(            @Context HttpServletRequest httpReq,            @Context UriInfo uriInfo,            @Context ContainerRequestContext rc,            @QueryParam(\"steps\") @DefaultValue(\"false\") boolean enableInstructions,            @QueryParam(\"voice_instructions\") @DefaultValue(\"false\") boolean voiceInstructions,            @QueryParam(\"banner_instructions\") @DefaultValue(\"false\") boolean bannerInstructions,            @QueryParam(\"roundabout_exits\") @DefaultValue(\"false\") boolean roundaboutExits,            @QueryParam(\"voice_units\") @DefaultValue(\"metric\") String voiceUnits,            @QueryParam(\"overview\") @DefaultValue(\"simplified\") String overview,            @QueryParam(\"geometries\") @DefaultValue(\"polyline\") String geometries,            @QueryParam(\"bearings\") @DefaultValue(\"\") String bearings,            @QueryParam(\"language\") @DefaultValue(\"en\") String localeStr,            @PathParam(\"profile\") String mapboxProfile) {        if (!geometries.equals(\"polyline6\"))            throw new IllegalArgumentException(\"Currently, we only support polyline6\");        if (!enableInstructions)            throw new IllegalArgumentException(\"Currently, you need to enable steps\");        if (!roundaboutExits)            throw new IllegalArgumentException(\"Roundabout exits have to be enabled right now\");        if (!voiceInstructions)            throw new IllegalArgumentException(\"You need to enable voice instructions right now\");        if (!bannerInstructions)            throw new IllegalArgumentException(\"You need to enable banner instructions right now\");        double minPathPrecision = 1;        if (overview.equals(\"full\"))            minPathPrecision = 0;        DistanceUtils.Unit unit;        if (voiceUnits.equals(\"metric\")) {            unit = DistanceUtils.Unit.METRIC;        } else {            unit = DistanceUtils.Unit.IMPERIAL;        }        String ghProfile = resolverMap.getOrDefault(mapboxProfile, mapboxProfile);        List<GHPoint> requestPoints = getPointsFromRequest(httpReq, mapboxProfile);        List<Double> favoredHeadings = getBearing(bearings);        if (favoredHeadings.size() > 0 && favoredHeadings.size() != requestPoints.size()) {            throw new IllegalArgumentException(\"Number of bearings and waypoints did not match\");        }        StopWatch sw = new StopWatch().start();        GHResponse ghResponse = calcRoute(favoredHeadings, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);        if (!ghResponse.hasErrors() && favoredHeadings.size() > 0) {            GHResponse noHeadingResponse = calcRoute(Collections.EMPTY_LIST, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);            if (ghResponse.getBest().getDistance() != noHeadingResponse.getBest().getDistance()) {                ghResponse.getAll().add(noHeadingResponse.getBest());            }        }        float took = sw.stop().getSeconds();        String infoStr = httpReq.getRemoteAddr() + \" \" + httpReq.getLocale() + \" \" + httpReq.getHeader(\"User-Agent\");        String logStr = httpReq.getQueryString() + \" \" + infoStr + \" \" + requestPoints + \", took:\"                + took + \", \" + ghProfile;        Locale locale = Helper.getLocale(localeStr);        DistanceConfig config = new DistanceConfig(unit, translationMap, locale);        if (ghResponse.hasErrors()) {            logger.error(logStr + \", errors:\" + ghResponse.getErrors());            return Response.status(422).entity(NavigateResponseConverter.convertFromGHResponseError(ghResponse)).                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).                    build();        } else {            logger.info(logStr);            return Response.ok(NavigateResponseConverter.convertFromGHResponse(ghResponse, translationMap, locale, config)).                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).                    build();        }    }    private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> requestPoints, String profileStr,                                 String localeStr, boolean enableInstructions, double minPathPrecision) {        GHRequest request;        if (favoredHeadings.size() > 0) {            request = new GHRequest(requestPoints, favoredHeadings);        } else {            request = new GHRequest(requestPoints);        }        request.setProfile(profileStr).                setLocale(localeStr).                putHint(CALC_POINTS, true).                putHint(INSTRUCTIONS, enableInstructions).                putHint(WAY_POINT_MAX_DISTANCE, minPathPrecision).                putHint(Parameters.CH.DISABLE, true).                putHint(Parameters.Routing.PASS_THROUGH, false);        return graphHopper.route(request);    }    private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {        String url = httpServletRequest.getRequestURI();        String urlStart = \"/navigate/directions/v5/gh/\" + profile + \"/\";        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(\"Incorrect URL \" + url);        url = url.substring(urlStart.length());        String[] pointStrings = url.split(\";\");        List<GHPoint> points = new ArrayList<>(pointStrings.length);        for (int i = 0; i < pointStrings.length; i++) {            points.add(GHPoint.fromStringLonLat(pointStrings[i]));        }        return points;    }    static List<Double> getBearing(String bearingString) {        if (bearingString == null || bearingString.isEmpty())            return Collections.EMPTY_LIST;        String[] bearingArray = bearingString.split(\";\", -1);        List<Double> bearings = new ArrayList<>(bearingArray.length);        for (int i = 0; i < bearingArray.length; i++) {            String singleBearing = bearingArray[i];            if (singleBearing.isEmpty()) {                bearings.add(Double.NaN);            } else {                if (!singleBearing.contains(\",\")) {                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);                }                String[] singleBearingArray = singleBearing.split(\",\");                try {                    bearings.add(Double.parseDouble(singleBearingArray[0]));                } catch (NumberFormatException e) {                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);                }            }        }        return bearings;    }}", "nl": "import com.graphhopper.GHRequest;import com.graphhopper.GHResponse;import com.graphhopper.GraphHopperAPI;import com.graphhopper.GraphHopperConfig;import com.graphhopper.util.Helper;import com.graphhopper.util.Parameters;import com.graphhopper.util.StopWatch;import com.graphhopper.util.TranslationMap;import com.graphhopper.util.shapes.GHPoint;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.inject.Inject;import javax.servlet.http.HttpServletRequest;import javax.ws.rs.*;import javax.ws.rs.container.ContainerRequestContext;import javax.ws.rs.core.Context;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import javax.ws.rs.core.UriInfo;import java.util.*;import static com.graphhopper.util.Parameters.Routing.*;@Path(\"navigate/directions/v5/gh\")public class NavigateResource {    private static final Logger logger = LoggerFactory.getLogger(NavigateResource.class);    private final GraphHopperAPI graphHopper;    private final TranslationMap translationMap;    private final Map<String, String> resolverMap;    @Inject    public NavigateResource(GraphHopperAPI graphHopper, TranslationMap translationMap, GraphHopperConfig config) {        this.graphHopper = graphHopper;        resolverMap = config.asPMap().getObject(\"profiles_mapbox\", new HashMap<>());        if (resolverMap.isEmpty()) {            resolverMap.put(\"driving\", \"car\");            resolverMap.put(\"driving-traffic\", \"car\");            resolverMap.put(\"walking\", \"foot\");            resolverMap.put(\"cycling\", \"bike\");        }        this.translationMap = translationMap;    }    @GET    @Path(\"/{profile}/{coordinatesArray : .+}\")    @Produces({MediaType.APPLICATION_JSON})    public Response doGet(            @Context HttpServletRequest httpReq,            @Context UriInfo uriInfo,            @Context ContainerRequestContext rc,            @QueryParam(\"steps\") @DefaultValue(\"false\") boolean enableInstructions,            @QueryParam(\"voice_instructions\") @DefaultValue(\"false\") boolean voiceInstructions,            @QueryParam(\"banner_instructions\") @DefaultValue(\"false\") boolean bannerInstructions,            @QueryParam(\"roundabout_exits\") @DefaultValue(\"false\") boolean roundaboutExits,            @QueryParam(\"voice_units\") @DefaultValue(\"metric\") String voiceUnits,            @QueryParam(\"overview\") @DefaultValue(\"simplified\") String overview,            @QueryParam(\"geometries\") @DefaultValue(\"polyline\") String geometries,            @QueryParam(\"bearings\") @DefaultValue(\"\") String bearings,            @QueryParam(\"language\") @DefaultValue(\"en\") String localeStr,            @PathParam(\"profile\") String mapboxProfile) {        if (!geometries.equals(\"polyline6\"))            throw new IllegalArgumentException(\"Currently, we only support polyline6\");        if (!enableInstructions)            throw new IllegalArgumentException(\"Currently, you need to enable steps\");        if (!roundaboutExits)            throw new IllegalArgumentException(\"Roundabout exits have to be enabled right now\");        if (!voiceInstructions)            throw new IllegalArgumentException(\"You need to enable voice instructions right now\");        if (!bannerInstructions)            throw new IllegalArgumentException(\"You need to enable banner instructions right now\");        double minPathPrecision = 1;        if (overview.equals(\"full\"))            minPathPrecision = 0;        DistanceUtils.Unit unit;        if (voiceUnits.equals(\"metric\")) {            unit = DistanceUtils.Unit.METRIC;        } else {            unit = DistanceUtils.Unit.IMPERIAL;        }        String ghProfile = resolverMap.getOrDefault(mapboxProfile, mapboxProfile);        List<GHPoint> requestPoints = getPointsFromRequest(httpReq, mapboxProfile);        List<Double> favoredHeadings = getBearing(bearings);        if (favoredHeadings.size() > 0 && favoredHeadings.size() != requestPoints.size()) {            throw new IllegalArgumentException(\"Number of bearings and waypoints did not match\");        }        StopWatch sw = new StopWatch().start();        GHResponse ghResponse = calcRoute(favoredHeadings, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);        if (!ghResponse.hasErrors() && favoredHeadings.size() > 0) {            GHResponse noHeadingResponse = calcRoute(Collections.EMPTY_LIST, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);            if (ghResponse.getBest().getDistance() != noHeadingResponse.getBest().getDistance()) {                ghResponse.getAll().add(noHeadingResponse.getBest());            }        }        float took = sw.stop().getSeconds();        String infoStr = httpReq.getRemoteAddr() + \" \" + httpReq.getLocale() + \" \" + httpReq.getHeader(\"User-Agent\");        String logStr = httpReq.getQueryString() + \" \" + infoStr + \" \" + requestPoints + \", took:\"                + took + \", \" + ghProfile;        Locale locale = Helper.getLocale(localeStr);        DistanceConfig config = new DistanceConfig(unit, translationMap, locale);        if (ghResponse.hasErrors()) {            logger.error(logStr + \", errors:\" + ghResponse.getErrors());            return Response.status(422).entity(NavigateResponseConverter.convertFromGHResponseError(ghResponse)).                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).                    build();        } else {            logger.info(logStr);            return Response.ok(NavigateResponseConverter.convertFromGHResponse(ghResponse, translationMap, locale, config)).                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).                    build();        }    }    private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> requestPoints, String profileStr,                                 String localeStr, boolean enableInstructions, double minPathPrecision) {        GHRequest request;        if (favoredHeadings.size() > 0) {            request = new GHRequest(requestPoints, favoredHeadings);        } else {            request = new GHRequest(requestPoints);        }        request.setProfile(profileStr).                setLocale(localeStr).                putHint(CALC_POINTS, true).                putHint(INSTRUCTIONS, enableInstructions).                putHint(WAY_POINT_MAX_DISTANCE, minPathPrecision).                putHint(Parameters.CH.DISABLE, true).                putHint(Parameters.Routing.PASS_THROUGH, false);        return graphHopper.route(request);    }    private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {        String url = httpServletRequest.getRequestURI();        url = url.replaceFirst(\"/navigate/directions/v5/gh/\" + profile + \"/\", \"\");        url = url.replaceAll(\"\\\\?[*]\", \"\");        String[] pointStrings = url.split(\";\");        List<GHPoint> points = new ArrayList<>(pointStrings.length);        for (int i = 0; i < pointStrings.length; i++) {            points.add(GHPoint.fromStringLonLat(pointStrings[i]));        }        return points;    }    static List<Double> getBearing(String bearingString) {        if (bearingString == null || bearingString.isEmpty())            return Collections.EMPTY_LIST;        String[] bearingArray = bearingString.split(\";\", -1);        List<Double> bearings = new ArrayList<>(bearingArray.length);        for (int i = 0; i < bearingArray.length; i++) {            String singleBearing = bearingArray[i];            if (singleBearing.isEmpty()) {                bearings.add(Double.NaN);            } else {                if (!singleBearing.contains(\",\")) {                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);                }                String[] singleBearingArray = singleBearing.split(\",\");                try {                    bearings.add(Double.parseDouble(singleBearingArray[0]));                } catch (NumberFormatException e) {                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);                }            }        }        return bearings;    }}"}
{"code": "import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Type;import java.net.MalformedURLException;import java.net.URL;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.attribute.FileTime;import java.text.DateFormatSymbols;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.Enumeration;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Set;import java.util.TimeZone;import java.util.Vector;import java.util.concurrent.ConcurrentHashMap;import java.util.zip.ZipOutputStream;import javax.annotation.Priority;import javax.inject.Provider;import javax.mail.Message;import javax.mail.Session;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.naming.NamingException;import javax.script.ScriptContext;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.httpclient.Credentials;import org.apache.commons.httpclient.HttpClient;import org.apache.commons.httpclient.URIException;import org.apache.commons.httpclient.UsernamePasswordCredentials;import org.apache.commons.httpclient.auth.AuthScope;import org.apache.commons.httpclient.methods.GetMethod;import org.apache.commons.httpclient.util.URIUtil;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.ArrayUtils;import org.apache.commons.lang3.RandomStringUtils;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.commons.lang3.math.NumberUtils;import org.apache.commons.lang3.reflect.FieldUtils;import org.apache.velocity.VelocityContext;import org.hibernate.HibernateException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.DocumentCreatedEvent;import org.xwiki.bridge.event.DocumentCreatingEvent;import org.xwiki.bridge.event.DocumentDeletedEvent;import org.xwiki.bridge.event.DocumentDeletingEvent;import org.xwiki.bridge.event.DocumentRolledBackEvent;import org.xwiki.bridge.event.DocumentRollingBackEvent;import org.xwiki.bridge.event.DocumentUpdatedEvent;import org.xwiki.bridge.event.DocumentUpdatingEvent;import org.xwiki.bridge.event.WikiCopiedEvent;import org.xwiki.bridge.event.WikiDeletedEvent;import org.xwiki.cache.Cache;import org.xwiki.classloader.ClassLoaderManager;import org.xwiki.component.event.ComponentDescriptorAddedEvent;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.manager.NamespacedComponentManager;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.container.servlet.HttpServletUtils;import org.xwiki.context.Execution;import org.xwiki.edit.EditConfiguration;import org.xwiki.job.Job;import org.xwiki.job.JobException;import org.xwiki.job.JobExecutor;import org.xwiki.job.annotation.Serializable;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.event.status.JobStatus.State;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.mail.MailListener;import org.xwiki.mail.MailSender;import org.xwiki.mail.MailSenderConfiguration;import org.xwiki.mail.MailStatusResultSerializer;import org.xwiki.mail.XWikiAuthenticator;import org.xwiki.model.EntityType;import org.xwiki.model.reference.AttachmentReference;import org.xwiki.model.reference.AttachmentReferenceResolver;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.LocalDocumentReference;import org.xwiki.model.reference.ObjectReference;import org.xwiki.model.reference.PageReference;import org.xwiki.model.reference.PageReferenceResolver;import org.xwiki.model.reference.RegexEntityReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.observation.EventListener;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.event.CancelableEvent;import org.xwiki.observation.event.Event;import org.xwiki.query.QueryException;import org.xwiki.query.QueryFilter;import org.xwiki.refactoring.batch.BatchOperationExecutor;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.Block.Axes;import org.xwiki.rendering.block.MetaDataBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.block.match.MetadataBlockMatcher;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.listener.MetaData;import org.xwiki.rendering.parser.ParseException;import org.xwiki.rendering.renderer.BlockRenderer;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.syntax.SyntaxContent;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceReferenceResolver;import org.xwiki.resource.ResourceType;import org.xwiki.resource.ResourceTypeResolver;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.script.ScriptContextManager;import org.xwiki.skin.Resource;import org.xwiki.skin.Skin;import org.xwiki.skin.SkinManager;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLConfiguration;import org.xwiki.user.CurrentUserReference;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.velocity.VelocityContextFactory;import org.xwiki.velocity.VelocityManager;import org.xwiki.velocity.XWikiVelocityContext;import org.xwiki.velocity.XWikiVelocityException;import org.xwiki.wiki.descriptor.WikiDescriptor;import org.xwiki.wiki.descriptor.WikiDescriptorManager;import org.xwiki.wiki.manager.WikiManager;import org.xwiki.wiki.manager.WikiManagerException;import org.xwiki.xml.XMLUtils;import com.xpn.xwiki.api.Api;import com.xpn.xwiki.api.Document;import com.xpn.xwiki.api.User;import com.xpn.xwiki.criteria.api.XWikiCriteriaService;import com.xpn.xwiki.doc.DeletedAttachment;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MandatoryDocumentInitializer;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiAttachmentArchive;import com.xpn.xwiki.doc.XWikiDeletedDocument;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;import com.xpn.xwiki.doc.XWikiDocumentArchive;import com.xpn.xwiki.internal.WikiInitializerJob;import com.xpn.xwiki.internal.WikiInitializerRequest;import com.xpn.xwiki.internal.XWikiCfgConfigurationSource;import com.xpn.xwiki.internal.XWikiConfigDelegate;import com.xpn.xwiki.internal.XWikiInitializerJob;import com.xpn.xwiki.internal.debug.DebugConfiguration;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;import com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;import com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;import com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;import com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyEvent;import com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;import com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;import com.xpn.xwiki.internal.render.LinkedResourceHelper;import com.xpn.xwiki.internal.render.OldRendering;import com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;import com.xpn.xwiki.internal.skin.InternalSkinConfiguration;import com.xpn.xwiki.internal.skin.InternalSkinManager;import com.xpn.xwiki.internal.skin.WikiSkin;import com.xpn.xwiki.internal.skin.WikiSkinUtils;import com.xpn.xwiki.internal.store.StoreConfiguration;import com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;import com.xpn.xwiki.internal.velocity.VelocityEvaluator;import com.xpn.xwiki.job.JobRequestContext;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.PropertyInterface;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;import com.xpn.xwiki.objects.classes.PropertyClass;import com.xpn.xwiki.objects.meta.MetaClass;import com.xpn.xwiki.plugin.XWikiPluginInterface;import com.xpn.xwiki.plugin.XWikiPluginManager;import com.xpn.xwiki.render.groovy.XWikiPageClassLoader;import com.xpn.xwiki.stats.api.XWikiStatsService;import com.xpn.xwiki.stats.impl.SearchEngineRule;import com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;import com.xpn.xwiki.store.AttachmentRecycleBinStore;import com.xpn.xwiki.store.AttachmentVersioningStore;import com.xpn.xwiki.store.XWikiAttachmentStoreInterface;import com.xpn.xwiki.store.XWikiCacheStoreInterface;import com.xpn.xwiki.store.XWikiHibernateStore;import com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;import com.xpn.xwiki.store.XWikiStoreInterface;import com.xpn.xwiki.store.XWikiVersioningStoreInterface;import com.xpn.xwiki.user.api.XWikiAuthService;import com.xpn.xwiki.user.api.XWikiGroupService;import com.xpn.xwiki.user.api.XWikiRightService;import com.xpn.xwiki.user.api.XWikiUser;import com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;import com.xpn.xwiki.util.Util;import com.xpn.xwiki.util.XWikiStubContextProvider;import com.xpn.xwiki.web.Utils;import com.xpn.xwiki.web.XWikiEngineContext;import com.xpn.xwiki.web.XWikiMessageTool;import com.xpn.xwiki.web.XWikiRequest;import com.xpn.xwiki.web.XWikiServletRequestStub;import com.xpn.xwiki.web.XWikiURLFactory;import com.xpn.xwiki.web.XWikiURLFactoryService;import com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;import com.xpn.xwiki.web.includeservletasstring.IncludeServletAsString;@Serializable(false)public class XWiki implements EventListener{    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";    public static final String DEFAULT_HOME_SPACE = \"Main\";    public static final String SYSTEM_SPACE = \"XWiki\";    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;    public static final String CACHE_VERSION = \"cache-version\";    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");    public static final String DEFAULT_ENCODING = \"UTF-8\";    private static final String NO_VALUE = \"---\";    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");    private XWikiStoreInterface store;    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;    private AttachmentVersioningStore defaultAttachmentArchiveStore;    private XWikiVersioningStoreInterface versioningStore;    private XWikiRecycleBinStoreInterface recycleBinStore;    private AttachmentRecycleBinStore attachmentRecycleBinStore;    private XWikiPluginManager pluginManager;    private XWikiAuthService authService;    private XWikiRightService rightService;    private XWikiGroupService groupService;    private XWikiStatsService statsService;    private XWikiURLFactoryService urlFactoryService;    private XWikiCriteriaService criteriaService;    private final Object AUTH_SERVICE_LOCK = new Object();    private final Object RIGHT_SERVICE_LOCK = new Object();    private final Object GROUP_SERVICE_LOCK = new Object();    private final Object STATS_SERVICE_LOCK = new Object();    private final Object URLFACTORY_SERVICE_LOCK = new Object();    private MetaClass metaclass;    private String version;    private XWikiEngineContext engine_context;    private String database;    private String fullNameSQL;    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();    private boolean isReadOnly = false;    @Deprecated    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;    public static final String MACROS_FILE = \"/templates/macros.txt\";    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";    private static final String VERSION_FILE_PROPERTY = \"version\";    private static XWikiInitializerJob job;    private List<String> configuredSyntaxes;    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;    private EntityReferenceResolver<String> relativeEntityReferenceResolver;    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;    private ResourceReferenceManager resourceReferenceManager;    private JobExecutor jobExecutor;    private InternalSkinManager internalSkinManager;    private TemplateManager templateManager;    private RenderingContext renderingContext;    private VelocityEvaluator velocityEvaluator;    private Boolean hasBacklinks;    private ConfigurationSource xwikicfg;    private ConfigurationSource wikiConfiguration;    private UserPropertiesResolver userPropertiesResolver;    private ConfigurationSource spaceConfiguration;    private EditConfiguration editConfiguration;    private URLConfiguration urlConfiguration;    private StoreConfiguration storeConfiguration;    private HibernateConfiguration hibernateConfiguration;    private ObservationManager observationManager;    private Provider<XWikiContext> xcontextProvider;    private ContextualLocalizationManager localization;    private Provider<OldRendering> oldRenderingProvider;    private ParseGroovyFromString parseGroovyFromString;    private JobProgressManager progress;    private Provider<DocumentReference> defaultDocumentReferenceProvider;    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;    private PageReferenceResolver<EntityReference> currentgetpageResolver;    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;    private WikiSkinUtils wikiSkinUtils;    private DocumentRevisionProvider documentRevisionProvider;    private VelocityContextFactory velocityContextFactory;    private WikiDescriptorManager wikiDescriptorManager;    private AsyncContext asyncContext;    private ConfigurationSource getConfiguration()    {        if (this.xwikicfg == null) {            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);        }        return this.xwikicfg;    }    private ConfigurationSource getWikiConfiguration()    {        if (this.wikiConfiguration == null) {            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");        }        return this.wikiConfiguration;    }    private ConfigurationSource getSpaceConfiguration()    {        if (this.spaceConfiguration == null) {            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");        }        return this.spaceConfiguration;    }    private UserPropertiesResolver getAllUserPropertiesResolver()    {        if (this.userPropertiesResolver == null) {            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");        }        return this.userPropertiesResolver;    }    private EditConfiguration getEditConfiguration()    {        if (this.editConfiguration == null) {            this.editConfiguration = Utils.getComponent(EditConfiguration.class);        }        return this.editConfiguration;    }    private URLConfiguration getURLConfiguration()    {        if (this.urlConfiguration == null) {            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);        }        return this.urlConfiguration;    }    private StoreConfiguration getStoreConfiguration()    {        if (this.storeConfiguration == null) {            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);        }        return this.storeConfiguration;    }    private HibernateConfiguration getHibernateConfiguration()    {        if (this.hibernateConfiguration == null) {            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);        }        return this.hibernateConfiguration;    }    private InternalSkinManager getInternalSkinManager()    {        if (this.internalSkinManager == null) {            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);        }        return this.internalSkinManager;    }    private TemplateManager getTemplateManager()    {        if (this.templateManager == null) {            this.templateManager = Utils.getComponent(TemplateManager.class);        }        return this.templateManager;    }    private RenderingContext getRenderingContext()    {        if (this.renderingContext == null) {            this.renderingContext = Utils.getComponent(RenderingContext.class);        }        return this.renderingContext;    }    private MutableRenderingContext getMutableRenderingContext()    {        return getRenderingContext() instanceof MutableRenderingContext            ? (MutableRenderingContext) getRenderingContext() : null;    }    private VelocityEvaluator getVelocityEvaluator()    {        if (this.velocityEvaluator == null) {            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);        }        return this.velocityEvaluator;    }    private ObservationManager getObservationManager()    {        if (this.observationManager == null) {            this.observationManager = Utils.getComponent(ObservationManager.class);        }        return this.observationManager;    }    private XWikiContext getXWikiContext()    {        if (this.xcontextProvider == null) {            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);        }        return this.xcontextProvider.get();    }    private ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    private OldRendering getOldRendering()    {        if (this.oldRenderingProvider == null) {            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);        }        return this.oldRenderingProvider.get();    }    private ParseGroovyFromString getParseGroovyFromString()    {        if (this.parseGroovyFromString == null) {            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);        }        return this.parseGroovyFromString;    }    private JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()    {        if (this.defaultDocumentReferenceProvider == null) {            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);        }        return this.defaultDocumentReferenceProvider;    }    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()    {        if (this.currentgetdocumentResolver == null) {            this.currentgetdocumentResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");        }        return this.currentgetdocumentResolver;    }    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()    {        if (this.currentgetpageResolver == null) {            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");        }        return this.currentgetpageResolver;    }    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()    {        if (this.currentAttachmentReferenceResolver == null) {            this.currentAttachmentReferenceResolver =                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentAttachmentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()    {        if (this.defaultEntityReferenceSerializer == null) {            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultEntityReferenceSerializer;    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()    {        if (this.currentReferenceDocumentReferenceResolver == null) {            this.currentReferenceDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentReferenceDocumentReferenceResolver;    }    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()    {        if (this.currentMixedEntityReferenceResolver == null) {            this.currentMixedEntityReferenceResolver =                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedEntityReferenceResolver;    }    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()    {        if (this.relativeEntityReferenceResolver == null) {            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");        }        return this.relativeEntityReferenceResolver;    }    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()    {        if (this.localStringEntityReferenceSerializer == null) {            this.localStringEntityReferenceSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localStringEntityReferenceSerializer;    }    private ResourceReferenceManager getResourceReferenceManager()    {        if (this.resourceReferenceManager == null) {            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);        }        return this.resourceReferenceManager;    }    private JobExecutor getJobExecutor()    {        if (this.jobExecutor == null) {            this.jobExecutor = Utils.getComponent(JobExecutor.class);        }        return this.jobExecutor;    }    private DocumentReference getDefaultDocumentReference()    {        return getDefaultDocumentReferenceProvider().get();    }    private WikiSkinUtils getWikiSkinUtils()    {        if (this.wikiSkinUtils == null) {            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);        }        return this.wikiSkinUtils;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    private VelocityContextFactory getVelocityContextFactory()    {        if (this.velocityContextFactory == null) {            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);        }        return this.velocityContextFactory;    }    private WikiDescriptorManager getWikiDescriptorManager()    {        if (this.wikiDescriptorManager == null) {            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);        }        return this.wikiDescriptorManager;    }    private AsyncContext getAsyncContext()    {        if (this.asyncContext == null) {            this.asyncContext = Utils.getComponent(AsyncContext.class);        }        return this.asyncContext;    }    private String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException    {        return getMainXWiki(true, context);    }    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException    {        String xwikiname = DEFAULT_MAIN_WIKI;        context.setMainXWiki(xwikiname);        XWiki xwiki;        try {            XWikiEngineContext econtext = context.getEngineContext();            xwiki = (XWiki) econtext.getAttribute(xwikiname);            if (xwiki == null) {                synchronized (XWiki.class) {                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                    if (xwiki == null && job == null) {                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);                        if (job.getStatus() == null) {                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)                                .initialize(context);                            job.startAsync();                        }                    }                }                if (wait) {                    job.join();                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                }            }            context.setWiki(xwiki);            return xwiki;        } catch (Exception e) {            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,                \"Could not initialize main XWiki instance\", e);        }    }    public static boolean isInitializing(XWikiContext xcontext)    {        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));    }    public static XWiki getXWiki(XWikiContext context) throws XWikiException    {        return getXWiki(true, context);    }    /**     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.     * <p>     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.     *     * @param wait wait until XWiki is initialized     * @param xcontext see {@link XWikiContext}     * @return an XWiki object configured for the wiki corresponding to the current request     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's a", "nl": "import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Type;import java.net.MalformedURLException;import java.net.URL;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.attribute.FileTime;import java.text.DateFormatSymbols;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.Enumeration;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Set;import java.util.TimeZone;import java.util.Vector;import java.util.concurrent.ConcurrentHashMap;import java.util.zip.ZipOutputStream;import javax.annotation.Priority;import javax.inject.Provider;import javax.mail.Message;import javax.mail.Session;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.naming.NamingException;import javax.script.ScriptContext;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.httpclient.Credentials;import org.apache.commons.httpclient.HttpClient;import org.apache.commons.httpclient.URIException;import org.apache.commons.httpclient.UsernamePasswordCredentials;import org.apache.commons.httpclient.auth.AuthScope;import org.apache.commons.httpclient.methods.GetMethod;import org.apache.commons.httpclient.util.URIUtil;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.ArrayUtils;import org.apache.commons.lang3.RandomStringUtils;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.commons.lang3.math.NumberUtils;import org.apache.commons.lang3.reflect.FieldUtils;import org.apache.velocity.VelocityContext;import org.hibernate.HibernateException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.DocumentCreatedEvent;import org.xwiki.bridge.event.DocumentCreatingEvent;import org.xwiki.bridge.event.DocumentDeletedEvent;import org.xwiki.bridge.event.DocumentDeletingEvent;import org.xwiki.bridge.event.DocumentRolledBackEvent;import org.xwiki.bridge.event.DocumentRollingBackEvent;import org.xwiki.bridge.event.DocumentUpdatedEvent;import org.xwiki.bridge.event.DocumentUpdatingEvent;import org.xwiki.bridge.event.WikiCopiedEvent;import org.xwiki.bridge.event.WikiDeletedEvent;import org.xwiki.cache.Cache;import org.xwiki.classloader.ClassLoaderManager;import org.xwiki.component.event.ComponentDescriptorAddedEvent;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.manager.NamespacedComponentManager;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.container.servlet.HttpServletUtils;import org.xwiki.context.Execution;import org.xwiki.edit.EditConfiguration;import org.xwiki.job.Job;import org.xwiki.job.JobException;import org.xwiki.job.JobExecutor;import org.xwiki.job.annotation.Serializable;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.event.status.JobStatus.State;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.mail.MailListener;import org.xwiki.mail.MailSender;import org.xwiki.mail.MailSenderConfiguration;import org.xwiki.mail.MailStatusResultSerializer;import org.xwiki.mail.XWikiAuthenticator;import org.xwiki.model.EntityType;import org.xwiki.model.reference.AttachmentReference;import org.xwiki.model.reference.AttachmentReferenceResolver;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.LocalDocumentReference;import org.xwiki.model.reference.ObjectReference;import org.xwiki.model.reference.PageReference;import org.xwiki.model.reference.PageReferenceResolver;import org.xwiki.model.reference.RegexEntityReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.observation.EventListener;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.event.CancelableEvent;import org.xwiki.observation.event.Event;import org.xwiki.query.QueryException;import org.xwiki.query.QueryFilter;import org.xwiki.refactoring.batch.BatchOperationExecutor;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.Block.Axes;import org.xwiki.rendering.block.MetaDataBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.block.match.MetadataBlockMatcher;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.listener.MetaData;import org.xwiki.rendering.parser.ParseException;import org.xwiki.rendering.renderer.BlockRenderer;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.syntax.SyntaxContent;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceReferenceResolver;import org.xwiki.resource.ResourceType;import org.xwiki.resource.ResourceTypeResolver;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.script.ScriptContextManager;import org.xwiki.skin.Resource;import org.xwiki.skin.Skin;import org.xwiki.skin.SkinManager;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLConfiguration;import org.xwiki.user.CurrentUserReference;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.velocity.VelocityContextFactory;import org.xwiki.velocity.VelocityManager;import org.xwiki.velocity.XWikiVelocityContext;import org.xwiki.velocity.XWikiVelocityException;import org.xwiki.wiki.descriptor.WikiDescriptor;import org.xwiki.wiki.descriptor.WikiDescriptorManager;import org.xwiki.wiki.manager.WikiManager;import org.xwiki.wiki.manager.WikiManagerException;import org.xwiki.xml.XMLUtils;import com.xpn.xwiki.api.Api;import com.xpn.xwiki.api.Document;import com.xpn.xwiki.api.User;import com.xpn.xwiki.criteria.api.XWikiCriteriaService;import com.xpn.xwiki.doc.DeletedAttachment;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MandatoryDocumentInitializer;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiAttachmentArchive;import com.xpn.xwiki.doc.XWikiDeletedDocument;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;import com.xpn.xwiki.doc.XWikiDocumentArchive;import com.xpn.xwiki.internal.WikiInitializerJob;import com.xpn.xwiki.internal.WikiInitializerRequest;import com.xpn.xwiki.internal.XWikiCfgConfigurationSource;import com.xpn.xwiki.internal.XWikiConfigDelegate;import com.xpn.xwiki.internal.XWikiInitializerJob;import com.xpn.xwiki.internal.debug.DebugConfiguration;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;import com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;import com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;import com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;import com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyEvent;import com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;import com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;import com.xpn.xwiki.internal.render.LinkedResourceHelper;import com.xpn.xwiki.internal.render.OldRendering;import com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;import com.xpn.xwiki.internal.skin.InternalSkinConfiguration;import com.xpn.xwiki.internal.skin.InternalSkinManager;import com.xpn.xwiki.internal.skin.WikiSkin;import com.xpn.xwiki.internal.skin.WikiSkinUtils;import com.xpn.xwiki.internal.store.StoreConfiguration;import com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;import com.xpn.xwiki.internal.velocity.VelocityEvaluator;import com.xpn.xwiki.job.JobRequestContext;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.PropertyInterface;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;import com.xpn.xwiki.objects.classes.PropertyClass;import com.xpn.xwiki.objects.meta.MetaClass;import com.xpn.xwiki.plugin.XWikiPluginInterface;import com.xpn.xwiki.plugin.XWikiPluginManager;import com.xpn.xwiki.render.groovy.XWikiPageClassLoader;import com.xpn.xwiki.stats.api.XWikiStatsService;import com.xpn.xwiki.stats.impl.SearchEngineRule;import com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;import com.xpn.xwiki.store.AttachmentRecycleBinStore;import com.xpn.xwiki.store.AttachmentVersioningStore;import com.xpn.xwiki.store.XWikiAttachmentStoreInterface;import com.xpn.xwiki.store.XWikiCacheStoreInterface;import com.xpn.xwiki.store.XWikiHibernateStore;import com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;import com.xpn.xwiki.store.XWikiStoreInterface;import com.xpn.xwiki.store.XWikiVersioningStoreInterface;import com.xpn.xwiki.user.api.XWikiAuthService;import com.xpn.xwiki.user.api.XWikiGroupService;import com.xpn.xwiki.user.api.XWikiRightService;import com.xpn.xwiki.user.api.XWikiUser;import com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;import com.xpn.xwiki.util.Util;import com.xpn.xwiki.util.XWikiStubContextProvider;import com.xpn.xwiki.web.Utils;import com.xpn.xwiki.web.XWikiEngineContext;import com.xpn.xwiki.web.XWikiMessageTool;import com.xpn.xwiki.web.XWikiRequest;import com.xpn.xwiki.web.XWikiServletRequestStub;import com.xpn.xwiki.web.XWikiURLFactory;import com.xpn.xwiki.web.XWikiURLFactoryService;import com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;import com.xpn.xwiki.web.includeservletasstring.IncludeServletAsString;@Serializable(false)public class XWiki implements EventListener{    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";    public static final String DEFAULT_HOME_SPACE = \"Main\";    public static final String SYSTEM_SPACE = \"XWiki\";    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;    public static final String CACHE_VERSION = \"cache-version\";    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");    public static final String DEFAULT_ENCODING = \"UTF-8\";    private static final String NO_VALUE = \"---\";    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");    private XWikiStoreInterface store;    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;    private AttachmentVersioningStore defaultAttachmentArchiveStore;    private XWikiVersioningStoreInterface versioningStore;    private XWikiRecycleBinStoreInterface recycleBinStore;    private AttachmentRecycleBinStore attachmentRecycleBinStore;    private XWikiPluginManager pluginManager;    private XWikiAuthService authService;    private XWikiRightService rightService;    private XWikiGroupService groupService;    private XWikiStatsService statsService;    private XWikiURLFactoryService urlFactoryService;    private XWikiCriteriaService criteriaService;    private final Object AUTH_SERVICE_LOCK = new Object();    private final Object RIGHT_SERVICE_LOCK = new Object();    private final Object GROUP_SERVICE_LOCK = new Object();    private final Object STATS_SERVICE_LOCK = new Object();    private final Object URLFACTORY_SERVICE_LOCK = new Object();    private MetaClass metaclass;    private String version;    private XWikiEngineContext engine_context;    private String database;    private String fullNameSQL;    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();    private boolean isReadOnly = false;    @Deprecated    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;    public static final String MACROS_FILE = \"/templates/macros.txt\";    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";    private static final String VERSION_FILE_PROPERTY = \"version\";    private static XWikiInitializerJob job;    private List<String> configuredSyntaxes;    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;    private EntityReferenceResolver<String> relativeEntityReferenceResolver;    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;    private ResourceReferenceManager resourceReferenceManager;    private JobExecutor jobExecutor;    private InternalSkinManager internalSkinManager;    private TemplateManager templateManager;    private RenderingContext renderingContext;    private VelocityEvaluator velocityEvaluator;    private Boolean hasBacklinks;    private ConfigurationSource xwikicfg;    private ConfigurationSource wikiConfiguration;    private UserPropertiesResolver userPropertiesResolver;    private ConfigurationSource spaceConfiguration;    private EditConfiguration editConfiguration;    private URLConfiguration urlConfiguration;    private StoreConfiguration storeConfiguration;    private HibernateConfiguration hibernateConfiguration;    private ObservationManager observationManager;    private Provider<XWikiContext> xcontextProvider;    private ContextualLocalizationManager localization;    private Provider<OldRendering> oldRenderingProvider;    private ParseGroovyFromString parseGroovyFromString;    private JobProgressManager progress;    private Provider<DocumentReference> defaultDocumentReferenceProvider;    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;    private PageReferenceResolver<EntityReference> currentgetpageResolver;    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;    private WikiSkinUtils wikiSkinUtils;    private DocumentRevisionProvider documentRevisionProvider;    private VelocityContextFactory velocityContextFactory;    private WikiDescriptorManager wikiDescriptorManager;    private AsyncContext asyncContext;    private ConfigurationSource getConfiguration()    {        if (this.xwikicfg == null) {            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);        }        return this.xwikicfg;    }    private ConfigurationSource getWikiConfiguration()    {        if (this.wikiConfiguration == null) {            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");        }        return this.wikiConfiguration;    }    private ConfigurationSource getSpaceConfiguration()    {        if (this.spaceConfiguration == null) {            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");        }        return this.spaceConfiguration;    }    private UserPropertiesResolver getAllUserPropertiesResolver()    {        if (this.userPropertiesResolver == null) {            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");        }        return this.userPropertiesResolver;    }    private EditConfiguration getEditConfiguration()    {        if (this.editConfiguration == null) {            this.editConfiguration = Utils.getComponent(EditConfiguration.class);        }        return this.editConfiguration;    }    private URLConfiguration getURLConfiguration()    {        if (this.urlConfiguration == null) {            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);        }        return this.urlConfiguration;    }    private StoreConfiguration getStoreConfiguration()    {        if (this.storeConfiguration == null) {            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);        }        return this.storeConfiguration;    }    private HibernateConfiguration getHibernateConfiguration()    {        if (this.hibernateConfiguration == null) {            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);        }        return this.hibernateConfiguration;    }    private InternalSkinManager getInternalSkinManager()    {        if (this.internalSkinManager == null) {            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);        }        return this.internalSkinManager;    }    private TemplateManager getTemplateManager()    {        if (this.templateManager == null) {            this.templateManager = Utils.getComponent(TemplateManager.class);        }        return this.templateManager;    }    private RenderingContext getRenderingContext()    {        if (this.renderingContext == null) {            this.renderingContext = Utils.getComponent(RenderingContext.class);        }        return this.renderingContext;    }    private MutableRenderingContext getMutableRenderingContext()    {        return getRenderingContext() instanceof MutableRenderingContext            ? (MutableRenderingContext) getRenderingContext() : null;    }    private VelocityEvaluator getVelocityEvaluator()    {        if (this.velocityEvaluator == null) {            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);        }        return this.velocityEvaluator;    }    private ObservationManager getObservationManager()    {        if (this.observationManager == null) {            this.observationManager = Utils.getComponent(ObservationManager.class);        }        return this.observationManager;    }    private XWikiContext getXWikiContext()    {        if (this.xcontextProvider == null) {            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);        }        return this.xcontextProvider.get();    }    private ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    private OldRendering getOldRendering()    {        if (this.oldRenderingProvider == null) {            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);        }        return this.oldRenderingProvider.get();    }    private ParseGroovyFromString getParseGroovyFromString()    {        if (this.parseGroovyFromString == null) {            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);        }        return this.parseGroovyFromString;    }    private JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()    {        if (this.defaultDocumentReferenceProvider == null) {            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);        }        return this.defaultDocumentReferenceProvider;    }    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()    {        if (this.currentgetdocumentResolver == null) {            this.currentgetdocumentResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");        }        return this.currentgetdocumentResolver;    }    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()    {        if (this.currentgetpageResolver == null) {            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");        }        return this.currentgetpageResolver;    }    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()    {        if (this.currentAttachmentReferenceResolver == null) {            this.currentAttachmentReferenceResolver =                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentAttachmentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()    {        if (this.defaultEntityReferenceSerializer == null) {            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultEntityReferenceSerializer;    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()    {        if (this.currentReferenceDocumentReferenceResolver == null) {            this.currentReferenceDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentReferenceDocumentReferenceResolver;    }    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()    {        if (this.currentMixedEntityReferenceResolver == null) {            this.currentMixedEntityReferenceResolver =                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedEntityReferenceResolver;    }    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()    {        if (this.relativeEntityReferenceResolver == null) {            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");        }        return this.relativeEntityReferenceResolver;    }    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()    {        if (this.localStringEntityReferenceSerializer == null) {            this.localStringEntityReferenceSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localStringEntityReferenceSerializer;    }    private ResourceReferenceManager getResourceReferenceManager()    {        if (this.resourceReferenceManager == null) {            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);        }        return this.resourceReferenceManager;    }    private JobExecutor getJobExecutor()    {        if (this.jobExecutor == null) {            this.jobExecutor = Utils.getComponent(JobExecutor.class);        }        return this.jobExecutor;    }    private DocumentReference getDefaultDocumentReference()    {        return getDefaultDocumentReferenceProvider().get();    }    private WikiSkinUtils getWikiSkinUtils()    {        if (this.wikiSkinUtils == null) {            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);        }        return this.wikiSkinUtils;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    private VelocityContextFactory getVelocityContextFactory()    {        if (this.velocityContextFactory == null) {            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);        }        return this.velocityContextFactory;    }    private WikiDescriptorManager getWikiDescriptorManager()    {        if (this.wikiDescriptorManager == null) {            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);        }        return this.wikiDescriptorManager;    }    private AsyncContext getAsyncContext()    {        if (this.asyncContext == null) {            this.asyncContext = Utils.getComponent(AsyncContext.class);        }        return this.asyncContext;    }    private String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException    {        return getMainXWiki(true, context);    }    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException    {        String xwikiname = DEFAULT_MAIN_WIKI;        context.setMainXWiki(xwikiname);        XWiki xwiki;        try {            XWikiEngineContext econtext = context.getEngineContext();            xwiki = (XWiki) econtext.getAttribute(xwikiname);            if (xwiki == null) {                synchronized (XWiki.class) {                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                    if (xwiki == null && job == null) {                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);                        if (job.getStatus() == null) {                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)                                .initialize(context);                            job.startAsync();                        }                    }                }                if (wait) {                    job.join();                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                }            }            context.setWiki(xwiki);            return xwiki;        } catch (Exception e) {            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,                \"Could not initialize main XWiki instance\", e);        }    }    public static boolean isInitializing(XWikiContext xcontext)    {        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));    }    public static XWiki getXWiki(XWikiContext context) throws XWikiException    {        return getXWiki(true, context);    }    /**     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.     * <p>     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.     *     * @param wait wait until XWiki is initialized     * @param xcontext see {@link XWikiContext}     * @return an XWiki object configured for the wiki corresponding to the current request     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's a"}
{"code": "import java.io.ByteArrayInputStream;import java.net.URL;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Date;import java.util.Enumeration;import java.util.HashMap;import java.util.Locale;import java.util.Map;import javax.inject.Named;import javax.inject.Provider;import javax.servlet.http.Cookie;import org.apache.commons.collections4.IteratorUtils;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;import org.xwiki.bridge.event.DocumentCreatedEvent;import org.xwiki.bridge.event.DocumentCreatingEvent;import org.xwiki.bridge.event.DocumentDeletedEvent;import org.xwiki.bridge.event.DocumentDeletingEvent;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.model.reference.DocumentReference;import org.xwiki.observation.EventListener;import org.xwiki.observation.ObservationManager;import org.xwiki.query.QueryExecutor;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.wiki.WikiModel;import org.xwiki.test.annotation.AfterComponent;import org.xwiki.test.annotation.AllComponents;import org.xwiki.test.junit5.mockito.InjectComponentManager;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.test.mockito.MockitoComponentManager;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.XWikiCfgConfigurationSource;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.BaseProperty;import com.xpn.xwiki.objects.StringProperty;import com.xpn.xwiki.objects.classes.PropertyClass;import com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;import com.xpn.xwiki.test.MockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.OldcoreTest;import com.xpn.xwiki.user.api.XWikiRightService;import com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;import com.xpn.xwiki.web.XWikiRequest;import com.xpn.xwiki.web.XWikiServletRequest;import com.xpn.xwiki.web.XWikiServletRequestStub;import com.xpn.xwiki.web.XWikiServletResponseStub;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.anyString;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.ArgumentMatchers.notNull;import static org.mockito.ArgumentMatchers.same;import static org.mockito.Mockito.atLeastOnce;import static org.mockito.Mockito.doAnswer;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@OldcoreTest(mockXWiki = false)@AllComponentspublic class XWikiTest{    @InjectMockitoOldcore    MockitoOldcore oldcore;    @MockComponent    private XWikiRecycleBinStoreInterface recycleBinStoreInterface;    private static final String DOCWIKI = \"Wiki\";    private static final String DOCSPACE = \"MilkyWay\";    private static final String DOCNAME = \"Fidis\";    private XWikiDocument document;    private XWiki xwiki;    @AfterComponent    public void afterComponent() throws Exception    {        MockitoComponentManager componentManager = this.oldcore.getMocker();        componentManager.unregisterComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);        componentManager.registerMockComponent(QueryExecutor.class, \"hql\");        componentManager.unregisterComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)            , \"context\");        Provider<ComponentManager> componentManagerProvider = componentManager            .registerMockComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)                , \"context\");        when(componentManagerProvider.get()).thenReturn(componentManager);        componentManager.registerMockComponent(WikiModel.class);    }    @BeforeEach    protected void beforeEach() throws Exception    {        this.document = new XWikiDocument(new DocumentReference(\"Wiki\", \"MilkyWay\", \"Fidis\"));        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequestStub());        this.oldcore.getXWikiContext().setResponse(new XWikiServletResponseStub());        this.oldcore.getXWikiContext().setURL(new URL(\"http:        this.oldcore.getXWikiContext().setLocale(null);        this.xwiki = this.oldcore.getSpyXWiki();        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.render.velocity.macrolist\", \"\");        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());        this.document.setCreator(\"Condor\");        this.document.setAuthor(\"Albatross\");        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());        this.xwiki.setRecycleBinStore(this.recycleBinStoreInterface);        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);    }    @Test    public void testUserNotAddedByDefaultToXWikiAllGroupWhenThisGroupImplicit() throws Exception    {        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();        xwiki.setGroupService(xWikiGroupService);        XWiki spyXWiki = Mockito.spy(xwiki);        spyXWiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());        Mockito.verify(spyXWiki, times(0)).addUserToGroup(anyString(), anyString(), any(XWikiContext.class));    }    @Test    public void testUserAddedToXWikiAllGroupWhenItsSpecifiedByConfigurationRegardlessXWikiAllGroupIsImplicit()        throws Exception    {        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();        xwiki.setGroupService(xWikiGroupService);        this.xwiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());        verify(this.xwiki, times(1)).addUserToGroup(\"XWiki.user1\", \"XWiki.XWikiAllGroup\",            this.oldcore.getXWikiContext());    }    @Test    public void testAuthorAfterDocumentCopy() throws XWikiException    {        DocumentReference copyReference =            new DocumentReference(\"Lyre\", this.document.getDocumentReference().getLastSpaceReference());        DocumentReference author = this.document.getAuthorReference();        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());        assertEquals(author, copy.getAuthorReference());    }    @Test    public void testCreatorAfterDocumentCopy() throws XWikiException    {        DocumentReference copyReference =            new DocumentReference(\"Sirius\", this.document.getDocumentReference().getLastSpaceReference());        DocumentReference creator = this.document.getCreatorReference();        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());        assertEquals(creator, copy.getCreatorReference());    }    @Test    public void testCreationDateAfterDocumentCopy() throws XWikiException, InterruptedException    {        Date sourceCreationDate = this.document.getCreationDate();        Thread.sleep(1000);        DocumentReference copyReference = new DocumentReference(this.document.getDocumentReference().getName() + \"Copy\",            this.document.getDocumentReference().getLastSpaceReference());        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());        assertTrue(copy.getCreationDate().equals(sourceCreationDate));    }    @Test    public void testParseTemplateConsidersObjectField() throws XWikiException    {        DocumentReference skinReference =            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"XWikiSkins\");        XWikiDocument skinClass = new XWikiDocument(skinReference);        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());        DocumentReference mySkinReference =            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\");        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));    }    @Test    public void testParseTemplateConsidersAttachment() throws XWikiException    {        XWikiDocument skin =            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\"));        XWikiAttachment attachment = new XWikiAttachment();        skin.getAttachmentList().add(attachment);        attachment.setContent(\"parsing an attachment\".getBytes());        attachment.setFilename(\"template.vm\");        attachment.setDoc(skin);        this.xwiki.saveDocument(skin, this.oldcore.getXWikiContext());        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));        assertFalse(this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()).isNew());        assertEquals(skin, this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()));        assertEquals(\"parsing an attachment\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));    }    @Test    public void testParseTemplateConsidersObjectFieldBeforeAttachment() throws Exception    {        DocumentReference skinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiSkins\");        XWikiDocument skinClass = new XWikiDocument(skinReference);        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());        DocumentReference mySkinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"Skin\");        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");        XWikiAttachment attachment = new XWikiAttachment();        skinDocument.getAttachmentList().add(attachment);        attachment.setContent(new ByteArrayInputStream(\"parsing an attachment\".getBytes()));        attachment.setFilename(\"template.vm\");        attachment.setDoc(skinDocument);        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithoutStripDotsWithoutAscii()    {        assertEquals(\"ee{&.txt\",            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, false, this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithoutStripDotsWithAscii()    {        assertEquals(\"ee.txt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, true, this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithStripDotsWithoutAscii()    {        assertEquals(\"ee{&txt\",            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, false, this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithStripDotsWithAscii()    {        assertEquals(\"eetxt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, true, this.oldcore.getXWikiContext()));    }    @Test    public void testSaveDocumentSendsObservationEvents() throws Exception    {        EventListener mockListener = mock(EventListener.class);        when(mockListener.getName()).thenReturn(\"testlistener\");        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Some\", \"Document\");        when(mockListener.getEvents())            .thenReturn(Arrays.asList(new DocumentCreatedEvent(ref), new DocumentCreatingEvent(ref)));        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);        om.addListener(mockListener);        verify(mockListener).getEvents();        XWikiDocument document = new XWikiDocument(ref);        document.setContent(\"the content\");        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));    }    @Test    public void testRenameDocumentSendsObservationEvents() throws Exception    {        DocumentReference sourceReference = new DocumentReference(\"xwikitest\", \"Some\", \"Source\");        DocumentReference targetReference = new DocumentReference(\"xwikitest\", \"Some\", \"Target\");        XWikiDocument sourceDocument = new XWikiDocument(sourceReference);        sourceDocument.setSyntax(Syntax.PLAIN_1_0);        this.xwiki.saveDocument(sourceDocument, this.oldcore.getXWikiContext());        EventListener mockListener = mock(EventListener.class);        when(mockListener.getName()).thenReturn(\"testlistener\");        when(mockListener.getEvents()).thenReturn(            Arrays.asList(new DocumentCreatedEvent(targetReference), new DocumentCreatingEvent(targetReference),                new DocumentDeletingEvent(sourceReference), new DocumentDeletedEvent(sourceReference)));        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);        om.addListener(mockListener);        verify(mockListener).getEvents();        this.xwiki.renameDocument(sourceReference, targetReference, false, Collections.emptyList(), null,            this.oldcore.getXWikiContext());        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));    }    @Test    public void testDeleteDocumentSendsObservationEvents() throws Exception    {        EventListener mockListener = mock(EventListener.class);        when(mockListener.getName()).thenReturn(\"testlistener\");        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Another\", \"Document\");        when(mockListener.getEvents())            .thenReturn(Arrays.asList(new DocumentDeletedEvent(ref), new DocumentDeletingEvent(ref)));        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);        om.addListener(mockListener);        verify(mockListener).getEvents();        XWikiDocument document = new XWikiDocument(ref);        document.setContent(\"the content\");        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());        this.xwiki.deleteDocument(document, false, this.oldcore.getXWikiContext());        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));    }    @Test    public void testLanguageSelection() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @SuppressWarnings(\"unchecked\")            @Override            public Enumeration getLocales()            {                ArrayList<Locale> locales = new ArrayList<Locale>();                locales.add(new Locale(\"*\"));                locales.add(new Locale(\"en\", \"US\"));                locales.add(new Locale(\"fr\"));                locales.add(new Locale(\"de\"));                return IteratorUtils.asEnumeration(locales.iterator());            }            @Override            public String getHeader(String s)            {                if (\"language\".equals(s)) {                    return null;                }                return \"en\";            }            @Override            public Cookie getCookie(String cookieName)            {                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        assertEquals(\"en\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testLanguageSelectionWithSupportedLanguages() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @SuppressWarnings(\"unchecked\")            @Override            public Enumeration getLocales()            {                ArrayList<Locale> locales = new ArrayList<Locale>();                locales.add(new Locale(\"*\"));                locales.add(new Locale(\"fr\", \"FR\"));                locales.add(new Locale(\"de\"));                return IteratorUtils.asEnumeration(locales.iterator());            }            @Override            public String getHeader(String s)            {                if (\"language\".equals(s)) {                    return null;                }                return \"en\";            }            @Override            public Cookie getCookie(String cookieName)            {                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");        assertEquals(\"fr_FR\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testIsMultilingualDefaultFalse() throws Exception    {        assertFalse(this.xwiki.isMultiLingual(this.oldcore.getXWikiContext()));    }    @Test    public void testGetCurrentContentSyntaxId()    {        XWikiDocument doc1 = new XWikiDocument();        doc1.setSyntax(Syntax.CREOLE_1_0);        XWikiDocument doc2 = new XWikiDocument();        doc2.setSyntax(Syntax.PLAIN_1_0);        assertNull(this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));        assertEquals(\"syntaxId\", this.xwiki.getCurrentContentSyntaxId(\"syntaxId\", this.oldcore.getXWikiContext()));        this.oldcore.getXWikiContext().setDoc(doc1);        assertEquals(Syntax.CREOLE_1_0.toIdString(),            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));        this.oldcore.getXWikiContext().put(\"sdoc\", doc2);        assertEquals(Syntax.PLAIN_1_0.toIdString(),            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));    }    @Test    public void testValidationKeyStorage() throws Exception    {        XWikiContext context = this.oldcore.getXWikiContext();        context.setLanguage(\"en\");        XWikiRequest request = mock(XWikiRequest.class);        when(request.getParameter(\"xwikiname\")).thenReturn(\"TestUser\");        when(request.getParameter(\"validkey\")).thenReturn(\"plaintextkey\");        context.setRequest(request);        XWikiDocument testUser =            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"TestUser\"));        BaseObject userObject = (BaseObject) this.xwiki.getUserClass(context).newObject(context);        BaseProperty validationKey = new StringProperty();        validationKey.setValue(\"plaintextkey\");        userObject.safeput(\"validkey\", validationKey);        testUser.addObject(\"XWiki.XWikiUsers\", userObject);        this.xwiki.saveDocument(testUser, context);        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));        XWikiDocument reloadedDocument = this.xwiki.getDocument(testUser, context);        assertEquals(\"\", reloadedDocument.getObject(\"XWiki.XWikiUsers\").getStringValue(\"validkey\"));        validationKey.setValue(\"wrong key\");        this.xwiki.saveDocument(testUser, context);        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"plaintextkey\");        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));        userObject.safeput(\"validkey\", validationKey);        this.xwiki.saveDocument(testUser, context);        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"wrong key\");        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));        userObject.safeput(\"validkey\", validationKey);        this.xwiki.saveDocument(testUser, context);        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));    }    @Test    public void testGetPrefsClass() throws Exception    {        when(this.oldcore.getMockStore().getLimitSize(any(), any(), any())).thenReturn(255);        XWikiDocument prefsDoc = new XWikiDocument(new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiPreferences\"));        final Map<DocumentReference, XWikiDocument> documents = new HashMap<DocumentReference, XWikiDocument>();        documents.put(prefsDoc.getDocumentReference(), prefsDoc);        when(this.oldcore.getMockStore().loadXWikiDoc(notNull(), same(this.oldcore.getXWikiContext())))            .then(new Answer<XWikiDocument>()            {                @Override                public XWikiDocument answer(InvocationOnMock invocation) throws Throwable                {                    XWikiDocument document = (XWikiDocument) invocation.getArgument(0);                    if (!documents.containsKey(document.getDocumentReference())) {                        documents.put(document.getDocumentReference(), document);                    } else {                        document = documents.get(document.getDocumentReference());                    }                    return document;                }            });        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());        verify(this.oldcore.getMockStore(), atLeastOnce()).loadXWikiDoc(notNull(),            same(this.oldcore.getXWikiContext()));        verify(this.oldcore.getMockStore()).saveXWikiDoc(same(prefsDoc), same(this.oldcore.getXWikiContext()));    }    @Test    public void testSkinResourcesAreAlwaysAllowed() throws XWikiException    {        XWikiDocument doc1 = new XWikiDocument(            new DocumentReference(\"xwiki\", Arrays.asList(\"resources\", \"icons\", \"xwiki\"), \"noavatar.png\"));        XWikiDocument doc2 =            new XWikiDocument(new DocumentReference(\"xwiki\", Arrays.asList(\"skins\", \"flamingo\", \"xwiki\"), \"style.css\"));        assertTrue(this.xwiki.checkAccess(\"skin\", doc1, this.oldcore.getXWikiContext()));        assertTrue(this.xwiki.checkAccess(\"skin\", doc2, this.oldcore.getXWikiContext()));        verify(this.oldcore.getMockRightService(), never()).checkAccess(any(), any(), any());        verify(this.oldcore.getMockAuthService(), times(2)).checkAuth(this.oldcore.getXWikiContext());    }    @Test    public void testCheckActiveSuperadmin() throws Exception    {        int isUserActive =            this.xwiki.checkActive(XWikiRightService.SUPERADMIN_USER_FULLNAME, this.oldcore.getXWikiContext());        assertEquals(1, isUserActive);    }    @Test    public void testCheckActivePrefixedSuperadmin() throws Exception    {        int isUserActive = this.xwiki.checkActive(\"xwiki:\" + XWikiRightService.SUPERADMIN_USER_FULLNAME,            this.oldcore.getXWikiContext());        assertEquals(1, isUserActive);    }    @Test    public void testGetLocalePreferenceWithContext() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));        this.oldcore.getXWikiContext().setLocale(Locale.FRENCH);        assertEquals(Locale.FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceDefaultNonMultilingual() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceWithParameterForcingUnset() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @Override            public String getParameter(String s)            {                if (\"language\".equals(s)) {                    return \"fr_CA\";                }                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceWithParameter() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @Override            public String getParameter(String s)            {                if (\"language\".equals(s)) {                    return \"fr_CA\";                }                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceWithParameterWithSupportedLanguages() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @Override            public String getParameter(String s)            {                if (\"language\".equals(s)) {                    return \"fr_CA\";                }                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languag", "nl": "import java.io.ByteArrayInputStream;import java.net.URL;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Date;import java.util.Enumeration;import java.util.HashMap;import java.util.Locale;import java.util.Map;import javax.inject.Named;import javax.inject.Provider;import javax.servlet.http.Cookie;import org.apache.commons.collections4.IteratorUtils;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;import org.xwiki.bridge.event.DocumentCreatedEvent;import org.xwiki.bridge.event.DocumentCreatingEvent;import org.xwiki.bridge.event.DocumentDeletedEvent;import org.xwiki.bridge.event.DocumentDeletingEvent;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.model.reference.DocumentReference;import org.xwiki.observation.EventListener;import org.xwiki.observation.ObservationManager;import org.xwiki.query.QueryExecutor;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.wiki.WikiModel;import org.xwiki.test.annotation.AfterComponent;import org.xwiki.test.annotation.AllComponents;import org.xwiki.test.junit5.mockito.InjectComponentManager;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.test.mockito.MockitoComponentManager;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.XWikiCfgConfigurationSource;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.BaseProperty;import com.xpn.xwiki.objects.StringProperty;import com.xpn.xwiki.objects.classes.PropertyClass;import com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;import com.xpn.xwiki.test.MockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.OldcoreTest;import com.xpn.xwiki.user.api.XWikiRightService;import com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;import com.xpn.xwiki.web.XWikiRequest;import com.xpn.xwiki.web.XWikiServletRequest;import com.xpn.xwiki.web.XWikiServletRequestStub;import com.xpn.xwiki.web.XWikiServletResponseStub;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.anyString;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.ArgumentMatchers.notNull;import static org.mockito.ArgumentMatchers.same;import static org.mockito.Mockito.atLeastOnce;import static org.mockito.Mockito.doAnswer;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@OldcoreTest(mockXWiki = false)@AllComponentspublic class XWikiTest{    @InjectMockitoOldcore    MockitoOldcore oldcore;    @MockComponent    private XWikiRecycleBinStoreInterface recycleBinStoreInterface;    private static final String DOCWIKI = \"Wiki\";    private static final String DOCSPACE = \"MilkyWay\";    private static final String DOCNAME = \"Fidis\";    private XWikiDocument document;    private XWiki xwiki;    @AfterComponent    public void afterComponent() throws Exception    {        MockitoComponentManager componentManager = this.oldcore.getMocker();        componentManager.unregisterComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);        componentManager.registerMockComponent(QueryExecutor.class, \"hql\");        componentManager.unregisterComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)            , \"context\");        Provider<ComponentManager> componentManagerProvider = componentManager            .registerMockComponent(new DefaultParameterizedType(null, Provider.class, ComponentManager.class)                , \"context\");        when(componentManagerProvider.get()).thenReturn(componentManager);        componentManager.registerMockComponent(WikiModel.class);    }    @BeforeEach    protected void beforeEach() throws Exception    {        this.document = new XWikiDocument(new DocumentReference(\"Wiki\", \"MilkyWay\", \"Fidis\"));        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequestStub());        this.oldcore.getXWikiContext().setResponse(new XWikiServletResponseStub());        this.oldcore.getXWikiContext().setURL(new URL(\"http:        this.oldcore.getXWikiContext().setLocale(null);        this.xwiki = this.oldcore.getSpyXWiki();        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.render.velocity.macrolist\", \"\");        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());        this.document.setCreator(\"Condor\");        this.document.setAuthor(\"Albatross\");        this.xwiki.saveDocument(this.document, this.oldcore.getXWikiContext());        this.xwiki.setRecycleBinStore(this.recycleBinStoreInterface);        this.oldcore.getXWikiContext().put(\"isInRenderingEngine\", true);    }    @Test    public void testUserNotAddedByDefaultToXWikiAllGroupWhenThisGroupImplicit() throws Exception    {        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();        xwiki.setGroupService(xWikiGroupService);        XWiki spyXWiki = Mockito.spy(xwiki);        spyXWiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());        Mockito.verify(spyXWiki, times(0)).addUserToGroup(anyString(), anyString(), any(XWikiContext.class));    }    @Test    public void testUserAddedToXWikiAllGroupWhenItsSpecifiedByConfigurationRegardlessXWikiAllGroupIsImplicit()        throws Exception    {        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.authentication.group.allgroupimplicit\", \"1\");        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");        XWikiGroupServiceImpl xWikiGroupService = new XWikiGroupServiceImpl();        xwiki.setGroupService(xWikiGroupService);        this.xwiki.setUserDefaultGroup(\"XWiki.user1\", this.oldcore.getXWikiContext());        verify(this.xwiki, times(1)).addUserToGroup(\"XWiki.user1\", \"XWiki.XWikiAllGroup\",            this.oldcore.getXWikiContext());    }    @Test    public void testAuthorAfterDocumentCopy() throws XWikiException    {        DocumentReference copyReference =            new DocumentReference(\"Lyre\", this.document.getDocumentReference().getLastSpaceReference());        DocumentReference author = this.document.getAuthorReference();        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());        assertEquals(author, copy.getAuthorReference());    }    @Test    public void testCreatorAfterDocumentCopy() throws XWikiException    {        DocumentReference copyReference =            new DocumentReference(\"Sirius\", this.document.getDocumentReference().getLastSpaceReference());        DocumentReference creator = this.document.getCreatorReference();        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());        assertEquals(creator, copy.getCreatorReference());    }    @Test    public void testCreationDateAfterDocumentCopy() throws XWikiException, InterruptedException    {        Date sourceCreationDate = this.document.getCreationDate();        Thread.sleep(1000);        DocumentReference copyReference = new DocumentReference(this.document.getDocumentReference().getName() + \"Copy\",            this.document.getDocumentReference().getLastSpaceReference());        this.xwiki.copyDocument(this.document.getDocumentReference(), copyReference, this.oldcore.getXWikiContext());        XWikiDocument copy = this.xwiki.getDocument(copyReference, this.oldcore.getXWikiContext());        assertTrue(copy.getCreationDate().equals(sourceCreationDate));    }    @Test    public void testParseTemplateConsidersObjectField() throws XWikiException    {        DocumentReference skinReference =            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"XWikiSkins\");        XWikiDocument skinClass = new XWikiDocument(skinReference);        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());        DocumentReference mySkinReference =            new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\");        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));    }    @Test    public void testParseTemplateConsidersAttachment() throws XWikiException    {        XWikiDocument skin =            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"Skin\"));        XWikiAttachment attachment = new XWikiAttachment();        skin.getAttachmentList().add(attachment);        attachment.setContent(\"parsing an attachment\".getBytes());        attachment.setFilename(\"template.vm\");        attachment.setDoc(skin);        this.xwiki.saveDocument(skin, this.oldcore.getXWikiContext());        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));        assertFalse(this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()).isNew());        assertEquals(skin, this.xwiki.getDocument(\"XWiki.Skin\", this.oldcore.getXWikiContext()));        assertEquals(\"parsing an attachment\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));    }    @Test    public void testParseTemplateConsidersObjectFieldBeforeAttachment() throws Exception    {        DocumentReference skinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiSkins\");        XWikiDocument skinClass = new XWikiDocument(skinReference);        skinClass.getXClass().addTextAreaField(\"template.vm\", \"template\", 80, 20);        this.xwiki.saveDocument(skinClass, this.oldcore.getXWikiContext());        DocumentReference mySkinReference = new DocumentReference(\"xwiki\", \"XWiki\", \"Skin\");        XWikiDocument skinDocument = new XWikiDocument(mySkinReference);        BaseObject obj = skinDocument.newXObject(skinReference, this.oldcore.getXWikiContext());        obj.setLargeStringValue(\"template.vm\", \"parsing a field\");        XWikiAttachment attachment = new XWikiAttachment();        skinDocument.getAttachmentList().add(attachment);        attachment.setContent(new ByteArrayInputStream(\"parsing an attachment\".getBytes()));        attachment.setFilename(\"template.vm\");        attachment.setDoc(skinDocument);        this.xwiki.saveDocument(skinDocument, this.oldcore.getXWikiContext());        this.oldcore.getXWikiContext().put(\"skin\", \"XWiki.Skin\");        assertEquals(\"XWiki.Skin\", this.xwiki.getSkin(this.oldcore.getXWikiContext()));        assertFalse(this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()).isNew());        assertEquals(skinDocument, this.xwiki.getDocument(mySkinReference, this.oldcore.getXWikiContext()));        assertEquals(\"parsing a field\", this.xwiki.parseTemplate(\"template.vm\", this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithoutStripDotsWithoutAscii()    {        assertEquals(\"ee{&.txt\",            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, false, this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithoutStripDotsWithAscii()    {        assertEquals(\"ee.txt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", false, true, this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithStripDotsWithoutAscii()    {        assertEquals(\"ee{&txt\",            this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, false, this.oldcore.getXWikiContext()));    }    @Test    public void testClearNameWithStripDotsWithAscii()    {        assertEquals(\"eetxt\", this.xwiki.clearName(\"\\u00E9\\u00EA{&.txt\", true, true, this.oldcore.getXWikiContext()));    }    @Test    public void testSaveDocumentSendsObservationEvents() throws Exception    {        EventListener mockListener = mock(EventListener.class);        when(mockListener.getName()).thenReturn(\"testlistener\");        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Some\", \"Document\");        when(mockListener.getEvents())            .thenReturn(Arrays.asList(new DocumentCreatedEvent(ref), new DocumentCreatingEvent(ref)));        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);        om.addListener(mockListener);        verify(mockListener).getEvents();        XWikiDocument document = new XWikiDocument(ref);        document.setContent(\"the content\");        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));    }    @Test    public void testRenameDocumentSendsObservationEvents() throws Exception    {        DocumentReference sourceReference = new DocumentReference(\"xwikitest\", \"Some\", \"Source\");        DocumentReference targetReference = new DocumentReference(\"xwikitest\", \"Some\", \"Target\");        XWikiDocument sourceDocument = new XWikiDocument(sourceReference);        sourceDocument.setSyntax(Syntax.PLAIN_1_0);        this.xwiki.saveDocument(sourceDocument, this.oldcore.getXWikiContext());        EventListener mockListener = mock(EventListener.class);        when(mockListener.getName()).thenReturn(\"testlistener\");        when(mockListener.getEvents()).thenReturn(            Arrays.asList(new DocumentCreatedEvent(targetReference), new DocumentCreatingEvent(targetReference),                new DocumentDeletingEvent(sourceReference), new DocumentDeletedEvent(sourceReference)));        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);        om.addListener(mockListener);        verify(mockListener).getEvents();        this.xwiki.renameDocument(sourceReference, targetReference, false, Collections.emptyList(), null,            this.oldcore.getXWikiContext());        verify(mockListener).onEvent(any(DocumentCreatingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentCreatedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));    }    @Test    public void testDeleteDocumentSendsObservationEvents() throws Exception    {        EventListener mockListener = mock(EventListener.class);        when(mockListener.getName()).thenReturn(\"testlistener\");        DocumentReference ref = new DocumentReference(\"xwikitest\", \"Another\", \"Document\");        when(mockListener.getEvents())            .thenReturn(Arrays.asList(new DocumentDeletedEvent(ref), new DocumentDeletingEvent(ref)));        ObservationManager om = this.oldcore.getMocker().getInstance(ObservationManager.class);        om.addListener(mockListener);        verify(mockListener).getEvents();        XWikiDocument document = new XWikiDocument(ref);        document.setContent(\"the content\");        this.xwiki.saveDocument(document, this.oldcore.getXWikiContext());        this.xwiki.deleteDocument(document, false, this.oldcore.getXWikiContext());        verify(mockListener).onEvent(any(DocumentDeletingEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));        verify(mockListener).onEvent(any(DocumentDeletedEvent.class), any(XWikiDocument.class),            same(this.oldcore.getXWikiContext()));    }    @Test    public void testLanguageSelection() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @SuppressWarnings(\"unchecked\")            @Override            public Enumeration getLocales()            {                ArrayList<Locale> locales = new ArrayList<Locale>();                locales.add(new Locale(\"*\"));                locales.add(new Locale(\"en\", \"US\"));                locales.add(new Locale(\"fr\"));                locales.add(new Locale(\"de\"));                return IteratorUtils.asEnumeration(locales.iterator());            }            @Override            public String getHeader(String s)            {                if (\"language\".equals(s)) {                    return null;                }                return \"en\";            }            @Override            public Cookie getCookie(String cookieName)            {                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        assertEquals(\"en\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testLanguageSelectionWithSupportedLanguages() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @SuppressWarnings(\"unchecked\")            @Override            public Enumeration getLocales()            {                ArrayList<Locale> locales = new ArrayList<Locale>();                locales.add(new Locale(\"*\"));                locales.add(new Locale(\"fr\", \"FR\"));                locales.add(new Locale(\"de\"));                return IteratorUtils.asEnumeration(locales.iterator());            }            @Override            public String getHeader(String s)            {                if (\"language\".equals(s)) {                    return null;                }                return \"en\";            }            @Override            public Cookie getCookie(String cookieName)            {                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");        assertEquals(\"fr_FR\", this.xwiki.getLanguagePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testIsMultilingualDefaultFalse() throws Exception    {        assertFalse(this.xwiki.isMultiLingual(this.oldcore.getXWikiContext()));    }    @Test    public void testGetCurrentContentSyntaxId()    {        XWikiDocument doc1 = new XWikiDocument();        doc1.setSyntax(Syntax.CREOLE_1_0);        XWikiDocument doc2 = new XWikiDocument();        doc2.setSyntax(Syntax.PLAIN_1_0);        assertNull(this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));        assertEquals(\"syntaxId\", this.xwiki.getCurrentContentSyntaxId(\"syntaxId\", this.oldcore.getXWikiContext()));        this.oldcore.getXWikiContext().setDoc(doc1);        assertEquals(Syntax.CREOLE_1_0.toIdString(),            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));        this.oldcore.getXWikiContext().put(\"sdoc\", doc2);        assertEquals(Syntax.PLAIN_1_0.toIdString(),            this.xwiki.getCurrentContentSyntaxId(null, this.oldcore.getXWikiContext()));    }    @Test    public void testValidationKeyStorage() throws Exception    {        XWikiContext context = this.oldcore.getXWikiContext();        context.setLanguage(\"en\");        XWikiRequest request = mock(XWikiRequest.class);        when(request.getParameter(\"xwikiname\")).thenReturn(\"TestUser\");        when(request.getParameter(\"validkey\")).thenReturn(\"plaintextkey\");        context.setRequest(request);        XWikiDocument testUser =            new XWikiDocument(new DocumentReference(this.oldcore.getXWikiContext().getWikiId(), \"XWiki\", \"TestUser\"));        BaseObject userObject = (BaseObject) this.xwiki.getUserClass(context).newObject(context);        BaseProperty validationKey = new StringProperty();        validationKey.setValue(\"plaintextkey\");        userObject.safeput(\"validkey\", validationKey);        testUser.addObject(\"XWiki.XWikiUsers\", userObject);        this.xwiki.saveDocument(testUser, context);        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));        validationKey.setValue(\"wrong key\");        this.xwiki.saveDocument(testUser, context);        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"plaintextkey\");        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));        userObject.safeput(\"validkey\", validationKey);        this.xwiki.saveDocument(testUser, context);        assertEquals(0, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));        validationKey = ((PropertyClass) this.xwiki.getUserClass(context).get(\"validkey\")).fromString(\"wrong key\");        assertTrue(validationKey.getValue().toString().startsWith(\"hash:\"));        userObject.safeput(\"validkey\", validationKey);        this.xwiki.saveDocument(testUser, context);        assertEquals(-1, this.xwiki.validateUser(false, this.oldcore.getXWikiContext()));    }    @Test    public void testGetPrefsClass() throws Exception    {        when(this.oldcore.getMockStore().getLimitSize(any(), any(), any())).thenReturn(255);        XWikiDocument prefsDoc = new XWikiDocument(new DocumentReference(\"xwiki\", \"XWiki\", \"XWikiPreferences\"));        final Map<DocumentReference, XWikiDocument> documents = new HashMap<DocumentReference, XWikiDocument>();        documents.put(prefsDoc.getDocumentReference(), prefsDoc);        when(this.oldcore.getMockStore().loadXWikiDoc(notNull(), same(this.oldcore.getXWikiContext())))            .then(new Answer<XWikiDocument>()            {                @Override                public XWikiDocument answer(InvocationOnMock invocation) throws Throwable                {                    XWikiDocument document = (XWikiDocument) invocation.getArgument(0);                    if (!documents.containsKey(document.getDocumentReference())) {                        documents.put(document.getDocumentReference(), document);                    } else {                        document = documents.get(document.getDocumentReference());                    }                    return document;                }            });        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());        this.xwiki.getPrefsClass(this.oldcore.getXWikiContext());        verify(this.oldcore.getMockStore(), atLeastOnce()).loadXWikiDoc(notNull(),            same(this.oldcore.getXWikiContext()));        verify(this.oldcore.getMockStore()).saveXWikiDoc(same(prefsDoc), same(this.oldcore.getXWikiContext()));    }    @Test    public void testSkinResourcesAreAlwaysAllowed() throws XWikiException    {        XWikiDocument doc1 = new XWikiDocument(            new DocumentReference(\"xwiki\", Arrays.asList(\"resources\", \"icons\", \"xwiki\"), \"noavatar.png\"));        XWikiDocument doc2 =            new XWikiDocument(new DocumentReference(\"xwiki\", Arrays.asList(\"skins\", \"flamingo\", \"xwiki\"), \"style.css\"));        assertTrue(this.xwiki.checkAccess(\"skin\", doc1, this.oldcore.getXWikiContext()));        assertTrue(this.xwiki.checkAccess(\"skin\", doc2, this.oldcore.getXWikiContext()));        verify(this.oldcore.getMockRightService(), never()).checkAccess(any(), any(), any());        verify(this.oldcore.getMockAuthService(), times(2)).checkAuth(this.oldcore.getXWikiContext());    }    @Test    public void testCheckActiveSuperadmin() throws Exception    {        int isUserActive =            this.xwiki.checkActive(XWikiRightService.SUPERADMIN_USER_FULLNAME, this.oldcore.getXWikiContext());        assertEquals(1, isUserActive);    }    @Test    public void testCheckActivePrefixedSuperadmin() throws Exception    {        int isUserActive = this.xwiki.checkActive(\"xwiki:\" + XWikiRightService.SUPERADMIN_USER_FULLNAME,            this.oldcore.getXWikiContext());        assertEquals(1, isUserActive);    }    @Test    public void testGetLocalePreferenceWithContext() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));        this.oldcore.getXWikiContext().setLocale(Locale.FRENCH);        assertEquals(Locale.FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceDefaultNonMultilingual() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null));        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceWithParameterForcingUnset() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @Override            public String getParameter(String s)            {                if (\"language\".equals(s)) {                    return \"fr_CA\";                }                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        this.oldcore.getMockXWikiCfg().setProperty(\"xwiki.language.forceSupported\", \"0\");        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceWithParameter() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @Override            public String getParameter(String s)            {                if (\"language\".equals(s)) {                    return \"fr_CA\";                }                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        assertEquals(Locale.ENGLISH, this.xwiki.getLocalePreference(this.oldcore.getXWikiContext()));    }    @Test    public void testGetLocalePreferenceWithParameterWithSupportedLanguages() throws Exception    {        this.oldcore.getXWikiContext().setRequest(new XWikiServletRequest(null)        {            @Override            public String getParameter(String s)            {                if (\"language\".equals(s)) {                    return \"fr_CA\";                }                return null;            }        });        this.oldcore.getMockWikiConfigurationSource().setProperty(\"multilingual\", \"1\");        this.oldcore.getMockWikiConfigurationSource().setProperty(\"languages\", \"en, |fr_FR, |en_US, |fr_CA\");        assertEquals(Locale.CANADA_FRENCH, this.xwiki.getLocalePreference(this.oldcore."}
{"code": "import java.io.StringWriter;import java.util.ArrayList;import java.util.Collections;import java.util.List;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Singleton;import org.apache.commons.lang3.StringUtils;import org.apache.velocity.VelocityContext;import org.xwiki.component.annotation.Component;import org.xwiki.context.Execution;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.GroupBlock;import org.xwiki.rendering.block.LinkBlock;import org.xwiki.rendering.block.WordBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.executor.ContentExecutor;import org.xwiki.rendering.listener.reference.ResourceReference;import org.xwiki.rendering.listener.reference.ResourceType;import org.xwiki.rendering.macro.dashboard.Gadget;import org.xwiki.rendering.macro.dashboard.GadgetSource;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.MacroTransformationContext;import org.xwiki.rendering.util.ParserUtils;import org.xwiki.security.authorization.AuthorExecutor;import org.xwiki.security.authorization.AuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.velocity.VelocityEngine;import org.xwiki.velocity.VelocityManager;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;@Component@Singletonpublic class DefaultGadgetSource implements GadgetSource{    protected static final EntityReference GADGET_CLASS =        new EntityReference(\"GadgetClass\", EntityType.DOCUMENT, new EntityReference(\"XWiki\", EntityType.SPACE));    @Inject    protected Execution execution;    @Inject    @Named(\"current\")    protected DocumentReferenceResolver<String> currentReferenceResolver;    @Inject    @Named(\"current\")    protected DocumentReferenceResolver<EntityReference> currentReferenceEntityResolver;    @Inject    @Named(\"local\")    private EntityReferenceSerializer<String> localReferenceSerializer;    @Inject    private AuthorExecutor authorExecutor;    @Inject    private VelocityManager velocityManager;    @Inject    private ContentExecutor<MacroTransformationContext> contentExecutor;    @Inject    private JobProgressManager progress;    @Inject    private AuthorizationManager authorizationManager;    private ParserUtils parserUtils = new ParserUtils();    @Override    public List<Gadget> getGadgets(String source, MacroTransformationContext context) throws Exception    {        DocumentReference sourceDocRef = getSourceDocumentReference(source);        if (sourceDocRef == null) {            return new ArrayList<>();        }        XWikiContext xContext = getXWikiContext();        XWiki xWiki = xContext.getWiki();        XWikiDocument sourceDoc = xWiki.getDocument(sourceDocRef, xContext);        DocumentReference gadgetsClass = currentReferenceEntityResolver.resolve(GADGET_CLASS);        List<BaseObject> gadgetObjects = sourceDoc.getXObjects(gadgetsClass);        if (gadgetObjects == null || gadgetObjects.isEmpty()) {            return new ArrayList<>();        }        this.progress.startStep(this, \"dashboard.progress.prepareGadgets\", \"Prepare gadgets for document [{}] ({})\",            sourceDocRef, gadgetObjects.size());        this.progress.pushLevelProgress(gadgetObjects.size(), this);        try {            return prepareGadgets(gadgetObjects, sourceDoc.getSyntax(), context);        } finally {            this.progress.popLevelProgress(this);            this.progress.endStep(this);        }    }    private List<Gadget> prepareGadgets(List<BaseObject> objects, Syntax sourceSyntax,        MacroTransformationContext context) throws Exception    {        List<Gadget> gadgets = new ArrayList<>();        VelocityContext velocityContext = velocityManager.getVelocityContext();        String key = context.getTransformationContext().getId();        if (key == null) {            key = \"unknown namespace\";        }        VelocityEngine velocityEngine = velocityManager.getVelocityEngine();        for (BaseObject xObject : objects) {            if (xObject != null) {                this.progress.startStep(this, \"dashboard.progress.prepareGadget\", \"Prepare gadget [{}:{}]\",                    xObject.getDocumentReference(), xObject.getNumber());                String title = xObject.getStringValue(\"title\");                String content = xObject.getLargeStringValue(\"content\");                String position = xObject.getStringValue(\"position\");                String id = xObject.getNumber() + \"\";                String gadgetTitle;                XWikiDocument ownerDocument = xObject.getOwnerDocument();                if (this.authorizationManager.hasAccess(Right.SCRIPT, ownerDocument.getAuthorReference(), ownerDocument.getDocumentReference())) {                    gadgetTitle =                        this.evaluateVelocityTitle(velocityContext, velocityEngine, key, title, ownerDocument);                } else {                    gadgetTitle = title;                }                List<Block> titleBlocks =                    renderGadgetProperty(gadgetTitle, sourceSyntax, xObject.getDocumentReference(),                        ownerDocument, context);                List<Block> contentBlocks =                    renderGadgetProperty(content, sourceSyntax, xObject.getDocumentReference(),                        ownerDocument, context);                Gadget gadget = new Gadget(id, titleBlocks, contentBlocks, position);                gadget.setTitleSource(title);                gadgets.add(gadget);            } else {                this.progress.startStep(this, \"dashboard.progress.skipNullGadget\", \"Null gadget object\");            }            this.progress.endStep(this);        }        return gadgets;    }    private String evaluateVelocityTitle(VelocityContext velocityContext, VelocityEngine velocityEngine, String key,        String title, XWikiDocument ownerDocument) throws Exception    {        return this.authorExecutor.call(() -> {            StringWriter writer = new StringWriter();            velocityEngine.evaluate(velocityContext, writer, key, title);            return writer.toString();        }, ownerDocument.getAuthorReference(), ownerDocument.getDocumentReference());    }    private List<Block> renderGadgetProperty(String content, Syntax sourceSyntax, EntityReference sourceReference,        XWikiDocument ownerDocument, MacroTransformationContext context)        throws Exception    {        return authorExecutor.call(() -> {            XDOM xdom = this.contentExecutor.execute(content, sourceSyntax, sourceReference, context);            List<Block> xdomBlocks = xdom.getChildren();            this.parserUtils.removeTopLevelParagraph(xdomBlocks);            return xdomBlocks;        }, ownerDocument.getAuthorReference(), ownerDocument.getDocumentReference());    }    private DocumentReference getSourceDocumentReference(String source)    {        if (StringUtils.isEmpty(source)) {            return getXWikiContext().getDoc().getDocumentReference();        }        return currentReferenceResolver.resolve(source);    }    private XWikiContext getXWikiContext()    {        return (XWikiContext) execution.getContext().getProperty(\"xwikicontext\");    }    @Override    public List<Block> getDashboardSourceMetadata(String source, MacroTransformationContext context)    {        DocumentReference sourceDoc = getSourceDocumentReference(source);        String classParameterName = \"class\";        GroupBlock metadataContainer = new GroupBlock();        metadataContainer.setParameter(classParameterName, DashboardMacro.METADATA);        XWikiContext xContext = getXWikiContext();        String editURL = xContext.getWiki().getURL(sourceDoc, \"save\", \"\", \"\", xContext);        LinkBlock editURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(editURL, ResourceType.URL), false);        editURLBlock.setParameter(classParameterName, DashboardMacro.EDIT_URL);        metadataContainer.addChild(editURLBlock);        String removeURL = xContext.getWiki().getURL(sourceDoc, \"objectremove\", \"\", \"\", xContext);        LinkBlock removeURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(removeURL, ResourceType.URL), false);        removeURLBlock.setParameter(classParameterName, DashboardMacro.REMOVE_URL);        metadataContainer.addChild(removeURLBlock);        String addURL = xContext.getWiki().getURL(sourceDoc, \"objectadd\", \"\", \"\", xContext);        LinkBlock addURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(addURL, ResourceType.URL), false);        addURLBlock.setParameter(classParameterName, DashboardMacro.ADD_URL);        metadataContainer.addChild(addURLBlock);        GroupBlock sourcePageBlock = new GroupBlock();        sourcePageBlock.addChild(new WordBlock(sourceDoc.getName()));        sourcePageBlock.setParameter(classParameterName, DashboardMacro.SOURCE_PAGE);        metadataContainer.addChild(sourcePageBlock);        GroupBlock sourceSpaceBlock = new GroupBlock();        sourceSpaceBlock.addChild(new WordBlock(            this.localReferenceSerializer.serialize(sourceDoc.getLastSpaceReference())));        sourceSpaceBlock.setParameter(classParameterName, DashboardMacro.SOURCE_SPACE);        metadataContainer.addChild(sourceSpaceBlock);        GroupBlock sourceWikiBlock = new GroupBlock();        sourceWikiBlock.addChild(new WordBlock(sourceDoc.getWikiReference().getName()));        sourceWikiBlock.setParameter(classParameterName, DashboardMacro.SOURCE_WIKI);        metadataContainer.addChild(sourceWikiBlock);        String sourceURL = xContext.getWiki().getURL(sourceDoc, \"view\", \"\", \"\", xContext);        LinkBlock sourceURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(sourceURL, ResourceType.URL), false);        sourceURLBlock.setParameter(classParameterName, DashboardMacro.SOURCE_URL);        metadataContainer.addChild(sourceURLBlock);        return Collections.<Block> singletonList(metadataContainer);    }    @Override    public boolean isEditing()    {        XWikiContext context = getXWikiContext();        return \"inline\".equals(context.getAction()) || \"edit\".equals(context.getAction());    }}", "nl": "import java.io.StringWriter;import java.util.ArrayList;import java.util.Collections;import java.util.List;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Singleton;import org.apache.commons.lang3.StringUtils;import org.apache.velocity.VelocityContext;import org.xwiki.component.annotation.Component;import org.xwiki.context.Execution;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.GroupBlock;import org.xwiki.rendering.block.LinkBlock;import org.xwiki.rendering.block.WordBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.executor.ContentExecutor;import org.xwiki.rendering.executor.ContentExecutorException;import org.xwiki.rendering.listener.reference.ResourceReference;import org.xwiki.rendering.listener.reference.ResourceType;import org.xwiki.rendering.macro.dashboard.Gadget;import org.xwiki.rendering.macro.dashboard.GadgetSource;import org.xwiki.rendering.parser.MissingParserException;import org.xwiki.rendering.parser.ParseException;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.MacroTransformationContext;import org.xwiki.rendering.util.ParserUtils;import org.xwiki.security.authorization.AuthorExecutor;import org.xwiki.velocity.VelocityEngine;import org.xwiki.velocity.VelocityManager;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;@Component@Singletonpublic class DefaultGadgetSource implements GadgetSource{    protected static final EntityReference GADGET_CLASS =        new EntityReference(\"GadgetClass\", EntityType.DOCUMENT, new EntityReference(\"XWiki\", EntityType.SPACE));    @Inject    protected Execution execution;    @Inject    @Named(\"current\")    protected DocumentReferenceResolver<String> currentReferenceResolver;    @Inject    @Named(\"current\")    protected DocumentReferenceResolver<EntityReference> currentReferenceEntityResolver;    @Inject    @Named(\"local\")    private EntityReferenceSerializer<String> localReferenceSerializer;    @Inject    private AuthorExecutor authorExecutor;    @Inject    private VelocityManager velocityManager;    @Inject    private ContentExecutor<MacroTransformationContext> contentExecutor;    @Inject    private JobProgressManager progress;    private ParserUtils parserUtils = new ParserUtils();    @Override    public List<Gadget> getGadgets(String source, MacroTransformationContext context) throws Exception    {        DocumentReference sourceDocRef = getSourceDocumentReference(source);        if (sourceDocRef == null) {            return new ArrayList<>();        }        XWikiContext xContext = getXWikiContext();        XWiki xWiki = xContext.getWiki();        XWikiDocument sourceDoc = xWiki.getDocument(sourceDocRef, xContext);        DocumentReference gadgetsClass = currentReferenceEntityResolver.resolve(GADGET_CLASS);        List<BaseObject> gadgetObjects = sourceDoc.getXObjects(gadgetsClass);        if (gadgetObjects == null || gadgetObjects.isEmpty()) {            return new ArrayList<>();        }        this.progress.startStep(this, \"dashboard.progress.prepareGadgets\", \"Prepare gadgets for document [{}] ({})\",            sourceDocRef, gadgetObjects.size());        this.progress.pushLevelProgress(gadgetObjects.size(), this);        try {            return prepareGadgets(gadgetObjects, sourceDoc.getSyntax(), context);        } finally {            this.progress.popLevelProgress(this);            this.progress.endStep(this);        }    }    private List<Gadget> prepareGadgets(List<BaseObject> objects, Syntax sourceSyntax,        MacroTransformationContext context) throws Exception    {        List<Gadget> gadgets = new ArrayList<>();        VelocityContext velocityContext = velocityManager.getVelocityContext();        String key = context.getTransformationContext().getId();        if (key == null) {            key = \"unknown namespace\";        }        VelocityEngine velocityEngine = velocityManager.getVelocityEngine();        for (BaseObject xObject : objects) {            if (xObject != null) {                this.progress.startStep(this, \"dashboard.progress.prepareGadget\", \"Prepare gadget [{}:{}]\",                    xObject.getDocumentReference(), xObject.getNumber());                String title = xObject.getStringValue(\"title\");                String content = xObject.getLargeStringValue(\"content\");                String position = xObject.getStringValue(\"position\");                String id = xObject.getNumber() + \"\";                StringWriter writer = new StringWriter();                velocityEngine.evaluate(velocityContext, writer, key, title);                String gadgetTitle = writer.toString();                List<Block> titleBlocks =                    renderGadgetProperty(gadgetTitle, sourceSyntax, xObject.getDocumentReference(),                        xObject.getOwnerDocument(), context);                List<Block> contentBlocks =                    renderGadgetProperty(content, sourceSyntax, xObject.getDocumentReference(),                        xObject.getOwnerDocument(), context);                Gadget gadget = new Gadget(id, titleBlocks, contentBlocks, position);                gadget.setTitleSource(title);                gadgets.add(gadget);            } else {                this.progress.startStep(this, \"dashboard.progress.skipNullGadget\", \"Null gadget object\");            }            this.progress.endStep(this);        }        return gadgets;    }    private List<Block> renderGadgetProperty(String content, Syntax sourceSyntax, EntityReference sourceReference,        XWikiDocument ownerDocument, MacroTransformationContext context)        throws Exception    {        return authorExecutor.call(() -> {            XDOM xdom = this.contentExecutor.execute(content, sourceSyntax, sourceReference, context);            List<Block> xdomBlocks = xdom.getChildren();            this.parserUtils.removeTopLevelParagraph(xdomBlocks);            return xdomBlocks;        }, ownerDocument.getAuthorReference(), ownerDocument.getDocumentReference());    }    private DocumentReference getSourceDocumentReference(String source)    {        if (StringUtils.isEmpty(source)) {            return getXWikiContext().getDoc().getDocumentReference();        }        return currentReferenceResolver.resolve(source);    }    private XWikiContext getXWikiContext()    {        return (XWikiContext) execution.getContext().getProperty(\"xwikicontext\");    }    @Override    public List<Block> getDashboardSourceMetadata(String source, MacroTransformationContext context)    {        DocumentReference sourceDoc = getSourceDocumentReference(source);        String classParameterName = \"class\";        GroupBlock metadataContainer = new GroupBlock();        metadataContainer.setParameter(classParameterName, DashboardMacro.METADATA);        XWikiContext xContext = getXWikiContext();        String editURL = xContext.getWiki().getURL(sourceDoc, \"save\", \"\", \"\", xContext);        LinkBlock editURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(editURL, ResourceType.URL), false);        editURLBlock.setParameter(classParameterName, DashboardMacro.EDIT_URL);        metadataContainer.addChild(editURLBlock);        String removeURL = xContext.getWiki().getURL(sourceDoc, \"objectremove\", \"\", \"\", xContext);        LinkBlock removeURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(removeURL, ResourceType.URL), false);        removeURLBlock.setParameter(classParameterName, DashboardMacro.REMOVE_URL);        metadataContainer.addChild(removeURLBlock);        String addURL = xContext.getWiki().getURL(sourceDoc, \"objectadd\", \"\", \"\", xContext);        LinkBlock addURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(addURL, ResourceType.URL), false);        addURLBlock.setParameter(classParameterName, DashboardMacro.ADD_URL);        metadataContainer.addChild(addURLBlock);        GroupBlock sourcePageBlock = new GroupBlock();        sourcePageBlock.addChild(new WordBlock(sourceDoc.getName()));        sourcePageBlock.setParameter(classParameterName, DashboardMacro.SOURCE_PAGE);        metadataContainer.addChild(sourcePageBlock);        GroupBlock sourceSpaceBlock = new GroupBlock();        sourceSpaceBlock.addChild(new WordBlock(            this.localReferenceSerializer.serialize(sourceDoc.getLastSpaceReference())));        sourceSpaceBlock.setParameter(classParameterName, DashboardMacro.SOURCE_SPACE);        metadataContainer.addChild(sourceSpaceBlock);        GroupBlock sourceWikiBlock = new GroupBlock();        sourceWikiBlock.addChild(new WordBlock(sourceDoc.getWikiReference().getName()));        sourceWikiBlock.setParameter(classParameterName, DashboardMacro.SOURCE_WIKI);        metadataContainer.addChild(sourceWikiBlock);        String sourceURL = xContext.getWiki().getURL(sourceDoc, \"view\", \"\", \"\", xContext);        LinkBlock sourceURLBlock =            new LinkBlock(Collections.<Block> emptyList(), new ResourceReference(sourceURL, ResourceType.URL), false);        sourceURLBlock.setParameter(classParameterName, DashboardMacro.SOURCE_URL);        metadataContainer.addChild(sourceURLBlock);        return Collections.<Block> singletonList(metadataContainer);    }    @Override    public boolean isEditing()    {        XWikiContext context = getXWikiContext();        return \"inline\".equals(context.getAction()) || \"edit\".equals(context.getAction());    }}"}
{"code": "import java.io.StringWriter;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.Callable;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.Mock;import org.mockito.stubbing.Answer;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.rendering.block.WordBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.executor.ContentExecutor;import org.xwiki.rendering.macro.dashboard.Gadget;import org.xwiki.rendering.transformation.MacroTransformationContext;import org.xwiki.rendering.transformation.TransformationContext;import org.xwiki.security.authorization.AuthorExecutor;import org.xwiki.security.authorization.AuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.test.mockito.MockitoComponentManager;import org.xwiki.velocity.VelocityEngine;import org.xwiki.velocity.VelocityManager;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentTestclass DefaultGadgetSourceTest{    @InjectMockComponents    private DefaultGadgetSource defaultGadgetSource;    private static final String testSource = \"XWiki.Test\";    private static final String transformationId = \"fooId\";    @MockComponent    private AuthorExecutor authorExecutor;    @MockComponent    private AuthorizationManager authorizationManager;    @Mock    private DocumentReference documentReference;    @Mock    private XWikiDocument xWikiDocument;    @Mock    private XWikiDocument ownerDocument;    @Mock    private DocumentReference ownerAuthorReference;    @Mock    private DocumentReference ownerSourceReference;    @Mock    private XWiki xwiki;    @Mock    private XWikiContext xWikiContext;    @Mock    private DocumentReference gadgetClassReference;    @Mock    private MacroTransformationContext macroTransformationContext;    @Mock    private VelocityEngine velocityEngine;    private ContentExecutor<MacroTransformationContext> contentExecutor;    @BeforeEach    void setup(MockitoComponentManager componentManager) throws Exception    {        DocumentReferenceResolver<String> currentReferenceResolver =            componentManager.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");        when(currentReferenceResolver.resolve(testSource)).thenReturn(documentReference);        Execution execution = componentManager.getInstance(Execution.class);        ExecutionContext executionContext = mock(ExecutionContext.class);        when(execution.getContext()).thenReturn(executionContext);        when(executionContext.getProperty(\"xwikicontext\")).thenReturn(xWikiContext);        when(xWikiContext.getWiki()).thenReturn(xwiki);        when(xwiki.getDocument(documentReference, xWikiContext)).thenReturn(xWikiDocument);        DocumentReferenceResolver<EntityReference> currentReferenceEntityResolver =            componentManager.getInstance(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");        when(currentReferenceEntityResolver.resolve(DefaultGadgetSource.GADGET_CLASS)).thenReturn(gadgetClassReference);        TransformationContext transformationContext = mock(TransformationContext.class);        when(macroTransformationContext.getTransformationContext()).thenReturn(transformationContext);        when(transformationContext.getId()).thenReturn(transformationId);        VelocityManager velocityManager = componentManager.getInstance(VelocityManager.class);        when(velocityManager.getVelocityEngine()).thenReturn(velocityEngine);        when(authorExecutor.call(any(), eq(ownerAuthorReference), eq(ownerSourceReference))).then(invocationOnMock -> {            Callable callable = (Callable) invocationOnMock.getArguments()[0];            return callable.call();        });        this.contentExecutor =            componentManager.getInstance(ContentExecutor.TYPE_MACRO_TRANSFORMATION);        when(contentExecutor.execute(any(), any(), any(), any())).then((Answer<XDOM>) invocationOnMock -> {            String content = invocationOnMock.getArgument(0);            XDOM xdom = new XDOM(Collections.singletonList(new WordBlock(content)));            return xdom;        });        when(ownerDocument.getAuthorReference()).thenReturn(ownerAuthorReference);        when(ownerDocument.getDocumentReference()).thenReturn(ownerSourceReference);    }    @Test    void getGadgets() throws Exception    {        assertEquals(new ArrayList<>(), this.defaultGadgetSource.getGadgets(testSource, macroTransformationContext));        BaseObject gadgetObject1 = mock(BaseObject.class);        when(xWikiDocument.getXObjects(gadgetClassReference)).thenReturn(Collections.singletonList(gadgetObject1));        when(gadgetObject1.getOwnerDocument()).thenReturn(ownerDocument);        when(gadgetObject1.getStringValue(\"title\")).thenReturn(\"Gadget 1\");        when(gadgetObject1.getLargeStringValue(\"content\")).thenReturn(\"Some content\");        when(gadgetObject1.getStringValue(\"position\")).thenReturn(\"0\");        when(gadgetObject1.getNumber()).thenReturn(42);        when(this.authorizationManager.hasAccess(Right.SCRIPT, ownerAuthorReference, ownerSourceReference)).thenReturn(true);        when(this.velocityEngine.evaluate(any(), any(), any(), eq(\"Gadget 1\"))).then((Answer<Void>) invocation -> {            Object[] args = invocation.getArguments();            StringWriter stringWriter = (StringWriter) args[1];            String title = \"Evaluated velocity version of gadget 1\";            stringWriter.append(title);            return null;        });        List<Gadget> gadgets = this.defaultGadgetSource.getGadgets(testSource, macroTransformationContext);        assertEquals(1, gadgets.size());        Gadget gadget = gadgets.get(0);        assertEquals(\"Evaluated velocity version of gadget 1\", gadget.getTitle().get(0).toString());        assertEquals(\"Some content\", gadget.getContent().get(0).toString());        assertEquals(\"42\", gadget.getId());        verify(this.contentExecutor)            .execute(eq(\"Evaluated velocity version of gadget 1\"), any(), any(), any());        verify(this.contentExecutor)            .execute(eq(\"Some content\"), any(), any(), any());    }    @Test    void getGadgetWithoutScriptRight() throws Exception    {        assertEquals(new ArrayList<>(), this.defaultGadgetSource.getGadgets(testSource, macroTransformationContext));        BaseObject gadgetObject1 = mock(BaseObject.class);        when(xWikiDocument.getXObjects(gadgetClassReference)).thenReturn(Collections.singletonList(gadgetObject1));        when(gadgetObject1.getOwnerDocument()).thenReturn(ownerDocument);        when(gadgetObject1.getStringValue(\"title\")).thenReturn(\"Gadget 2\");        when(gadgetObject1.getLargeStringValue(\"content\")).thenReturn(\"Some other content\");        when(gadgetObject1.getStringValue(\"position\")).thenReturn(\"2\");        when(gadgetObject1.getNumber()).thenReturn(12);        when(this.authorizationManager.hasAccess(Right.SCRIPT, ownerAuthorReference, ownerSourceReference)).thenReturn(false);        List<Gadget> gadgets = this.defaultGadgetSource.getGadgets(testSource, macroTransformationContext);        assertEquals(1, gadgets.size());        Gadget gadget = gadgets.get(0);        assertEquals(\"Gadget 2\", gadget.getTitle().get(0).toString());        assertEquals(\"Some other content\", gadget.getContent().get(0).toString());        assertEquals(\"12\", gadget.getId());        verify(this.contentExecutor)            .execute(eq(\"Gadget 2\"), any(), any(), any());        verify(this.contentExecutor)            .execute(eq(\"Some other content\"), any(), any(), any());    }}", "nl": "import java.io.StringWriter;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.Callable;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.Mock;import org.mockito.stubbing.Answer;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.rendering.block.WordBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.executor.ContentExecutor;import org.xwiki.rendering.macro.dashboard.Gadget;import org.xwiki.rendering.transformation.MacroTransformationContext;import org.xwiki.rendering.transformation.TransformationContext;import org.xwiki.security.authorization.AuthorExecutor;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.test.mockito.MockitoComponentManager;import org.xwiki.velocity.VelocityEngine;import org.xwiki.velocity.VelocityManager;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;@ComponentTestclass DefaultGadgetSourceTest{    @InjectMockComponents    private DefaultGadgetSource defaultGadgetSource;    private static final String testSource = \"XWiki.Test\";    private static final String transformationId = \"fooId\";    @MockComponent    private AuthorExecutor authorExecutor;    @Mock    private DocumentReference documentReference;    @Mock    private XWikiDocument xWikiDocument;    @Mock    private XWikiDocument ownerDocument;    @Mock    private DocumentReference ownerAuthorReference;    @Mock    private DocumentReference ownerSourceReference;    @Mock    private XWiki xwiki;    @Mock    private XWikiContext xWikiContext;    @Mock    private DocumentReference gadgetClassReference;    @Mock    private MacroTransformationContext macroTransformationContext;    @BeforeEach    void setup(MockitoComponentManager componentManager) throws Exception    {        DocumentReferenceResolver<String> currentReferenceResolver =            componentManager.getInstance(DocumentReferenceResolver.TYPE_STRING, \"current\");        when(currentReferenceResolver.resolve(testSource)).thenReturn(documentReference);        Execution execution = componentManager.getInstance(Execution.class);        ExecutionContext executionContext = mock(ExecutionContext.class);        when(execution.getContext()).thenReturn(executionContext);        when(executionContext.getProperty(\"xwikicontext\")).thenReturn(xWikiContext);        when(xWikiContext.getWiki()).thenReturn(xwiki);        when(xwiki.getDocument(documentReference, xWikiContext)).thenReturn(xWikiDocument);        DocumentReferenceResolver<EntityReference> currentReferenceEntityResolver =            componentManager.getInstance(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");        when(currentReferenceEntityResolver.resolve(DefaultGadgetSource.GADGET_CLASS)).thenReturn(gadgetClassReference);        TransformationContext transformationContext = mock(TransformationContext.class);        when(macroTransformationContext.getTransformationContext()).thenReturn(transformationContext);        when(transformationContext.getId()).thenReturn(transformationId);        VelocityManager velocityManager = componentManager.getInstance(VelocityManager.class);        VelocityEngine velocityEngine = mock(VelocityEngine.class);        when(velocityManager.getVelocityEngine()).thenReturn(velocityEngine);        when(velocityEngine.evaluate(any(), any(), any(), any(String.class))).then((Answer<Void>) invocation -> {            Object[] args = invocation.getArguments();            StringWriter stringWriter = (StringWriter) args[1];            String title = (String) args[3];            stringWriter.append(title);            return null;        });        AuthorExecutor authorExecutor = componentManager.getInstance(AuthorExecutor.class);        when(authorExecutor.call(any(), eq(ownerAuthorReference), eq(ownerSourceReference))).then(invocationOnMock -> {            Callable callable = (Callable) invocationOnMock.getArguments()[0];            return callable.call();        });        ContentExecutor<MacroTransformationContext> contentExecutor =            componentManager.getInstance(ContentExecutor.TYPE_MACRO_TRANSFORMATION);        when(contentExecutor.execute(any(), any(), any(), any())).then((Answer<XDOM>) invocationOnMock -> {            String content = invocationOnMock.getArgument(0);            XDOM xdom = new XDOM(Collections.singletonList(new WordBlock(content)));            return xdom;        });        when(ownerDocument.getAuthorReference()).thenReturn(ownerAuthorReference);        when(ownerDocument.getDocumentReference()).thenReturn(ownerSourceReference);    }    @Test    void getGadgets() throws Exception    {        assertEquals(new ArrayList<>(), this.defaultGadgetSource.getGadgets(testSource, macroTransformationContext));        BaseObject gadgetObject1 = mock(BaseObject.class);        when(xWikiDocument.getXObjects(gadgetClassReference)).thenReturn(Collections.singletonList(gadgetObject1));        when(gadgetObject1.getOwnerDocument()).thenReturn(ownerDocument);        when(gadgetObject1.getStringValue(\"title\")).thenReturn(\"Gadget 1\");        when(gadgetObject1.getLargeStringValue(\"content\")).thenReturn(\"Some content\");        when(gadgetObject1.getStringValue(\"position\")).thenReturn(\"0\");        when(gadgetObject1.getNumber()).thenReturn(42);        List<Gadget> gadgets = this.defaultGadgetSource.getGadgets(testSource, macroTransformationContext);        assertEquals(1, gadgets.size());        Gadget gadget = gadgets.get(0);        assertEquals(\"Gadget 1\", gadget.getTitle().get(0).toString());        assertEquals(\"Some content\", gadget.getContent().get(0).toString());        assertEquals(\"42\", gadget.getId());    }}"}
{"code": "import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Collections;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import org.apache.commons.fileupload.FileItem;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.suigeneris.jrcs.diff.DifferentiationFailedException;import org.suigeneris.jrcs.diff.delta.Delta;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.display.internal.DocumentDisplayerParameters;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.ObjectReference;import org.xwiki.model.reference.PageReference;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.parser.ParseException;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiConstant;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.criteria.impl.Period;import com.xpn.xwiki.criteria.impl.PeriodFactory;import com.xpn.xwiki.criteria.impl.Range;import com.xpn.xwiki.criteria.impl.RangeFactory;import com.xpn.xwiki.criteria.impl.RevisionCriteria;import com.xpn.xwiki.criteria.impl.Scope;import com.xpn.xwiki.criteria.impl.ScopeFactory;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MetaDataDiff;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiDocumentArchive;import com.xpn.xwiki.doc.XWikiLink;import com.xpn.xwiki.doc.XWikiLock;import com.xpn.xwiki.internal.XWikiCfgConfigurationSource;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.BaseProperty;import com.xpn.xwiki.objects.ObjectDiff;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;import com.xpn.xwiki.stats.api.XWikiStatsService;import com.xpn.xwiki.stats.impl.DocumentStats;import com.xpn.xwiki.stats.impl.RefererStats;import com.xpn.xwiki.util.TOCGenerator;import com.xpn.xwiki.util.Util;import com.xpn.xwiki.web.Utils;public class Document extends Api{    private static final Logger LOGGER = LoggerFactory.getLogger(Document.class);    protected XWikiDocument initialDoc;    protected XWikiDocument doc;    protected Object currentObj;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;    private EntityReferenceSerializer<String> localEntityReferenceSerializer;    private EntityReferenceSerializer<String> compactWikiEntityReferenceSerializer;    private DocumentRevisionProvider documentRevisionProvider;    private ConfigurationSource configuration;    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()    {        if (this.defaultEntityReferenceSerializer == null) {            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultEntityReferenceSerializer;    }    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()    {        if (this.localEntityReferenceSerializer == null) {            this.localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localEntityReferenceSerializer;    }    private EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()    {        if (this.compactWikiEntityReferenceSerializer == null) {            this.compactWikiEntityReferenceSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");        }        return this.compactWikiEntityReferenceSerializer;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    private ConfigurationSource getConfiguration()    {        if (this.configuration == null) {            this.configuration = Utils.getComponent(ConfigurationSource.class);        }        return this.configuration;    }    public Document(XWikiDocument doc, XWikiContext context)    {        super(context);        this.initialDoc = doc;        this.doc = this.initialDoc;    }    public XWikiDocument getDocument()    {        if (hasProgrammingRights()) {            return this.doc;        } else {            return null;        }    }    protected XWikiDocument getDoc()    {        if (this.initialDoc == this.doc) {            this.doc = this.initialDoc.clone();        }        return this.doc;    }    public long getId()    {        return this.doc.getId();    }    public DocumentReference getDocumentReference()    {        return this.doc.getDocumentReference();    }    public DocumentReference getDocumentReferenceWithLocale()    {        return this.doc.getDocumentReferenceWithLocale();    }    public PageReference getPageReference()    {        return this.doc.getPageReference();    }    public PageReference getPageReferenceWithLocale()    {        return this.doc.getPageReferenceWithLocale();    }    @Deprecated    public String getName(){    return this.doc.getDocumentReference().getName();}    public String getSpace()    {        return this.doc.getSpace();    }    public String getWiki()    {        return this.doc.getDocumentReference().getWikiReference().getName();    }    public String getFullName()    {        return getLocalEntityReferenceSerializer().serialize(this.doc.getDocumentReference());    }    public String getPrefixedFullName()    {        return getDefaultEntityReferenceSerializer().serialize(this.doc.getDocumentReference());    }    public Version getRCSVersion()    {        return this.doc.getRCSVersion();    }    public String getVersion()    {        return this.doc.getVersion();    }    public String getPreviousVersion()    {        return this.doc.getPreviousVersion();    }    public String getTitle()    {        return this.doc.getTitle();    }    public String getDisplayTitle()    {        return this.doc.getRenderedTitle(getXWikiContext());    }    public String getPlainTitle()    {        return this.doc.getRenderedTitle(Syntax.PLAIN_1_0, getXWikiContext());    }    public String getRenderedTitle(String syntaxId) throws XWikiException    {        try {            return this.doc.getRenderedTitle(Syntax.valueOf(syntaxId), getXWikiContext());        } catch (ParseException e) {            LOGGER.error(\"Failed to parse provided syntax identifier [\" + syntaxId + \"]\", e);            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,                \"Failed to parse syntax identifier [\" + syntaxId + \"]\", e);        } catch (Exception e) {            LOGGER.error(\"Failed to render document [\" + getPrefixedFullName() + \"] title content\", e);            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,                \"Failed to render document [\" + getPrefixedFullName() + \"] content title\", e);        }    }    public String getFormat()    {        return this.doc.getFormat();    }    public String getAuthor()    {        return this.doc.getAuthor();    }    public DocumentReference getAuthorReference()    {        return this.doc.getAuthorReference();    }    public String getContentAuthor()    {        return this.doc.getContentAuthor();    }    public DocumentReference getContentAuthorReference()    {        return this.doc.getContentAuthorReference();    }    public Date getDate()    {        return this.doc.getDate();    }    public Date getContentUpdateDate()    {        return this.doc.getContentUpdateDate();    }    public Date getCreationDate()    {        return this.doc.getCreationDate();    }    public String getParent()    {        return this.doc.getParent();    }    public DocumentReference getParentReference()    {        return this.doc.getParentReference();    }    public String getCreator()    {        return this.doc.getCreator();    }    public DocumentReference getCreatorReference()    {        return this.doc.getCreatorReference();    }    public String getContent()    {        return this.doc.getContent();    }    public XDOM getXDOM()    {        return this.doc.getXDOM();    }    public Syntax getSyntax()    {        return this.doc.getSyntax();    }    @Deprecated    public String getSyntaxId()    {        return this.doc.getSyntax().toIdString();    }    @Deprecated    public String getLanguage()    {        return this.doc.getLanguage();    }    public Locale getLocale()    {        return this.doc.getLocale();    }    public String getTemplate()    {        String templateReferenceAsString = \"\";        DocumentReference templateDocumentReference = this.doc.getTemplateDocumentReference();        if (templateDocumentReference != null) {            templateReferenceAsString = getLocalEntityReferenceSerializer().serialize(templateDocumentReference);        }        return templateReferenceAsString;    }    @Deprecated    public String getRealLanguage() throws XWikiException    {        return this.doc.getRealLanguage(getXWikiContext());    }    public Locale getRealLocale()    {        return this.doc.getRealLocale();    }    @Deprecated    public String getDefaultLanguage()    {        return this.doc.getDefaultLanguage();    }    public Locale getDefaultLocale()    {        return this.doc.getDefaultLocale();    }    public void setDefaultLocale(Locale defaultLocale)    {        this.doc.setDefaultLocale(defaultLocale);    }    public String getDefaultTemplate()    {        return this.doc.getDefaultTemplate();    }    public String getComment()    {        return this.doc.getComment();    }    public boolean isMinorEdit()    {        return this.doc.isMinorEdit();    }    @Unstable    public List<Locale> getTranslationLocales() throws XWikiException    {        return this.doc.getTranslationLocales(getXWikiContext());    }    public String getTranslatedContent() throws XWikiException    {        return this.doc.getTranslatedContent(getXWikiContext());    }    public String getTranslatedContent(String locale) throws XWikiException    {        return this.doc.getTranslatedContent(locale, getXWikiContext());    }    public Document getTranslatedDocument(String locale) throws XWikiException    {        return this.doc.getTranslatedDocument(locale, getXWikiContext()).newDocument(getXWikiContext());    }    public Document getTranslatedDocument() throws XWikiException    {        return this.doc.getTranslatedDocument(getXWikiContext()).newDocument(getXWikiContext());    }    public String displayDocument(Syntax targetSyntax) throws XWikiException    {        return this.doc.displayDocument(targetSyntax, getXWikiContext());    }    public String displayDocument(Syntax targetSyntax, boolean restricted) throws XWikiException    {        return this.doc.displayDocument(targetSyntax, restricted, getXWikiContext());    }    public String displayDocument() throws XWikiException    {        return this.doc.displayDocument(getXWikiContext());    }    public String displayDocument(boolean restricted) throws XWikiException    {        return this.doc.displayDocument(restricted, getXWikiContext());    }    public String getRenderedContent() throws XWikiException    {        return this.doc.getRenderedContent(getXWikiContext());    }    public String getRenderedContent(boolean transformationContextIsolated) throws XWikiException    {        return this.doc.getRenderedContent(transformationContextIsolated, getXWikiContext());    }    @Deprecated    public String getRenderedContent(String text) throws XWikiException    {        return getRenderedContent(text, Syntax.XWIKI_1_0.toIdString());    }    public String getRenderedContent(String text, String syntaxId) throws XWikiException    {        return getRenderedContent(text, syntaxId, false);    }    public String getRenderedContentRestricted(String text, String syntaxId) throws XWikiException    {        return getRenderedContent(text, syntaxId, true);    }    private String getRenderedContent(String text, String syntaxId, boolean restricted) throws XWikiException    {        return this.doc.getRenderedContent(text, syntaxId, restricted, getCallerDocument(getXWikiContext()),            getXWikiContext());    }    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId) throws XWikiException    {        return this.doc.getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false,            getCallerDocument(getXWikiContext()), getXWikiContext());    }    private XWikiDocument getCallerDocument(XWikiContext xcontext)    {        XWikiDocument sdoc = (XWikiDocument) xcontext.get(\"sdoc\");        if (sdoc == null) {            sdoc = xcontext.getDoc();        }        return sdoc;    }    public String getRenderedContent(Syntax targetSyntax) throws XWikiException    {        return this.doc.getRenderedContent(targetSyntax, getXWikiContext());    }    public String getEscapedContent() throws XWikiException    {        return this.doc.getEscapedContent(getXWikiContext());    }    public String getArchive() throws XWikiException    {        return this.doc.getDocumentArchive(getXWikiContext()).getArchive(getXWikiContext());    }    public XWikiDocumentArchive getDocumentArchive() throws XWikiException    {        if (hasProgrammingRights()) {            return this.doc.getDocumentArchive(getXWikiContext());        }        return null;    }    public boolean isNew()    {        return this.doc.isNew();    }    public String getAttachmentURL(String filename)    {        return this.doc.getAttachmentURL(filename, getXWikiContext());    }    public String getAttachmentURL(String filename, String action)    {        return this.doc.getAttachmentURL(filename, action, getXWikiContext());    }    public String getAttachmentURL(String filename, String action, String queryString)    {        return this.doc.getAttachmentURL(filename, action, queryString, getXWikiContext());    }    /**     * Get an old revision of an attachment.     *     * @param filename the name of the attachment.     * @param version a revisio", "nl": "import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Collections;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import org.apache.commons.fileupload.FileItem;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.suigeneris.jrcs.diff.DifferentiationFailedException;import org.suigeneris.jrcs.diff.delta.Delta;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.display.internal.DocumentDisplayerParameters;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.ObjectReference;import org.xwiki.model.reference.PageReference;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.parser.ParseException;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiConstant;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.criteria.impl.Period;import com.xpn.xwiki.criteria.impl.PeriodFactory;import com.xpn.xwiki.criteria.impl.Range;import com.xpn.xwiki.criteria.impl.RangeFactory;import com.xpn.xwiki.criteria.impl.RevisionCriteria;import com.xpn.xwiki.criteria.impl.Scope;import com.xpn.xwiki.criteria.impl.ScopeFactory;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MetaDataDiff;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiDocumentArchive;import com.xpn.xwiki.doc.XWikiLink;import com.xpn.xwiki.doc.XWikiLock;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.BaseProperty;import com.xpn.xwiki.objects.ObjectDiff;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;import com.xpn.xwiki.stats.api.XWikiStatsService;import com.xpn.xwiki.stats.impl.DocumentStats;import com.xpn.xwiki.stats.impl.RefererStats;import com.xpn.xwiki.util.TOCGenerator;import com.xpn.xwiki.util.Util;import com.xpn.xwiki.web.Utils;public class Document extends Api{    private static final Logger LOGGER = LoggerFactory.getLogger(Document.class);    protected XWikiDocument initialDoc;    protected XWikiDocument doc;    protected Object currentObj;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;    private EntityReferenceSerializer<String> localEntityReferenceSerializer;    private EntityReferenceSerializer<String> compactWikiEntityReferenceSerializer;    private DocumentRevisionProvider documentRevisionProvider;    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()    {        if (this.defaultEntityReferenceSerializer == null) {            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultEntityReferenceSerializer;    }    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()    {        if (this.localEntityReferenceSerializer == null) {            this.localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localEntityReferenceSerializer;    }    private EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()    {        if (this.compactWikiEntityReferenceSerializer == null) {            this.compactWikiEntityReferenceSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");        }        return this.compactWikiEntityReferenceSerializer;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    public Document(XWikiDocument doc, XWikiContext context)    {        super(context);        this.initialDoc = doc;        this.doc = this.initialDoc;    }    public XWikiDocument getDocument()    {        if (hasProgrammingRights()) {            return this.doc;        } else {            return null;        }    }    protected XWikiDocument getDoc()    {        if (this.initialDoc == this.doc) {            this.doc = this.initialDoc.clone();        }        return this.doc;    }    public long getId()    {        return this.doc.getId();    }    public DocumentReference getDocumentReference()    {        return this.doc.getDocumentReference();    }    public DocumentReference getDocumentReferenceWithLocale()    {        return this.doc.getDocumentReferenceWithLocale();    }    public PageReference getPageReference()    {        return this.doc.getPageReference();    }    public PageReference getPageReferenceWithLocale()    {        return this.doc.getPageReferenceWithLocale();    }    @Deprecated    public String getName(){    return this.doc.getDocumentReference().getName();}    public String getSpace()    {        return this.doc.getSpace();    }    public String getWiki()    {        return this.doc.getDocumentReference().getWikiReference().getName();    }    public String getFullName()    {        return getLocalEntityReferenceSerializer().serialize(this.doc.getDocumentReference());    }    public String getPrefixedFullName()    {        return getDefaultEntityReferenceSerializer().serialize(this.doc.getDocumentReference());    }    public Version getRCSVersion()    {        return this.doc.getRCSVersion();    }    public String getVersion()    {        return this.doc.getVersion();    }    public String getPreviousVersion()    {        return this.doc.getPreviousVersion();    }    public String getTitle()    {        return this.doc.getTitle();    }    public String getDisplayTitle()    {        return this.doc.getRenderedTitle(getXWikiContext());    }    public String getPlainTitle()    {        return this.doc.getRenderedTitle(Syntax.PLAIN_1_0, getXWikiContext());    }    public String getRenderedTitle(String syntaxId) throws XWikiException    {        try {            return this.doc.getRenderedTitle(Syntax.valueOf(syntaxId), getXWikiContext());        } catch (ParseException e) {            LOGGER.error(\"Failed to parse provided syntax identifier [\" + syntaxId + \"]\", e);            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,                \"Failed to parse syntax identifier [\" + syntaxId + \"]\", e);        } catch (Exception e) {            LOGGER.error(\"Failed to render document [\" + getPrefixedFullName() + \"] title content\", e);            throw new XWikiException(XWikiException.MODULE_XWIKI_RENDERING, XWikiException.ERROR_XWIKI_UNKNOWN,                \"Failed to render document [\" + getPrefixedFullName() + \"] content title\", e);        }    }    public String getFormat()    {        return this.doc.getFormat();    }    public String getAuthor()    {        return this.doc.getAuthor();    }    public DocumentReference getAuthorReference()    {        return this.doc.getAuthorReference();    }    public String getContentAuthor()    {        return this.doc.getContentAuthor();    }    public DocumentReference getContentAuthorReference()    {        return this.doc.getContentAuthorReference();    }    public Date getDate()    {        return this.doc.getDate();    }    public Date getContentUpdateDate()    {        return this.doc.getContentUpdateDate();    }    public Date getCreationDate()    {        return this.doc.getCreationDate();    }    public String getParent()    {        return this.doc.getParent();    }    public DocumentReference getParentReference()    {        return this.doc.getParentReference();    }    public String getCreator()    {        return this.doc.getCreator();    }    public DocumentReference getCreatorReference()    {        return this.doc.getCreatorReference();    }    public String getContent()    {        return this.doc.getContent();    }    public XDOM getXDOM()    {        return this.doc.getXDOM();    }    public Syntax getSyntax()    {        return this.doc.getSyntax();    }    @Deprecated    public String getSyntaxId()    {        return this.doc.getSyntax().toIdString();    }    @Deprecated    public String getLanguage()    {        return this.doc.getLanguage();    }    public Locale getLocale()    {        return this.doc.getLocale();    }    public String getTemplate()    {        String templateReferenceAsString = \"\";        DocumentReference templateDocumentReference = this.doc.getTemplateDocumentReference();        if (templateDocumentReference != null) {            templateReferenceAsString = getLocalEntityReferenceSerializer().serialize(templateDocumentReference);        }        return templateReferenceAsString;    }    @Deprecated    public String getRealLanguage() throws XWikiException    {        return this.doc.getRealLanguage(getXWikiContext());    }    public Locale getRealLocale()    {        return this.doc.getRealLocale();    }    @Deprecated    public String getDefaultLanguage()    {        return this.doc.getDefaultLanguage();    }    public Locale getDefaultLocale()    {        return this.doc.getDefaultLocale();    }    public void setDefaultLocale(Locale defaultLocale)    {        this.doc.setDefaultLocale(defaultLocale);    }    public String getDefaultTemplate()    {        return this.doc.getDefaultTemplate();    }    public String getComment()    {        return this.doc.getComment();    }    public boolean isMinorEdit()    {        return this.doc.isMinorEdit();    }    @Unstable    public List<Locale> getTranslationLocales() throws XWikiException    {        return this.doc.getTranslationLocales(getXWikiContext());    }    public String getTranslatedContent() throws XWikiException    {        return this.doc.getTranslatedContent(getXWikiContext());    }    public String getTranslatedContent(String locale) throws XWikiException    {        return this.doc.getTranslatedContent(locale, getXWikiContext());    }    public Document getTranslatedDocument(String locale) throws XWikiException    {        return this.doc.getTranslatedDocument(locale, getXWikiContext()).newDocument(getXWikiContext());    }    public Document getTranslatedDocument() throws XWikiException    {        return this.doc.getTranslatedDocument(getXWikiContext()).newDocument(getXWikiContext());    }    public String displayDocument(Syntax targetSyntax) throws XWikiException    {        return this.doc.displayDocument(targetSyntax, getXWikiContext());    }    public String displayDocument(Syntax targetSyntax, boolean restricted) throws XWikiException    {        return this.doc.displayDocument(targetSyntax, restricted, getXWikiContext());    }    public String displayDocument() throws XWikiException    {        return this.doc.displayDocument(getXWikiContext());    }    public String displayDocument(boolean restricted) throws XWikiException    {        return this.doc.displayDocument(restricted, getXWikiContext());    }    public String getRenderedContent() throws XWikiException    {        return this.doc.getRenderedContent(getXWikiContext());    }    public String getRenderedContent(boolean transformationContextIsolated) throws XWikiException    {        return this.doc.getRenderedContent(transformationContextIsolated, getXWikiContext());    }    @Deprecated    public String getRenderedContent(String text) throws XWikiException    {        return getRenderedContent(text, Syntax.XWIKI_1_0.toIdString());    }    public String getRenderedContent(String text, String syntaxId) throws XWikiException    {        return getRenderedContent(text, syntaxId, false);    }    public String getRenderedContentRestricted(String text, String syntaxId) throws XWikiException    {        return getRenderedContent(text, syntaxId, true);    }    private String getRenderedContent(String text, String syntaxId, boolean restricted) throws XWikiException    {        return this.doc.getRenderedContent(text, syntaxId, restricted, getCallerDocument(getXWikiContext()),            getXWikiContext());    }    public String getRenderedContent(String text, String sourceSyntaxId, String targetSyntaxId) throws XWikiException    {        return this.doc.getRenderedContent(text, sourceSyntaxId, targetSyntaxId, false,            getCallerDocument(getXWikiContext()), getXWikiContext());    }    private XWikiDocument getCallerDocument(XWikiContext xcontext)    {        XWikiDocument sdoc = (XWikiDocument) xcontext.get(\"sdoc\");        if (sdoc == null) {            sdoc = xcontext.getDoc();        }        return sdoc;    }    public String getRenderedContent(Syntax targetSyntax) throws XWikiException    {        return this.doc.getRenderedContent(targetSyntax, getXWikiContext());    }    public String getEscapedContent() throws XWikiException    {        return this.doc.getEscapedContent(getXWikiContext());    }    public String getArchive() throws XWikiException    {        return this.doc.getDocumentArchive(getXWikiContext()).getArchive(getXWikiContext());    }    public XWikiDocumentArchive getDocumentArchive() throws XWikiException    {        if (hasProgrammingRights()) {            return this.doc.getDocumentArchive(getXWikiContext());        }        return null;    }    public boolean isNew()    {        return this.doc.isNew();    }    public String getAttachmentURL(String filename)    {        return this.doc.getAttachmentURL(filename, getXWikiContext());    }    public String getAttachmentURL(String filename, String action)    {        return this.doc.getAttachmentURL(filename, action, getXWikiContext());    }    public String getAttachmentURL(String filename, String action, String queryString)    {        return this.doc.getAttachmentURL(filename, action, queryString, getXWikiContext());    }    public String getAttachmentRevisionURL(String filename, String version)    {        return this.doc.getAttachmentRevisionURL(filename, version, getXWikiContext());    }    /**     * Get"}
{"code": "import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.mail.Address;import javax.mail.BodyPart;import javax.mail.Multipart;import javax.mail.internet.MimeMessage;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.RandomStringUtils;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.xwiki.administration.test.po.ResetPasswordCompletePage;import org.xwiki.administration.test.po.ResetPasswordPage;import org.xwiki.test.docker.junit5.TestConfiguration;import org.xwiki.test.docker.junit5.UITest;import org.xwiki.test.integration.junit.LogCaptureConfiguration;import org.xwiki.test.ui.TestUtils;import org.xwiki.test.ui.po.LoginPage;import com.icegreen.greenmail.util.GreenMail;import com.icegreen.greenmail.util.ServerSetupTest;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;@UITest(sshPorts = {    3025},    properties = {        \"xwikiDbHbmCommonExtraMappings=mailsender.hbm.xml\",        \"xwikiPropertiesAdditionalProperties=test.prchecker.excludePattern=.*:XWiki\\\\.ResetPassword|.*:XWiki\\\\.ResetPasswordComplete\"    },    extraJARs = {        \"org.xwiki.platform:xwiki-platform-mail-send-storage\"    })public class ResetPasswordIT{    private GreenMail mail;    @BeforeEach    public void startMail(TestUtils setup, TestConfiguration testConfiguration)    {        this.mail = new GreenMail(ServerSetupTest.SMTP);        this.mail.start();        configureEmail(setup, testConfiguration);    }    @AfterEach    public void stopMail(TestUtils setup, LogCaptureConfiguration logCaptureConfiguration)    {        if (this.mail != null) {            this.mail.stop();        }        restoreSettings(setup);        logCaptureConfiguration.registerExcludes(\"CSRFToken: Secret token verification failed, token\");    }    @Test    public void resetForgottenPassword(TestUtils setup) throws Exception    {        setup.loginAsSuperAdmin();        String userName = \"testUser\" + RandomStringUtils.randomAlphanumeric(6);        String password = \"password\";        String newPassword = \"newPassword\";        setup.createUser(userName, password, null);        setup.forceGuestUser();        ResetPasswordPage resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(\"SomeUserThatDoesNotExist\");        resetPasswordPage = resetPasswordPage.clickResetPassword();        assertFalse(resetPasswordPage.isResetPasswordSent());        assertTrue(resetPasswordPage.getMessage().contains(\"user does not exist\"));        resetPasswordPage = resetPasswordPage.clickRetry();        resetPasswordPage.setUserName(userName);        resetPasswordPage.clickResetPassword();        assertFalse(resetPasswordPage.isResetPasswordSent());        assertTrue(resetPasswordPage.getMessage().contains(\"email address not provided\"));        setup.loginAsSuperAdmin();        setup.updateObject(\"XWiki\", userName, \"XWiki.XWikiUsers\", 0, \"email\", \"foo@bar.com\", \"form_token\",            setup.getSecretToken());        setup.forceGuestUser();        resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(userName);        ResetPasswordPage newResetPasswordPage = resetPasswordPage.clickResetPassword();        assertTrue(newResetPasswordPage.getMessage().contains(\"An e-mail was sent\"),            \"Actual message: \" + newResetPasswordPage.getMessage());        assertFalse(newResetPasswordPage.getMessage().contains(\"foo@bar.com\"),            \"Actual message: \" + newResetPasswordPage.getMessage());        assertTrue(resetPasswordPage.isResetPasswordSent());        assertTrue(this.mail.waitForIncomingEmail(1));        MimeMessage[] receivedEmails = this.mail.getReceivedMessages();        assertEquals(1, receivedEmails.length);        MimeMessage receivedEmail = receivedEmails[0];        assertEquals(\"Password reset request for \" + userName, receivedEmail.getSubject());        String receivedMailContent = getMessageContent(receivedEmail).get(\"textPart\");        String passwordResetLink = getResetLink(receivedMailContent, \"xwiki%3AXWiki.\" + userName);        assertNotNull(passwordResetLink);        setup.gotoPage(passwordResetLink);        ResetPasswordCompletePage resetPasswordCompletePage = new ResetPasswordCompletePage();        assertTrue(resetPasswordCompletePage.isResetLinkValid());        resetPasswordCompletePage.setPassword(newPassword);        resetPasswordCompletePage.setPasswordConfirmation(newPassword);        resetPasswordCompletePage = resetPasswordCompletePage.clickSave();        assertTrue(resetPasswordCompletePage.isPasswordSuccessfullyReset());        LoginPage loginPage = resetPasswordCompletePage.clickLogin();        loginPage.loginAs(userName, newPassword);        assertEquals(userName, setup.getLoggedInUserName());    }    private Map<String, String> getMessageContent(MimeMessage message) throws Exception    {        Map<String, String> messageMap = new HashMap<>();        Address[] addresses = message.getAllRecipients();        assertTrue(addresses.length == 1);        messageMap.put(\"recipient\", addresses[0].toString());        messageMap.put(\"subjectLine\", message.getSubject());        Multipart mp = (Multipart) message.getContent();        BodyPart plain = getPart(mp, \"text/plain\");        if (plain != null) {            messageMap.put(\"textPart\", IOUtils.toString(plain.getInputStream(), \"UTF-8\"));        }        BodyPart html = getPart(mp, \"text/html\");        if (html != null) {            messageMap.put(\"htmlPart\", IOUtils.toString(html.getInputStream(), \"UTF-8\"));        }        return messageMap;    }    private BodyPart getPart(Multipart messageContent, String mimeType) throws Exception    {        for (int i = 0; i < messageContent.getCount(); i++) {            BodyPart part = messageContent.getBodyPart(i);            if (part.isMimeType(mimeType)) {                return part;            }            if (part.isMimeType(\"multipart/related\") || part.isMimeType(\"multipart/alternative\")                || part.isMimeType(\"multipart/mixed\"))            {                BodyPart out = getPart((Multipart) part.getContent(), mimeType);                if (out != null) {                    return out;                }            }        }        return null;    }    private String getResetLink(String emailContent, String userName)    {        String result = null;        Pattern resetLinkPattern = Pattern.compile(\"http[^\\\\s]+?authenticate/reset\\\\?u=\" + userName + \"\\\\&v=\\\\w+\");        Matcher matcher = resetLinkPattern.matcher(emailContent);        if (matcher.find()) {            result = matcher.group();        }        return result;    }    private void configureEmail(TestUtils setup, TestConfiguration testConfiguration)    {        setup.updateObject(\"Mail\", \"MailConfig\", \"Mail.SendMailConfigClass\", 0, \"host\",            testConfiguration.getServletEngine().getHostIP(), \"port\", \"3025\", \"sendWaitTime\", \"0\");    }    private void restoreSettings(TestUtils setup)    {        setup.loginAsSuperAdmin();        setup.deleteLatestVersion(\"Mail\", \"MailConfig\");    }}", "nl": "import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.mail.Address;import javax.mail.BodyPart;import javax.mail.Multipart;import javax.mail.internet.MimeMessage;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.RandomStringUtils;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.xwiki.administration.test.po.ResetPasswordCompletePage;import org.xwiki.administration.test.po.ResetPasswordPage;import org.xwiki.test.docker.junit5.TestConfiguration;import org.xwiki.test.docker.junit5.UITest;import org.xwiki.test.integration.junit.LogCaptureConfiguration;import org.xwiki.test.ui.TestUtils;import org.xwiki.test.ui.po.LoginPage;import com.icegreen.greenmail.util.GreenMail;import com.icegreen.greenmail.util.ServerSetupTest;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;@UITest(sshPorts = {    3025},    properties = {        \"xwikiDbHbmCommonExtraMappings=mailsender.hbm.xml\",        \"xwikiPropertiesAdditionalProperties=test.prchecker.excludePattern=.*:XWiki\\\\.ResetPassword|.*:XWiki\\\\.ResetPasswordComplete\"    },    extraJARs = {        \"org.xwiki.platform:xwiki-platform-mail-send-storage\"    })public class ResetPasswordIT{    private GreenMail mail;    @BeforeEach    public void startMail(TestUtils setup, TestConfiguration testConfiguration)    {        this.mail = new GreenMail(ServerSetupTest.SMTP);        this.mail.start();        configureEmail(setup, testConfiguration);    }    @AfterEach    public void stopMail(TestUtils setup, LogCaptureConfiguration logCaptureConfiguration)    {        if (this.mail != null) {            this.mail.stop();        }        restoreSettings(setup);        logCaptureConfiguration.registerExcludes(\"CSRFToken: Secret token verification failed, token\");    }    @Test    public void resetForgottenPassword(TestUtils setup) throws Exception    {        setup.loginAsSuperAdmin();        String userName = \"testUser\" + RandomStringUtils.randomAlphanumeric(6);        String password = \"password\";        String newPassword = \"newPassword\";        setup.createUser(userName, password, null);        setup.forceGuestUser();        ResetPasswordPage resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(\"SomeUserThatDoesNotExist\");        resetPasswordPage = resetPasswordPage.clickResetPassword();        assertFalse(resetPasswordPage.isResetPasswordSent());        assertTrue(resetPasswordPage.getMessage().contains(\"user does not exist\"));        resetPasswordPage = resetPasswordPage.clickRetry();        resetPasswordPage.setUserName(userName);        resetPasswordPage.clickResetPassword();        assertFalse(resetPasswordPage.isResetPasswordSent());        assertTrue(resetPasswordPage.getMessage().contains(\"email address not provided\"));        setup.loginAsSuperAdmin();        setup.updateObject(\"XWiki\", userName, \"XWiki.XWikiUsers\", 0, \"email\", \"foo@bar.com\", \"form_token\",            setup.getSecretToken());        setup.forceGuestUser();        resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(userName);        resetPasswordPage.clickResetPassword();        assertTrue(resetPasswordPage.isResetPasswordSent());        assertTrue(this.mail.waitForIncomingEmail(1));        MimeMessage[] receivedEmails = this.mail.getReceivedMessages();        assertEquals(1, receivedEmails.length);        MimeMessage receivedEmail = receivedEmails[0];        assertEquals(\"Password reset request for \" + userName, receivedEmail.getSubject());        String receivedMailContent = getMessageContent(receivedEmail).get(\"textPart\");        String passwordResetLink = getResetLink(receivedMailContent, \"xwiki%3AXWiki.\" + userName);        assertNotNull(passwordResetLink);        setup.gotoPage(passwordResetLink);        ResetPasswordCompletePage resetPasswordCompletePage = new ResetPasswordCompletePage();        assertTrue(resetPasswordCompletePage.isResetLinkValid());        resetPasswordCompletePage.setPassword(newPassword);        resetPasswordCompletePage.setPasswordConfirmation(newPassword);        resetPasswordCompletePage = resetPasswordCompletePage.clickSave();        assertTrue(resetPasswordCompletePage.isPasswordSuccessfullyReset());        LoginPage loginPage = resetPasswordCompletePage.clickLogin();        loginPage.loginAs(userName, newPassword);        assertEquals(userName, setup.getLoggedInUserName());    }    private Map<String, String> getMessageContent(MimeMessage message) throws Exception    {        Map<String, String> messageMap = new HashMap<>();        Address[] addresses = message.getAllRecipients();        assertTrue(addresses.length == 1);        messageMap.put(\"recipient\", addresses[0].toString());        messageMap.put(\"subjectLine\", message.getSubject());        Multipart mp = (Multipart) message.getContent();        BodyPart plain = getPart(mp, \"text/plain\");        if (plain != null) {            messageMap.put(\"textPart\", IOUtils.toString(plain.getInputStream(), \"UTF-8\"));        }        BodyPart html = getPart(mp, \"text/html\");        if (html != null) {            messageMap.put(\"htmlPart\", IOUtils.toString(html.getInputStream(), \"UTF-8\"));        }        return messageMap;    }    private BodyPart getPart(Multipart messageContent, String mimeType) throws Exception    {        for (int i = 0; i < messageContent.getCount(); i++) {            BodyPart part = messageContent.getBodyPart(i);            if (part.isMimeType(mimeType)) {                return part;            }            if (part.isMimeType(\"multipart/related\") || part.isMimeType(\"multipart/alternative\")                || part.isMimeType(\"multipart/mixed\"))            {                BodyPart out = getPart((Multipart) part.getContent(), mimeType);                if (out != null) {                    return out;                }            }        }        return null;    }    private String getResetLink(String emailContent, String userName)    {        String result = null;        Pattern resetLinkPattern = Pattern.compile(\"http[^\\\\s]+?authenticate/reset\\\\?u=\" + userName + \"\\\\&v=\\\\w+\");        Matcher matcher = resetLinkPattern.matcher(emailContent);        if (matcher.find()) {            result = matcher.group();        }        return result;    }    private void configureEmail(TestUtils setup, TestConfiguration testConfiguration)    {        setup.updateObject(\"Mail\", \"MailConfig\", \"Mail.SendMailConfigClass\", 0, \"host\",            testConfiguration.getServletEngine().getHostIP(), \"port\", \"3025\", \"sendWaitTime\", \"0\");    }    private void restoreSettings(TestUtils setup)    {        setup.loginAsSuperAdmin();        setup.deleteLatestVersion(\"Mail\", \"MailConfig\");    }}"}
{"code": "import javax.inject.Named;import javax.inject.Singleton;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.annotation.Component;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;@Component@Named(\"admin\")@Singletonpublic class AdminAction extends XWikiAction{    private static final Logger LOGGER = LoggerFactory.getLogger(AdminAction.class);    public AdminAction()    {        this.waitForXWikiInitialization = false;    }    @Override    protected Class<? extends XWikiForm> getFormClass()    {        return EditForm.class;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        XWikiRequest request = context.getRequest();        String content = request.getParameter(\"content\");        XWikiDocument doc = context.getDoc();        XWikiForm form = context.getForm();        synchronized (doc) {            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");            EditForm peform = (EditForm) form;            String parent = peform.getParent();            if (parent != null) {                doc.setParent(parent);            }            String creator = peform.getCreator();            if (creator != null) {                doc.setCreator(creator);            }            String defaultTemplate = peform.getDefaultTemplate();            if (defaultTemplate != null) {                doc.setDefaultTemplate(defaultTemplate);            }            String defaultLanguage = peform.getDefaultLanguage();            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {                doc.setDefaultLanguage(defaultLanguage);            }            if (doc.getDefaultLanguage().equals(\"\")) {                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));            }            String language = context.getWiki().getLanguagePreference(context);            String languagefromrequest = context.getRequest().getParameter(\"language\");            String languagetoedit =                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {                languagetoedit = \"\";            }            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {                languagetoedit = \"\";            }            if (languagetoedit.equals(\"\")) {                tdoc = doc;                context.put(\"tdoc\", doc);                if (doc.isNew()) {                    doc.setDefaultLanguage(language);                    doc.setLanguage(\"\");                }            } else {                if ((tdoc == doc)) {                    tdoc = new XWikiDocument(doc.getDocumentReference());                    tdoc.setLanguage(languagetoedit);                    tdoc.setContent(doc.getContent());                    tdoc.setSyntax(doc.getSyntax());                    tdoc.setAuthor(context.getUser());                    tdoc.setStore(doc.getStore());                    context.put(\"tdoc\", tdoc);                }            }            XWikiDocument tdoc2 = tdoc.clone();            if (content != null && !content.isEmpty()) {                tdoc2.setContent(content);            }            context.put(\"tdoc\", tdoc2);            try {                readFromTemplate(tdoc2, peform.getTemplate(), context);            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                    context.put(\"exception\", e);                    return \"docalreadyexists\";                }            }            try {                XWikiLock lock = tdoc.getLock(context);                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {                    tdoc.setLock(context.getUser(), context);                }            } catch (Exception e) {                LOGGER.error(\"Exception while setting up lock\", e);            }        }        return \"admin\";    }}", "nl": "import javax.inject.Named;import javax.inject.Singleton;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.annotation.Component;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;@Component@Named(\"admin\")@Singletonpublic class AdminAction extends XWikiAction{    private static final Logger LOGGER = LoggerFactory.getLogger(AdminAction.class);    public AdminAction()    {        this.waitForXWikiInitialization = false;    }    @Override    protected Class<? extends XWikiForm> getFormClass()    {        return EditForm.class;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        XWikiRequest request = context.getRequest();        String content = request.getParameter(\"content\");        XWikiDocument doc = context.getDoc();        XWikiForm form = context.getForm();        synchronized (doc) {            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");            EditForm peform = (EditForm) form;            String parent = peform.getParent();            if (parent != null) {                doc.setParent(parent);            }            String creator = peform.getCreator();            if (creator != null) {                doc.setCreator(creator);            }            String defaultTemplate = peform.getDefaultTemplate();            if (defaultTemplate != null) {                doc.setDefaultTemplate(defaultTemplate);            }            String defaultLanguage = peform.getDefaultLanguage();            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {                doc.setDefaultLanguage(defaultLanguage);            }            if (doc.getDefaultLanguage().equals(\"\")) {                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));            }            String language = context.getWiki().getLanguagePreference(context);            String languagefromrequest = context.getRequest().getParameter(\"language\");            String languagetoedit =                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {                languagetoedit = \"\";            }            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {                languagetoedit = \"\";            }            if (languagetoedit.equals(\"\")) {                tdoc = doc;                context.put(\"tdoc\", doc);                if (doc.isNew()) {                    doc.setDefaultLanguage(language);                    doc.setLanguage(\"\");                }            } else {                if ((tdoc == doc)) {                    tdoc = new XWikiDocument(doc.getDocumentReference());                    tdoc.setLanguage(languagetoedit);                    tdoc.setContent(doc.getContent());                    tdoc.setSyntax(doc.getSyntax());                    tdoc.setAuthor(context.getUser());                    tdoc.setStore(doc.getStore());                    context.put(\"tdoc\", tdoc);                }            }            XWikiDocument tdoc2 = tdoc.clone();            if (content != null && !content.isEmpty()) {                tdoc2.setContent(content);            }            context.put(\"tdoc\", tdoc2);            try {                tdoc2.readFromTemplate(peform, context);            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                    context.put(\"exception\", e);                    return \"docalreadyexists\";                }            }            try {                XWikiLock lock = tdoc.getLock(context);                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {                    tdoc.setLock(context.getUser(), context);                }            } catch (Exception e) {                LOGGER.error(\"Exception while setting up lock\", e);            }        }        return \"admin\";    }}"}
{"code": "import java.util.HashMap;import java.util.Locale;import java.util.Map;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.lang3.StringUtils;import org.xwiki.component.annotation.Component;import org.xwiki.csrf.CSRFToken;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.SpaceReference;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.util.Util;@Component@Named(\"create\")@Singletonpublic class CreateAction extends XWikiAction{    private static final String CREATE_TEMPLATE = \"create\";    private static final String PARENT = \"parent\";    private static final String SPACE_REFERENCE = \"spaceReference\";    private static final String NAME = \"name\";    private static final String TEMPLATE = \"template\";    private static final String IS_SPACE = \"isSpace\";    private static final String WEBHOME = \"WebHome\";    private static final String LOCAL_SERIALIZER_HINT = \"local\";    private static final String CURRENT_MIXED_RESOLVER_HINT = \"currentmixed\";    private enum ActionOnCreate    {        EDIT(\"edit\"),        SAVE_AND_EDIT(\"saveandedit\"),        SAVE_AND_VIEW(\"saveandview\");        private static final Map<String, ActionOnCreate> BY_ACTION = new HashMap<>();        static {            for (ActionOnCreate actionOnCreate : values()) {                BY_ACTION.put(actionOnCreate.action, actionOnCreate);            }        }        private final String action;        ActionOnCreate(String action)        {            this.action = action;        }        public static ActionOnCreate valueOfAction(String action)        {            return BY_ACTION.get(action);        }    }    public CreateAction()    {        this.waitForXWikiInitialization = false;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        CreateActionRequestHandler handler = new CreateActionRequestHandler(context);        handler.processRequest();        ScriptContext scontext = getCurrentScriptContext();        scontext.setAttribute(SPACE_REFERENCE, handler.getSpaceReference(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(NAME, handler.getName(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(IS_SPACE, handler.isSpace(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"availableTemplateProviders\", handler.getAvailableTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"recommendedTemplateProviders\", handler.getRecommendedTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        DocumentReference newDocumentReference = handler.getNewDocumentReference();        if (newDocumentReference == null) {            return CREATE_TEMPLATE;        }        if (!handler.isTemplateProviderAllowedToCreateInCurrentSpace()) {            return CREATE_TEMPLATE;        }        checkRights(newDocumentReference.getLastSpaceReference(), context);        XWikiDocument newDocument = context.getWiki().getDocument(newDocumentReference, context);        if (handler.isDocumentAlreadyExisting(newDocument) || handler.isDocumentPathTooLong(newDocumentReference)            || !this.isEntityReferenceNameValid(newDocumentReference)) {            return CREATE_TEMPLATE;        }        if (StringUtils.isBlank(handler.getType()) && !handler.hasTemplate()) {            return CREATE_TEMPLATE;        }        doCreate(context, newDocument, handler.isSpace(), handler.getTemplateProvider());        return null;    }    private void checkRights(SpaceReference spaceReference, XWikiContext context) throws XWikiException    {        ContextualAuthorizationManager authManager = Utils.getComponent(ContextualAuthorizationManager.class);        if (!authManager.hasAccess(Right.EDIT, spaceReference)) {            Object[] args = { spaceReference.toString(), context.getUser() };            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,                \"The creation of a document into the space {0} has been denied to user {1}\", null, args);        }    }    private void doCreate(XWikiContext context, XWikiDocument newDocument, boolean isSpace, BaseObject templateProvider)        throws XWikiException    {        XWikiRequest request = context.getRequest();        XWikiDocument doc = context.getDoc();        String parent = getParent(request, doc, isSpace, context);        String title = getTitle(request, newDocument, isSpace);        String template = getTemplate(templateProvider, request);        ActionOnCreate actionOnCreate = getActionOnCreate(templateProvider);        String action = null;        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            initAndSaveDocument(context, newDocument, title, template, parent);            action = newDocument.getDefaultEditMode(context);        } else {            action = actionOnCreate == ActionOnCreate.SAVE_AND_VIEW ? \"save\" : getEditMode(template, context);        }        String redirectParams = getRedirectParameters(parent, title, template, actionOnCreate);        String redirectURL = newDocument.getURL(action, redirectParams, context);        redirectURL = context.getResponse().encodeRedirectURL(redirectURL);        if (context.getRequest().getParameterMap().containsKey(\"ajax\")) {            context.getResponse().setHeader(\"redirect\", redirectURL);        } else {            sendRedirect(context.getResponse(), redirectURL);        }    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, CURRENT_MIXED_RESOLVER_HINT);    }    private void initAndSaveDocument(XWikiContext context, XWikiDocument newDocument, String title, String template,        String parent) throws XWikiException    {        XWiki xwiki = context.getWiki();        newDocument.setLocale(Locale.ROOT);        if (newDocument.getDefaultLocale() == Locale.ROOT) {            newDocument.setDefaultLocale(xwiki.getLocalePreference(context));        }        readFromTemplate(newDocument, template, context);        if (!StringUtils.isEmpty(parent)) {            DocumentReference parentReference = this.currentmixedReferenceResolver.resolve(parent);            newDocument.setParentReference(parentReference);        }        if (title != null) {            newDocument.setTitle(title);        }        DocumentReference currentUserReference = context.getUserReference();        newDocument.setAuthorReference(currentUserReference);        newDocument.setCreatorReference(currentUserReference);        xwiki.checkSavingDocument(currentUserReference, newDocument, context);        xwiki.saveDocument(newDocument, context);    }    private String getRedirectParameters(String parent, String title, String template, ActionOnCreate actionOnCreate)    {        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            return null;        }        String redirectParams = \"template=\" + Util.encodeURI(template, null);        if (parent != null) {            redirectParams += \"&parent=\" + Util.encodeURI(parent, null);        }        if (title != null) {            redirectParams += \"&title=\" + Util.encodeURI(title, null);        }        if (actionOnCreate == ActionOnCreate.SAVE_AND_VIEW) {            CSRFToken csrf = Utils.getComponent(CSRFToken.class);            redirectParams += \"&form_token=\" + Util.encodeURI(csrf.getToken(), null);        }        return redirectParams;    }    private String getTemplate(BaseObject templateProvider, XWikiRequest request)    {        String result = \"\";        if (templateProvider != null) {            result = templateProvider.getStringValue(TEMPLATE);        } else if (request.getParameter(TEMPLATE) != null) {            result = request.getParameter(TEMPLATE);        }        return result;    }    private String getParent(XWikiRequest request, XWikiDocument doc, boolean isSpace, XWikiContext context)    {        String parent = request.getParameter(PARENT);        if (StringUtils.isEmpty(parent)) {            EntityReferenceSerializer<String> localSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, LOCAL_SERIALIZER_HINT);            if (doc.isNew()) {                Provider<DocumentReference> defaultDocumentReferenceProvider =                    Utils.getComponent(DocumentReference.TYPE_PROVIDER);                DocumentReference parentRef =                    defaultDocumentReferenceProvider.get().setWikiReference(context.getWikiReference());                parent = localSerializer.serialize(parentRef);            } else {                DocumentReference parentRef = doc.getDocumentReference();                parent = localSerializer.serialize(parentRef);            }        }        return parent;    }    private String getTitle(XWikiRequest request, XWikiDocument newDocument, boolean isSpace)    {        String title = request.getParameter(\"title\");        if (StringUtils.isEmpty(title)) {            if (isSpace) {                title = newDocument.getDocumentReference().getLastSpaceReference().getName();            } else {                title = newDocument.getDocumentReference().getName();                if (WEBHOME.equals(title)) {                    title = newDocument.getDocumentReference().getLastSpaceReference().getName();                }            }        }        return title;    }    private ActionOnCreate getActionOnCreate(BaseObject templateProvider)    {        if (templateProvider != null) {            String action = templateProvider.getStringValue(\"action\");            ActionOnCreate actionOnCreate = ActionOnCreate.valueOfAction(action);            if (actionOnCreate != null) {                return actionOnCreate;            }        }        return ActionOnCreate.EDIT;    }    private String getEditMode(String template, XWikiContext context)        throws XWikiException    {        String editAction = ActionOnCreate.EDIT.name().toLowerCase();        XWiki xwiki = context.getWiki();        if (!StringUtils.isEmpty(template)) {            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);            if (xwiki.exists(templateReference, context)) {                editAction = xwiki.getDocument(templateReference, context).getDefaultEditMode(context);            }        }        return editAction;    }}", "nl": "import java.util.HashMap;import java.util.Locale;import java.util.Map;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.lang3.StringUtils;import org.xwiki.component.annotation.Component;import org.xwiki.csrf.CSRFToken;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.SpaceReference;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.util.Util;@Component@Named(\"create\")@Singletonpublic class CreateAction extends XWikiAction{    private static final String CREATE_TEMPLATE = \"create\";    private static final String PARENT = \"parent\";    private static final String SPACE_REFERENCE = \"spaceReference\";    private static final String NAME = \"name\";    private static final String TEMPLATE = \"template\";    private static final String IS_SPACE = \"isSpace\";    private static final String WEBHOME = \"WebHome\";    private static final String LOCAL_SERIALIZER_HINT = \"local\";    private static final String CURRENT_MIXED_RESOLVER_HINT = \"currentmixed\";    private enum ActionOnCreate    {        EDIT(\"edit\"),        SAVE_AND_EDIT(\"saveandedit\"),        SAVE_AND_VIEW(\"saveandview\");        private static final Map<String, ActionOnCreate> BY_ACTION = new HashMap<>();        static {            for (ActionOnCreate actionOnCreate : values()) {                BY_ACTION.put(actionOnCreate.action, actionOnCreate);            }        }        private final String action;        ActionOnCreate(String action)        {            this.action = action;        }        public static ActionOnCreate valueOfAction(String action)        {            return BY_ACTION.get(action);        }    }    public CreateAction()    {        this.waitForXWikiInitialization = false;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        CreateActionRequestHandler handler = new CreateActionRequestHandler(context);        handler.processRequest();        ScriptContext scontext = getCurrentScriptContext();        scontext.setAttribute(SPACE_REFERENCE, handler.getSpaceReference(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(NAME, handler.getName(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(IS_SPACE, handler.isSpace(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"availableTemplateProviders\", handler.getAvailableTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"recommendedTemplateProviders\", handler.getRecommendedTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        DocumentReference newDocumentReference = handler.getNewDocumentReference();        if (newDocumentReference == null) {            return CREATE_TEMPLATE;        }        if (!handler.isTemplateProviderAllowedToCreateInCurrentSpace()) {            return CREATE_TEMPLATE;        }        checkRights(newDocumentReference.getLastSpaceReference(), context);        XWikiDocument newDocument = context.getWiki().getDocument(newDocumentReference, context);        if (handler.isDocumentAlreadyExisting(newDocument) || handler.isDocumentPathTooLong(newDocumentReference)            || !this.isEntityReferenceNameValid(newDocumentReference)) {            return CREATE_TEMPLATE;        }        if (StringUtils.isBlank(handler.getType()) && !handler.hasTemplate()) {            return CREATE_TEMPLATE;        }        doCreate(context, newDocument, handler.isSpace(), handler.getTemplateProvider());        return null;    }    private void checkRights(SpaceReference spaceReference, XWikiContext context) throws XWikiException    {        ContextualAuthorizationManager authManager = Utils.getComponent(ContextualAuthorizationManager.class);        if (!authManager.hasAccess(Right.EDIT, spaceReference)) {            Object[] args = { spaceReference.toString(), context.getUser() };            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,                \"The creation of a document into the space {0} has been denied to user {1}\", null, args);        }    }    private void doCreate(XWikiContext context, XWikiDocument newDocument, boolean isSpace, BaseObject templateProvider)        throws XWikiException    {        XWikiRequest request = context.getRequest();        XWikiDocument doc = context.getDoc();        String parent = getParent(request, doc, isSpace, context);        String title = getTitle(request, newDocument, isSpace);        String template = getTemplate(templateProvider, request);        ActionOnCreate actionOnCreate = getActionOnCreate(templateProvider);        String action = null;        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            initAndSaveDocument(context, newDocument, title, template, parent);            action = newDocument.getDefaultEditMode(context);        } else {            action = actionOnCreate == ActionOnCreate.SAVE_AND_VIEW ? \"save\" : getEditMode(template, context);        }        String redirectParams = getRedirectParameters(parent, title, template, actionOnCreate);        String redirectURL = newDocument.getURL(action, redirectParams, context);        redirectURL = context.getResponse().encodeRedirectURL(redirectURL);        if (context.getRequest().getParameterMap().containsKey(\"ajax\")) {            context.getResponse().setHeader(\"redirect\", redirectURL);        } else {            sendRedirect(context.getResponse(), redirectURL);        }    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, CURRENT_MIXED_RESOLVER_HINT);    }    private void initAndSaveDocument(XWikiContext context, XWikiDocument newDocument, String title, String template,        String parent) throws XWikiException    {        XWiki xwiki = context.getWiki();        DocumentReferenceResolver<String> resolver = getCurrentMixedDocumentReferenceResolver();        newDocument.setLocale(Locale.ROOT);        if (newDocument.getDefaultLocale() == Locale.ROOT) {            newDocument.setDefaultLocale(xwiki.getLocalePreference(context));        }        DocumentReference templateReference = resolver.resolve(template);        newDocument.readFromTemplate(templateReference, context);        if (!StringUtils.isEmpty(parent)) {            DocumentReference parentReference = resolver.resolve(parent);            newDocument.setParentReference(parentReference);        }        if (title != null) {            newDocument.setTitle(title);        }        DocumentReference currentUserReference = context.getUserReference();        newDocument.setAuthorReference(currentUserReference);        newDocument.setCreatorReference(currentUserReference);        xwiki.checkSavingDocument(currentUserReference, newDocument, context);        xwiki.saveDocument(newDocument, context);    }    private String getRedirectParameters(String parent, String title, String template, ActionOnCreate actionOnCreate)    {        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            return null;        }        String redirectParams = \"template=\" + Util.encodeURI(template, null);        if (parent != null) {            redirectParams += \"&parent=\" + Util.encodeURI(parent, null);        }        if (title != null) {            redirectParams += \"&title=\" + Util.encodeURI(title, null);        }        if (actionOnCreate == ActionOnCreate.SAVE_AND_VIEW) {            CSRFToken csrf = Utils.getComponent(CSRFToken.class);            redirectParams += \"&form_token=\" + Util.encodeURI(csrf.getToken(), null);        }        return redirectParams;    }    private String getTemplate(BaseObject templateProvider, XWikiRequest request)    {        String result = \"\";        if (templateProvider != null) {            result = templateProvider.getStringValue(TEMPLATE);        } else if (request.getParameter(TEMPLATE) != null) {            result = request.getParameter(TEMPLATE);        }        return result;    }    private String getParent(XWikiRequest request, XWikiDocument doc, boolean isSpace, XWikiContext context)    {        String parent = request.getParameter(PARENT);        if (StringUtils.isEmpty(parent)) {            EntityReferenceSerializer<String> localSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, LOCAL_SERIALIZER_HINT);            if (doc.isNew()) {                Provider<DocumentReference> defaultDocumentReferenceProvider =                    Utils.getComponent(DocumentReference.TYPE_PROVIDER);                DocumentReference parentRef =                    defaultDocumentReferenceProvider.get().setWikiReference(context.getWikiReference());                parent = localSerializer.serialize(parentRef);            } else {                DocumentReference parentRef = doc.getDocumentReference();                parent = localSerializer.serialize(parentRef);            }        }        return parent;    }    private String getTitle(XWikiRequest request, XWikiDocument newDocument, boolean isSpace)    {        String title = request.getParameter(\"title\");        if (StringUtils.isEmpty(title)) {            if (isSpace) {                title = newDocument.getDocumentReference().getLastSpaceReference().getName();            } else {                title = newDocument.getDocumentReference().getName();                if (WEBHOME.equals(title)) {                    title = newDocument.getDocumentReference().getLastSpaceReference().getName();                }            }        }        return title;    }    private ActionOnCreate getActionOnCreate(BaseObject templateProvider)    {        if (templateProvider != null) {            String action = templateProvider.getStringValue(\"action\");            ActionOnCreate actionOnCreate = ActionOnCreate.valueOfAction(action);            if (actionOnCreate != null) {                return actionOnCreate;            }        }        return ActionOnCreate.EDIT;    }    private String getEditMode(String template, XWikiContext context)        throws XWikiException    {        String editAction = ActionOnCreate.EDIT.name().toLowerCase();        XWiki xwiki = context.getWiki();        if (!StringUtils.isEmpty(template)) {            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);            if (xwiki.exists(templateReference, context)) {                editAction = xwiki.getDocument(templateReference, context).getDefaultEditMode(context);            }        }        return editAction;    }}"}
{"code": "import javax.inject.Named;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.math.NumberUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.annotation.Component;import org.xwiki.rendering.syntax.Syntax;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;@Component@Named(\"edit\")@Singletonpublic class EditAction extends XWikiAction{    private static final Logger LOGGER = LoggerFactory.getLogger(EditAction.class);    public EditAction()    {        this.waitForXWikiInitialization = false;    }    @Override    protected Class<? extends XWikiForm> getFormClass()    {        return EditForm.class;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        try {            XWikiDocument editedDocument = prepareEditedDocument(context);            maybeLockDocument(editedDocument, context);        } catch (XWikiException e) {            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                context.put(\"exception\", e);                return \"docalreadyexists\";            } else {                throw e;            }        }        context.put(\"display\", \"edit\");        return \"edit\";    }    protected XWikiDocument prepareEditedDocument(XWikiContext context) throws XWikiException    {        XWikiDocument editedDocument = getEditedDocument(context);        EditForm editForm = (EditForm) context.getForm();        readFromTemplate(editedDocument, editForm.getTemplate(), context);        updateDocumentTitleAndContentFromRequest(editedDocument, context);        editedDocument.readObjectsFromForm(editForm, context);        if (editedDocument.isNew()) {            editedDocument.setCreatorReference(context.getUserReference());            editedDocument.setAuthorReference(context.getUserReference());            editedDocument.setContentAuthorReference(context.getUserReference());        }        putDocumentOnContext(editedDocument, context);        return editedDocument;    }    private XWikiDocument getEditedDocument(XWikiContext context) throws XWikiException    {        XWikiDocument doc = context.getDoc();        boolean hasTranslation = doc != context.get(\"tdoc\");        doc = doc.clone();        context.put(\"doc\", doc);        EditForm editForm = (EditForm) context.getForm();        doc.readDocMetaFromForm(editForm, context);        String language = context.getWiki().getLanguagePreference(context);        if (doc.isNew() && doc.getDefaultLanguage().equals(\"\")) {            doc.setDefaultLanguage(language);        }        String languageToEdit = StringUtils.isEmpty(editForm.getLanguage()) ? language : editForm.getLanguage();        if (languageToEdit == null || languageToEdit.equals(\"default\")) {            languageToEdit = \"\";        }        if (doc.isNew() || doc.getDefaultLanguage().equals(languageToEdit)) {            languageToEdit = \"\";        }        if (!hasTranslation && StringUtils.isEmpty(editForm.getLanguage())) {            languageToEdit = \"\";        }        XWikiDocument tdoc;        if (languageToEdit.equals(\"\")) {            tdoc = doc;            if (doc.isNew()) {                doc.setDefaultLanguage(language);                doc.setLanguage(\"\");            }        } else if (!hasTranslation && context.getWiki().isMultiLingual(context)) {            tdoc = new XWikiDocument(doc.getDocumentReference());            tdoc.setLanguage(languageToEdit);            tdoc.setDefaultLocale(doc.getDefaultLocale());            tdoc.setTitle(doc.getTitle());            tdoc.setContent(doc.getContent());            tdoc.setSyntax(doc.getSyntax());            tdoc.setAuthorReference(context.getUserReference());            tdoc.setStore(doc.getStore());        } else {            tdoc = ((XWikiDocument) context.get(\"tdoc\")).clone();        }        return tdoc;    }    private void updateDocumentTitleAndContentFromRequest(XWikiDocument document, XWikiContext context)        throws XWikiException    {        boolean sectionEditingEnabled = context.getWiki().hasSectionEdit(context);        int sectionNumber = sectionEditingEnabled ? NumberUtils.toInt(context.getRequest().getParameter(\"section\")) : 0;        getCurrentScriptContext().setAttribute(\"sectionNumber\", sectionNumber, ScriptContext.ENGINE_SCOPE);        EditForm editForm = (EditForm) context.getForm();        if (editForm.getContent() != null) {            document.setContent(editForm.getContent());        } else if (sectionNumber > 0) {            document.setContent(document.getContentOfSection(sectionNumber));        }        if (editForm.getTitle() != null) {            document.setTitle(editForm.getTitle());        } else if (sectionNumber > 0 && document.getSections().size() > 0) {            String sectionTitle = document.getDocumentSection(1).getSectionTitle();            if (StringUtils.isNotBlank(sectionTitle)) {                String sectionPlainTitle = document.getRenderedContent(sectionTitle, document.getSyntax().toIdString(),                    Syntax.PLAIN_1_0.toIdString(), context);                document.setTitle(localizePlainOrKey(\"core.editors.content.titleField.sectionEditingFormat\",                    document.getRenderedTitle(Syntax.PLAIN_1_0, context), sectionNumber, sectionPlainTitle));            }        }    }    private void putDocumentOnContext(XWikiDocument document, XWikiContext context)    {        context.put(\"tdoc\", document);        context.put(\"cdoc\", context.get(\"tdoc\"));    }    private void maybeLockDocument(XWikiDocument document, XWikiContext context)    {        try {            XWikiLock lock = document.getLock(context);            EditForm editForm = (EditForm) context.getForm();            if (lock == null || lock.getUserName().equals(context.getUser()) || editForm.isLockForce()) {                document.setLock(context.getUser(), context);            }        } catch (Exception e) {            LOGGER.error(\"Exception while setting up lock\", e);        }    }}", "nl": "import javax.inject.Named;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.math.NumberUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.annotation.Component;import org.xwiki.rendering.syntax.Syntax;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;@Component@Named(\"edit\")@Singletonpublic class EditAction extends XWikiAction{    private static final Logger LOGGER = LoggerFactory.getLogger(EditAction.class);    public EditAction()    {        this.waitForXWikiInitialization = false;    }    @Override    protected Class<? extends XWikiForm> getFormClass()    {        return EditForm.class;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        try {            XWikiDocument editedDocument = prepareEditedDocument(context);            maybeLockDocument(editedDocument, context);        } catch (XWikiException e) {            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                context.put(\"exception\", e);                return \"docalreadyexists\";            } else {                throw e;            }        }        context.put(\"display\", \"edit\");        return \"edit\";    }    protected XWikiDocument prepareEditedDocument(XWikiContext context) throws XWikiException    {        XWikiDocument editedDocument = getEditedDocument(context);        EditForm editForm = (EditForm) context.getForm();        editedDocument.readFromTemplate(editForm, context);        updateDocumentTitleAndContentFromRequest(editedDocument, context);        editedDocument.readObjectsFromForm(editForm, context);        if (editedDocument.isNew()) {            editedDocument.setCreatorReference(context.getUserReference());            editedDocument.setAuthorReference(context.getUserReference());            editedDocument.setContentAuthorReference(context.getUserReference());        }        putDocumentOnContext(editedDocument, context);        return editedDocument;    }    private XWikiDocument getEditedDocument(XWikiContext context) throws XWikiException    {        XWikiDocument doc = context.getDoc();        boolean hasTranslation = doc != context.get(\"tdoc\");        doc = doc.clone();        context.put(\"doc\", doc);        EditForm editForm = (EditForm) context.getForm();        doc.readDocMetaFromForm(editForm, context);        String language = context.getWiki().getLanguagePreference(context);        if (doc.isNew() && doc.getDefaultLanguage().equals(\"\")) {            doc.setDefaultLanguage(language);        }        String languageToEdit = StringUtils.isEmpty(editForm.getLanguage()) ? language : editForm.getLanguage();        if (languageToEdit == null || languageToEdit.equals(\"default\")) {            languageToEdit = \"\";        }        if (doc.isNew() || doc.getDefaultLanguage().equals(languageToEdit)) {            languageToEdit = \"\";        }        if (!hasTranslation && StringUtils.isEmpty(editForm.getLanguage())) {            languageToEdit = \"\";        }        XWikiDocument tdoc;        if (languageToEdit.equals(\"\")) {            tdoc = doc;            if (doc.isNew()) {                doc.setDefaultLanguage(language);                doc.setLanguage(\"\");            }        } else if (!hasTranslation && context.getWiki().isMultiLingual(context)) {            tdoc = new XWikiDocument(doc.getDocumentReference());            tdoc.setLanguage(languageToEdit);            tdoc.setDefaultLocale(doc.getDefaultLocale());            tdoc.setTitle(doc.getTitle());            tdoc.setContent(doc.getContent());            tdoc.setSyntax(doc.getSyntax());            tdoc.setAuthorReference(context.getUserReference());            tdoc.setStore(doc.getStore());        } else {            tdoc = ((XWikiDocument) context.get(\"tdoc\")).clone();        }        return tdoc;    }    private void updateDocumentTitleAndContentFromRequest(XWikiDocument document, XWikiContext context)        throws XWikiException    {        boolean sectionEditingEnabled = context.getWiki().hasSectionEdit(context);        int sectionNumber = sectionEditingEnabled ? NumberUtils.toInt(context.getRequest().getParameter(\"section\")) : 0;        getCurrentScriptContext().setAttribute(\"sectionNumber\", sectionNumber, ScriptContext.ENGINE_SCOPE);        EditForm editForm = (EditForm) context.getForm();        if (editForm.getContent() != null) {            document.setContent(editForm.getContent());        } else if (sectionNumber > 0) {            document.setContent(document.getContentOfSection(sectionNumber));        }        if (editForm.getTitle() != null) {            document.setTitle(editForm.getTitle());        } else if (sectionNumber > 0 && document.getSections().size() > 0) {            String sectionTitle = document.getDocumentSection(1).getSectionTitle();            if (StringUtils.isNotBlank(sectionTitle)) {                String sectionPlainTitle = document.getRenderedContent(sectionTitle, document.getSyntax().toIdString(),                    Syntax.PLAIN_1_0.toIdString(), context);                document.setTitle(localizePlainOrKey(\"core.editors.content.titleField.sectionEditingFormat\",                    document.getRenderedTitle(Syntax.PLAIN_1_0, context), sectionNumber, sectionPlainTitle));            }        }    }    private void putDocumentOnContext(XWikiDocument document, XWikiContext context)    {        context.put(\"tdoc\", document);        context.put(\"cdoc\", context.get(\"tdoc\"));    }    private void maybeLockDocument(XWikiDocument document, XWikiContext context)    {        try {            XWikiLock lock = document.getLock(context);            EditForm editForm = (EditForm) context.getForm();            if (lock == null || lock.getUserName().equals(context.getUser()) || editForm.isLockForce()) {                document.setLock(context.getUser(), context);            }        } catch (Exception e) {            LOGGER.error(\"Exception while setting up lock\", e);        }    }}"}
{"code": "import javax.inject.Named;import javax.inject.Singleton;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.annotation.Component;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;@Component@Named(\"inline\")@Singleton@Deprecatedpublic class InlineAction extends XWikiAction{    private static final Logger LOGGER = LoggerFactory.getLogger(InlineAction.class);    @Override    protected Class<? extends XWikiForm> getFormClass()    {        return EditForm.class;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        XWikiDocument doc = context.getDoc();        synchronized (doc) {            XWikiForm form = context.getForm();            XWikiDocument cdoc = (XWikiDocument) context.get(\"cdoc\");            if (cdoc == null) {                cdoc = doc;            }            EditForm peform = (EditForm) form;            XWikiDocument doc2 = doc.clone();            context.put(\"doc\", doc2);            String parent = peform.getParent();            if (parent != null) {                doc2.setParent(parent);            }            String creator = peform.getCreator();            if (creator != null) {                doc2.setCreator(creator);            }            String defaultLanguage = peform.getDefaultLanguage();            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {                doc2.setDefaultLanguage(defaultLanguage);            }            if (doc2.getDefaultLanguage().equals(\"\")) {                doc2.setDefaultLanguage(context.getWiki().getLanguagePreference(context));            }            try {                readFromTemplate(doc2, peform.getTemplate(), context);            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                    return \"docalreadyexists\";                }            }            if (doc == cdoc) {                context.put(\"cdoc\", doc2);            } else {                XWikiDocument cdoc2 = cdoc.clone();                readFromTemplate(cdoc2, peform.getTemplate(), context);                context.put(\"cdoc\", cdoc2);            }            doc2.readFromForm((EditForm) form, context);            if (doc2.isNew()) {                doc2.setCreatorReference(context.getUserReference());                doc2.setAuthorReference(context.getUserReference());                doc2.setContentAuthorReference(context.getUserReference());            }            try {                XWikiLock lock = doc.getLock(context);                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {                    doc.setLock(context.getUser(), context);                }            } catch (Exception e) {                LOGGER.error(\"Exception while setting up lock\", e);            }        }        context.put(\"display\", \"edit\");        return \"inline\";    }}", "nl": "import javax.inject.Named;import javax.inject.Singleton;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.annotation.Component;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;@Component@Named(\"inline\")@Singleton@Deprecatedpublic class InlineAction extends XWikiAction{    private static final Logger LOGGER = LoggerFactory.getLogger(InlineAction.class);    @Override    protected Class<? extends XWikiForm> getFormClass()    {        return EditForm.class;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        XWikiDocument doc = context.getDoc();        synchronized (doc) {            XWikiForm form = context.getForm();            XWikiDocument cdoc = (XWikiDocument) context.get(\"cdoc\");            if (cdoc == null) {                cdoc = doc;            }            EditForm peform = (EditForm) form;            XWikiDocument doc2 = doc.clone();            context.put(\"doc\", doc2);            String parent = peform.getParent();            if (parent != null) {                doc2.setParent(parent);            }            String creator = peform.getCreator();            if (creator != null) {                doc2.setCreator(creator);            }            String defaultLanguage = peform.getDefaultLanguage();            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {                doc2.setDefaultLanguage(defaultLanguage);            }            if (doc2.getDefaultLanguage().equals(\"\")) {                doc2.setDefaultLanguage(context.getWiki().getLanguagePreference(context));            }            try {                doc2.readFromTemplate(peform, context);            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                    return \"docalreadyexists\";                }            }            if (doc == cdoc) {                context.put(\"cdoc\", doc2);            } else {                XWikiDocument cdoc2 = cdoc.clone();                cdoc2.readFromTemplate(peform, context);                context.put(\"cdoc\", cdoc2);            }            doc2.readFromForm((EditForm) form, context);            if (doc2.isNew()) {                doc2.setCreatorReference(context.getUserReference());                doc2.setAuthorReference(context.getUserReference());                doc2.setContentAuthorReference(context.getUserReference());            }            try {                XWikiLock lock = doc.getLock(context);                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {                    doc.setLock(context.getUser(), context);                }            } catch (Exception e) {                LOGGER.error(\"Exception while setting up lock\", e);            }        }        context.put(\"display\", \"edit\");        return \"inline\";    }}"}
{"code": "import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Objects;import javax.inject.Named;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.httpclient.HttpStatus;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.suigeneris.jrcs.diff.DifferentiationFailedException;import org.suigeneris.jrcs.diff.delta.Delta;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.component.annotation.Component;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.diff.ConflictDecision;import org.xwiki.job.Job;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.refactoring.job.CreateRequest;import org.xwiki.refactoring.script.RefactoringScriptService;import org.xwiki.script.service.ScriptService;import org.xwiki.store.merge.MergeConflictDecisionsManager;import org.xwiki.store.merge.MergeDocumentResult;import org.xwiki.store.merge.MergeManager;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MetaDataDiff;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;import com.xpn.xwiki.doc.merge.MergeConfiguration;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.objects.ObjectDiff;@Component@Named(\"save\")@Singletonpublic class SaveAction extends PreviewAction{    public static final String ACTION_NAME = \"save\";    protected static final String ASYNC_PARAM = \"async\";    private static final Logger LOGGER = LoggerFactory.getLogger(SaveAction.class);    private static final String SAVED_OBJECT_VERSION_KEY = \"SaveAction.savedObjectVersion\";    private static final String MERGED_DOCUMENTS = \"SaveAction.mergedDocuments\";    private static final String FORCE_SAVE_MERGE = \"merge\";    private static final String FORCE_SAVE_OVERRIDE = \"override\";    private DocumentRevisionProvider documentRevisionProvider;    private MergeManager mergeManager;    private MergeConflictDecisionsManager conflictDecisionsManager;    public SaveAction()    {        this.waitForXWikiInitialization = true;    }    public boolean save(XWikiContext context) throws XWikiException    {        XWiki xwiki = context.getWiki();        XWikiRequest request = context.getRequest();        XWikiDocument doc = context.getDoc();        EditForm form = (EditForm) context.getForm();        int sectionNumber = 0;        if (request.getParameter(\"section\") != null && xwiki.hasSectionEdit(context)) {            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));        }        if (doc.isNew() && !this.isEntityReferenceNameValid(doc.getDocumentReference())) {            context.put(\"message\", \"entitynamevalidation.create.invalidname\");            context.put(\"messageParameters\",                new Object[] { getLocalSerializer().serialize(doc.getDocumentReference())});            return true;        }        XWikiDocument originalDoc = doc;        doc = doc.clone();        String language = form.getLanguage();        XWikiDocument tdoc;        if (doc.isNew() || (language == null) || (language.equals(\"\")) || (language.equals(\"default\"))            || (language.equals(doc.getDefaultLanguage()))) {            tdoc = doc;        } else {            tdoc = doc.getTranslatedDocument(language, context);            if ((tdoc == doc) && xwiki.isMultiLingual(context)) {                tdoc = new XWikiDocument(doc.getDocumentReference());                tdoc.setLanguage(language);                tdoc.setStore(doc.getStore());                originalDoc = tdoc;            } else if (tdoc != doc) {                originalDoc = tdoc;                tdoc = tdoc.clone();            }        }        if (doc.isNew()) {            doc.setLocale(Locale.ROOT);            if (doc.getDefaultLocale() == Locale.ROOT) {                doc.setDefaultLocale(xwiki.getLocalePreference(context));            }        }        try {            readFromTemplate(tdoc, form.getTemplate(), context);        } catch (XWikiException e) {            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                context.put(\"exception\", e);                return true;            }        }        if (form.isConvertSyntax() && !tdoc.getSyntax().toIdString().equals(form.getSyntaxId())) {            convertSyntax(tdoc, form.getSyntaxId(), context);        }        if (sectionNumber != 0) {            XWikiDocument sectionDoc = tdoc.clone();            sectionDoc.readFromForm(form, context);            String sectionContent = sectionDoc.getContent() + \"\\n\";            String content = tdoc.updateDocumentSection(sectionNumber, sectionContent);            tdoc.setContent(content);            tdoc.setComment(sectionDoc.getComment());            tdoc.setMinorEdit(sectionDoc.isMinorEdit());        } else {            tdoc.readFromForm(form, context);        }        String username = context.getUser();        tdoc.setAuthor(username);        if (tdoc.isNew()) {            tdoc.setCreator(username);        }        tdoc.setMetaDataDirty(true);        if (\"1\".equals(request.getParameter(\"xvalidate\"))) {            boolean validationResult = tdoc.validate(context);            if (validationResult == false) {                context.put(\"display\", \"edit\");                context.setAction(tdoc.getDefaultEditMode(context));                context.put(\"doc\", doc);                context.put(\"cdoc\", tdoc);                context.put(\"tdoc\", tdoc);                getCurrentScriptContext().setAttribute(\"editor\", \"inline\", ScriptContext.ENGINE_SCOPE);                return true;            }        }        if (tdoc.getXObject(RedirectClassDocumentInitializer.REFERENCE) != null            && request.getParameter(\"XWiki.RedirectClass_0_location\") == null) {            tdoc.removeXObjects(RedirectClassDocumentInitializer.REFERENCE);        }        if (isConflictCheckEnabled() && Utils.isAjaxRequest(context)            && request.getParameter(\"previousVersion\") != null) {            if (isConflictingWithVersion(context, originalDoc, tdoc)) {                return true;            }        }        xwiki.checkSavingDocument(context.getUserReference(), tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);        xwiki.saveDocument(tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);        context.put(SAVED_OBJECT_VERSION_KEY, tdoc.getRCSVersion());        Job createJob = startCreateJob(tdoc.getDocumentReference(), form);        if (createJob != null) {            if (isAsync(request)) {                if (Utils.isAjaxRequest(context)) {                    sendRedirect(context.getResponse(), String.format(\"%s/rest/jobstatus/%s?media=json\",                        context.getRequest().getContextPath(), serializeJobId(createJob.getRequest().getId())));                }            } else {                try {                    createJob.join();                } catch (InterruptedException e) {                    throw new XWikiException(String.format(                        \"Interrupted while waiting for template [%s] to be processed when creating the document [%s]\",                        form.getTemplate(), tdoc.getDocumentReference()), e);                }            }        } else {            XWikiLock lock = tdoc.getLock(context);            if (lock != null) {                tdoc.removeLock(context);            }        }        return false;    }    private boolean isConflictCheckEnabled()    {        ConfigurationSource configurationSource = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");        return configurationSource.getProperty(\"edit.conflictChecking.enabled\", true);    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    private MergeManager getMergeManager()    {        if (this.mergeManager == null) {            this.mergeManager = Utils.getComponent(MergeManager.class);        }        return this.mergeManager;    }    private MergeConflictDecisionsManager getConflictDecisionsManager()    {        if (this.conflictDecisionsManager == null) {            this.conflictDecisionsManager = Utils.getComponent(MergeConflictDecisionsManager.class);        }        return this.conflictDecisionsManager;    }    private void recordConflictDecisions(XWikiContext context, DocumentReference documentReference)    {        XWikiRequest request = context.getRequest();        String[] mergeChoices = request.getParameterValues(\"mergeChoices\");        String[] customChoices = request.getParameterValues(\"customChoices\");        Map<String, String> customChoicesMap = new HashMap<>();        if (customChoices != null) {            for (String customChoice : customChoices) {                String[] splittedCustomChoiceInfo = customChoice.split(\"=\");                String conflictReference = splittedCustomChoiceInfo[0];                String customValue = customChoice.substring(conflictReference.length() + 1);                try {                    customValue = URLDecoder.decode(customValue, request.getCharacterEncoding());                } catch (UnsupportedEncodingException e) {                    LOGGER.error(\"Error while decoding a custom value decision.\", e);                }                customChoicesMap.put(conflictReference, customValue);            }        }        if (mergeChoices != null) {            for (String choice : mergeChoices) {                String[] splittedChoiceInfo = choice.split(\"=\");                String conflictReference = splittedChoiceInfo[0];                String selectedChoice = splittedChoiceInfo[1];                List<String> customValue = null;                ConflictDecision.DecisionType decisionType =                    ConflictDecision.DecisionType.valueOf(selectedChoice.toUpperCase());                if (decisionType == ConflictDecision.DecisionType.CUSTOM) {                    customValue = Collections.singletonList(customChoicesMap.get(conflictReference));                }                getConflictDecisionsManager().recordDecision(documentReference, context.getUserReference(),                    conflictReference, decisionType, customValue);            }        }    }    private boolean isConflictingWithVersion(XWikiContext context, XWikiDocument originalDoc, XWikiDocument modifiedDoc)        throws XWikiException    {        XWikiRequest request = context.getRequest();        if (FORCE_SAVE_OVERRIDE.equals(request.getParameter(\"forceSave\"))) {            return false;        }        if (\"true\".equals(request.getParameter(\"isNew\")) && originalDoc.isNew()) {            return false;        }        Version previousVersion = new Version(request.getParameter(\"previousVersion\"));        Version latestVersion = originalDoc.getRCSVersion();        Date editingVersionDate = new Date(Long.parseLong(request.getParameter(\"editingVersionDate\")));        Date latestVersionDate = originalDoc.getDate();        if (!latestVersion.equals(previousVersion) || latestVersionDate.after(editingVersionDate)) {            try {                XWikiDocument previousDoc =                    getDocumentRevisionProvider().getRevision(originalDoc, previousVersion.toString());                if (!originalDoc.isNew() && previousDoc != null) {                    List<Delta> contentDiff =                        originalDoc.getContentDiff(previousVersion.toString(), latestVersion.toString(), context);                    List<List<ObjectDiff>> objectDiff =                        originalDoc.getObjectDiff(previousVersion.toString(), latestVersion.toString(), context);                    List<MetaDataDiff> metaDataDiff =                        originalDoc.getMetaDataDiff(previousVersion.toString(), latestVersion.toString(), context);                    List<MetaDataDiff> filteredMetaDataDiff = new ArrayList<>();                    for (MetaDataDiff dataDiff : metaDataDiff) {                        if (!dataDiff.getField().equals(\"author\")) {                            filteredMetaDataDiff.add(dataDiff);                        }                    }                    if (contentDiff.isEmpty() && objectDiff.isEmpty() && filteredMetaDataDiff.isEmpty()) {                        return false;                    } else {                        MergeConfiguration mergeConfiguration = new MergeConfiguration();                        mergeConfiguration.setUserReference(context.getUserReference());                        mergeConfiguration.setConcernedDocument(modifiedDoc.getDocumentReferenceWithLocale());                        mergeConfiguration.setProvidedVersionsModifiables(true);                        recordConflictDecisions(context, modifiedDoc.getDocumentReferenceWithLocale());                        MergeDocumentResult mergeDocumentResult =                            getMergeManager().mergeDocument(previousDoc, originalDoc, modifiedDoc, mergeConfiguration);                        getConflictDecisionsManager().removeConflictDecisionList(                            modifiedDoc.getDocumentReferenceWithLocale(), context.getUserReference());                        if (FORCE_SAVE_MERGE.equals(request.getParameter(\"forceSave\"))                            || !mergeDocumentResult.hasConflicts()) {                            context.put(MERGED_DOCUMENTS, \"true\");                            return false;                        } else {                            getConflictDecisionsManager().recordConflicts(modifiedDoc.getDocumentReferenceWithLocale(),                                context.getUserReference(),                                mergeDocumentResult.getConflicts(MergeDocumentResult.DocumentPart.CONTENT));                        }                    }                }                Map<String, String> jsonObject = new LinkedHashMap<>();                jsonObject.put(\"previousVersion\", previousVersion.toString());                jsonObject.put(\"previousVersionDate\", editingVersionDate.toString());                jsonObject.put(\"latestVersion\", latestVersion.toString());                jsonObject.put(\"latestVersionDate\", latestVersionDate.toString());                this.answerJSON(context, HttpStatus.SC_CONFLICT, jsonObject);                return true;            } catch (DifferentiationFailedException e) {                throw new XWikiException(\"Error while loading the diff\", e);            }        }        return false;    }    @Override    public boolean action(XWikiContext context) throws XWikiException    {        if (!csrfTokenCheck(context, true)) {            return false;        }        if (save(context)) {            return true;        }        if (Utils.isAjaxRequest(context)) {            Map<String, String> jsonAnswer = new LinkedHashMap<>();            Version newVersion = (Version) context.get(SAVED_OBJECT_VERSION_KEY);            jsonAnswer.put(\"newVersion\", newVersion.toString());            if (\"true\".equals(context.get(MERGED_DOCUMENTS))) {                jsonAnswer.put(\"mergedDocument\", \"true\");            }            answerJSON(context, HttpStatus.SC_OK, jsonAnswer);        } else {            sendRedirect(context.getResponse(), Utils.getRedirect(\"view\", context));        }        return false;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        XWikiException e = (XWikiException) context.get(\"exception\");        if ((e != null) && (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY)) {            return \"docalreadyexists\";        }        if (\"edit\".equals(context.get(\"display\"))) {            return context.getAction();        }        return \"exception\";    }    private boolean isAsync(XWikiRequest request)    {        return \"true\".equals(request.get(ASYNC_PARAM));    }    private Job startCreateJob(EntityReference entityReference, EditForm editForm) throws XWikiException    {        DocumentReference templateReference = resolveTemplate(editForm.getTemplate());        if (templateReference == null) {            return null;        }        RefactoringScriptService refactoring =            (RefactoringScriptService) Utils.getComponent(ScriptService.class, \"refactoring\");        CreateRequest request = refactoring.getRequestFactory().createCreateRequest(Arrays.asList(entityReference));        request.setCheckAuthorRights(false);        request.setEntityReferences(Arrays.asList(entityReference));        request.setTemplateReference(templateReference);        request.setSkippedEntities(Arrays.asList(entityReference));        Job createJob = refactoring.create(request);        if (createJob != null) {            return createJob;        } else {            throw new XWikiException(String.format(\"Failed to schedule the create job for [%s]\", entityReference),                refactoring.getLastError());        }    }    private String serializeJobId(List<String> jobId)    {        return StringUtils.join(jobId, \"/\");    }    private void convertSyntax(XWikiDocument doc, String targetSyntaxId, XWikiContext xcontext) throws XWikiException    {        doc.convertSyntax(targetSyntaxId, xcontext);        for (Locale locale : doc.getTranslationLocales(xcontext)) {            if (!Objects.equals(locale, doc.getLocale())) {                XWikiDocument tdoc = doc.getTranslatedDocument(locale, xcontext);                if (!tdoc.getSyntax().toIdString().equals(targetSyntaxId)) {                    tdoc.convertSyntax(targetSyntaxId, xcontext);                    xcontext.getWiki().saveDocument(tdoc,                        String.format(\"Document converted from syntax %s to syntax %s\", tdoc.getSyntax().toIdString(),                            targetSyntaxId),                        xcontext);                }            }        }    }}", "nl": "import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Objects;import javax.inject.Named;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.httpclient.HttpStatus;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.suigeneris.jrcs.diff.DifferentiationFailedException;import org.suigeneris.jrcs.diff.delta.Delta;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.component.annotation.Component;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.diff.ConflictDecision;import org.xwiki.job.Job;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.refactoring.job.CreateRequest;import org.xwiki.refactoring.script.RefactoringScriptService;import org.xwiki.script.service.ScriptService;import org.xwiki.store.merge.MergeConflictDecisionsManager;import org.xwiki.store.merge.MergeDocumentResult;import org.xwiki.store.merge.MergeManager;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MetaDataDiff;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;import com.xpn.xwiki.doc.merge.MergeConfiguration;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.objects.ObjectDiff;@Component@Named(\"save\")@Singletonpublic class SaveAction extends PreviewAction{    public static final String ACTION_NAME = \"save\";    protected static final String ASYNC_PARAM = \"async\";    private static final Logger LOGGER = LoggerFactory.getLogger(SaveAction.class);    private static final String SAVED_OBJECT_VERSION_KEY = \"SaveAction.savedObjectVersion\";    private static final String MERGED_DOCUMENTS = \"SaveAction.mergedDocuments\";    private static final String FORCE_SAVE_MERGE = \"merge\";    private static final String FORCE_SAVE_OVERRIDE = \"override\";    private DocumentRevisionProvider documentRevisionProvider;    private MergeManager mergeManager;    private MergeConflictDecisionsManager conflictDecisionsManager;    public SaveAction()    {        this.waitForXWikiInitialization = true;    }    public boolean save(XWikiContext context) throws XWikiException    {        XWiki xwiki = context.getWiki();        XWikiRequest request = context.getRequest();        XWikiDocument doc = context.getDoc();        EditForm form = (EditForm) context.getForm();        int sectionNumber = 0;        if (request.getParameter(\"section\") != null && xwiki.hasSectionEdit(context)) {            sectionNumber = Integer.parseInt(request.getParameter(\"section\"));        }        if (doc.isNew() && !this.isEntityReferenceNameValid(doc.getDocumentReference())) {            context.put(\"message\", \"entitynamevalidation.create.invalidname\");            context.put(\"messageParameters\",                new Object[] { getLocalSerializer().serialize(doc.getDocumentReference())});            return true;        }        XWikiDocument originalDoc = doc;        doc = doc.clone();        String language = form.getLanguage();        XWikiDocument tdoc;        if (doc.isNew() || (language == null) || (language.equals(\"\")) || (language.equals(\"default\"))            || (language.equals(doc.getDefaultLanguage()))) {            tdoc = doc;        } else {            tdoc = doc.getTranslatedDocument(language, context);            if ((tdoc == doc) && xwiki.isMultiLingual(context)) {                tdoc = new XWikiDocument(doc.getDocumentReference());                tdoc.setLanguage(language);                tdoc.setStore(doc.getStore());                originalDoc = tdoc;            } else if (tdoc != doc) {                originalDoc = tdoc;                tdoc = tdoc.clone();            }        }        if (doc.isNew()) {            doc.setLocale(Locale.ROOT);            if (doc.getDefaultLocale() == Locale.ROOT) {                doc.setDefaultLocale(xwiki.getLocalePreference(context));            }        }        try {            tdoc.readFromTemplate(form.getTemplate(), context);        } catch (XWikiException e) {            if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {                context.put(\"exception\", e);                return true;            }        }        if (form.isConvertSyntax() && !tdoc.getSyntax().toIdString().equals(form.getSyntaxId())) {            convertSyntax(tdoc, form.getSyntaxId(), context);        }        if (sectionNumber != 0) {            XWikiDocument sectionDoc = tdoc.clone();            sectionDoc.readFromForm(form, context);            String sectionContent = sectionDoc.getContent() + \"\\n\";            String content = tdoc.updateDocumentSection(sectionNumber, sectionContent);            tdoc.setContent(content);            tdoc.setComment(sectionDoc.getComment());            tdoc.setMinorEdit(sectionDoc.isMinorEdit());        } else {            tdoc.readFromForm(form, context);        }        String username = context.getUser();        tdoc.setAuthor(username);        if (tdoc.isNew()) {            tdoc.setCreator(username);        }        tdoc.setMetaDataDirty(true);        if (\"1\".equals(request.getParameter(\"xvalidate\"))) {            boolean validationResult = tdoc.validate(context);            if (validationResult == false) {                context.put(\"display\", \"edit\");                context.setAction(tdoc.getDefaultEditMode(context));                context.put(\"doc\", doc);                context.put(\"cdoc\", tdoc);                context.put(\"tdoc\", tdoc);                getCurrentScriptContext().setAttribute(\"editor\", \"inline\", ScriptContext.ENGINE_SCOPE);                return true;            }        }        if (tdoc.getXObject(RedirectClassDocumentInitializer.REFERENCE) != null            && request.getParameter(\"XWiki.RedirectClass_0_location\") == null) {            tdoc.removeXObjects(RedirectClassDocumentInitializer.REFERENCE);        }        if (isConflictCheckEnabled() && Utils.isAjaxRequest(context)            && request.getParameter(\"previousVersion\") != null) {            if (isConflictingWithVersion(context, originalDoc, tdoc)) {                return true;            }        }        xwiki.checkSavingDocument(context.getUserReference(), tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);        xwiki.saveDocument(tdoc, tdoc.getComment(), tdoc.isMinorEdit(), context);        context.put(SAVED_OBJECT_VERSION_KEY, tdoc.getRCSVersion());        Job createJob = startCreateJob(tdoc.getDocumentReference(), form);        if (createJob != null) {            if (isAsync(request)) {                if (Utils.isAjaxRequest(context)) {                    sendRedirect(context.getResponse(), String.format(\"%s/rest/jobstatus/%s?media=json\",                        context.getRequest().getContextPath(), serializeJobId(createJob.getRequest().getId())));                }            } else {                try {                    createJob.join();                } catch (InterruptedException e) {                    throw new XWikiException(String.format(                        \"Interrupted while waiting for template [%s] to be processed when creating the document [%s]\",                        form.getTemplate(), tdoc.getDocumentReference()), e);                }            }        } else {            XWikiLock lock = tdoc.getLock(context);            if (lock != null) {                tdoc.removeLock(context);            }        }        return false;    }    private boolean isConflictCheckEnabled()    {        ConfigurationSource configurationSource = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");        return configurationSource.getProperty(\"edit.conflictChecking.enabled\", true);    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    private MergeManager getMergeManager()    {        if (this.mergeManager == null) {            this.mergeManager = Utils.getComponent(MergeManager.class);        }        return this.mergeManager;    }    private MergeConflictDecisionsManager getConflictDecisionsManager()    {        if (this.conflictDecisionsManager == null) {            this.conflictDecisionsManager = Utils.getComponent(MergeConflictDecisionsManager.class);        }        return this.conflictDecisionsManager;    }    private void recordConflictDecisions(XWikiContext context, DocumentReference documentReference)    {        XWikiRequest request = context.getRequest();        String[] mergeChoices = request.getParameterValues(\"mergeChoices\");        String[] customChoices = request.getParameterValues(\"customChoices\");        Map<String, String> customChoicesMap = new HashMap<>();        if (customChoices != null) {            for (String customChoice : customChoices) {                String[] splittedCustomChoiceInfo = customChoice.split(\"=\");                String conflictReference = splittedCustomChoiceInfo[0];                String customValue = customChoice.substring(conflictReference.length() + 1);                try {                    customValue = URLDecoder.decode(customValue, request.getCharacterEncoding());                } catch (UnsupportedEncodingException e) {                    LOGGER.error(\"Error while decoding a custom value decision.\", e);                }                customChoicesMap.put(conflictReference, customValue);            }        }        if (mergeChoices != null) {            for (String choice : mergeChoices) {                String[] splittedChoiceInfo = choice.split(\"=\");                String conflictReference = splittedChoiceInfo[0];                String selectedChoice = splittedChoiceInfo[1];                List<String> customValue = null;                ConflictDecision.DecisionType decisionType =                    ConflictDecision.DecisionType.valueOf(selectedChoice.toUpperCase());                if (decisionType == ConflictDecision.DecisionType.CUSTOM) {                    customValue = Collections.singletonList(customChoicesMap.get(conflictReference));                }                getConflictDecisionsManager().recordDecision(documentReference, context.getUserReference(),                    conflictReference, decisionType, customValue);            }        }    }    private boolean isConflictingWithVersion(XWikiContext context, XWikiDocument originalDoc, XWikiDocument modifiedDoc)        throws XWikiException    {        XWikiRequest request = context.getRequest();        if (FORCE_SAVE_OVERRIDE.equals(request.getParameter(\"forceSave\"))) {            return false;        }        if (\"true\".equals(request.getParameter(\"isNew\")) && originalDoc.isNew()) {            return false;        }        Version previousVersion = new Version(request.getParameter(\"previousVersion\"));        Version latestVersion = originalDoc.getRCSVersion();        Date editingVersionDate = new Date(Long.parseLong(request.getParameter(\"editingVersionDate\")));        Date latestVersionDate = originalDoc.getDate();        if (!latestVersion.equals(previousVersion) || latestVersionDate.after(editingVersionDate)) {            try {                XWikiDocument previousDoc =                    getDocumentRevisionProvider().getRevision(originalDoc, previousVersion.toString());                if (!originalDoc.isNew() && previousDoc != null) {                    List<Delta> contentDiff =                        originalDoc.getContentDiff(previousVersion.toString(), latestVersion.toString(), context);                    List<List<ObjectDiff>> objectDiff =                        originalDoc.getObjectDiff(previousVersion.toString(), latestVersion.toString(), context);                    List<MetaDataDiff> metaDataDiff =                        originalDoc.getMetaDataDiff(previousVersion.toString(), latestVersion.toString(), context);                    List<MetaDataDiff> filteredMetaDataDiff = new ArrayList<>();                    for (MetaDataDiff dataDiff : metaDataDiff) {                        if (!dataDiff.getField().equals(\"author\")) {                            filteredMetaDataDiff.add(dataDiff);                        }                    }                    if (contentDiff.isEmpty() && objectDiff.isEmpty() && filteredMetaDataDiff.isEmpty()) {                        return false;                    } else {                        MergeConfiguration mergeConfiguration = new MergeConfiguration();                        mergeConfiguration.setUserReference(context.getUserReference());                        mergeConfiguration.setConcernedDocument(modifiedDoc.getDocumentReferenceWithLocale());                        mergeConfiguration.setProvidedVersionsModifiables(true);                        recordConflictDecisions(context, modifiedDoc.getDocumentReferenceWithLocale());                        MergeDocumentResult mergeDocumentResult =                            getMergeManager().mergeDocument(previousDoc, originalDoc, modifiedDoc, mergeConfiguration);                        getConflictDecisionsManager().removeConflictDecisionList(                            modifiedDoc.getDocumentReferenceWithLocale(), context.getUserReference());                        if (FORCE_SAVE_MERGE.equals(request.getParameter(\"forceSave\"))                            || !mergeDocumentResult.hasConflicts()) {                            context.put(MERGED_DOCUMENTS, \"true\");                            return false;                        } else {                            getConflictDecisionsManager().recordConflicts(modifiedDoc.getDocumentReferenceWithLocale(),                                context.getUserReference(),                                mergeDocumentResult.getConflicts(MergeDocumentResult.DocumentPart.CONTENT));                        }                    }                }                Map<String, String> jsonObject = new LinkedHashMap<>();                jsonObject.put(\"previousVersion\", previousVersion.toString());                jsonObject.put(\"previousVersionDate\", editingVersionDate.toString());                jsonObject.put(\"latestVersion\", latestVersion.toString());                jsonObject.put(\"latestVersionDate\", latestVersionDate.toString());                this.answerJSON(context, HttpStatus.SC_CONFLICT, jsonObject);                return true;            } catch (DifferentiationFailedException e) {                throw new XWikiException(\"Error while loading the diff\", e);            }        }        return false;    }    @Override    public boolean action(XWikiContext context) throws XWikiException    {        if (!csrfTokenCheck(context, true)) {            return false;        }        if (save(context)) {            return true;        }        if (Utils.isAjaxRequest(context)) {            Map<String, String> jsonAnswer = new LinkedHashMap<>();            Version newVersion = (Version) context.get(SAVED_OBJECT_VERSION_KEY);            jsonAnswer.put(\"newVersion\", newVersion.toString());            if (\"true\".equals(context.get(MERGED_DOCUMENTS))) {                jsonAnswer.put(\"mergedDocument\", \"true\");            }            answerJSON(context, HttpStatus.SC_OK, jsonAnswer);        } else {            sendRedirect(context.getResponse(), Utils.getRedirect(\"view\", context));        }        return false;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        XWikiException e = (XWikiException) context.get(\"exception\");        if ((e != null) && (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY)) {            return \"docalreadyexists\";        }        if (\"edit\".equals(context.get(\"display\"))) {            return context.getAction();        }        return \"exception\";    }    private boolean isAsync(XWikiRequest request)    {        return \"true\".equals(request.get(ASYNC_PARAM));    }    private Job startCreateJob(EntityReference entityReference, EditForm editForm) throws XWikiException    {        if (StringUtils.isBlank(editForm.getTemplate())) {            return null;        }        RefactoringScriptService refactoring =            (RefactoringScriptService) Utils.getComponent(ScriptService.class, \"refactoring\");        CreateRequest request = refactoring.getRequestFactory().createCreateRequest(Arrays.asList(entityReference));        request.setCheckAuthorRights(false);        request.setEntityReferences(Arrays.asList(entityReference));        DocumentReferenceResolver<String> resolver =            Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        EntityReference templateReference = resolver.resolve(editForm.getTemplate());        request.setTemplateReference(templateReference);        request.setSkippedEntities(Arrays.asList(entityReference));        Job createJob = refactoring.create(request);        if (createJob != null) {            return createJob;        } else {            throw new XWikiException(String.format(\"Failed to schedule the create job for [%s]\", entityReference),                refactoring.getLastError());        }    }    private String serializeJobId(List<String> jobId)    {        return StringUtils.join(jobId, \"/\");    }    private void convertSyntax(XWikiDocument doc, String targetSyntaxId, XWikiContext xcontext) throws XWikiException    {        doc.convertSyntax(targetSyntaxId, xcontext);        for (Locale locale : doc.getTranslationLocales(xcontext)) {            if (!Objects.equals(locale, doc.getLocale())) {                XWikiDocument tdoc = doc.getTranslatedDocument(locale, xcontext);                if (!tdoc.getSyntax().toIdString().equals(targetSyntaxId)) {                    tdoc.convertSyntax(targetSyntaxId, xcontext);                    xcontext.getWiki().saveDocument(tdoc,                        String.format(\"Document converted from syntax %s to syntax %s\", tdoc.getSyntax().toIdString(),                            targetSyntaxId),                        xcontext);                }            }        }    }}"}
{"code": "import java.io.IOException;import java.net.URL;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import javax.inject.Inject;import javax.inject.Named;import javax.script.ScriptContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.velocity.VelocityContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.ActionExecutedEvent;import org.xwiki.bridge.event.ActionExecutingEvent;import org.xwiki.component.descriptor.ComponentDescriptor;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.container.Container;import org.xwiki.container.Request;import org.xwiki.container.servlet.ServletContainerException;import org.xwiki.container.servlet.ServletContainerInitializer;import org.xwiki.container.servlet.ServletRequest;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.csrf.CSRFToken;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.internal.DefaultJobProgress;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceProvider;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.EntityReferenceValueProvider;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.WrappedThreadEventListener;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.NotFoundResourceHandlerException;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceHandler;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceType;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;import org.xwiki.script.ScriptContextManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.velocity.VelocityManager;import com.fasterxml.jackson.databind.ObjectMapper;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.internal.web.LegacyAction;import com.xpn.xwiki.monitor.api.MonitorPlugin;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;public abstract class XWikiAction implements LegacyAction{    public static final String ACTION_PROGRESS = \"actionprogress\";    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");    @Inject    protected ComponentDescriptor<LegacyAction> componentDescriptor;    @Inject    protected Container container;    @Inject    protected Execution execution;    @Inject    protected ContextualAuthorizationManager autorization;    @Inject    @Named(\"currentmixed\")    protected DocumentReferenceResolver<String> currentmixedReferenceResolver;    protected boolean waitForXWikiInitialization = true;    protected boolean handleRedirectObject = false;    private ContextualLocalizationManager localization;    private JobProgressManager progress;    private ScriptContextManager scriptContextManager;    private EntityNameValidationManager entityNameValidationManager;    private EntityNameValidationConfiguration entityNameValidationConfiguration;    private EntityReferenceSerializer<String> localSerializer;    @Unstable    protected Class<? extends XWikiForm> getFormClass()    {        return null;    }    protected ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    protected String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    protected JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    protected EntityNameValidationManager getEntityNameValidationManager()    {        if (this.entityNameValidationManager == null) {            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);        }        return this.entityNameValidationManager;    }    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()    {        if (this.entityNameValidationConfiguration == null) {            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);        }        return this.entityNameValidationConfiguration;    }    protected EntityReferenceSerializer<String> getLocalSerializer()    {        if (this.localSerializer == null) {            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localSerializer;    }    protected ScriptContext getCurrentScriptContext()    {        if (this.scriptContextManager == null) {            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);        }        return this.scriptContextManager.getCurrentScriptContext();    }    @Override    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception    {        XWikiContext context = null;        try {            context = initializeXWikiContext(servletRequest, servletResponse);            execute(context);        } finally {            if (context != null) {                cleanupComponents();            }        }    }    @Unstable    protected boolean isEntityReferenceNameValid(EntityReference entityReference)    {        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null            && this.getEntityNameValidationConfiguration().useValidation()) {            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {                Object[] args = {getLocalSerializer().serialize(entityReference)};                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,                    args);                ScriptContext scontext = getCurrentScriptContext();                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);                return false;            }        }        return true;    }    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)    {        try {            context.getResponse().setContentType(\"text/plain\");            context.getResponse().setStatus(httpStatusCode);            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());            context.getResponse().getWriter().print(message);        } catch (IOException e) {            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);        }    }    public void execute(XWikiContext context) throws Exception    {        MonitorPlugin monitor = null;        FileUploadPlugin fileupload = null;        DefaultJobProgress actionProgress = null;        ObservationManager om = Utils.getComponent(ObservationManager.class);        Execution execution = Utils.getComponent(Execution.class);        String docName = \"\";        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");        String sasync = context.getRequest().get(\"async\");        try {            String action = context.getAction();            if (debug && om != null && execution != null) {                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());                om.addListener(new WrappedThreadEventListener(actionProgress));                ExecutionContext econtext = execution.getContext();                if (econtext != null) {                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);                }            }            getProgress().pushLevelProgress(2, this);            getProgress().startStep(this, \"Get XWiki instance\");            XWiki xwiki;            try {                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);                if (xwiki == null) {                    renderInit(context);                    return;                }            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {                    xwiki = XWiki.getMainXWiki(context);                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);                    context.setURLFactory(urlf);                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);                    VelocityContext vcontext = velocityManager.getVelocityContext();                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));                        }                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {                            xwiki.prepareResources(context);                            EntityReferenceValueProvider valueProvider =                                Utils.getComponent(EntityReferenceValueProvider.class);                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),                                valueProvider.getDefaultValue(EntityType.SPACE),                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),                                context);                            return;                        }                    } else {                        return;                    }                } else {                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);                    throw e;                }            }            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                return;            }            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);            context.setURLFactory(urlf);            if (redirectSpaceURLs(action, urlf, xwiki, context)) {                return;            }            String sajax = context.getRequest().get(\"ajax\");            boolean ajax = false;            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {                ajax = true;            }            context.put(\"ajax\", ajax);            boolean async = false;            if (StringUtils.isNotEmpty(sasync)) {                async = sasync.equals(\"true\");            } else {                async = !ajax && !this.waitForXWikiInitialization;            }            Utils.getComponent(AsyncContext.class).setEnabled(async);            if (monitor != null) {                monitor.startTimer(\"request\");            }            getProgress().startStep(this, \"Execute request\");            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);            VelocityContext vcontext = velocityManager.getVelocityContext();            getProgress().pushLevelProgress(7, this);            boolean eventSent = false;            try {                getProgress().startStep(this, \"Prepare documents and put them in the context\");                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {                    return;                }                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);                if (monitor != null) {                    monitor.startRequest(\"\", context.getAction(), context.getURL());                    monitor.startTimer(\"multipart\");                }                getProgress().startStep(this, \"Parses multipart\");                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);                if (monitor != null) {                    monitor.endTimer(\"multipart\");                }                if (monitor != null) {                    monitor.setWikiPage(context.getDoc().getFullName());                }                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");                try {                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());                    om.notify(event, context.getDoc(), context);                    eventSent = true;                    if (event.isCanceled()) {                        return;                    }                } catch (Throwable ex) {                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()                        + \" using action [\" + context.getAction() + \"]\", ex);                }                if (monitor != null) {                    monitor.endTimer(\"prenotify\");                }                getProgress().startStep(this, \"Search and execute entity resource handler\");                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");                EntityResourceReference entityResourceReference =                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();                String originalAction = context.getAction();                try {                    context.setAction(entityResourceReference.getAction().getActionName());                    entityResourceReferenceHandler.handle(entityResourceReference,                        DefaultResourceReferenceHandlerChain.EMPTY);                    return;                } catch (NotFoundResourceHandlerException e) {                    context.setAction(originalAction);                }                getProgress().startStep(this, \"Execute action render\");                boolean hasRedirect = false;                if (handleRedirectObject) {                    hasRedirect = handleRedirectObject(context);                }                String renderResult = null;                XWikiDocument doc = context.getDoc();                docName = doc.getFullName();                if (!hasRedirect && action(context)) {                    renderResult = render(context);                }                if (renderResult != null) {                    if (doc.isNew() && \"view\".equals(context.getAction())                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))                        && !\"children\".equals(context.getRequest().get(\"viewer\"))                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, context);                    } else {                        String page = Utils.getPage(context.getRequest(), renderResult);                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);                    }                }                return;            } catch (Throwable e) {                if (e instanceof IOException) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);                }                if (!(e instanceof XWikiException)) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,                        \"Uncaught exception\", e);                }                try {                    XWikiException xex = (XWikiException) e;                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.debug(\"Connection aborted\", e);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                            context.put(\"cause\", \"disabled\");                        }                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {                        context.put(\"message\", \"attachmentdoesnotexist\");                        Utils.parseTemplate(                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),                            context, vcontext);                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);                        return;                    }                    velocityManager.getVelocityContext().put(\"exp\", e);                    if (LOGGER.isWarnEnabled()) {                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {                            return;                        }                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);                    }                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);                    return;                } catch (XWikiException ex) {                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.error(\"Connection aborted\");                    }                } catch (Exception e2) {                    LOGGER.error(\"Uncaught exceptions (inner): \", e);                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);                }                return;            } finally {                try {                    context.getResponse().getWriter().flush();                } catch (Throwable e) {                }                if (monitor != null) {                    monitor.endTimer(\"request\");                    monitor.startTimer(\"notify\");                }                if (eventSent) {                    try {                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);                    } catch (Throwable ex) {                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"                            + context.getAction() + \"]\", ex);                    }                }                if (monitor != null) {                    monitor.endTimer(\"notify\");                }                getProgress().startStep(this, \"Cleanup database connections\");", "nl": "import java.io.IOException;import java.net.URL;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import javax.inject.Inject;import javax.script.ScriptContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.velocity.VelocityContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.ActionExecutedEvent;import org.xwiki.bridge.event.ActionExecutingEvent;import org.xwiki.component.descriptor.ComponentDescriptor;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.container.Container;import org.xwiki.container.Request;import org.xwiki.container.servlet.ServletContainerException;import org.xwiki.container.servlet.ServletContainerInitializer;import org.xwiki.container.servlet.ServletRequest;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.csrf.CSRFToken;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.internal.DefaultJobProgress;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceProvider;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.EntityReferenceValueProvider;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.WrappedThreadEventListener;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.NotFoundResourceHandlerException;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceHandler;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceType;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;import org.xwiki.script.ScriptContextManager;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.velocity.VelocityManager;import com.fasterxml.jackson.databind.ObjectMapper;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.internal.web.LegacyAction;import com.xpn.xwiki.monitor.api.MonitorPlugin;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;public abstract class XWikiAction implements LegacyAction{    public static final String ACTION_PROGRESS = \"actionprogress\";    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");    @Inject    protected ComponentDescriptor<LegacyAction> componentDescriptor;    @Inject    protected Container container;    @Inject    protected Execution execution;    protected boolean waitForXWikiInitialization = true;    protected boolean handleRedirectObject = false;    private ContextualLocalizationManager localization;    private JobProgressManager progress;    private ScriptContextManager scriptContextManager;    private EntityNameValidationManager entityNameValidationManager;    private EntityNameValidationConfiguration entityNameValidationConfiguration;    private EntityReferenceSerializer<String> localSerializer;    @Unstable    protected Class<? extends XWikiForm> getFormClass()    {        return null;    }    protected ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    protected String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    protected JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    protected EntityNameValidationManager getEntityNameValidationManager()    {        if (this.entityNameValidationManager == null) {            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);        }        return this.entityNameValidationManager;    }    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()    {        if (this.entityNameValidationConfiguration == null) {            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);        }        return this.entityNameValidationConfiguration;    }    protected EntityReferenceSerializer<String> getLocalSerializer()    {        if (this.localSerializer == null) {            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localSerializer;    }    protected ScriptContext getCurrentScriptContext()    {        if (this.scriptContextManager == null) {            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);        }        return this.scriptContextManager.getCurrentScriptContext();    }    @Override    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception    {        XWikiContext context = null;        try {            context = initializeXWikiContext(servletRequest, servletResponse);            execute(context);        } finally {            if (context != null) {                cleanupComponents();            }        }    }    @Unstable    protected boolean isEntityReferenceNameValid(EntityReference entityReference)    {        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null            && this.getEntityNameValidationConfiguration().useValidation()) {            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {                Object[] args = {getLocalSerializer().serialize(entityReference)};                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,                    args);                ScriptContext scontext = getCurrentScriptContext();                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);                return false;            }        }        return true;    }    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)    {        try {            context.getResponse().setContentType(\"text/plain\");            context.getResponse().setStatus(httpStatusCode);            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());            context.getResponse().getWriter().print(message);        } catch (IOException e) {            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);        }    }    public void execute(XWikiContext context) throws Exception    {        MonitorPlugin monitor = null;        FileUploadPlugin fileupload = null;        DefaultJobProgress actionProgress = null;        ObservationManager om = Utils.getComponent(ObservationManager.class);        Execution execution = Utils.getComponent(Execution.class);        String docName = \"\";        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");        String sasync = context.getRequest().get(\"async\");        try {            String action = context.getAction();            if (debug && om != null && execution != null) {                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());                om.addListener(new WrappedThreadEventListener(actionProgress));                ExecutionContext econtext = execution.getContext();                if (econtext != null) {                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);                }            }            getProgress().pushLevelProgress(2, this);            getProgress().startStep(this, \"Get XWiki instance\");            XWiki xwiki;            try {                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);                if (xwiki == null) {                    renderInit(context);                    return;                }            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {                    xwiki = XWiki.getMainXWiki(context);                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);                    context.setURLFactory(urlf);                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);                    VelocityContext vcontext = velocityManager.getVelocityContext();                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));                        }                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {                            xwiki.prepareResources(context);                            EntityReferenceValueProvider valueProvider =                                Utils.getComponent(EntityReferenceValueProvider.class);                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),                                valueProvider.getDefaultValue(EntityType.SPACE),                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),                                context);                            return;                        }                    } else {                        return;                    }                } else {                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);                    throw e;                }            }            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                return;            }            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);            context.setURLFactory(urlf);            if (redirectSpaceURLs(action, urlf, xwiki, context)) {                return;            }            String sajax = context.getRequest().get(\"ajax\");            boolean ajax = false;            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {                ajax = true;            }            context.put(\"ajax\", ajax);            boolean async = false;            if (StringUtils.isNotEmpty(sasync)) {                async = sasync.equals(\"true\");            } else {                async = !ajax && !this.waitForXWikiInitialization;            }            Utils.getComponent(AsyncContext.class).setEnabled(async);            if (monitor != null) {                monitor.startTimer(\"request\");            }            getProgress().startStep(this, \"Execute request\");            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);            VelocityContext vcontext = velocityManager.getVelocityContext();            getProgress().pushLevelProgress(7, this);            boolean eventSent = false;            try {                getProgress().startStep(this, \"Prepare documents and put them in the context\");                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {                    return;                }                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);                if (monitor != null) {                    monitor.startRequest(\"\", context.getAction(), context.getURL());                    monitor.startTimer(\"multipart\");                }                getProgress().startStep(this, \"Parses multipart\");                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);                if (monitor != null) {                    monitor.endTimer(\"multipart\");                }                if (monitor != null) {                    monitor.setWikiPage(context.getDoc().getFullName());                }                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");                try {                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());                    om.notify(event, context.getDoc(), context);                    eventSent = true;                    if (event.isCanceled()) {                        return;                    }                } catch (Throwable ex) {                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()                        + \" using action [\" + context.getAction() + \"]\", ex);                }                if (monitor != null) {                    monitor.endTimer(\"prenotify\");                }                getProgress().startStep(this, \"Search and execute entity resource handler\");                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");                EntityResourceReference entityResourceReference =                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();                String originalAction = context.getAction();                try {                    context.setAction(entityResourceReference.getAction().getActionName());                    entityResourceReferenceHandler.handle(entityResourceReference,                        DefaultResourceReferenceHandlerChain.EMPTY);                    return;                } catch (NotFoundResourceHandlerException e) {                    context.setAction(originalAction);                }                getProgress().startStep(this, \"Execute action render\");                boolean hasRedirect = false;                if (handleRedirectObject) {                    hasRedirect = handleRedirectObject(context);                }                String renderResult = null;                XWikiDocument doc = context.getDoc();                docName = doc.getFullName();                if (!hasRedirect && action(context)) {                    renderResult = render(context);                }                if (renderResult != null) {                    if (doc.isNew() && \"view\".equals(context.getAction())                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))                        && !\"children\".equals(context.getRequest().get(\"viewer\"))                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, context);                    } else {                        String page = Utils.getPage(context.getRequest(), renderResult);                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);                    }                }                return;            } catch (Throwable e) {                if (e instanceof IOException) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);                }                if (!(e instanceof XWikiException)) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,                        \"Uncaught exception\", e);                }                try {                    XWikiException xex = (XWikiException) e;                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.debug(\"Connection aborted\", e);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                            context.put(\"cause\", \"disabled\");                        }                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {                        context.put(\"message\", \"attachmentdoesnotexist\");                        Utils.parseTemplate(                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),                            context, vcontext);                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);                        return;                    }                    velocityManager.getVelocityContext().put(\"exp\", e);                    if (LOGGER.isWarnEnabled()) {                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {                            return;                        }                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);                    }                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);                    return;                } catch (XWikiException ex) {                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.error(\"Connection aborted\");                    }                } catch (Exception e2) {                    LOGGER.error(\"Uncaught exceptions (inner): \", e);                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);                }                return;            } finally {                try {                    context.getResponse().getWriter().flush();                } catch (Throwable e) {                }                if (monitor != null) {                    monitor.endTimer(\"request\");                    monitor.startTimer(\"notify\");                }                if (eventSent) {                    try {                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);                    } catch (Throwable ex) {                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"                            + context.getAction() + \"]\", ex);                    }                }                if (monitor != null) {                    monitor.endTimer(\"notify\");                }                getProgress().startStep(this, \"Cleanup database connections\");                xwiki.getStore().cleanUp(context);                getProgress().popLevelProgress(this);            }        } finally {            if (monitor != null) {                monitor.e"}
{"code": "import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Locale;import javax.inject.Provider;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.observation.ObservationManager;import org.xwiki.query.Query;import org.xwiki.query.QueryManager;import org.xwiki.security.authorization.Right;import org.xwiki.test.annotation.ComponentList;import org.xwiki.test.junit5.mockito.InjectMockComponents;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.test.MockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.OldcoreTest;import com.xpn.xwiki.test.reference.ReferenceComponentList;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentList@ReferenceComponentList@OldcoreTestclass CreateActionTest{    @InjectMockitoOldcore    MockitoOldcore oldcore;    XWikiURLFactory mockURLFactory;    @InjectMockComponents    CreateAction action;    XWikiContext context;    XWikiRequest mockRequest;    XWikiResponse mockResponse;    Query mockTemplateProvidersQuery;    @BeforeEach    public void beforeEach() throws Exception    {        this.context = this.oldcore.getXWikiContext();        Utils.setComponentManager(this.oldcore.getMocker());        QueryManager mockSecureQueryManager =            this.oldcore.getMocker().registerMockComponent((Type) QueryManager.class, \"secure\");        this.mockTemplateProvidersQuery = mock(Query.class);        when(mockSecureQueryManager.createQuery(any(), any())).thenReturn(this.mockTemplateProvidersQuery);        when(this.mockTemplateProvidersQuery.execute()).thenReturn(Collections.emptyList());        when(this.oldcore.getMockContextualAuthorizationManager().hasAccess(any(Right.class),            any(EntityReference.class))).thenReturn(true);        Provider<DocumentReference> mockDocumentReferenceProvider =            this.oldcore.getMocker().registerMockComponent(DocumentReference.TYPE_PROVIDER);        when(mockDocumentReferenceProvider.get())            .thenReturn(new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\"));        this.mockURLFactory = mock(XWikiURLFactory.class);        this.context.setURLFactory(this.mockURLFactory);        this.mockRequest = mock(XWikiRequest.class);        this.context.setRequest(this.mockRequest);        this.mockResponse = mock(XWikiResponse.class);        this.context.setResponse(this.mockResponse);        when(this.mockRequest.get(\"type\")).thenReturn(\"plain\");        this.oldcore.getMocker().registerMockComponent(ObservationManager.class);    }    @Test    void newDocumentFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    void newDocumentButNonTerminalFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,            \"xwiki\", context);    }    @Test    void newDocumentFromURLWhenNoType() throws Exception    {        when(mockRequest.get(\"type\")).thenReturn(null);        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertEquals(\"create\", result);    }    @Test    void newDocumentWebHomeTopLevelFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",            context);    }    @Test    void newDocumentWebHomeFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,            \"xwiki\", context);    }    @Test    void newDocumentWebHomeButTerminalFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    void newDocumentWebHomeTopLevelSpaceButTerminalFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertEquals(\"create\", result);        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));    }    @Test    void existingDocumentFromUINoName() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertEquals(\"create\", result);        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));    }    @Test    void existingDocumentFromUI() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,            \"xwiki\", context);    }    @Test    void existingDocumentFromUICheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y.Z\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null,            \"xwiki\", context);    }    @Test    void existingDocumentTerminalFromUI() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    void existingDocumentTerminalFromUICheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",            context);    }    @Test    void existingDocumentTerminalFromUIButAlreadyExisting() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        oldcore.getDocuments().put(new DocumentReference(documentReference, Locale.ROOT), document);        when(document.getContent()).thenReturn(\"Some non-empty content\");        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"WebHome\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertEquals(\"create\", result);        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");        assertNotNull(exception);        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY, exception.getCode());        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));    }    @Test    void notExistingDocumentFromUIButNameTooLong() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(10);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo123456789\");        String result = action.render(context);        assertEquals(\"create\", result);        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");        assertNotNull(exception);        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));    }    @Test    void notExistingDocumentFromUIButSpaceTooLong() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(10);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"1.3.5.7.9.11\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo\");        String result = action.render(context);        assertEquals(\"create\", result);        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");        assertNotNull(exception);        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));    }    @Test    void existingDocumentFromUITopLevelDocument() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    void existingDocumentFromUIDeprecated() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    void existingDocumentFromUIDeprecatedCheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"page\")).thenReturn(\"Z\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",            context);    }    @Test    void existingDocumentNonTerminalFromUIDeprecated() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",            context);    }    @Test    void existingDocumentNonTerminalFromUIDeprecatedIgnoringPage() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",            context);    }    @Test    void existingDocumentNonTerminalFromUIDeprecatedCheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X.Y\", null,            \"xwiki\", context);    }    @Test    void existingDocumentFromUITemplateProviderExistingButNoneSelected() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        mockExistingTemplateProviders(\"XWiki.MyTemplateProvider\",            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.emptyList());        String result = action.render(context);        assertEquals(\"create\", result);        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(), any(), any(XWikiContext.class));    }    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,        List<String> allowedSpaces) throws Exception    {        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, false);    }    private void mockExistingTemplateProviders(String fullName, DocumentReference resol", "nl": "import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Locale;import javax.inject.Provider;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.observation.ObservationManager;import org.xwiki.query.Query;import org.xwiki.query.QueryManager;import org.xwiki.security.authorization.Right;import org.xwiki.test.annotation.ComponentList;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.test.MockitoOldcoreRule;import com.xpn.xwiki.test.reference.ReferenceComponentList;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentList@ReferenceComponentListpublic class CreateActionTest{    @Rule    public MockitoOldcoreRule oldcore = new MockitoOldcoreRule();    XWikiURLFactory mockURLFactory;    CreateAction action;    XWikiContext context;    XWikiRequest mockRequest;    XWikiResponse mockResponse;    Query mockTemplateProvidersQuery;    @Before    public void setUp() throws Exception    {        context = oldcore.getXWikiContext();        Utils.setComponentManager(oldcore.getMocker());        QueryManager mockSecureQueryManager =            oldcore.getMocker().registerMockComponent((Type) QueryManager.class, \"secure\");        mockTemplateProvidersQuery = mock(Query.class);        when(mockSecureQueryManager.createQuery(any(), any())).thenReturn(mockTemplateProvidersQuery);        when(mockTemplateProvidersQuery.execute()).thenReturn(Collections.emptyList());        when(oldcore.getMockContextualAuthorizationManager().hasAccess(any(Right.class), any(EntityReference.class)))            .thenReturn(true);        Provider<DocumentReference> mockDocumentReferenceProvider =            oldcore.getMocker().registerMockComponent(DocumentReference.TYPE_PROVIDER);        when(mockDocumentReferenceProvider.get())            .thenReturn(new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\"));        mockURLFactory = mock(XWikiURLFactory.class);        context.setURLFactory(mockURLFactory);        action = new CreateAction();        mockRequest = mock(XWikiRequest.class);        context.setRequest(mockRequest);        mockResponse = mock(XWikiResponse.class);        context.setResponse(mockResponse);        when(mockRequest.get(\"type\")).thenReturn(\"plain\");        this.oldcore.getMocker().registerMockComponent(ObservationManager.class);    }    @Test    public void newDocumentFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    public void newDocumentButNonTerminalFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"nonterminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,            \"xwiki\", context);    }    @Test    public void newDocumentFromURLWhenNoType() throws Exception    {        when(mockRequest.get(\"type\")).thenReturn(null);        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"Y\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertEquals(\"create\", result);    }    @Test    public void newDocumentWebHomeTopLevelFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",            context);    }    @Test    public void newDocumentWebHomeFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,            \"xwiki\", context);    }    @Test    public void newDocumentWebHomeButTerminalFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\", \"Y\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    public void newDocumentWebHomeTopLevelSpaceButTerminalFromURL() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"X\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(true);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertEquals(\"create\", result);        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),            any(), any(XWikiContext.class));    }    @Test    public void existingDocumentFromUINoName() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        String result = action.render(context);        assertEquals(\"create\", result);        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),            any(), any(XWikiContext.class));    }    @Test    public void existingDocumentFromUI() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null,            \"xwiki\", context);    }    @Test    public void existingDocumentFromUICheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y.Z\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null,            \"xwiki\", context);    }    @Test    public void existingDocumentTerminalFromUI() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    public void existingDocumentTerminalFromUICheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Z\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",            context);    }    @Test    public void existingDocumentTerminalFromUIButAlreadyExisting() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        oldcore.getDocuments().put(new DocumentReference(documentReference, Locale.ROOT), document);        when(document.getContent()).thenReturn(\"Some non-empty content\");        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"WebHome\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"terminal\");        String result = action.render(context);        assertEquals(\"create\", result);        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");        assertNotNull(exception);        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY, exception.getCode());        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),            any(), any(XWikiContext.class));    }    @Test    public void notExistingDocumentFromUIButNameTooLong() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(10);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"Main\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo123456789\");        String result = action.render(context);        assertEquals(\"create\", result);        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");        assertNotNull(exception);        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),            any(), any(XWikiContext.class));    }    @Test    public void notExistingDocumentFromUIButSpaceTooLong() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(10);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"1.3.5.7.9.11\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Foo\");        String result = action.render(context);        assertEquals(\"create\", result);        XWikiException exception = (XWikiException) this.oldcore.getScriptContext().getAttribute(\"createException\");        assertNotNull(exception);        assertEquals(XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG, exception.getCode());        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),            any(), any(XWikiContext.class));    }    @Test    public void existingDocumentFromUITopLevelDocument() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    public void existingDocumentFromUIDeprecated() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"Y\", \"edit\", \"template=&parent=Main.WebHome&title=Y\", null, \"xwiki\",            context);    }    @Test    public void existingDocumentFromUIDeprecatedCheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"page\")).thenReturn(\"Z\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"Z\", \"edit\", \"template=&parent=Main.WebHome&title=Z\", null, \"xwiki\",            context);    }    @Test    public void existingDocumentNonTerminalFromUIDeprecated() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",            context);    }    @Test    public void existingDocumentNonTerminalFromUIDeprecatedIgnoringPage() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"page\")).thenReturn(\"Y\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X\", null, \"xwiki\",            context);    }    @Test    public void existingDocumentNonTerminalFromUIDeprecatedCheckEscaping() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"space\")).thenReturn(\"X.Y\");        when(mockRequest.getParameter(\"tocreate\")).thenReturn(\"space\");        String result = action.render(context);        assertNull(result);        verify(mockURLFactory).createURL(\"X\\\\.Y\", \"WebHome\", \"edit\", \"template=&parent=Main.WebHome&title=X.Y\", null,            \"xwiki\", context);    }    @Test    public void existingDocumentFromUITemplateProviderExistingButNoneSelected() throws Exception    {        DocumentReference documentReference = new DocumentReference(\"xwiki\", Arrays.asList(\"Main\"), \"WebHome\");        XWikiDocument document = mock(XWikiDocument.class);        when(document.getDocumentReference()).thenReturn(documentReference);        when(document.isNew()).thenReturn(false);        when(document.getLocalReferenceMaxLength()).thenReturn(255);        context.setDoc(document);        when(mockRequest.getParameter(\"spaceReference\")).thenReturn(\"X\");        when(mockRequest.getParameter(\"name\")).thenReturn(\"Y\");        mockExistingTemplateProviders(\"XWiki.MyTemplateProvider\",            new DocumentReference(\"xwiki\", Arrays.asList(\"XWiki\"), \"MyTemplateProvider\"), Collections.EMPTY_LIST);        String result = action.render(context);        assertEquals(\"create\", result);        verify(mockURLFactory, never()).createURL(any(), any(), any(), any(), any(),            any(), any(XWikiContext.class));    }    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,        List<String> allowedSpaces) throws Exception    {        mockExistingTemplateProviders(fullName, resolvedDocumentReference, allowedSpaces, false);    }    private void mockExistingTemplateProviders(String fullName, DocumentReference resolvedDocumentReference,        List<String> allowedSpaces, Boolean terminal)"}
{"code": "import java.util.Collections;import java.util.Date;import javax.inject.Named;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.context.Execution;import org.xwiki.job.Job;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.validation.EntityNameValidation;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.refactoring.job.CreateRequest;import org.xwiki.refactoring.script.RefactoringScriptService;import org.xwiki.refactoring.script.RequestFactory;import org.xwiki.script.service.ScriptService;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.test.annotation.ComponentList;import org.xwiki.test.junit5.mockito.InjectComponentManager;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.test.mockito.MockitoComponentManager;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;import com.xpn.xwiki.test.MockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.OldcoreTest;import com.xpn.xwiki.test.reference.ReferenceComponentList;import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentList@ReferenceComponentList@OldcoreTest(mockXWiki = false)class SaveActionTest{    private static final DocumentReference USER_REFERENCE = new DocumentReference(\"xwiki\", \"XWiki\", \"FooBar\");    @InjectMockitoOldcore    private MockitoOldcore oldcore;    @InjectComponentManager    private MockitoComponentManager componentManager;    @MockComponent    private EntityNameValidationManager entityNameValidationManager;    @MockComponent    private EntityNameValidationConfiguration entityNameValidationConfiguration;    @MockComponent    private Execution execution;    @MockComponent    @Named(\"xwikiproperties\")    private ConfigurationSource propertiesConf;    @MockComponent    private ContextualAuthorizationManager autorization;    @MockComponent    private DocumentRevisionProvider documentRevisionProvider;    private XWikiContext context;    @InjectMockComponents    private SaveAction saveAction;    private XWikiRequest mockRequest;    private XWikiResponse mockResponse;    private XWikiDocument mockDocument;    private XWikiDocument mockClonedDocument;    private EditForm mockForm;    private XWiki xWiki;    @BeforeEach    void setup()    {        this.context = this.oldcore.getXWikiContext();        this.xWiki = mock(XWiki.class);        this.context.setWiki(this.xWiki);        this.mockRequest = mock(XWikiRequest.class);        this.context.setRequest(this.mockRequest);        this.mockResponse = mock(XWikiResponse.class);        this.context.setResponse(this.mockResponse);        this.mockDocument = mock(XWikiDocument.class);        this.context.setDoc(this.mockDocument);        this.mockClonedDocument = mock(XWikiDocument.class);        when(this.mockDocument.clone()).thenReturn(this.mockClonedDocument);        this.mockForm = mock(EditForm.class);        this.context.setForm(this.mockForm);        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(false);        this.context.setUserReference(USER_REFERENCE);    }    @Test    void newDocumentInvalidName() throws Exception    {        when(mockDocument.isNew()).thenReturn(true);        DocumentReference documentReference = new DocumentReference(\"XWiki\", \"Foo\", \"Bar\");        when(mockDocument.getDocumentReference()).thenReturn(documentReference);        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(true);        EntityNameValidation entityNameValidation = mock(EntityNameValidation.class);        when(this.entityNameValidationManager.getEntityReferenceNameStrategy()).thenReturn(entityNameValidation);        when(entityNameValidation.isValid(documentReference)).thenReturn(false);        assertTrue(saveAction.save(this.context));        assertEquals(\"entitynamevalidation.create.invalidname\", context.get(\"message\"));        assertArrayEquals(new Object[] {\"Foo.Bar\"}, (Object[]) context.get(\"messageParameters\"));    }    @Test    void validSave() throws Exception    {        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));        when(mockForm.getTemplate()).thenReturn(\"\");        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");        verify(mockClonedDocument).setMetaDataDirty(true);        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);        verify(mockClonedDocument).removeLock(this.context);    }    @Test    void validSaveNewTranslation() throws Exception    {        when(mockForm.getLanguage()).thenReturn(\"fr\");        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(mockClonedDocument);        when(mockClonedDocument.getDocumentReference()).thenReturn(new DocumentReference(\"xwiki\", \"My\", \"Page\"));        when(mockClonedDocument.getStore()).thenReturn(this.oldcore.getMockStore());        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());        context.put(\"ajax\", true);        when(xWiki.isMultiLingual(this.context)).thenReturn(true);        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.1\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(this.xWiki).checkSavingDocument(eq(USER_REFERENCE), any(XWikiDocument.class), eq(\"\"), eq(false),            eq(this.context));        verify(this.xWiki).saveDocument(any(XWikiDocument.class), eq(\"\"), eq(false), eq(this.context));    }    @Test    void validSaveOldTranslation() throws Exception    {        when(mockForm.getLanguage()).thenReturn(\"fr\");        XWikiDocument translation = mock(XWikiDocument.class);        when(mockForm.getTemplate()).thenReturn(\"\");        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(translation);        when(translation.clone()).thenReturn(mockClonedDocument);        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());        context.put(\"ajax\", true);        when(xWiki.isMultiLingual(this.context)).thenReturn(true);        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.3\");        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"1000\");        when(translation.getRCSVersion()).thenReturn(new Version(\"1.3\"));        when(translation.getDate()).thenReturn(new Date(0));        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.4\"));        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.4\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);    }    @Test    void validSaveRequestImageUploadAndConflictCheck() throws Exception    {        when(mockDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));        when(mockForm.getTemplate()).thenReturn(\"\");        when(this.propertiesConf.getProperty(\"edit.conflictChecking.enabled\")).thenReturn(true);        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");        context.put(\"ajax\", true);        when(mockRequest.getParameter(\"forceSave\")).thenReturn(\"\");        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");        when(mockDocument.getDate()).thenReturn(new Date(42));        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"43\");        when(this.documentRevisionProvider.getRevision(mockDocument, \"1.1\")).thenReturn(mock(XWikiDocument.class));        when(mockDocument.getContentDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());        when(mockDocument.getMetaDataDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());        when(mockDocument.getObjectDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");        verify(mockClonedDocument).setMetaDataDirty(true);        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);        verify(mockClonedDocument).removeLock(this.context);    }    @Test    void saveFromTemplate() throws Exception    {        when(this.mockForm.getTemplate()).thenReturn(\"TemplateSpace.TemplateDocument\");        DocumentReference templateReference =            new DocumentReference(context.getWikiId(), \"TemplateSpace\", \"TemplateDocument\");        when(this.autorization.hasAccess(Right.VIEW, templateReference)).thenReturn(false);        assertFalse(this.saveAction.save(this.context));        verify(this.mockClonedDocument, never()).readFromTemplate(templateReference, this.context);        when(this.autorization.hasAccess(Right.VIEW, templateReference)).thenReturn(true);        RefactoringScriptService refactoring = mock(RefactoringScriptService.class);        RequestFactory requestFactory = mock(RequestFactory.class);        when(refactoring.getRequestFactory()).thenReturn(requestFactory);        CreateRequest request = mock(CreateRequest.class);        when(requestFactory.createCreateRequest(any())).thenReturn(request);        Job job = mock(Job.class);        when(refactoring.create(request)).thenReturn(job);        this.componentManager.registerComponent(ScriptService.class, \"refactoring\", refactoring);        assertFalse(this.saveAction.save(this.context));        verify(this.mockClonedDocument).readFromTemplate(templateReference, this.context);    }}", "nl": "import java.util.Collections;import java.util.Date;import javax.inject.Named;import org.apache.commons.lang.time.DateUtils;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.context.Execution;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.validation.EntityNameValidation;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.test.annotation.ComponentList;import org.xwiki.test.junit5.mockito.MockComponent;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiLock;import com.xpn.xwiki.test.MockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;import com.xpn.xwiki.test.junit5.mockito.OldcoreTest;import com.xpn.xwiki.test.reference.ReferenceComponentList;import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentList@ReferenceComponentList@OldcoreTest(mockXWiki = false)public class SaveActionTest{    private static final DocumentReference USER_REFERENCE = new DocumentReference(\"xwiki\", \"XWiki\", \"FooBar\");    @InjectMockitoOldcore    private MockitoOldcore oldcore;    @MockComponent    private EntityNameValidationManager entityNameValidationManager;    @MockComponent    private EntityNameValidationConfiguration entityNameValidationConfiguration;    @MockComponent    private Execution execution;    @MockComponent    @Named(\"xwikiproperties\")    private ConfigurationSource propertiesConf;    @MockComponent    private DocumentRevisionProvider documentRevisionProvider;    private XWikiContext context;    private SaveAction saveAction;    private XWikiRequest mockRequest;    private XWikiResponse mockResponse;    private XWikiDocument mockDocument;    private XWikiDocument mockClonedDocument;    private EditForm mockForm;    private XWiki xWiki;    @BeforeEach    void setup()    {        this.saveAction = new SaveAction();        context = oldcore.getXWikiContext();        xWiki = mock(XWiki.class);        context.setWiki(this.xWiki);        mockRequest = mock(XWikiRequest.class);        context.setRequest(mockRequest);        mockResponse = mock(XWikiResponse.class);        context.setResponse(mockResponse);        mockDocument = mock(XWikiDocument.class);        context.setDoc(mockDocument);        mockClonedDocument = mock(XWikiDocument.class);        when(mockDocument.clone()).thenReturn(mockClonedDocument);        mockForm = mock(EditForm.class);        context.setForm(mockForm);        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(false);        context.setUserReference(USER_REFERENCE);    }    @Test    void newDocumentInvalidName() throws Exception    {        when(mockDocument.isNew()).thenReturn(true);        DocumentReference documentReference = new DocumentReference(\"XWiki\", \"Foo\", \"Bar\");        when(mockDocument.getDocumentReference()).thenReturn(documentReference);        when(this.entityNameValidationConfiguration.useValidation()).thenReturn(true);        EntityNameValidation entityNameValidation = mock(EntityNameValidation.class);        when(this.entityNameValidationManager.getEntityReferenceNameStrategy()).thenReturn(entityNameValidation);        when(entityNameValidation.isValid(documentReference)).thenReturn(false);        assertTrue(saveAction.save(this.context));        assertEquals(\"entitynamevalidation.create.invalidname\", context.get(\"message\"));        assertArrayEquals(new Object[] { \"Foo.Bar\" }, (Object[]) context.get(\"messageParameters\"));    }    @Test    void validSave() throws Exception    {        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));        when(mockForm.getTemplate()).thenReturn(\"\");        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(mockClonedDocument).readFromTemplate(\"\", this.context);        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");        verify(mockClonedDocument).setMetaDataDirty(true);        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);        verify(mockClonedDocument).removeLock(this.context);    }    @Test    void validSaveNewTranslation() throws Exception    {        when(mockForm.getLanguage()).thenReturn(\"fr\");        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(mockClonedDocument);        when(mockClonedDocument.getDocumentReference()).thenReturn(new DocumentReference(\"xwiki\", \"My\", \"Page\"));        when(mockClonedDocument.getStore()).thenReturn(this.oldcore.getMockStore());        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());        context.put(\"ajax\", true);        when(xWiki.isMultiLingual(this.context)).thenReturn(true);        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.1\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(this.xWiki).checkSavingDocument(eq(USER_REFERENCE), any(XWikiDocument.class), eq(\"\"),            eq(false), eq(this.context));        verify(this.xWiki).saveDocument(any(XWikiDocument.class), eq(\"\"), eq(false), eq(this.context));    }    @Test    void validSaveOldTranslation() throws Exception    {        when(mockForm.getLanguage()).thenReturn(\"fr\");        XWikiDocument translation = mock(XWikiDocument.class);        when(mockForm.getTemplate()).thenReturn(\"\");        when(mockClonedDocument.getTranslatedDocument(\"fr\", this.context)).thenReturn(translation);        when(translation.clone()).thenReturn(mockClonedDocument);        when(xWiki.getStore()).thenReturn(this.oldcore.getMockStore());        context.put(\"ajax\", true);        when(xWiki.isMultiLingual(this.context)).thenReturn(true);        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.3\");        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"1000\");        when(translation.getRCSVersion()).thenReturn(new Version(\"1.3\"));        when(translation.getDate()).thenReturn(new Date(0));        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.4\"));        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.4\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);    }    @Test    void validSaveRequestImageUploadAndConflictCheck() throws Exception    {        when(mockDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));        when(mockClonedDocument.getRCSVersion()).thenReturn(new Version(\"1.2\"));        when(mockClonedDocument.getComment()).thenReturn(\"My Changes\");        when(mockClonedDocument.getLock(this.context)).thenReturn(mock(XWikiLock.class));        when(mockForm.getTemplate()).thenReturn(\"\");        when(this.propertiesConf.getProperty(\"edit.conflictChecking.enabled\")).thenReturn(true);        when(mockRequest.getParameter(\"previousVersion\")).thenReturn(\"1.1\");        context.put(\"ajax\", true);        when(mockRequest.getParameter(\"forceSave\")).thenReturn(\"\");        when(mockRequest.getParameter(\"isNew\")).thenReturn(\"true\");        when(mockDocument.getDate()).thenReturn(new Date(42));        when(mockRequest.getParameter(\"editingVersionDate\")).thenReturn(\"43\");        when(this.documentRevisionProvider.getRevision(mockDocument, \"1.1\")).thenReturn(mock(XWikiDocument.class));        when(mockDocument.getContentDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());        when(mockDocument.getMetaDataDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());        when(mockDocument.getObjectDiff(\"1.1\", \"1.2\", context)).thenReturn(Collections.emptyList());        assertFalse(saveAction.save(this.context));        assertEquals(new Version(\"1.2\"), this.context.get(\"SaveAction.savedObjectVersion\"));        verify(mockClonedDocument).readFromTemplate(\"\", this.context);        verify(mockClonedDocument).setAuthor(\"XWiki.FooBar\");        verify(mockClonedDocument).setMetaDataDirty(true);        verify(this.xWiki).checkSavingDocument(USER_REFERENCE, mockClonedDocument, \"My Changes\", false, this.context);        verify(this.xWiki).saveDocument(mockClonedDocument, \"My Changes\", false, this.context);        verify(mockClonedDocument).removeLock(this.context);    }}"}
{"code": "import java.util.HashMap;import java.util.Locale;import java.util.Map;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.lang3.StringUtils;import org.xwiki.component.annotation.Component;import org.xwiki.csrf.CSRFToken;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.SpaceReference;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.util.Util;@Component@Named(\"create\")@Singletonpublic class CreateAction extends XWikiAction{    private static final String CREATE_TEMPLATE = \"create\";    private static final String PARENT = \"parent\";    private static final String SPACE_REFERENCE = \"spaceReference\";    private static final String NAME = \"name\";    private static final String TEMPLATE = \"template\";    private static final String IS_SPACE = \"isSpace\";    private static final String WEBHOME = \"WebHome\";    private static final String LOCAL_SERIALIZER_HINT = \"local\";    private enum ActionOnCreate    {        EDIT(\"edit\"),        SAVE_AND_EDIT(\"saveandedit\"),        SAVE_AND_VIEW(\"saveandview\");        private static final Map<String, ActionOnCreate> BY_ACTION = new HashMap<>();        static {            for (ActionOnCreate actionOnCreate : values()) {                BY_ACTION.put(actionOnCreate.action, actionOnCreate);            }        }        private final String action;        ActionOnCreate(String action)        {            this.action = action;        }        public static ActionOnCreate valueOfAction(String action)        {            return BY_ACTION.get(action);        }    }    public CreateAction()    {        this.waitForXWikiInitialization = false;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        CreateActionRequestHandler handler = new CreateActionRequestHandler(context);        handler.processRequest();        ScriptContext scontext = getCurrentScriptContext();        scontext.setAttribute(SPACE_REFERENCE, handler.getSpaceReference(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(NAME, handler.getName(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(IS_SPACE, handler.isSpace(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"availableTemplateProviders\", handler.getAvailableTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"recommendedTemplateProviders\", handler.getRecommendedTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        DocumentReference newDocumentReference = handler.getNewDocumentReference();        if (newDocumentReference == null) {            return CREATE_TEMPLATE;        }        if (!handler.isTemplateProviderAllowedToCreateInCurrentSpace()) {            return CREATE_TEMPLATE;        }        checkRights(newDocumentReference.getLastSpaceReference(), context);        XWikiDocument newDocument = context.getWiki().getDocument(newDocumentReference, context);        if (handler.isDocumentAlreadyExisting(newDocument) || handler.isDocumentPathTooLong(newDocumentReference)            || !this.isEntityReferenceNameValid(newDocumentReference)) {            return CREATE_TEMPLATE;        }        if (StringUtils.isBlank(handler.getType()) && !handler.hasTemplate()) {            return CREATE_TEMPLATE;        }        doCreate(context, newDocument, handler.isSpace(), handler.getTemplateProvider());        return null;    }    private void checkRights(SpaceReference spaceReference, XWikiContext context) throws XWikiException    {        ContextualAuthorizationManager authManager = Utils.getComponent(ContextualAuthorizationManager.class);        if (!authManager.hasAccess(Right.EDIT, spaceReference)) {            Object[] args = { spaceReference.toString(), context.getUser() };            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,                \"The creation of a document into the space {0} has been denied to user {1}\", null, args);        }    }    private void doCreate(XWikiContext context, XWikiDocument newDocument, boolean isSpace, BaseObject templateProvider)        throws XWikiException    {        XWikiRequest request = context.getRequest();        XWikiDocument doc = context.getDoc();        String parent = getParent(request, doc, isSpace, context);        String title = getTitle(request, newDocument, isSpace);        String template = getTemplate(templateProvider, request);        ActionOnCreate actionOnCreate = getActionOnCreate(templateProvider);        String action = null;        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            initAndSaveDocument(context, newDocument, title, template, parent);            action = newDocument.getDefaultEditMode(context);        } else {            action = actionOnCreate == ActionOnCreate.SAVE_AND_VIEW ? \"save\" : getEditMode(template, context);        }        String redirectParams = getRedirectParameters(parent, title, template, actionOnCreate);        String redirectURL = newDocument.getURL(action, redirectParams, context);        redirectURL = context.getResponse().encodeRedirectURL(redirectURL);        if (context.getRequest().getParameterMap().containsKey(\"ajax\")) {            context.getResponse().setHeader(\"redirect\", redirectURL);        } else {            sendRedirect(context.getResponse(), redirectURL);        }    }    private void initAndSaveDocument(XWikiContext context, XWikiDocument newDocument, String title, String template,        String parent) throws XWikiException    {        XWiki xwiki = context.getWiki();        newDocument.setLocale(Locale.ROOT);        if (newDocument.getDefaultLocale() == Locale.ROOT) {            newDocument.setDefaultLocale(xwiki.getLocalePreference(context));        }        readFromTemplate(newDocument, template, context);        if (!StringUtils.isEmpty(parent)) {            DocumentReference parentReference = getCurrentMixedDocumentReferenceResolver().resolve(parent);            newDocument.setParentReference(parentReference);        }        if (title != null) {            newDocument.setTitle(title);        }        DocumentReference currentUserReference = context.getUserReference();        newDocument.setAuthorReference(currentUserReference);        newDocument.setCreatorReference(currentUserReference);        xwiki.checkSavingDocument(currentUserReference, newDocument, context);        xwiki.saveDocument(newDocument, context);    }    private String getRedirectParameters(String parent, String title, String template, ActionOnCreate actionOnCreate)    {        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            return null;        }        String redirectParams = \"template=\" + Util.encodeURI(template, null);        if (parent != null) {            redirectParams += \"&parent=\" + Util.encodeURI(parent, null);        }        if (title != null) {            redirectParams += \"&title=\" + Util.encodeURI(title, null);        }        if (actionOnCreate == ActionOnCreate.SAVE_AND_VIEW) {            CSRFToken csrf = Utils.getComponent(CSRFToken.class);            redirectParams += \"&form_token=\" + Util.encodeURI(csrf.getToken(), null);        }        return redirectParams;    }    private String getTemplate(BaseObject templateProvider, XWikiRequest request)    {        String result = \"\";        if (templateProvider != null) {            result = templateProvider.getStringValue(TEMPLATE);        } else if (request.getParameter(TEMPLATE) != null) {            result = request.getParameter(TEMPLATE);        }        return result;    }    private String getParent(XWikiRequest request, XWikiDocument doc, boolean isSpace, XWikiContext context)    {        String parent = request.getParameter(PARENT);        if (StringUtils.isEmpty(parent)) {            EntityReferenceSerializer<String> localSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, LOCAL_SERIALIZER_HINT);            if (doc.isNew()) {                Provider<DocumentReference> defaultDocumentReferenceProvider =                    Utils.getComponent(DocumentReference.TYPE_PROVIDER);                DocumentReference parentRef =                    defaultDocumentReferenceProvider.get().setWikiReference(context.getWikiReference());                parent = localSerializer.serialize(parentRef);            } else {                DocumentReference parentRef = doc.getDocumentReference();                parent = localSerializer.serialize(parentRef);            }        }        return parent;    }    private String getTitle(XWikiRequest request, XWikiDocument newDocument, boolean isSpace)    {        String title = request.getParameter(\"title\");        if (StringUtils.isEmpty(title)) {            if (isSpace) {                title = newDocument.getDocumentReference().getLastSpaceReference().getName();            } else {                title = newDocument.getDocumentReference().getName();                if (WEBHOME.equals(title)) {                    title = newDocument.getDocumentReference().getLastSpaceReference().getName();                }            }        }        return title;    }    private ActionOnCreate getActionOnCreate(BaseObject templateProvider)    {        if (templateProvider != null) {            String action = templateProvider.getStringValue(\"action\");            ActionOnCreate actionOnCreate = ActionOnCreate.valueOfAction(action);            if (actionOnCreate != null) {                return actionOnCreate;            }        }        return ActionOnCreate.EDIT;    }    private String getEditMode(String template, XWikiContext context)        throws XWikiException    {        String editAction = ActionOnCreate.EDIT.name().toLowerCase();        XWiki xwiki = context.getWiki();        if (!StringUtils.isEmpty(template)) {            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);            if (xwiki.exists(templateReference, context)) {                editAction = xwiki.getDocument(templateReference, context).getDefaultEditMode(context);            }        }        return editAction;    }}", "nl": "import java.util.HashMap;import java.util.Locale;import java.util.Map;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import javax.script.ScriptContext;import org.apache.commons.lang3.StringUtils;import org.xwiki.component.annotation.Component;import org.xwiki.csrf.CSRFToken;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.SpaceReference;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.util.Util;@Component@Named(\"create\")@Singletonpublic class CreateAction extends XWikiAction{    private static final String CREATE_TEMPLATE = \"create\";    private static final String PARENT = \"parent\";    private static final String SPACE_REFERENCE = \"spaceReference\";    private static final String NAME = \"name\";    private static final String TEMPLATE = \"template\";    private static final String IS_SPACE = \"isSpace\";    private static final String WEBHOME = \"WebHome\";    private static final String LOCAL_SERIALIZER_HINT = \"local\";    private static final String CURRENT_MIXED_RESOLVER_HINT = \"currentmixed\";    private enum ActionOnCreate    {        EDIT(\"edit\"),        SAVE_AND_EDIT(\"saveandedit\"),        SAVE_AND_VIEW(\"saveandview\");        private static final Map<String, ActionOnCreate> BY_ACTION = new HashMap<>();        static {            for (ActionOnCreate actionOnCreate : values()) {                BY_ACTION.put(actionOnCreate.action, actionOnCreate);            }        }        private final String action;        ActionOnCreate(String action)        {            this.action = action;        }        public static ActionOnCreate valueOfAction(String action)        {            return BY_ACTION.get(action);        }    }    public CreateAction()    {        this.waitForXWikiInitialization = false;    }    @Override    public String render(XWikiContext context) throws XWikiException    {        CreateActionRequestHandler handler = new CreateActionRequestHandler(context);        handler.processRequest();        ScriptContext scontext = getCurrentScriptContext();        scontext.setAttribute(SPACE_REFERENCE, handler.getSpaceReference(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(NAME, handler.getName(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(IS_SPACE, handler.isSpace(), ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"availableTemplateProviders\", handler.getAvailableTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        scontext.setAttribute(\"recommendedTemplateProviders\", handler.getRecommendedTemplateProviders(),            ScriptContext.ENGINE_SCOPE);        DocumentReference newDocumentReference = handler.getNewDocumentReference();        if (newDocumentReference == null) {            return CREATE_TEMPLATE;        }        if (!handler.isTemplateProviderAllowedToCreateInCurrentSpace()) {            return CREATE_TEMPLATE;        }        checkRights(newDocumentReference.getLastSpaceReference(), context);        XWikiDocument newDocument = context.getWiki().getDocument(newDocumentReference, context);        if (handler.isDocumentAlreadyExisting(newDocument) || handler.isDocumentPathTooLong(newDocumentReference)            || !this.isEntityReferenceNameValid(newDocumentReference)) {            return CREATE_TEMPLATE;        }        if (StringUtils.isBlank(handler.getType()) && !handler.hasTemplate()) {            return CREATE_TEMPLATE;        }        doCreate(context, newDocument, handler.isSpace(), handler.getTemplateProvider());        return null;    }    private void checkRights(SpaceReference spaceReference, XWikiContext context) throws XWikiException    {        ContextualAuthorizationManager authManager = Utils.getComponent(ContextualAuthorizationManager.class);        if (!authManager.hasAccess(Right.EDIT, spaceReference)) {            Object[] args = { spaceReference.toString(), context.getUser() };            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,                \"The creation of a document into the space {0} has been denied to user {1}\", null, args);        }    }    private void doCreate(XWikiContext context, XWikiDocument newDocument, boolean isSpace, BaseObject templateProvider)        throws XWikiException    {        XWikiRequest request = context.getRequest();        XWikiDocument doc = context.getDoc();        String parent = getParent(request, doc, isSpace, context);        String title = getTitle(request, newDocument, isSpace);        String template = getTemplate(templateProvider, request);        ActionOnCreate actionOnCreate = getActionOnCreate(templateProvider);        String action = null;        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            initAndSaveDocument(context, newDocument, title, template, parent);            action = newDocument.getDefaultEditMode(context);        } else {            action = actionOnCreate == ActionOnCreate.SAVE_AND_VIEW ? \"save\" : getEditMode(template, context);        }        String redirectParams = getRedirectParameters(parent, title, template, actionOnCreate);        String redirectURL = newDocument.getURL(action, redirectParams, context);        redirectURL = context.getResponse().encodeRedirectURL(redirectURL);        if (context.getRequest().getParameterMap().containsKey(\"ajax\")) {            context.getResponse().setHeader(\"redirect\", redirectURL);        } else {            sendRedirect(context.getResponse(), redirectURL);        }    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, CURRENT_MIXED_RESOLVER_HINT);    }    private void initAndSaveDocument(XWikiContext context, XWikiDocument newDocument, String title, String template,        String parent) throws XWikiException    {        XWiki xwiki = context.getWiki();        newDocument.setLocale(Locale.ROOT);        if (newDocument.getDefaultLocale() == Locale.ROOT) {            newDocument.setDefaultLocale(xwiki.getLocalePreference(context));        }        readFromTemplate(newDocument, template, context);        if (!StringUtils.isEmpty(parent)) {            DocumentReference parentReference = this.currentmixedReferenceResolver.resolve(parent);            newDocument.setParentReference(parentReference);        }        if (title != null) {            newDocument.setTitle(title);        }        DocumentReference currentUserReference = context.getUserReference();        newDocument.setAuthorReference(currentUserReference);        newDocument.setCreatorReference(currentUserReference);        xwiki.checkSavingDocument(currentUserReference, newDocument, context);        xwiki.saveDocument(newDocument, context);    }    private String getRedirectParameters(String parent, String title, String template, ActionOnCreate actionOnCreate)    {        if (actionOnCreate == ActionOnCreate.SAVE_AND_EDIT) {            return null;        }        String redirectParams = \"template=\" + Util.encodeURI(template, null);        if (parent != null) {            redirectParams += \"&parent=\" + Util.encodeURI(parent, null);        }        if (title != null) {            redirectParams += \"&title=\" + Util.encodeURI(title, null);        }        if (actionOnCreate == ActionOnCreate.SAVE_AND_VIEW) {            CSRFToken csrf = Utils.getComponent(CSRFToken.class);            redirectParams += \"&form_token=\" + Util.encodeURI(csrf.getToken(), null);        }        return redirectParams;    }    private String getTemplate(BaseObject templateProvider, XWikiRequest request)    {        String result = \"\";        if (templateProvider != null) {            result = templateProvider.getStringValue(TEMPLATE);        } else if (request.getParameter(TEMPLATE) != null) {            result = request.getParameter(TEMPLATE);        }        return result;    }    private String getParent(XWikiRequest request, XWikiDocument doc, boolean isSpace, XWikiContext context)    {        String parent = request.getParameter(PARENT);        if (StringUtils.isEmpty(parent)) {            EntityReferenceSerializer<String> localSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, LOCAL_SERIALIZER_HINT);            if (doc.isNew()) {                Provider<DocumentReference> defaultDocumentReferenceProvider =                    Utils.getComponent(DocumentReference.TYPE_PROVIDER);                DocumentReference parentRef =                    defaultDocumentReferenceProvider.get().setWikiReference(context.getWikiReference());                parent = localSerializer.serialize(parentRef);            } else {                DocumentReference parentRef = doc.getDocumentReference();                parent = localSerializer.serialize(parentRef);            }        }        return parent;    }    private String getTitle(XWikiRequest request, XWikiDocument newDocument, boolean isSpace)    {        String title = request.getParameter(\"title\");        if (StringUtils.isEmpty(title)) {            if (isSpace) {                title = newDocument.getDocumentReference().getLastSpaceReference().getName();            } else {                title = newDocument.getDocumentReference().getName();                if (WEBHOME.equals(title)) {                    title = newDocument.getDocumentReference().getLastSpaceReference().getName();                }            }        }        return title;    }    private ActionOnCreate getActionOnCreate(BaseObject templateProvider)    {        if (templateProvider != null) {            String action = templateProvider.getStringValue(\"action\");            ActionOnCreate actionOnCreate = ActionOnCreate.valueOfAction(action);            if (actionOnCreate != null) {                return actionOnCreate;            }        }        return ActionOnCreate.EDIT;    }    private String getEditMode(String template, XWikiContext context)        throws XWikiException    {        String editAction = ActionOnCreate.EDIT.name().toLowerCase();        XWiki xwiki = context.getWiki();        if (!StringUtils.isEmpty(template)) {            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);            if (xwiki.exists(templateReference, context)) {                editAction = xwiki.getDocument(templateReference, context).getDefaultEditMode(context);            }        }        return editAction;    }}"}
{"code": "import java.io.IOException;import java.net.URL;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import javax.inject.Inject;import javax.inject.Named;import javax.script.ScriptContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.velocity.VelocityContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.ActionExecutedEvent;import org.xwiki.bridge.event.ActionExecutingEvent;import org.xwiki.component.descriptor.ComponentDescriptor;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.container.Container;import org.xwiki.container.Request;import org.xwiki.container.servlet.ServletContainerException;import org.xwiki.container.servlet.ServletContainerInitializer;import org.xwiki.container.servlet.ServletRequest;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.csrf.CSRFToken;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.internal.DefaultJobProgress;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceProvider;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.EntityReferenceValueProvider;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.WrappedThreadEventListener;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.NotFoundResourceHandlerException;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceHandler;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceType;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;import org.xwiki.script.ScriptContextManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.velocity.VelocityManager;import com.fasterxml.jackson.databind.ObjectMapper;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.internal.web.LegacyAction;import com.xpn.xwiki.monitor.api.MonitorPlugin;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;public abstract class XWikiAction implements LegacyAction{    public static final String ACTION_PROGRESS = \"actionprogress\";    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");    @Inject    protected ComponentDescriptor<LegacyAction> componentDescriptor;    @Inject    protected Container container;    @Inject    protected Execution execution;    protected boolean waitForXWikiInitialization = true;    protected boolean handleRedirectObject = false;    @Inject    @Named(\"currentmixed\")    private DocumentReferenceResolver<String> currentmixedReferenceResolver;    @Inject    private ContextualAuthorizationManager autorization;    private ContextualLocalizationManager localization;    private JobProgressManager progress;    private ScriptContextManager scriptContextManager;    private EntityNameValidationManager entityNameValidationManager;    private EntityNameValidationConfiguration entityNameValidationConfiguration;    private EntityReferenceSerializer<String> localSerializer;    @Unstable    protected Class<? extends XWikiForm> getFormClass()    {        return null;    }    protected ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        return this.currentmixedReferenceResolver;    }    protected ContextualAuthorizationManager getContextualAuthorizationManager()    {        return this.autorization;    }    protected String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    protected JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    protected EntityNameValidationManager getEntityNameValidationManager()    {        if (this.entityNameValidationManager == null) {            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);        }        return this.entityNameValidationManager;    }    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()    {        if (this.entityNameValidationConfiguration == null) {            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);        }        return this.entityNameValidationConfiguration;    }    protected EntityReferenceSerializer<String> getLocalSerializer()    {        if (this.localSerializer == null) {            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localSerializer;    }    protected ScriptContext getCurrentScriptContext()    {        if (this.scriptContextManager == null) {            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);        }        return this.scriptContextManager.getCurrentScriptContext();    }    @Override    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception    {        XWikiContext context = null;        try {            context = initializeXWikiContext(servletRequest, servletResponse);            execute(context);        } finally {            if (context != null) {                cleanupComponents();            }        }    }    @Unstable    protected boolean isEntityReferenceNameValid(EntityReference entityReference)    {        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null            && this.getEntityNameValidationConfiguration().useValidation()) {            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {                Object[] args = {getLocalSerializer().serialize(entityReference)};                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,                    args);                ScriptContext scontext = getCurrentScriptContext();                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);                return false;            }        }        return true;    }    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)    {        try {            context.getResponse().setContentType(\"text/plain\");            context.getResponse().setStatus(httpStatusCode);            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());            context.getResponse().getWriter().print(message);        } catch (IOException e) {            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);        }    }    public void execute(XWikiContext context) throws Exception    {        MonitorPlugin monitor = null;        FileUploadPlugin fileupload = null;        DefaultJobProgress actionProgress = null;        ObservationManager om = Utils.getComponent(ObservationManager.class);        Execution execution = Utils.getComponent(Execution.class);        String docName = \"\";        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");        String sasync = context.getRequest().get(\"async\");        try {            String action = context.getAction();            if (debug && om != null && execution != null) {                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());                om.addListener(new WrappedThreadEventListener(actionProgress));                ExecutionContext econtext = execution.getContext();                if (econtext != null) {                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);                }            }            getProgress().pushLevelProgress(2, this);            getProgress().startStep(this, \"Get XWiki instance\");            XWiki xwiki;            try {                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);                if (xwiki == null) {                    renderInit(context);                    return;                }            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {                    xwiki = XWiki.getMainXWiki(context);                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);                    context.setURLFactory(urlf);                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);                    VelocityContext vcontext = velocityManager.getVelocityContext();                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));                        }                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {                            xwiki.prepareResources(context);                            EntityReferenceValueProvider valueProvider =                                Utils.getComponent(EntityReferenceValueProvider.class);                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),                                valueProvider.getDefaultValue(EntityType.SPACE),                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),                                context);                            return;                        }                    } else {                        return;                    }                } else {                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);                    throw e;                }            }            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                return;            }            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);            context.setURLFactory(urlf);            if (redirectSpaceURLs(action, urlf, xwiki, context)) {                return;            }            String sajax = context.getRequest().get(\"ajax\");            boolean ajax = false;            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {                ajax = true;            }            context.put(\"ajax\", ajax);            boolean async = false;            if (StringUtils.isNotEmpty(sasync)) {                async = sasync.equals(\"true\");            } else {                async = !ajax && !this.waitForXWikiInitialization;            }            Utils.getComponent(AsyncContext.class).setEnabled(async);            if (monitor != null) {                monitor.startTimer(\"request\");            }            getProgress().startStep(this, \"Execute request\");            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);            VelocityContext vcontext = velocityManager.getVelocityContext();            getProgress().pushLevelProgress(7, this);            boolean eventSent = false;            try {                getProgress().startStep(this, \"Prepare documents and put them in the context\");                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {                    return;                }                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);                if (monitor != null) {                    monitor.startRequest(\"\", context.getAction(), context.getURL());                    monitor.startTimer(\"multipart\");                }                getProgress().startStep(this, \"Parses multipart\");                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);                if (monitor != null) {                    monitor.endTimer(\"multipart\");                }                if (monitor != null) {                    monitor.setWikiPage(context.getDoc().getFullName());                }                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");                try {                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());                    om.notify(event, context.getDoc(), context);                    eventSent = true;                    if (event.isCanceled()) {                        return;                    }                } catch (Throwable ex) {                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()                        + \" using action [\" + context.getAction() + \"]\", ex);                }                if (monitor != null) {                    monitor.endTimer(\"prenotify\");                }                getProgress().startStep(this, \"Search and execute entity resource handler\");                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");                EntityResourceReference entityResourceReference =                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();                String originalAction = context.getAction();                try {                    context.setAction(entityResourceReference.getAction().getActionName());                    entityResourceReferenceHandler.handle(entityResourceReference,                        DefaultResourceReferenceHandlerChain.EMPTY);                    return;                } catch (NotFoundResourceHandlerException e) {                    context.setAction(originalAction);                }                getProgress().startStep(this, \"Execute action render\");                boolean hasRedirect = false;                if (handleRedirectObject) {                    hasRedirect = handleRedirectObject(context);                }                String renderResult = null;                XWikiDocument doc = context.getDoc();                docName = doc.getFullName();                if (!hasRedirect && action(context)) {                    renderResult = render(context);                }                if (renderResult != null) {                    if (doc.isNew() && \"view\".equals(context.getAction())                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))                        && !\"children\".equals(context.getRequest().get(\"viewer\"))                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, context);                    } else {                        String page = Utils.getPage(context.getRequest(), renderResult);                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);                    }                }                return;            } catch (Throwable e) {                if (e instanceof IOException) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);                }                if (!(e instanceof XWikiException)) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,                        \"Uncaught exception\", e);                }                try {                    XWikiException xex = (XWikiException) e;                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.debug(\"Connection aborted\", e);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                            context.put(\"cause\", \"disabled\");                        }                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {                        context.put(\"message\", \"attachmentdoesnotexist\");                        Utils.parseTemplate(                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),                            context, vcontext);                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);                        return;                    }                    velocityManager.getVelocityContext().put(\"exp\", e);                    if (LOGGER.isWarnEnabled()) {                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {                            return;                        }                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);                    }                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);                    return;                } catch (XWikiException ex) {                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.error(\"Connection aborted\");                    }                } catch (Exception e2) {                    LOGGER.error(\"Uncaught exceptions (inner): \", e);                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);                }                return;            } finally {                try {                    context.getResponse().getWriter().flush();                } catch (Throwable e) {                }                if (monitor != null) {                    monitor.endTimer(\"request\");                    monitor.startTimer(\"notify\");                }                if (eventSent) {                    try {                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);                    } catch (Throwable ex) {", "nl": "import java.io.IOException;import java.net.URL;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import javax.inject.Inject;import javax.inject.Named;import javax.script.ScriptContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.velocity.VelocityContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.ActionExecutedEvent;import org.xwiki.bridge.event.ActionExecutingEvent;import org.xwiki.component.descriptor.ComponentDescriptor;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.container.Container;import org.xwiki.container.Request;import org.xwiki.container.servlet.ServletContainerException;import org.xwiki.container.servlet.ServletContainerInitializer;import org.xwiki.container.servlet.ServletRequest;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.csrf.CSRFToken;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.internal.DefaultJobProgress;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceProvider;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.EntityReferenceValueProvider;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.WrappedThreadEventListener;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.NotFoundResourceHandlerException;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceHandler;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceType;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;import org.xwiki.script.ScriptContextManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.velocity.VelocityManager;import com.fasterxml.jackson.databind.ObjectMapper;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.internal.web.LegacyAction;import com.xpn.xwiki.monitor.api.MonitorPlugin;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;public abstract class XWikiAction implements LegacyAction{    public static final String ACTION_PROGRESS = \"actionprogress\";    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");    @Inject    protected ComponentDescriptor<LegacyAction> componentDescriptor;    @Inject    protected Container container;    @Inject    protected Execution execution;    @Inject    protected ContextualAuthorizationManager autorization;    @Inject    @Named(\"currentmixed\")    protected DocumentReferenceResolver<String> currentmixedReferenceResolver;    protected boolean waitForXWikiInitialization = true;    protected boolean handleRedirectObject = false;    private ContextualLocalizationManager localization;    private JobProgressManager progress;    private ScriptContextManager scriptContextManager;    private EntityNameValidationManager entityNameValidationManager;    private EntityNameValidationConfiguration entityNameValidationConfiguration;    private EntityReferenceSerializer<String> localSerializer;    @Unstable    protected Class<? extends XWikiForm> getFormClass()    {        return null;    }    protected ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    protected String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    protected JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    protected EntityNameValidationManager getEntityNameValidationManager()    {        if (this.entityNameValidationManager == null) {            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);        }        return this.entityNameValidationManager;    }    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()    {        if (this.entityNameValidationConfiguration == null) {            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);        }        return this.entityNameValidationConfiguration;    }    protected EntityReferenceSerializer<String> getLocalSerializer()    {        if (this.localSerializer == null) {            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localSerializer;    }    protected ScriptContext getCurrentScriptContext()    {        if (this.scriptContextManager == null) {            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);        }        return this.scriptContextManager.getCurrentScriptContext();    }    @Override    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception    {        XWikiContext context = null;        try {            context = initializeXWikiContext(servletRequest, servletResponse);            execute(context);        } finally {            if (context != null) {                cleanupComponents();            }        }    }    @Unstable    protected boolean isEntityReferenceNameValid(EntityReference entityReference)    {        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null            && this.getEntityNameValidationConfiguration().useValidation()) {            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {                Object[] args = {getLocalSerializer().serialize(entityReference)};                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,                    args);                ScriptContext scontext = getCurrentScriptContext();                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);                return false;            }        }        return true;    }    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)    {        try {            context.getResponse().setContentType(\"text/plain\");            context.getResponse().setStatus(httpStatusCode);            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());            context.getResponse().getWriter().print(message);        } catch (IOException e) {            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);        }    }    public void execute(XWikiContext context) throws Exception    {        MonitorPlugin monitor = null;        FileUploadPlugin fileupload = null;        DefaultJobProgress actionProgress = null;        ObservationManager om = Utils.getComponent(ObservationManager.class);        Execution execution = Utils.getComponent(Execution.class);        String docName = \"\";        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");        String sasync = context.getRequest().get(\"async\");        try {            String action = context.getAction();            if (debug && om != null && execution != null) {                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());                om.addListener(new WrappedThreadEventListener(actionProgress));                ExecutionContext econtext = execution.getContext();                if (econtext != null) {                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);                }            }            getProgress().pushLevelProgress(2, this);            getProgress().startStep(this, \"Get XWiki instance\");            XWiki xwiki;            try {                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);                if (xwiki == null) {                    renderInit(context);                    return;                }            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {                    xwiki = XWiki.getMainXWiki(context);                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);                    context.setURLFactory(urlf);                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);                    VelocityContext vcontext = velocityManager.getVelocityContext();                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));                        }                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {                            xwiki.prepareResources(context);                            EntityReferenceValueProvider valueProvider =                                Utils.getComponent(EntityReferenceValueProvider.class);                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),                                valueProvider.getDefaultValue(EntityType.SPACE),                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),                                context);                            return;                        }                    } else {                        return;                    }                } else {                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);                    throw e;                }            }            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                return;            }            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);            context.setURLFactory(urlf);            if (redirectSpaceURLs(action, urlf, xwiki, context)) {                return;            }            String sajax = context.getRequest().get(\"ajax\");            boolean ajax = false;            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {                ajax = true;            }            context.put(\"ajax\", ajax);            boolean async = false;            if (StringUtils.isNotEmpty(sasync)) {                async = sasync.equals(\"true\");            } else {                async = !ajax && !this.waitForXWikiInitialization;            }            Utils.getComponent(AsyncContext.class).setEnabled(async);            if (monitor != null) {                monitor.startTimer(\"request\");            }            getProgress().startStep(this, \"Execute request\");            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);            VelocityContext vcontext = velocityManager.getVelocityContext();            getProgress().pushLevelProgress(7, this);            boolean eventSent = false;            try {                getProgress().startStep(this, \"Prepare documents and put them in the context\");                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {                    return;                }                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);                if (monitor != null) {                    monitor.startRequest(\"\", context.getAction(), context.getURL());                    monitor.startTimer(\"multipart\");                }                getProgress().startStep(this, \"Parses multipart\");                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);                if (monitor != null) {                    monitor.endTimer(\"multipart\");                }                if (monitor != null) {                    monitor.setWikiPage(context.getDoc().getFullName());                }                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");                try {                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());                    om.notify(event, context.getDoc(), context);                    eventSent = true;                    if (event.isCanceled()) {                        return;                    }                } catch (Throwable ex) {                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()                        + \" using action [\" + context.getAction() + \"]\", ex);                }                if (monitor != null) {                    monitor.endTimer(\"prenotify\");                }                getProgress().startStep(this, \"Search and execute entity resource handler\");                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");                EntityResourceReference entityResourceReference =                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();                String originalAction = context.getAction();                try {                    context.setAction(entityResourceReference.getAction().getActionName());                    entityResourceReferenceHandler.handle(entityResourceReference,                        DefaultResourceReferenceHandlerChain.EMPTY);                    return;                } catch (NotFoundResourceHandlerException e) {                    context.setAction(originalAction);                }                getProgress().startStep(this, \"Execute action render\");                boolean hasRedirect = false;                if (handleRedirectObject) {                    hasRedirect = handleRedirectObject(context);                }                String renderResult = null;                XWikiDocument doc = context.getDoc();                docName = doc.getFullName();                if (!hasRedirect && action(context)) {                    renderResult = render(context);                }                if (renderResult != null) {                    if (doc.isNew() && \"view\".equals(context.getAction())                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))                        && !\"children\".equals(context.getRequest().get(\"viewer\"))                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, context);                    } else {                        String page = Utils.getPage(context.getRequest(), renderResult);                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);                    }                }                return;            } catch (Throwable e) {                if (e instanceof IOException) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);                }                if (!(e instanceof XWikiException)) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,                        \"Uncaught exception\", e);                }                try {                    XWikiException xex = (XWikiException) e;                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.debug(\"Connection aborted\", e);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                            context.put(\"cause\", \"disabled\");                        }                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {                        context.put(\"message\", \"attachmentdoesnotexist\");                        Utils.parseTemplate(                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),                            context, vcontext);                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);                        return;                    }                    velocityManager.getVelocityContext().put(\"exp\", e);                    if (LOGGER.isWarnEnabled()) {                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {                            return;                        }                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);                    }                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);                    return;                } catch (XWikiException ex) {                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.error(\"Connection aborted\");                    }                } catch (Exception e2) {                    LOGGER.error(\"Uncaught exceptions (inner): \", e);                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);                }                return;            } finally {                try {                    context.getResponse().getWriter().flush();                } catch (Throwable e) {                }                if (monitor != null) {                    monitor.endTimer(\"request\");                    monitor.startTimer(\"notify\");                }                if (eventSent) {                    try {                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);                    } catch (Throwable ex) {                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"                            + context.getAction() + \"]\", ex);                    }                }                if (monitor != null) {                    monitor.endTimer(\"notify\");                }                getProgress().startStep(this, \"Cleanup database connections\");"}
{"code": "import java.io.IOException;import java.net.URLEncoder;import java.security.Principal;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.web.Utils;import org.apache.commons.lang3.StringUtils;import org.securityfilter.authenticator.FormAuthenticator;import org.securityfilter.filter.SecurityRequestWrapper;import org.securityfilter.filter.URLPatternMatcher;import org.securityfilter.realm.SimplePrincipal;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.container.servlet.filters.SavedRequestManager;import org.xwiki.security.authentication.AuthenticationFailureManager;import com.xpn.xwiki.internal.user.UserAuthenticatedEventNotifier;import com.xpn.xwiki.web.XWikiResponse;public class MyFormAuthenticator extends FormAuthenticator implements XWikiAuthenticator{    private static final Logger LOGGER = LoggerFactory.getLogger(MyFormAuthenticator.class);    private UserAuthenticatedEventNotifier userAuthenticatedEventNotifier;    private UserAuthenticatedEventNotifier getUserAuthenticatedEventNotifier()    {        if ( this.userAuthenticatedEventNotifier == null ) {            this.userAuthenticatedEventNotifier = Utils.getComponent(UserAuthenticatedEventNotifier.class);        }        return this.userAuthenticatedEventNotifier;    }    @Override    public void showLogin(HttpServletRequest request, HttpServletResponse response, XWikiContext context)        throws IOException    {        if (\"1\".equals(request.getParameter(\"basicauth\"))) {            String realmName = context.getWiki().Param(\"xwiki.authentication.realmname\");            if (realmName == null) {                realmName = \"XWiki\";            }            MyBasicAuthenticator.showLogin(request, response, realmName);        } else {            showLogin(request, response);        }    }    @Override    public void showLogin(HttpServletRequest request, HttpServletResponse response) throws IOException    {        String savedRequestId = request.getParameter(SavedRequestManager.getSavedRequestIdentifier());        if (StringUtils.isEmpty(savedRequestId)) {            savedRequestId = SavedRequestManager.saveRequest(request);        }        String sridParameter = SavedRequestManager.getSavedRequestIdentifier() + \"=\" + savedRequestId;        StringBuilder redirectBack = new StringBuilder(request.getRequestURI());        redirectBack.append('?');        String delimiter = \"\";        if (StringUtils.isNotEmpty(request.getQueryString())) {            redirectBack.append(request.getQueryString());            delimiter = \"&\";        }        if (!request.getParameterMap().containsKey(SavedRequestManager.getSavedRequestIdentifier())) {            redirectBack.append(delimiter);            redirectBack.append(sridParameter);        }        response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + this.loginPage + \"?\"            + sridParameter + \"&xredirect=\" + URLEncoder.encode(redirectBack.toString(), \"UTF-8\")));        return;    }    @Override    public boolean processLogin(SecurityRequestWrapper request, HttpServletResponse response) throws Exception    {        return processLogin(request, response, null);    }    private String convertUsername(String username, XWikiContext context)    {        return context.getWiki().convertUsername(username, context);    }    @Override    public boolean processLogin(SecurityRequestWrapper request, HttpServletResponse response, XWikiContext context)        throws Exception    {        try {            Principal principal = MyBasicAuthenticator.checkLogin(request, response, context);            if (principal != null) {                return false;            }            if (\"1\".equals(request.getParameter(\"basicauth\"))) {                return true;            }        } catch (Exception e) {        }        if (this.persistentLoginManager != null) {            Principal principal = request.getUserPrincipal();            if (principal == null || context.getWiki().ParamAsLong(\"xwiki.authentication.always\", 0) == 1) {                String username =                    convertUsername(this.persistentLoginManager.getRememberedUsername(request, response), context);                String password = this.persistentLoginManager.getRememberedPassword(request, response);                principal = authenticate(username, password, context);                if (principal != null) {                    if (LOGGER.isDebugEnabled()) {                        LOGGER.debug(\"User \" + principal.getName() + \" has been authentified from cookie\");                    }                    if (!StringUtils.contains(principal.getName(), ':')) {                        principal = new SimplePrincipal(context.getWikiId() + \":\" + principal.getName());                    }                    request.setUserPrincipal(principal);                    this.getUserAuthenticatedEventNotifier().notify(principal.getName());                } else {                    request.setUserPrincipal(null);                    if (username != null || password != null) {                        this.persistentLoginManager.forgetLogin(request, response);                    }                }            }        }        if ((this.loginSubmitPattern != null) && request.getMatchableURL().endsWith(this.loginSubmitPattern)) {            String username = convertUsername(request.getParameter(FORM_USERNAME), context);            String password = request.getParameter(FORM_PASSWORD);            String rememberme = request.getParameter(FORM_REMEMBERME);            rememberme = (rememberme == null) ? \"false\" : rememberme;            return processLogin(username, password, rememberme, request, response, context);        }        return false;    }    @Override    public boolean processLogin(String username, String password, String rememberme, SecurityRequestWrapper request,        HttpServletResponse response, XWikiContext context) throws Exception    {        Principal principal = authenticate(username, password, context);        AuthenticationFailureManager authenticationFailureManager =            Utils.getComponent(AuthenticationFailureManager.class);        if (principal != null && authenticationFailureManager.validateForm(username, request)) {            if (LOGGER.isInfoEnabled()) {                LOGGER.info(\"User \" + principal.getName() + \" has been logged-in\");            }            authenticationFailureManager.resetAuthenticationFailureCounter(username);            if (request.getUserPrincipal() != null && !username.equals(request.getRemoteUser())) {                request.getSession().invalidate();            }            if (this.persistentLoginManager != null) {                if (rememberme != null) {                    this.persistentLoginManager.rememberLogin(request, response, username, password);                } else {                    this.persistentLoginManager.forgetLogin(request, response);                }            }            if (!StringUtils.contains(principal.getName(), ':')) {                principal = new SimplePrincipal(context.getWikiId() + \":\" + principal.getName());            }            request.setUserPrincipal(principal);            this.getUserAuthenticatedEventNotifier().notify(principal.getName());            Boolean bAjax = (Boolean) context.get(\"ajax\");            if ((bAjax == null) || (!bAjax.booleanValue())) {                String continueToURL = getContinueToURL(request);                response.sendRedirect(response.encodeRedirectURL(continueToURL));            }        } else {            if (LOGGER.isInfoEnabled()) {                LOGGER.info(\"User \" + username + \" login has failed\");            }            authenticationFailureManager.recordAuthenticationFailure(username, request);            String returnCode = context.getWiki().Param(\"xwiki.authentication.unauthorized_code\");            int rCode = HttpServletResponse.SC_UNAUTHORIZED;            if ((returnCode != null) && (!returnCode.equals(\"\"))) {                try {                    rCode = Integer.parseInt(returnCode);                } catch (Exception e) {                    rCode = HttpServletResponse.SC_UNAUTHORIZED;                }            }            response.setStatus(rCode);         }        return true;    }    private String getContinueToURL(HttpServletRequest request)    {        String savedURL = request.getParameter(\"xredirect\");        if (StringUtils.isEmpty(savedURL)) {            savedURL = SavedRequestManager.getOriginalUrl(request);        }        if (!StringUtils.isEmpty(savedURL)) {            return savedURL;        }        return request.getContextPath() + this.defaultPage;    }    public static Principal authenticate(String username, String password, XWikiContext context) throws XWikiException    {        return context.getWiki().getAuthService().authenticate(username, password, context);    }    @Override    public boolean processLogout(SecurityRequestWrapper securityRequestWrapper,        HttpServletResponse httpServletResponse, URLPatternMatcher urlPatternMatcher) throws Exception    {        boolean result = super.processLogout(securityRequestWrapper, httpServletResponse, urlPatternMatcher);        if (result == true) {            if (this.persistentLoginManager != null) {                this.persistentLoginManager.forgetLogin(securityRequestWrapper, httpServletResponse);            }        }        return result;    }}", "nl": "import java.io.IOException;import java.net.URLEncoder;import java.security.Principal;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.web.Utils;import org.apache.commons.lang3.StringUtils;import org.securityfilter.authenticator.FormAuthenticator;import org.securityfilter.filter.SecurityRequestWrapper;import org.securityfilter.filter.URLPatternMatcher;import org.securityfilter.realm.SimplePrincipal;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.container.servlet.filters.SavedRequestManager;import org.xwiki.security.authentication.AuthenticationFailureManager;import com.xpn.xwiki.internal.user.UserAuthenticatedEventNotifier;public class MyFormAuthenticator extends FormAuthenticator implements XWikiAuthenticator{    private static final Logger LOGGER = LoggerFactory.getLogger(MyFormAuthenticator.class);    private UserAuthenticatedEventNotifier userAuthenticatedEventNotifier;    private UserAuthenticatedEventNotifier getUserAuthenticatedEventNotifier()    {        if ( this.userAuthenticatedEventNotifier == null ) {            this.userAuthenticatedEventNotifier = Utils.getComponent(UserAuthenticatedEventNotifier.class);        }        return this.userAuthenticatedEventNotifier;    }    @Override    public void showLogin(HttpServletRequest request, HttpServletResponse response, XWikiContext context)        throws IOException    {        if (\"1\".equals(request.getParameter(\"basicauth\"))) {            String realmName = context.getWiki().Param(\"xwiki.authentication.realmname\");            if (realmName == null) {                realmName = \"XWiki\";            }            MyBasicAuthenticator.showLogin(request, response, realmName);        } else {            showLogin(request, response);        }    }    @Override    public void showLogin(HttpServletRequest request, HttpServletResponse response) throws IOException    {        String savedRequestId = request.getParameter(SavedRequestManager.getSavedRequestIdentifier());        if (StringUtils.isEmpty(savedRequestId)) {            savedRequestId = SavedRequestManager.saveRequest(request);        }        String sridParameter = SavedRequestManager.getSavedRequestIdentifier() + \"=\" + savedRequestId;        StringBuilder redirectBack = new StringBuilder(request.getRequestURI());        redirectBack.append('?');        String delimiter = \"\";        if (StringUtils.isNotEmpty(request.getQueryString())) {            redirectBack.append(request.getQueryString());            delimiter = \"&\";        }        if (!request.getParameterMap().containsKey(SavedRequestManager.getSavedRequestIdentifier())) {            redirectBack.append(delimiter);            redirectBack.append(sridParameter);        }        response.sendRedirect(response.encodeRedirectURL(request.getContextPath() + this.loginPage + \"?\"            + sridParameter + \"&xredirect=\" + URLEncoder.encode(redirectBack.toString(), \"UTF-8\")));        return;    }    @Override    public boolean processLogin(SecurityRequestWrapper request, HttpServletResponse response) throws Exception    {        return processLogin(request, response, null);    }    private String convertUsername(String username, XWikiContext context)    {        return context.getWiki().convertUsername(username, context);    }    @Override    public boolean processLogin(SecurityRequestWrapper request, HttpServletResponse response, XWikiContext context)        throws Exception    {        try {            Principal principal = MyBasicAuthenticator.checkLogin(request, response, context);            if (principal != null) {                return false;            }            if (\"1\".equals(request.getParameter(\"basicauth\"))) {                return true;            }        } catch (Exception e) {        }        if (this.persistentLoginManager != null) {            Principal principal = request.getUserPrincipal();            if (principal == null || context.getWiki().ParamAsLong(\"xwiki.authentication.always\", 0) == 1) {                String username =                    convertUsername(this.persistentLoginManager.getRememberedUsername(request, response), context);                String password = this.persistentLoginManager.getRememberedPassword(request, response);                principal = authenticate(username, password, context);                if (principal != null) {                    if (LOGGER.isDebugEnabled()) {                        LOGGER.debug(\"User \" + principal.getName() + \" has been authentified from cookie\");                    }                    if (!StringUtils.contains(principal.getName(), ':')) {                        principal = new SimplePrincipal(context.getWikiId() + \":\" + principal.getName());                    }                    request.setUserPrincipal(principal);                    this.getUserAuthenticatedEventNotifier().notify(principal.getName());                } else {                    request.setUserPrincipal(null);                    if (username != null || password != null) {                        this.persistentLoginManager.forgetLogin(request, response);                    }                }            }        }        if ((this.loginSubmitPattern != null) && request.getMatchableURL().endsWith(this.loginSubmitPattern)) {            String username = convertUsername(request.getParameter(FORM_USERNAME), context);            String password = request.getParameter(FORM_PASSWORD);            String rememberme = request.getParameter(FORM_REMEMBERME);            rememberme = (rememberme == null) ? \"false\" : rememberme;            return processLogin(username, password, rememberme, request, response, context);        }        return false;    }    @Override    public boolean processLogin(String username, String password, String rememberme, SecurityRequestWrapper request,        HttpServletResponse response, XWikiContext context) throws Exception    {        Principal principal = authenticate(username, password, context);        AuthenticationFailureManager authenticationFailureManager =            Utils.getComponent(AuthenticationFailureManager.class);        if (principal != null && authenticationFailureManager.validateForm(username, request)) {            if (LOGGER.isInfoEnabled()) {                LOGGER.info(\"User \" + principal.getName() + \" has been logged-in\");            }            authenticationFailureManager.resetAuthenticationFailureCounter(username);            if (request.getUserPrincipal() != null && !username.equals(request.getRemoteUser())) {                request.getSession().invalidate();            }            if (this.persistentLoginManager != null) {                if (rememberme != null) {                    this.persistentLoginManager.rememberLogin(request, response, username, password);                } else {                    this.persistentLoginManager.forgetLogin(request, response);                }            }            if (!StringUtils.contains(principal.getName(), ':')) {                principal = new SimplePrincipal(context.getWikiId() + \":\" + principal.getName());            }            request.setUserPrincipal(principal);            this.getUserAuthenticatedEventNotifier().notify(principal.getName());            Boolean bAjax = (Boolean) context.get(\"ajax\");            if ((bAjax == null) || (!bAjax.booleanValue())) {                String continueToURL = getContinueToURL(request);                response.sendRedirect(response.encodeRedirectURL(continueToURL));            }        } else {            if (LOGGER.isInfoEnabled()) {                LOGGER.info(\"User \" + username + \" login has failed\");            }            authenticationFailureManager.recordAuthenticationFailure(username, request);            String returnCode = context.getWiki().Param(\"xwiki.authentication.unauthorized_code\");            int rCode = HttpServletResponse.SC_UNAUTHORIZED;            if ((returnCode != null) && (!returnCode.equals(\"\"))) {                try {                    rCode = Integer.parseInt(returnCode);                } catch (Exception e) {                    rCode = HttpServletResponse.SC_UNAUTHORIZED;                }            }            response.setStatus(rCode);         }        return true;    }    private String getContinueToURL(HttpServletRequest request)    {        String savedURL = request.getParameter(\"xredirect\");        if (StringUtils.isEmpty(savedURL)) {            savedURL = SavedRequestManager.getOriginalUrl(request);        }        if (!StringUtils.isEmpty(savedURL)) {            return savedURL;        }        return request.getContextPath() + this.defaultPage;    }    public static Principal authenticate(String username, String password, XWikiContext context) throws XWikiException    {        return context.getWiki().getAuthService().authenticate(username, password, context);    }    @Override    public boolean processLogout(SecurityRequestWrapper securityRequestWrapper,        HttpServletResponse httpServletResponse, URLPatternMatcher urlPatternMatcher) throws Exception    {        boolean result = super.processLogout(securityRequestWrapper, httpServletResponse, urlPatternMatcher);        if (result == true) {            if (this.persistentLoginManager != null) {                this.persistentLoginManager.forgetLogin(securityRequestWrapper, httpServletResponse);            }        }        return result;    }}"}
{"code": "import java.io.IOException;import java.net.URL;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import javax.inject.Inject;import javax.inject.Named;import javax.script.ScriptContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.velocity.VelocityContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.ActionExecutedEvent;import org.xwiki.bridge.event.ActionExecutingEvent;import org.xwiki.component.descriptor.ComponentDescriptor;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.container.Container;import org.xwiki.container.Request;import org.xwiki.container.servlet.ServletContainerException;import org.xwiki.container.servlet.ServletContainerInitializer;import org.xwiki.container.servlet.ServletRequest;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.csrf.CSRFToken;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.internal.DefaultJobProgress;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceProvider;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.EntityReferenceValueProvider;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.WrappedThreadEventListener;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.NotFoundResourceHandlerException;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceHandler;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceType;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;import org.xwiki.script.ScriptContextManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.velocity.VelocityManager;import com.fasterxml.jackson.databind.ObjectMapper;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.internal.web.LegacyAction;import com.xpn.xwiki.monitor.api.MonitorPlugin;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;public abstract class XWikiAction implements LegacyAction{    public static final String ACTION_PROGRESS = \"actionprogress\";    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");    @Inject    protected ComponentDescriptor<LegacyAction> componentDescriptor;    @Inject    protected Container container;    @Inject    protected Execution execution;    protected boolean waitForXWikiInitialization = true;    protected boolean handleRedirectObject = false;    @Inject    @Named(\"currentmixed\")    private DocumentReferenceResolver<String> currentmixedReferenceResolver;    @Inject    private ContextualAuthorizationManager autorization;    private ContextualLocalizationManager localization;    private JobProgressManager progress;    private ScriptContextManager scriptContextManager;    private EntityNameValidationManager entityNameValidationManager;    private EntityNameValidationConfiguration entityNameValidationConfiguration;    private EntityReferenceSerializer<String> localSerializer;    @Unstable    protected Class<? extends XWikiForm> getFormClass()    {        return null;    }    protected ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        return this.currentmixedReferenceResolver;    }    protected ContextualAuthorizationManager getContextualAuthorizationManager()    {        return this.autorization;    }    protected String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    protected JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    protected EntityNameValidationManager getEntityNameValidationManager()    {        if (this.entityNameValidationManager == null) {            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);        }        return this.entityNameValidationManager;    }    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()    {        if (this.entityNameValidationConfiguration == null) {            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);        }        return this.entityNameValidationConfiguration;    }    protected EntityReferenceSerializer<String> getLocalSerializer()    {        if (this.localSerializer == null) {            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localSerializer;    }    protected ScriptContext getCurrentScriptContext()    {        if (this.scriptContextManager == null) {            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);        }        return this.scriptContextManager.getCurrentScriptContext();    }    @Override    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception    {        XWikiContext context = null;        try {            context = initializeXWikiContext(servletRequest, servletResponse);            execute(context);        } finally {            if (context != null) {                cleanupComponents();            }        }    }    @Unstable    protected boolean isEntityReferenceNameValid(EntityReference entityReference)    {        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null            && this.getEntityNameValidationConfiguration().useValidation()) {            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {                Object[] args = {getLocalSerializer().serialize(entityReference)};                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,                    args);                ScriptContext scontext = getCurrentScriptContext();                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);                return false;            }        }        return true;    }    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)    {        try {            context.getResponse().setContentType(\"text/plain\");            context.getResponse().setStatus(httpStatusCode);            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());            context.getResponse().getWriter().print(message);        } catch (IOException e) {            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);        }    }    public void execute(XWikiContext context) throws Exception    {        MonitorPlugin monitor = null;        FileUploadPlugin fileupload = null;        DefaultJobProgress actionProgress = null;        ObservationManager om = Utils.getComponent(ObservationManager.class);        Execution execution = Utils.getComponent(Execution.class);        String docName = \"\";        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");        String sasync = context.getRequest().get(\"async\");        try {            String action = context.getAction();            if (debug && om != null && execution != null) {                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());                om.addListener(new WrappedThreadEventListener(actionProgress));                ExecutionContext econtext = execution.getContext();                if (econtext != null) {                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);                }            }            getProgress().pushLevelProgress(2, this);            getProgress().startStep(this, \"Get XWiki instance\");            XWiki xwiki;            try {                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);                if (xwiki == null) {                    renderInit(context);                    return;                }            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {                    xwiki = XWiki.getMainXWiki(context);                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);                    context.setURLFactory(urlf);                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);                    VelocityContext vcontext = velocityManager.getVelocityContext();                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));                        }                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {                            xwiki.prepareResources(context);                            EntityReferenceValueProvider valueProvider =                                Utils.getComponent(EntityReferenceValueProvider.class);                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),                                valueProvider.getDefaultValue(EntityType.SPACE),                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),                                context);                            return;                        }                    } else {                        return;                    }                } else {                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);                    throw e;                }            }            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                return;            }            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);            context.setURLFactory(urlf);            if (redirectSpaceURLs(action, urlf, xwiki, context)) {                return;            }            String sajax = context.getRequest().get(\"ajax\");            boolean ajax = false;            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {                ajax = true;            }            context.put(\"ajax\", ajax);            boolean async = false;            if (StringUtils.isNotEmpty(sasync)) {                async = sasync.equals(\"true\");            } else {                async = !ajax && !this.waitForXWikiInitialization;            }            Utils.getComponent(AsyncContext.class).setEnabled(async);            if (monitor != null) {                monitor.startTimer(\"request\");            }            getProgress().startStep(this, \"Execute request\");            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);            VelocityContext vcontext = velocityManager.getVelocityContext();            getProgress().pushLevelProgress(7, this);            boolean eventSent = false;            try {                getProgress().startStep(this, \"Prepare documents and put them in the context\");                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {                    return;                }                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);                if (monitor != null) {                    monitor.startRequest(\"\", context.getAction(), context.getURL());                    monitor.startTimer(\"multipart\");                }                getProgress().startStep(this, \"Parses multipart\");                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);                if (monitor != null) {                    monitor.endTimer(\"multipart\");                }                if (monitor != null) {                    monitor.setWikiPage(context.getDoc().getFullName());                }                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");                try {                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());                    om.notify(event, context.getDoc(), context);                    eventSent = true;                    if (event.isCanceled()) {                        return;                    }                } catch (Throwable ex) {                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()                        + \" using action [\" + context.getAction() + \"]\", ex);                }                if (monitor != null) {                    monitor.endTimer(\"prenotify\");                }                getProgress().startStep(this, \"Search and execute entity resource handler\");                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");                EntityResourceReference entityResourceReference =                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();                String originalAction = context.getAction();                try {                    context.setAction(entityResourceReference.getAction().getActionName());                    entityResourceReferenceHandler.handle(entityResourceReference,                        DefaultResourceReferenceHandlerChain.EMPTY);                    return;                } catch (NotFoundResourceHandlerException e) {                    context.setAction(originalAction);                }                getProgress().startStep(this, \"Execute action render\");                boolean hasRedirect = false;                if (handleRedirectObject) {                    hasRedirect = handleRedirectObject(context);                }                String renderResult = null;                XWikiDocument doc = context.getDoc();                docName = doc.getFullName();                if (!hasRedirect && action(context)) {                    renderResult = render(context);                }                if (renderResult != null) {                    if (doc.isNew() && \"view\".equals(context.getAction())                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))                        && !\"children\".equals(context.getRequest().get(\"viewer\"))                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, context);                    } else {                        String page = Utils.getPage(context.getRequest(), renderResult);                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);                    }                }                return;            } catch (Throwable e) {                if (e instanceof IOException) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);                }                if (!(e instanceof XWikiException)) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,                        \"Uncaught exception\", e);                }                try {                    XWikiException xex = (XWikiException) e;                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.debug(\"Connection aborted\", e);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                            context.put(\"cause\", \"disabled\");                        }                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {                        context.put(\"message\", \"attachmentdoesnotexist\");                        Utils.parseTemplate(                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),                            context, vcontext);                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);                        return;                    }                    velocityManager.getVelocityContext().put(\"exp\", e);                    if (LOGGER.isWarnEnabled()) {                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {                            return;                        }                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);                    }                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);                    return;                } catch (XWikiException ex) {                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.error(\"Connection aborted\");                    }                } catch (Exception e2) {                    LOGGER.error(\"Uncaught exceptions (inner): \", e);                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);                }                return;            } finally {                try {                    context.getResponse().getWriter().flush();                } catch (Throwable e) {                }                if (monitor != null) {                    monitor.endTimer(\"request\");                    monitor.startTimer(\"notify\");                }                if (eventSent) {                    try {                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);                    } catch (Throwable ex) {", "nl": "import java.io.IOException;import java.net.URL;import java.util.Arrays;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Vector;import javax.inject.Inject;import javax.inject.Named;import javax.script.ScriptContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.velocity.VelocityContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.bridge.event.ActionExecutedEvent;import org.xwiki.bridge.event.ActionExecutingEvent;import org.xwiki.component.descriptor.ComponentDescriptor;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.container.Container;import org.xwiki.container.Request;import org.xwiki.container.servlet.ServletContainerException;import org.xwiki.container.servlet.ServletContainerInitializer;import org.xwiki.container.servlet.ServletRequest;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.csrf.CSRFToken;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.internal.DefaultJobProgress;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceProvider;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.EntityReferenceValueProvider;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.model.validation.EntityNameValidationConfiguration;import org.xwiki.model.validation.EntityNameValidationManager;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.WrappedThreadEventListener;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.NotFoundResourceHandlerException;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceHandler;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceType;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;import org.xwiki.script.ScriptContextManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.velocity.VelocityManager;import com.fasterxml.jackson.databind.ObjectMapper;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.mandatory.RedirectClassDocumentInitializer;import com.xpn.xwiki.internal.web.LegacyAction;import com.xpn.xwiki.monitor.api.MonitorPlugin;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;public abstract class XWikiAction implements LegacyAction{    public static final String ACTION_PROGRESS = \"actionprogress\";    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");    @Inject    protected ComponentDescriptor<LegacyAction> componentDescriptor;    @Inject    protected Container container;    @Inject    protected Execution execution;    protected boolean waitForXWikiInitialization = true;    protected boolean handleRedirectObject = false;    @Inject    @Named(\"currentmixed\")    private DocumentReferenceResolver<String> currentmixedReferenceResolver;    @Inject    private ContextualAuthorizationManager autorization;    private ContextualLocalizationManager localization;    private JobProgressManager progress;    private ScriptContextManager scriptContextManager;    private EntityNameValidationManager entityNameValidationManager;    private EntityNameValidationConfiguration entityNameValidationConfiguration;    private EntityReferenceSerializer<String> localSerializer;    @Unstable    protected Class<? extends XWikiForm> getFormClass()    {        return null;    }    protected ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        return this.currentmixedReferenceResolver;    }    protected ContextualAuthorizationManager getContextualAuthorizationManager()    {        return this.autorization;    }    protected String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    protected JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    protected EntityNameValidationManager getEntityNameValidationManager()    {        if (this.entityNameValidationManager == null) {            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);        }        return this.entityNameValidationManager;    }    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()    {        if (this.entityNameValidationConfiguration == null) {            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);        }        return this.entityNameValidationConfiguration;    }    protected EntityReferenceSerializer<String> getLocalSerializer()    {        if (this.localSerializer == null) {            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localSerializer;    }    protected ScriptContext getCurrentScriptContext()    {        if (this.scriptContextManager == null) {            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);        }        return this.scriptContextManager.getCurrentScriptContext();    }    @Override    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception    {        XWikiContext context = null;        try {            context = initializeXWikiContext(servletRequest, servletResponse);            execute(context);        } finally {            if (context != null) {                cleanupComponents();            }        }    }    @Unstable    protected boolean isEntityReferenceNameValid(EntityReference entityReference)    {        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null            && this.getEntityNameValidationConfiguration().useValidation()) {            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {                Object[] args = {getLocalSerializer().serialize(entityReference)};                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,                    args);                ScriptContext scontext = getCurrentScriptContext();                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);                return false;            }        }        return true;    }    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)    {        try {            context.getResponse().setContentType(\"text/plain\");            context.getResponse().setStatus(httpStatusCode);            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());            context.getResponse().getWriter().print(message);        } catch (IOException e) {            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);        }    }    public void execute(XWikiContext context) throws Exception    {        MonitorPlugin monitor = null;        FileUploadPlugin fileupload = null;        DefaultJobProgress actionProgress = null;        ObservationManager om = Utils.getComponent(ObservationManager.class);        Execution execution = Utils.getComponent(Execution.class);        String docName = \"\";        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");        String sasync = context.getRequest().get(\"async\");        try {            String action = context.getAction();            if (debug && om != null && execution != null) {                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());                om.addListener(new WrappedThreadEventListener(actionProgress));                ExecutionContext econtext = execution.getContext();                if (econtext != null) {                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);                }            }            getProgress().pushLevelProgress(2, this);            getProgress().startStep(this, \"Get XWiki instance\");            XWiki xwiki;            try {                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);                if (xwiki == null) {                    renderInit(context);                    return;                }            } catch (XWikiException e) {                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {                    xwiki = XWiki.getMainXWiki(context);                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);                    context.setURLFactory(urlf);                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);                    VelocityContext vcontext = velocityManager.getVelocityContext();                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));                        }                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {                            xwiki.prepareResources(context);                            EntityReferenceValueProvider valueProvider =                                Utils.getComponent(EntityReferenceValueProvider.class);                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),                                valueProvider.getDefaultValue(EntityType.SPACE),                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),                                context);                            return;                        }                    } else {                        return;                    }                } else {                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);                    throw e;                }            }            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {                return;            }            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);            context.setURLFactory(urlf);            if (redirectSpaceURLs(action, urlf, xwiki, context)) {                return;            }            String sajax = context.getRequest().get(\"ajax\");            boolean ajax = false;            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {                ajax = true;            }            context.put(\"ajax\", ajax);            boolean async = false;            if (StringUtils.isNotEmpty(sasync)) {                async = sasync.equals(\"true\");            } else {                async = !ajax && !this.waitForXWikiInitialization;            }            Utils.getComponent(AsyncContext.class).setEnabled(async);            if (monitor != null) {                monitor.startTimer(\"request\");            }            getProgress().startStep(this, \"Execute request\");            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);            VelocityContext vcontext = velocityManager.getVelocityContext();            getProgress().pushLevelProgress(7, this);            boolean eventSent = false;            try {                getProgress().startStep(this, \"Prepare documents and put them in the context\");                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {                    return;                }                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);                if (monitor != null) {                    monitor.startRequest(\"\", context.getAction(), context.getURL());                    monitor.startTimer(\"multipart\");                }                getProgress().startStep(this, \"Parses multipart\");                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);                if (monitor != null) {                    monitor.endTimer(\"multipart\");                }                if (monitor != null) {                    monitor.setWikiPage(context.getDoc().getFullName());                }                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");                try {                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());                    om.notify(event, context.getDoc(), context);                    eventSent = true;                    if (event.isCanceled()) {                        return;                    }                } catch (Throwable ex) {                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()                        + \" using action [\" + context.getAction() + \"]\", ex);                }                if (monitor != null) {                    monitor.endTimer(\"prenotify\");                }                getProgress().startStep(this, \"Search and execute entity resource handler\");                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");                EntityResourceReference entityResourceReference =                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();                String originalAction = context.getAction();                try {                    context.setAction(entityResourceReference.getAction().getActionName());                    entityResourceReferenceHandler.handle(entityResourceReference,                        DefaultResourceReferenceHandlerChain.EMPTY);                    return;                } catch (NotFoundResourceHandlerException e) {                    context.setAction(originalAction);                }                getProgress().startStep(this, \"Execute action render\");                boolean hasRedirect = false;                if (handleRedirectObject) {                    hasRedirect = handleRedirectObject(context);                }                String renderResult = null;                XWikiDocument doc = context.getDoc();                docName = doc.getFullName();                if (!hasRedirect && action(context)) {                    renderResult = render(context);                }                if (renderResult != null) {                    if (doc.isNew() && \"view\".equals(context.getAction())                        && !\"recyclebin\".equals(context.getRequest().get(\"viewer\"))                        && !\"children\".equals(context.getRequest().get(\"viewer\"))                        && !\"siblings\".equals(context.getRequest().get(\"viewer\"))) {                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, context);                    } else {                        String page = Utils.getPage(context.getRequest(), renderResult);                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);                    }                }                return;            } catch (Throwable e) {                if (e instanceof IOException) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);                }                if (!(e instanceof XWikiException)) {                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,                        \"Uncaught exception\", e);                }                try {                    XWikiException xex = (XWikiException) e;                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.debug(\"Connection aborted\", e);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {                            context.put(\"cause\", \"disabled\");                        }                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {                        context.put(\"message\", \"attachmentdoesnotexist\");                        Utils.parseTemplate(                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);                        return;                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),                            context, vcontext);                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);                        return;                    }                    velocityManager.getVelocityContext().put(\"exp\", e);                    if (LOGGER.isWarnEnabled()) {                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {                            return;                        }                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);                    }                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);                    return;                } catch (XWikiException ex) {                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {                        LOGGER.error(\"Connection aborted\");                    }                } catch (Exception e2) {                    LOGGER.error(\"Uncaught exceptions (inner): \", e);                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);                }                return;            } finally {                try {                    context.getResponse().getWriter().flush();                } catch (Throwable e) {                }                if (monitor != null) {                    monitor.endTimer(\"request\");                    monitor.startTimer(\"notify\");                }                if (eventSent) {                    try {                        om.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);                    } catch (Throwable ex) {"}
{"code": "import java.io.IOException;import java.io.PrintWriter;import java.net.URL;import java.util.Collection;import java.util.Locale;import java.util.regex.Pattern;import javax.servlet.ServletOutputStream;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.url.URLSecurityManager;public class XWikiServletResponse implements XWikiResponse{    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiServletResponse.class);    private static final Pattern ABSOLUTE_URL_PATTERN = Pattern.compile(\"[a-z0-9]+:    private HttpServletResponse response;    public XWikiServletResponse(HttpServletResponse response)    {        this.response = response;    }    @Override    public int getStatus()    {        return this.response.getStatus();    }    @Override    public HttpServletResponse getHttpServletResponse()    {        return this.response;    }    @Override    public void sendRedirect(String redirect) throws IOException    {        if (StringUtils.isBlank(redirect)) {            return;        }        if (StringUtils.containsAny(redirect, '\\r', '\\n')) {            LOGGER.warn(\"Possible HTTP Response Splitting attack, attempting to redirect to [{}]\", redirect);            return;        }        if (ABSOLUTE_URL_PATTERN.matcher(redirect).matches()) {            if (!getURLSecurityManager().isDomainTrusted(new URL(redirect))) {                LOGGER.warn(                    \"Possible phishing attack, attempting to redirect to [{}], this request has been blocked. \"                        + \"If the request was legitimate, add the domain related to this request in the list \"                        + \"of trusted domains in the configuration.\", redirect);                return;            }        }        this.response.sendRedirect(redirect);    }    private URLSecurityManager getURLSecurityManager()    {        return Utils.getComponent(URLSecurityManager.class);    }    @Override    public void setContentType(String type)    {        this.response.setContentType(type);    }    @Override    public void setBufferSize(int i)    {        this.response.setBufferSize(i);    }    @Override    public int getBufferSize()    {        return this.response.getBufferSize();    }    @Override    public void flushBuffer() throws IOException    {        this.response.flushBuffer();    }    @Override    public void resetBuffer()    {        this.response.resetBuffer();    }    @Override    public boolean isCommitted()    {        return this.response.isCommitted();    }    @Override    public void reset()    {        this.response.reset();    }    @Override    public void setContentLength(int length)    {        this.response.setContentLength(length);    }    @Override    public void setContentLengthLong(long len)    {        this.response.setContentLengthLong(len);    }    @Override    public String getCharacterEncoding()    {        return this.response.getCharacterEncoding();    }    @Override    public ServletOutputStream getOutputStream() throws IOException    {        return this.response.getOutputStream();    }    @Override    public PrintWriter getWriter() throws IOException    {        return this.response.getWriter();    }    @Override    public void setCharacterEncoding(String s)    {        this.response.setCharacterEncoding(s);    }    @Override    public void addCookie(Cookie cookie)    {        this.response.addCookie(cookie);    }    public void addCookie(String cookieName, String cookieValue, int age)    {        Cookie cookie = new Cookie(cookieName, cookieValue);        cookie.setVersion(1);        cookie.setMaxAge(age);        this.response.addCookie(cookie);    }    @Override    public void removeCookie(String cookieName, XWikiRequest request)    {        Cookie cookie = request.getCookie(cookieName);        if (cookie != null) {            cookie.setMaxAge(0);            cookie.setPath(cookie.getPath());            addCookie(cookie);        }    }    @Override    public void setLocale(Locale locale)    {        this.response.setLocale(locale);    }    @Override    public Locale getLocale()    {        return this.response.getLocale();    }    @Override    public void setDateHeader(String name, long value)    {        this.response.setDateHeader(name, value);    }    @Override    public void setIntHeader(String name, int value)    {        this.response.setIntHeader(name, value);    }    @Override    public void setHeader(String name, String value)    {        this.response.setHeader(name, value);    }    @Override    public void addHeader(String name, String value)    {        this.response.addHeader(name, value);    }    @Override    public void addDateHeader(String name, long value)    {        this.response.addDateHeader(name, value);    }    @Override    public void addIntHeader(String name, int value)    {        this.response.addIntHeader(name, value);    }    @Override    public void setStatus(int i)    {        this.response.setStatus(i);    }    @Override    @Deprecated    public void setStatus(int i, String s)    {        this.response.setStatus(i, s);    }    @Override    public boolean containsHeader(String name)    {        return this.response.containsHeader(name);    }    @Override    public String encodeURL(String s)    {        return this.response.encodeURL(s);    }    @Override    public String encodeRedirectURL(String s)    {        return this.response.encodeRedirectURL(s);    }    @Override    @Deprecated    public String encodeUrl(String s)    {        return this.response.encodeUrl(s);    }    @Override    @Deprecated    public String encodeRedirectUrl(String s)    {        return this.response.encodeRedirectUrl(s);    }    @Override    public void sendError(int i, String s) throws IOException    {        this.response.sendError(i, s);    }    @Override    public void sendError(int i) throws IOException    {        this.response.sendError(i);    }    @Override    public String getContentType()    {        return this.response.getContentType();    }    @Override    public String getHeader(String s)    {        return this.response.getHeader(s);    }    @Override    public Collection<String> getHeaders(String s)    {        return this.response.getHeaders(s);    }    @Override    public Collection<String> getHeaderNames()    {        return this.response.getHeaderNames();    }}", "nl": "import java.io.IOException;import java.io.PrintWriter;import java.util.Collection;import java.util.Locale;import javax.servlet.ServletOutputStream;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class XWikiServletResponse implements XWikiResponse{    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiServletResponse.class);    private HttpServletResponse response;    public XWikiServletResponse(HttpServletResponse response)    {        this.response = response;    }    @Override    public int getStatus()    {        return this.response.getStatus();    }    @Override    public HttpServletResponse getHttpServletResponse()    {        return this.response;    }    @Override    public void sendRedirect(String redirect) throws IOException    {        if (StringUtils.isBlank(redirect)) {            return;        }        if (StringUtils.containsAny(redirect, '\\r', '\\n')) {            LOGGER.warn(\"Possible HTTP Response Splitting attack, attempting to redirect to [{}]\", redirect);            return;        }        this.response.sendRedirect(redirect);    }    @Override    public void setContentType(String type)    {        this.response.setContentType(type);    }    @Override    public void setBufferSize(int i)    {        this.response.setBufferSize(i);    }    @Override    public int getBufferSize()    {        return this.response.getBufferSize();    }    @Override    public void flushBuffer() throws IOException    {        this.response.flushBuffer();    }    @Override    public void resetBuffer()    {        this.response.resetBuffer();    }    @Override    public boolean isCommitted()    {        return this.response.isCommitted();    }    @Override    public void reset()    {        this.response.reset();    }    @Override    public void setContentLength(int length)    {        this.response.setContentLength(length);    }    @Override    public void setContentLengthLong(long len)    {        this.response.setContentLengthLong(len);    }    @Override    public String getCharacterEncoding()    {        return this.response.getCharacterEncoding();    }    @Override    public ServletOutputStream getOutputStream() throws IOException    {        return this.response.getOutputStream();    }    @Override    public PrintWriter getWriter() throws IOException    {        return this.response.getWriter();    }    @Override    public void setCharacterEncoding(String s)    {        this.response.setCharacterEncoding(s);    }    @Override    public void addCookie(Cookie cookie)    {        this.response.addCookie(cookie);    }    public void addCookie(String cookieName, String cookieValue, int age)    {        Cookie cookie = new Cookie(cookieName, cookieValue);        cookie.setVersion(1);        cookie.setMaxAge(age);        this.response.addCookie(cookie);    }    @Override    public void removeCookie(String cookieName, XWikiRequest request)    {        Cookie cookie = request.getCookie(cookieName);        if (cookie != null) {            cookie.setMaxAge(0);            cookie.setPath(cookie.getPath());            addCookie(cookie);        }    }    @Override    public void setLocale(Locale locale)    {        this.response.setLocale(locale);    }    @Override    public Locale getLocale()    {        return this.response.getLocale();    }    @Override    public void setDateHeader(String name, long value)    {        this.response.setDateHeader(name, value);    }    @Override    public void setIntHeader(String name, int value)    {        this.response.setIntHeader(name, value);    }    @Override    public void setHeader(String name, String value)    {        this.response.setHeader(name, value);    }    @Override    public void addHeader(String name, String value)    {        this.response.addHeader(name, value);    }    @Override    public void addDateHeader(String name, long value)    {        this.response.addDateHeader(name, value);    }    @Override    public void addIntHeader(String name, int value)    {        this.response.addIntHeader(name, value);    }    @Override    public void setStatus(int i)    {        this.response.setStatus(i);    }    @Override    @Deprecated    public void setStatus(int i, String s)    {        this.response.setStatus(i, s);    }    @Override    public boolean containsHeader(String name)    {        return this.response.containsHeader(name);    }    @Override    public String encodeURL(String s)    {        return this.response.encodeURL(s);    }    @Override    public String encodeRedirectURL(String s)    {        return this.response.encodeRedirectURL(s);    }    @Override    @Deprecated    public String encodeUrl(String s)    {        return this.response.encodeUrl(s);    }    @Override    @Deprecated    public String encodeRedirectUrl(String s)    {        return this.response.encodeRedirectUrl(s);    }    @Override    public void sendError(int i, String s) throws IOException    {        this.response.sendError(i, s);    }    @Override    public void sendError(int i) throws IOException    {        this.response.sendError(i);    }    @Override    public String getContentType()    {        return this.response.getContentType();    }    @Override    public String getHeader(String s)    {        return this.response.getHeader(s);    }    @Override    public Collection<String> getHeaders(String s)    {        return this.response.getHeaders(s);    }    @Override    public Collection<String> getHeaderNames()    {        return this.response.getHeaderNames();    }}"}
{"code": "import java.util.Collections;import java.util.List;import org.xwiki.component.annotation.Role;import org.xwiki.stability.Unstable;@Rolepublic interface URLConfiguration{    String getURLFormatId();    default boolean useResourceLastModificationDate()    {        return true;    }    @Unstable    default List<String> getTrustedDomains()    {        return Collections.emptyList();    }    @Unstable    default boolean isTrustedDomainsEnabled()    {        return true;    }}", "nl": "import org.xwiki.component.annotation.Role;@Rolepublic interface URLConfiguration{    String getURLFormatId();    default boolean useResourceLastModificationDate()    {        return true;    }}"}
{"code": "import java.net.URL;import org.xwiki.component.annotation.Role;import org.xwiki.stability.Unstable;@Role@Unstablepublic interface URLSecurityManager{    String BYPASS_DOMAIN_SECURITY_CHECK_CONTEXT_PROPERTY = \"bypassDomainSecurityCheck\";    boolean isDomainTrusted(URL urlToCheck);}", "nl": ""}
{"code": "import java.util.Collections;import java.util.List;import javax.inject.Inject;import javax.inject.Provider;import javax.inject.Singleton;import org.xwiki.component.annotation.Component;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.url.URLConfiguration;@Component@Singletonpublic class DefaultURLConfiguration implements URLConfiguration{    private static final String PREFIX = \"url.\";    @Inject    private Provider<ConfigurationSource> configuration;    @Override    public String getURLFormatId()    {        return this.configuration.get().getProperty(PREFIX + \"format\", \"standard\");    }    @Override    public boolean useResourceLastModificationDate()    {        return this.configuration.get().getProperty(PREFIX + \"useResourceLastModificationDate\", true);    }    @Override    public List<String> getTrustedDomains()    {        return this.configuration.get().getProperty(PREFIX + \"trustedDomains\", Collections.emptyList());    }    @Override    public boolean isTrustedDomainsEnabled()    {        return this.configuration.get().getProperty(PREFIX + \"trustedDomainsEnabled\", true);    }}", "nl": "import javax.inject.Inject;import javax.inject.Provider;import javax.inject.Singleton;import org.xwiki.component.annotation.Component;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.url.URLConfiguration;@Component@Singletonpublic class DefaultURLConfiguration implements URLConfiguration{    private static final String PREFIX = \"url.\";    @Inject    private Provider<ConfigurationSource> configuration;    @Override    public String getURLFormatId()    {        return this.configuration.get().getProperty(PREFIX + \"format\", \"standard\");    }    @Override    public boolean useResourceLastModificationDate()    {        return this.configuration.get().getProperty(PREFIX + \"useResourceLastModificationDate\", true);    }}"}
{"code": "import java.net.URL;import java.util.HashSet;import java.util.Set;import java.util.regex.Pattern;import javax.inject.Inject;import javax.inject.Singleton;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.slf4j.Logger;import org.xwiki.component.annotation.Component;import org.xwiki.context.Execution;import org.xwiki.url.URLConfiguration;import org.xwiki.url.URLSecurityManager;import org.xwiki.wiki.descriptor.WikiDescriptor;import org.xwiki.wiki.descriptor.WikiDescriptorManager;import org.xwiki.wiki.manager.WikiManagerException;@Component@Singletonpublic class DefaultURLSecurityManager implements URLSecurityManager{    private static final Pattern ACCEPTED_DOMAIN_PATTERN = Pattern.compile(\"([^.]+\\\\.[^.]+)+\");    private static final char DOT = '.';    @Inject    private URLConfiguration urlConfiguration;    @Inject    private WikiDescriptorManager wikiDescriptorManager;    @Inject    private Execution execution;    @Inject    private Logger logger;    private Set<String> trustedDomains;    private void computeTrustedDomains()    {        Set<String> domains;        domains = new HashSet<>(this.urlConfiguration.getTrustedDomains());        try {            for (WikiDescriptor wikiDescriptor : wikiDescriptorManager.getAll()) {                domains.addAll(wikiDescriptor.getAliases());            }        } catch (WikiManagerException e) {            logger.warn(\"Error while getting wiki descriptor to fill list of trusted domains: [{}]. \"                + \"The subwikis won't be taken into account for the list of trusted domains.\",                ExceptionUtils.getRootCauseMessage(e));        }        this.trustedDomains = new HashSet<>();        for (String domain : domains) {            if (ACCEPTED_DOMAIN_PATTERN.matcher(domain).matches()) {                this.trustedDomains.add(domain);            } else {                logger.warn(\"The domain [{}] specified in the trusted domains configuration won't be taken into \"                    + \"account since it doesn't respect the documented format.\", domain);            }        }    }    @Override    public boolean isDomainTrusted(URL urlToCheck)    {        if (this.urlConfiguration.isTrustedDomainsEnabled()) {            if (this.trustedDomains == null) {                computeTrustedDomains();            }            String host = urlToCheck.getHost();            while (StringUtils.contains(host, DOT)) {                if (trustedDomains.contains(host)) {                    return true;                } else {                    host = host.substring(host.indexOf(DOT) + 1);                }            }            Object bypassCheckProperty = execution.getContext()                .getProperty(URLSecurityManager.BYPASS_DOMAIN_SECURITY_CHECK_CONTEXT_PROPERTY);            boolean bypassCheck = bypassCheckProperty != null && Boolean.parseBoolean(bypassCheckProperty.toString());            if (bypassCheck) {                logger.info(\"Domain of URL [{}] does not belong to the list of trusted domains but it's considered as \"                    + \"trusted since the check has been bypassed.\", urlToCheck);            }            return bypassCheck;        } else {            return true;        }    }    public void invalidateCache()    {        this.trustedDomains = null;    }}", "nl": ""}
{"code": "import java.util.Arrays;import java.util.List;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Singleton;import org.xwiki.component.annotation.Component;import org.xwiki.model.reference.LocalDocumentReference;import org.xwiki.observation.AbstractEventListener;import org.xwiki.observation.event.Event;import org.xwiki.url.URLSecurityManager;import com.xpn.xwiki.internal.event.XObjectAddedEvent;import com.xpn.xwiki.internal.event.XObjectDeletedEvent;import com.xpn.xwiki.internal.event.XObjectUpdatedEvent;@Component@Singleton@Named(XWikiServerClassListener.NAME)public class XWikiServerClassListener extends AbstractEventListener{    public static final String NAME = \"org.xwiki.url.internal.XWikiServerClassListener\";    private static final LocalDocumentReference XWIKISERVER_CLASS =        new LocalDocumentReference(\"XWiki\", \"XWikiServerClass\");    private static final List<Event> EVENTS = Arrays.asList(        new XObjectAddedEvent(XWIKISERVER_CLASS),        new XObjectDeletedEvent(XWIKISERVER_CLASS),        new XObjectUpdatedEvent(XWIKISERVER_CLASS)    );    @Inject    private URLSecurityManager securityManager;    public XWikiServerClassListener()    {        super(NAME, EVENTS);    }    @Override    public void onEvent(Event event, Object source, Object data)    {        if (this.securityManager instanceof DefaultURLSecurityManager) {            ((DefaultURLSecurityManager) this.securityManager).invalidateCache();        }    }}", "nl": ""}
{"code": "import java.net.MalformedURLException;import java.net.URL;import java.util.Arrays;import java.util.Collections;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.RegisterExtension;import org.xwiki.context.Execution;import org.xwiki.context.ExecutionContext;import org.xwiki.test.LogLevel;import org.xwiki.test.junit5.LogCaptureExtension;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.url.URLConfiguration;import org.xwiki.url.URLSecurityManager;import org.xwiki.wiki.descriptor.WikiDescriptor;import org.xwiki.wiki.descriptor.WikiDescriptorManager;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;@ComponentTestclass DefaultURLSecurityManagerTest{    @InjectMockComponents    private DefaultURLSecurityManager urlSecurityManager;    @MockComponent    private URLConfiguration urlConfiguration;    @MockComponent    private WikiDescriptorManager wikiDescriptorManager;    @MockComponent    private Execution execution;    private ExecutionContext executionContext;    @RegisterExtension    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.INFO);    @BeforeEach    void setup()    {        this.executionContext = mock(ExecutionContext.class);        when(this.execution.getContext()).thenReturn(this.executionContext);        when(this.urlConfiguration.isTrustedDomainsEnabled()).thenReturn(true);    }    @Test    void isDomainTrusted() throws Exception    {        when(urlConfiguration.getTrustedDomains()).thenReturn(Arrays.asList(            \"foo.acme.org\",            \"com\"         ));        WikiDescriptor wikiDescriptor1 = mock(WikiDescriptor.class);        when(wikiDescriptor1.getAliases()).thenReturn(Arrays.asList(            \"www.xwiki.org\",            \"something.bar.com\"        ));        WikiDescriptor wikiDescriptor2 = mock(WikiDescriptor.class);        when(wikiDescriptor2.getAliases()).thenReturn(Collections.singletonList(            \"enterprise.eu\"        ));        when(this.wikiDescriptorManager.getAll()).thenReturn(Arrays.asList(wikiDescriptor1, wikiDescriptor2));        assertThat(\"www.xwiki.org is trusted\", this.urlSecurityManager            .isDomainTrusted(new URL(\"http:        assertThat(\"www.xwiki.org is trusted\", this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"www.xwiki.com is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"xwiki.org is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"foo.acme.org is trusted\", this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"bar.foo.acme.org is trusted since foo.acme.org is\", this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"buz.bar.foo.acme.org is trusted since foo.acme.org is\", this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"acme.org is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"www.acme.org is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"something.bar.thing.com is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"bar.thing.com is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"something.bar.com is tristed\", this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"enterprise.eu is trusted\", this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertThat(\"enterprise.eu. is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        assertEquals(\"The domain [com] specified in the trusted domains configuration won't be taken into account \"                + \"since it doesn't respect the documented format.\",            logCapture.getMessage(0));    }    @Test    void invalidateCache() throws Exception    {        when(urlConfiguration.getTrustedDomains()).thenReturn(Collections.singletonList(            \"xwiki.org\"        ));        assertThat(\"www.xwiki.org is trusted\", this.urlSecurityManager            .isDomainTrusted(new URL(\"http:        assertThat(\"foo.acme.org is not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        when(urlConfiguration.getTrustedDomains()).thenReturn(Collections.singletonList(            \"foo.acme.org\"        ));        assertThat(\"www.xwiki.org is still trusted\", this.urlSecurityManager            .isDomainTrusted(new URL(\"http:        assertThat(\"foo.acme.org is still not trusted\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"https:        this.urlSecurityManager.invalidateCache();        assertThat(\"www.xwiki.org is not trusted anymore\", !this.urlSecurityManager            .isDomainTrusted(new URL(\"http:        assertThat(\"foo.acme.org is trusted now\", this.urlSecurityManager            .isDomainTrusted(new URL(\"https:    }    @Test    void isDomainTrustedWhenCheckSkipped() throws MalformedURLException    {        when(urlConfiguration.getTrustedDomains()).thenReturn(Collections.singletonList(            \"foo.acme.org\"        ));        when(urlConfiguration.isTrustedDomainsEnabled()).thenReturn(false);        assertThat(\"Any domain can be trusted when check is skipped: check with www.xwiki.org\",            this.urlSecurityManager.isDomainTrusted(new URL(\"http:        assertThat(\"Any domain can be trusted when check is skipped: check with www.bar.eu\",            this.urlSecurityManager.isDomainTrusted(new URL(\"http:        assertThat(\"Any domain can be trusted when check is skipped: check with foo.acme.org\",            this.urlSecurityManager.isDomainTrusted(new URL(\"http:        when(urlConfiguration.isTrustedDomainsEnabled()).thenReturn(true);        assertThat(\"www.xwiki.org should not be trusted\",            !this.urlSecurityManager.isDomainTrusted(new URL(\"http:        assertThat(\"www.bar.eu should not be trusted\",            !this.urlSecurityManager.isDomainTrusted(new URL(\"http:        assertThat(\"foo.acme.org should be trusted\",            this.urlSecurityManager.isDomainTrusted(new URL(\"http:        when(this.executionContext.getProperty(URLSecurityManager.BYPASS_DOMAIN_SECURITY_CHECK_CONTEXT_PROPERTY))            .thenReturn(true);        assertThat(\"www.xwiki.org should be trusted when check is bypassed\",            this.urlSecurityManager.isDomainTrusted(new URL(\"http:        assertEquals(\"Domain of URL [http:                + \"it's considered as trusted since the check has been bypassed.\",            logCapture.getMessage(0));    }}", "nl": ""}
{"code": "import java.util.Arrays;import org.junit.jupiter.api.Test;import org.xwiki.url.internal.RelativeExtendedURL;import static org.junit.jupiter.api.Assertions.assertEquals;class RelativeExtendedURLTest{    @Test    void serialize()    {        RelativeExtendedURL url = new RelativeExtendedURL(Arrays.asList(\"a\", \"b\"));        assertEquals(\"a/b\", url.serialize());    }}", "nl": "import java.util.Arrays;import org.junit.jupiter.api.Test;import org.xwiki.url.internal.RelativeExtendedURL;import static org.junit.jupiter.api.Assertions.assertEquals;class RelativeExtendedURLTest{    @Test    void serialize()    {        RelativeExtendedURL url = new RelativeExtendedURL(Arrays.asList(\"a\", \"b\"));        assertEquals(\"a/b\", url.serialize());    }}"}
{"code": "import org.junit.jupiter.api.Test;import org.xwiki.context.ExecutionContext;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.url.URLConfiguration;import org.xwiki.url.internal.URLExecutionContextInitializer;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.when;@ComponentTestclass URLExecutionContextInitializerTest{    @InjectMockComponents    private URLExecutionContextInitializer initializer;    @MockComponent    private URLConfiguration configuration;    @Test    void initializeWhenFormatIdNotInContext() throws Exception    {        ExecutionContext ec = new ExecutionContext();        when(this.configuration.getURLFormatId()).thenReturn(\"test\");        this.initializer.initialize(ec);        assertEquals(\"test\", ec.getProperty(\"urlscheme\"));    }    @Test    void initializeWhenFormatIdAlreadyInContext() throws Exception    {        ExecutionContext ec = new ExecutionContext();        ec.setProperty(\"urlscheme\", \"existing\");        this.initializer.initialize(ec);        assertEquals(\"existing\", ec.getProperty(\"urlscheme\"));    }}", "nl": "import org.junit.jupiter.api.Test;import org.xwiki.context.ExecutionContext;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.url.internal.URLExecutionContextInitializer;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.when;@ComponentTestclass URLExecutionContextInitializerTest{    @InjectMockComponents    private URLExecutionContextInitializer initializer;    @MockComponent    private URLConfiguration configuration;    @Test    void initializeWhenFormatIdNotInContext() throws Exception    {        ExecutionContext ec = new ExecutionContext();        when(this.configuration.getURLFormatId()).thenReturn(\"test\");        this.initializer.initialize(ec);        assertEquals(\"test\", ec.getProperty(\"urlscheme\"));    }    @Test    void initializeWhenFormatIdAlreadyInContext() throws Exception    {        ExecutionContext ec = new ExecutionContext();        ec.setProperty(\"urlscheme\", \"existing\");        this.initializer.initialize(ec);        assertEquals(\"existing\", ec.getProperty(\"urlscheme\"));    }}"}
{"code": "import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.mail.Address;import javax.mail.BodyPart;import javax.mail.Multipart;import javax.mail.internet.MimeMessage;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.RandomStringUtils;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.xwiki.administration.test.po.ResetPasswordCompletePage;import org.xwiki.administration.test.po.ResetPasswordPage;import org.xwiki.test.docker.junit5.TestConfiguration;import org.xwiki.test.docker.junit5.UITest;import org.xwiki.test.integration.junit.LogCaptureConfiguration;import org.xwiki.test.ui.TestUtils;import org.xwiki.test.ui.po.LoginPage;import com.icegreen.greenmail.util.GreenMail;import com.icegreen.greenmail.util.ServerSetupTest;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;@UITest(sshPorts = {    3025},    properties = {        \"xwikiDbHbmCommonExtraMappings=mailsender.hbm.xml\",        \"xwikiPropertiesAdditionalProperties=test.prchecker.excludePattern=.*:XWiki\\\\.ResetPassword|.*:XWiki\\\\.ResetPasswordComplete\"    },    extraJARs = {        \"org.xwiki.platform:xwiki-platform-mail-send-storage\"    })public class ResetPasswordIT{    private GreenMail mail;    @BeforeEach    public void startMail(TestUtils setup, TestConfiguration testConfiguration)    {        this.mail = new GreenMail(ServerSetupTest.SMTP);        this.mail.start();        configureEmail(setup, testConfiguration);    }    @AfterEach    public void stopMail(TestUtils setup, LogCaptureConfiguration logCaptureConfiguration)    {        if (this.mail != null) {            this.mail.stop();        }        restoreSettings(setup);        logCaptureConfiguration.registerExcludes(\"CSRFToken: Secret token verification failed, token\");    }    @Test    public void resetForgottenPassword(TestUtils setup) throws Exception    {        setup.loginAsSuperAdmin();        String userName = \"testUser\" + RandomStringUtils.randomAlphanumeric(6);        String password = \"password\";        String newPassword = \"newPassword\";        setup.createUser(userName, password, null);        setup.forceGuestUser();        ResetPasswordPage resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(\"SomeUserThatDoesNotExist\");        resetPasswordPage = resetPasswordPage.clickResetPassword();        assertTrue(resetPasswordPage.isFormSubmitted());        resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(userName);        resetPasswordPage.clickResetPassword();        assertTrue(resetPasswordPage.isFormSubmitted());        setup.loginAsSuperAdmin();        setup.updateObject(\"XWiki\", userName, \"XWiki.XWikiUsers\", 0, \"email\", \"foo@bar.com\", \"form_token\",            setup.getSecretToken());        setup.forceGuestUser();        resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(userName);        ResetPasswordPage newResetPasswordPage = resetPasswordPage.clickResetPassword();        assertTrue(newResetPasswordPage.getMessage().contains(\"An e-mail was sent\"),            \"Actual message: \" + newResetPasswordPage.getMessage());        assertFalse(newResetPasswordPage.getMessage().contains(\"foo@bar.com\"),            \"Actual message: \" + newResetPasswordPage.getMessage());        assertTrue(resetPasswordPage.isFormSubmitted());        assertTrue(this.mail.waitForIncomingEmail(1));        MimeMessage[] receivedEmails = this.mail.getReceivedMessages();        assertEquals(1, receivedEmails.length);        MimeMessage receivedEmail = receivedEmails[0];        assertEquals(\"Password reset request for \" + userName, receivedEmail.getSubject());        String receivedMailContent = getMessageContent(receivedEmail).get(\"textPart\");        String passwordResetLink = getResetLink(receivedMailContent, \"xwiki%3AXWiki.\" + userName);        assertNotNull(passwordResetLink);        setup.gotoPage(passwordResetLink);        ResetPasswordCompletePage resetPasswordCompletePage = new ResetPasswordCompletePage();        assertTrue(resetPasswordCompletePage.isResetLinkValid());        resetPasswordCompletePage.setPassword(newPassword);        resetPasswordCompletePage.setPasswordConfirmation(newPassword);        resetPasswordCompletePage = resetPasswordCompletePage.clickSave();        assertTrue(resetPasswordCompletePage.isPasswordSuccessfullyReset());        LoginPage loginPage = resetPasswordCompletePage.clickLogin();        loginPage.loginAs(userName, newPassword);        assertEquals(userName, setup.getLoggedInUserName());    }    private Map<String, String> getMessageContent(MimeMessage message) throws Exception    {        Map<String, String> messageMap = new HashMap<>();        Address[] addresses = message.getAllRecipients();        assertTrue(addresses.length == 1);        messageMap.put(\"recipient\", addresses[0].toString());        messageMap.put(\"subjectLine\", message.getSubject());        Multipart mp = (Multipart) message.getContent();        BodyPart plain = getPart(mp, \"text/plain\");        if (plain != null) {            messageMap.put(\"textPart\", IOUtils.toString(plain.getInputStream(), \"UTF-8\"));        }        BodyPart html = getPart(mp, \"text/html\");        if (html != null) {            messageMap.put(\"htmlPart\", IOUtils.toString(html.getInputStream(), \"UTF-8\"));        }        return messageMap;    }    private BodyPart getPart(Multipart messageContent, String mimeType) throws Exception    {        for (int i = 0; i < messageContent.getCount(); i++) {            BodyPart part = messageContent.getBodyPart(i);            if (part.isMimeType(mimeType)) {                return part;            }            if (part.isMimeType(\"multipart/related\") || part.isMimeType(\"multipart/alternative\")                || part.isMimeType(\"multipart/mixed\"))            {                BodyPart out = getPart((Multipart) part.getContent(), mimeType);                if (out != null) {                    return out;                }            }        }        return null;    }    private String getResetLink(String emailContent, String userName)    {        String result = null;        Pattern resetLinkPattern = Pattern.compile(\"http[^\\\\s]+?authenticate/reset\\\\?u=\" + userName + \"\\\\&v=\\\\w+\");        Matcher matcher = resetLinkPattern.matcher(emailContent);        if (matcher.find()) {            result = matcher.group();        }        return result;    }    private void configureEmail(TestUtils setup, TestConfiguration testConfiguration)    {        setup.updateObject(\"Mail\", \"MailConfig\", \"Mail.SendMailConfigClass\", 0, \"host\",            testConfiguration.getServletEngine().getHostIP(), \"port\", \"3025\", \"sendWaitTime\", \"0\");    }    private void restoreSettings(TestUtils setup)    {        setup.loginAsSuperAdmin();        setup.deleteLatestVersion(\"Mail\", \"MailConfig\");    }}", "nl": "import java.util.HashMap;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.mail.Address;import javax.mail.BodyPart;import javax.mail.Multipart;import javax.mail.internet.MimeMessage;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.RandomStringUtils;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.xwiki.administration.test.po.ResetPasswordCompletePage;import org.xwiki.administration.test.po.ResetPasswordPage;import org.xwiki.test.docker.junit5.TestConfiguration;import org.xwiki.test.docker.junit5.UITest;import org.xwiki.test.integration.junit.LogCaptureConfiguration;import org.xwiki.test.ui.TestUtils;import org.xwiki.test.ui.po.LoginPage;import com.icegreen.greenmail.util.GreenMail;import com.icegreen.greenmail.util.ServerSetupTest;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;@UITest(sshPorts = {    3025},    properties = {        \"xwikiDbHbmCommonExtraMappings=mailsender.hbm.xml\",        \"xwikiPropertiesAdditionalProperties=test.prchecker.excludePattern=.*:XWiki\\\\.ResetPassword|.*:XWiki\\\\.ResetPasswordComplete\"    },    extraJARs = {        \"org.xwiki.platform:xwiki-platform-mail-send-storage\"    })public class ResetPasswordIT{    private GreenMail mail;    @BeforeEach    public void startMail(TestUtils setup, TestConfiguration testConfiguration)    {        this.mail = new GreenMail(ServerSetupTest.SMTP);        this.mail.start();        configureEmail(setup, testConfiguration);    }    @AfterEach    public void stopMail(TestUtils setup, LogCaptureConfiguration logCaptureConfiguration)    {        if (this.mail != null) {            this.mail.stop();        }        restoreSettings(setup);        logCaptureConfiguration.registerExcludes(\"CSRFToken: Secret token verification failed, token\");    }    @Test    public void resetForgottenPassword(TestUtils setup) throws Exception    {        setup.loginAsSuperAdmin();        String userName = \"testUser\" + RandomStringUtils.randomAlphanumeric(6);        String password = \"password\";        String newPassword = \"newPassword\";        setup.createUser(userName, password, null);        setup.forceGuestUser();        ResetPasswordPage resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(\"SomeUserThatDoesNotExist\");        resetPasswordPage = resetPasswordPage.clickResetPassword();        assertFalse(resetPasswordPage.isResetPasswordSent());        assertTrue(resetPasswordPage.getMessage().contains(\"user does not exist\"));        resetPasswordPage = resetPasswordPage.clickRetry();        resetPasswordPage.setUserName(userName);        resetPasswordPage.clickResetPassword();        assertFalse(resetPasswordPage.isResetPasswordSent());        assertTrue(resetPasswordPage.getMessage().contains(\"email address not provided\"));        setup.loginAsSuperAdmin();        setup.updateObject(\"XWiki\", userName, \"XWiki.XWikiUsers\", 0, \"email\", \"foo@bar.com\", \"form_token\",            setup.getSecretToken());        setup.forceGuestUser();        resetPasswordPage = ResetPasswordPage.gotoPage();        resetPasswordPage.setUserName(userName);        ResetPasswordPage newResetPasswordPage = resetPasswordPage.clickResetPassword();        assertTrue(newResetPasswordPage.getMessage().contains(\"An e-mail was sent\"),            \"Actual message: \" + newResetPasswordPage.getMessage());        assertFalse(newResetPasswordPage.getMessage().contains(\"foo@bar.com\"),            \"Actual message: \" + newResetPasswordPage.getMessage());        assertTrue(resetPasswordPage.isResetPasswordSent());        assertTrue(this.mail.waitForIncomingEmail(1));        MimeMessage[] receivedEmails = this.mail.getReceivedMessages();        assertEquals(1, receivedEmails.length);        MimeMessage receivedEmail = receivedEmails[0];        assertEquals(\"Password reset request for \" + userName, receivedEmail.getSubject());        String receivedMailContent = getMessageContent(receivedEmail).get(\"textPart\");        String passwordResetLink = getResetLink(receivedMailContent, \"xwiki%3AXWiki.\" + userName);        assertNotNull(passwordResetLink);        setup.gotoPage(passwordResetLink);        ResetPasswordCompletePage resetPasswordCompletePage = new ResetPasswordCompletePage();        assertTrue(resetPasswordCompletePage.isResetLinkValid());        resetPasswordCompletePage.setPassword(newPassword);        resetPasswordCompletePage.setPasswordConfirmation(newPassword);        resetPasswordCompletePage = resetPasswordCompletePage.clickSave();        assertTrue(resetPasswordCompletePage.isPasswordSuccessfullyReset());        LoginPage loginPage = resetPasswordCompletePage.clickLogin();        loginPage.loginAs(userName, newPassword);        assertEquals(userName, setup.getLoggedInUserName());    }    private Map<String, String> getMessageContent(MimeMessage message) throws Exception    {        Map<String, String> messageMap = new HashMap<>();        Address[] addresses = message.getAllRecipients();        assertTrue(addresses.length == 1);        messageMap.put(\"recipient\", addresses[0].toString());        messageMap.put(\"subjectLine\", message.getSubject());        Multipart mp = (Multipart) message.getContent();        BodyPart plain = getPart(mp, \"text/plain\");        if (plain != null) {            messageMap.put(\"textPart\", IOUtils.toString(plain.getInputStream(), \"UTF-8\"));        }        BodyPart html = getPart(mp, \"text/html\");        if (html != null) {            messageMap.put(\"htmlPart\", IOUtils.toString(html.getInputStream(), \"UTF-8\"));        }        return messageMap;    }    private BodyPart getPart(Multipart messageContent, String mimeType) throws Exception    {        for (int i = 0; i < messageContent.getCount(); i++) {            BodyPart part = messageContent.getBodyPart(i);            if (part.isMimeType(mimeType)) {                return part;            }            if (part.isMimeType(\"multipart/related\") || part.isMimeType(\"multipart/alternative\")                || part.isMimeType(\"multipart/mixed\"))            {                BodyPart out = getPart((Multipart) part.getContent(), mimeType);                if (out != null) {                    return out;                }            }        }        return null;    }    private String getResetLink(String emailContent, String userName)    {        String result = null;        Pattern resetLinkPattern = Pattern.compile(\"http[^\\\\s]+?authenticate/reset\\\\?u=\" + userName + \"\\\\&v=\\\\w+\");        Matcher matcher = resetLinkPattern.matcher(emailContent);        if (matcher.find()) {            result = matcher.group();        }        return result;    }    private void configureEmail(TestUtils setup, TestConfiguration testConfiguration)    {        setup.updateObject(\"Mail\", \"MailConfig\", \"Mail.SendMailConfigClass\", 0, \"host\",            testConfiguration.getServletEngine().getHostIP(), \"port\", \"3025\", \"sendWaitTime\", \"0\");    }    private void restoreSettings(TestUtils setup)    {        setup.loginAsSuperAdmin();        setup.deleteLatestVersion(\"Mail\", \"MailConfig\");    }}"}
{"code": "import org.openqa.selenium.By;import org.openqa.selenium.WebElement;import org.openqa.selenium.support.FindBy;import org.xwiki.test.ui.po.ViewPage;public class ResetPasswordPage extends ViewPage{    @FindBy(id = \"u\")    private WebElement userNameInput;    @FindBy(css = \"#resetPasswordForm input[type='submit']\")    private WebElement resetPasswordButton;    @FindBy(css = \".xwikimessage\")    private WebElement messageBox;    @FindBy(xpath = \"/    public boolean isFormSubmitted()    {        return !getDriver().hasElementWithoutWaiting(By.cssSelector(\"#resetPasswordForm\"))            && messageBox.getText().contains(\"An e-mail was sent to\");    }    public String getMessage()    {        return messageBox.getText();    }    public ResetPasswordPage clickRetry()    {        retryUserNameButton.click();        return new ResetPasswordPage();    }}", "nl": "import org.openqa.selenium.By;import org.openqa.selenium.WebElement;import org.openqa.selenium.support.FindBy;import org.xwiki.test.ui.po.ViewPage;public class ResetPasswordPage extends ViewPage{    @FindBy(id = \"u\")    private WebElement userNameInput;    @FindBy(css = \"#resetPasswordForm input[type='submit']\")    private WebElement resetPasswordButton;    @FindBy(css = \".xwikimessage\")    private WebElement messageBox;    @FindBy(xpath = \"    private WebElement retryUserNameButton;    public static ResetPasswordPage gotoPage()    {        getUtil().gotoPage(getUtil().getBaseURL() + \"authenticate/reset\");        return new ResetPasswordPage();    }    public String getUserName()    {        return userNameInput.getAttribute(\"value\");    }    public void setUserName(String userName)    {        this.userNameInput.sendKeys(userName);    }    public ResetPasswordPage clickResetPassword()    {        resetPasswordButton.click();        return new ResetPasswordPage();    }    public boolean isResetPasswordSent()    {        return !getDriver().hasElementWithoutWaiting(By.cssSelector(\"#resetPasswordForm\"))            && messageBox.getText().contains(\"An e-mail was sent to\");    }    public String getMessage()    {        return messageBox.getText();    }    public ResetPasswordPage clickRetry()    {        retryUserNameButton.click();        return new ResetPasswordPage();    }}"}
{"code": "import org.xwiki.stability.Unstable;import org.xwiki.user.UserReference;@Unstablepublic interface ResetPasswordRequestResponse{    UserReference getUserReference();    String getVerificationCode();}", "nl": "import javax.mail.internet.InternetAddress;import org.xwiki.stability.Unstable;import org.xwiki.user.UserReference;@Unstablepublic interface ResetPasswordRequestResponse{    UserReference getUserReference();    InternetAddress getUserEmail();    String getVerificationCode();}"}
{"code": "import java.net.MalformedURLException;import java.net.URL;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import javax.mail.internet.InternetAddress;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.xwiki.component.annotation.Component;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.LocalDocumentReference;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.resource.SerializeResourceReferenceException;import org.xwiki.resource.UnsupportedResourceReferenceException;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserManager;import org.xwiki.user.UserProperties;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.user.UserReference;import org.xwiki.user.UserReferenceSerializer;import org.xwiki.user.internal.document.DocumentUserReference;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.PropertyInterface;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;@Component@Singletonpublic class DefaultResetPasswordManager implements ResetPasswordManager{    protected static final String XWIKI_SPACE = \"XWiki\";    protected static final LocalDocumentReference LDAP_CLASS_REFERENCE =        new LocalDocumentReference(XWIKI_SPACE, \"LDAPProfileClass\");    protected static final LocalDocumentReference RESET_PASSWORD_REQUEST_CLASS_REFERENCE =        new LocalDocumentReference(XWIKI_SPACE, \"ResetPasswordRequestClass\");    protected static final LocalDocumentReference USER_CLASS_REFERENCE =        new LocalDocumentReference(XWIKI_SPACE, \"XWikiUsers\");    protected static final String VERIFICATION_PROPERTY = \"verification\";    @Inject    private UserManager userManager;    @Inject    private UserPropertiesResolver userPropertiesResolver;    @Inject    private ContextualLocalizationManager localizationManager;    @Inject    private Provider<XWikiContext> contextProvider;    @Inject    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> resourceReferenceSerializer;    @Inject    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @Inject    private UserReferenceSerializer<String> referenceSerializer;    @Inject    private Provider<ResetPasswordMailSender> resetPasswordMailSenderProvider;    @Inject    private Logger logger;    private boolean checkUserReference(UserReference userReference) throws ResetPasswordException    {        if (!(userReference instanceof DocumentUserReference)) {            throw new ResetPasswordException(\"Only user having a page on the wiki can reset their password.\");        }        return this.userManager.exists(userReference);    }    @Override    public ResetPasswordRequestResponse requestResetPassword(UserReference userReference) throws ResetPasswordException    {        if (this.checkUserReference(userReference)) {            UserProperties userProperties = this.userPropertiesResolver.resolve(userReference);            InternetAddress email = userProperties.getEmail();            if (email != null) {                DocumentUserReference documentUserReference = (DocumentUserReference) userReference;                DocumentReference reference = documentUserReference.getReference();                XWikiContext context = this.contextProvider.get();                try {                    XWikiDocument userDocument = context.getWiki().getDocument(reference, context);                    if (userDocument.getXObject(LDAP_CLASS_REFERENCE) != null) {                        String exceptionMessage =                            this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.ldapUser\",                                userReference.toString());                        throw new ResetPasswordException(exceptionMessage);                    }                    BaseObject xObject = userDocument.getXObject(RESET_PASSWORD_REQUEST_CLASS_REFERENCE, true, context);                    String verificationCode = context.getWiki().generateRandomString(30);                    xObject.set(VERIFICATION_PROPERTY, verificationCode, context);                    String saveComment =                        this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.versionComment\");                    context.getWiki().saveDocument(userDocument, saveComment, true, context);                    return new DefaultResetPasswordRequestResponse(userReference, verificationCode);                } catch (XWikiException e) {                    throw new ResetPasswordException(                        \"Error when reading user document to perform reset password request.\",                        e);                }            } else {                this.logger.info(\"User [{}] asked to reset their password, but did not have any email configured.\",                    userReference);            }        }        return new DefaultResetPasswordRequestResponse(userReference, null);    }    @Override    public void sendResetPasswordEmailRequest(ResetPasswordRequestResponse requestResponse)        throws ResetPasswordException    {        if (this.checkUserReference(requestResponse.getUserReference())) {            AuthenticationResourceReference resourceReference =                new AuthenticationResourceReference(AuthenticationAction.RESET_PASSWORD);            UserReference userReference = requestResponse.getUserReference();            UserProperties userProperties = this.userPropertiesResolver.resolve(userReference);            InternetAddress email = userProperties.getEmail();            String serializedUserReference = this.referenceSerializer.serialize(userReference);            String formattedName = \"\";            if (!StringUtils.isBlank(userProperties.getFirstName())) {                formattedName += userProperties.getFirstName();            }            if (!StringUtils.isBlank(userProperties.getLastName())) {                if (!StringUtils.isBlank(formattedName)) {                    formattedName += \" \";                }                formattedName += userProperties.getLastName();            }            if (StringUtils.isBlank(formattedName)) {                formattedName = serializedUserReference;            }            resourceReference.addParameter(\"u\", serializedUserReference);            resourceReference.addParameter(\"v\", requestResponse.getVerificationCode());            XWikiContext context = contextProvider.get();            ExtendedURL extendedURL = null;            try {                extendedURL = this.resourceReferenceSerializer.serialize(resourceReference);                extendedURL = this.urlNormalizer.normalize(extendedURL);                URL serverURL = context.getURLFactory().getServerURL(context);                URL externalVerificationURL = new URL(serverURL, extendedURL.serialize());                this.resetPasswordMailSenderProvider.get()                    .sendResetPasswordEmail(formattedName, email, externalVerificationURL);            } catch (SerializeResourceReferenceException | UnsupportedResourceReferenceException                | MalformedURLException e) {                throw new ResetPasswordException(\"Error when processing information for creating the email.\", e);            }        }    }    @Override    public ResetPasswordRequestResponse checkVerificationCode(UserReference userReference, String verificationCode)        throws ResetPasswordException    {        if (this.checkUserReference(userReference)) {            XWikiContext context = this.contextProvider.get();            DocumentUserReference documentUserReference = (DocumentUserReference) userReference;            DocumentReference reference = documentUserReference.getReference();            String exceptionMessage =                this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.step2.error.wrongParameters\",                    userReference.toString());            try {                XWikiDocument userDocument = context.getWiki().getDocument(reference, context);                BaseObject xObject = userDocument.getXObject(RESET_PASSWORD_REQUEST_CLASS_REFERENCE);                if (xObject == null) {                    throw new ResetPasswordException(exceptionMessage);                }                String storedVerificationCode = xObject.getStringValue(VERIFICATION_PROPERTY);                BaseClass xClass = xObject.getXClass(context);                PropertyInterface verification = xClass.get(VERIFICATION_PROPERTY);                if (!(verification instanceof PasswordClass)) {                    throw new ResetPasswordException(\"Bad definition of ResetPassword XClass.\");                }                PasswordClass passwordClass = (PasswordClass) verification;                String equivalentPassword =                    passwordClass.getEquivalentPassword(storedVerificationCode, verificationCode);                String newVerificationCode = context.getWiki().generateRandomString(30);                xObject.set(VERIFICATION_PROPERTY, newVerificationCode, context);                String saveComment = this.localizationManager                    .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.changeValidationKey\");                context.getWiki().saveDocument(userDocument, saveComment, true, context);                if (!storedVerificationCode.equals(equivalentPassword)) {                    throw new ResetPasswordException(exceptionMessage);                }                return new DefaultResetPasswordRequestResponse(userReference, newVerificationCode);            } catch (XWikiException e) {                throw new ResetPasswordException(\"Cannot open user document to check verification code.\", e);            }        } else {            return new DefaultResetPasswordRequestResponse(userReference, null);        }    }    @Override    public void resetPassword(UserReference userReference, String newPassword)        throws ResetPasswordException    {        if (this.checkUserReference(userReference)) {            XWikiContext context = this.contextProvider.get();            DocumentUserReference documentUserReference = (DocumentUserReference) userReference;            DocumentReference reference = documentUserReference.getReference();            try {                XWikiDocument userDocument = context.getWiki().getDocument(reference, context);                userDocument.removeXObjects(RESET_PASSWORD_REQUEST_CLASS_REFERENCE);                BaseObject userXObject = userDocument.getXObject(USER_CLASS_REFERENCE);                userXObject.setStringValue(\"password\", newPassword);                String saveComment = this.localizationManager.getTranslationPlain(                    \"xe.admin.passwordReset.step2.versionComment.passwordReset\");                context.getWiki().saveDocument(userDocument, saveComment, true, context);            } catch (XWikiException e) {                throw new ResetPasswordException(\"Cannot open user document to perform reset password.\", e);            }        }    }}", "nl": "import java.net.MalformedURLException;import java.net.URL;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import javax.mail.internet.InternetAddress;import org.apache.commons.lang3.StringUtils;import org.xwiki.component.annotation.Component;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.LocalDocumentReference;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.resource.SerializeResourceReferenceException;import org.xwiki.resource.UnsupportedResourceReferenceException;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserManager;import org.xwiki.user.UserProperties;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.user.UserReference;import org.xwiki.user.UserReferenceSerializer;import org.xwiki.user.internal.document.DocumentUserReference;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.PropertyInterface;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;@Component@Singletonpublic class DefaultResetPasswordManager implements ResetPasswordManager{    protected static final String XWIKI_SPACE = \"XWiki\";    protected static final LocalDocumentReference LDAP_CLASS_REFERENCE =        new LocalDocumentReference(XWIKI_SPACE, \"LDAPProfileClass\");    protected static final LocalDocumentReference RESET_PASSWORD_REQUEST_CLASS_REFERENCE =        new LocalDocumentReference(XWIKI_SPACE, \"ResetPasswordRequestClass\");    protected static final LocalDocumentReference USER_CLASS_REFERENCE =        new LocalDocumentReference(XWIKI_SPACE, \"XWikiUsers\");    protected static final String VERIFICATION_PROPERTY = \"verification\";    @Inject    private UserManager userManager;    @Inject    private UserPropertiesResolver userPropertiesResolver;    @Inject    private ContextualLocalizationManager localizationManager;    @Inject    private Provider<XWikiContext> contextProvider;    @Inject    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> resourceReferenceSerializer;    @Inject    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @Inject    private UserReferenceSerializer<String> referenceSerializer;    @Inject    private Provider<ResetPasswordMailSender> resetPasswordMailSenderProvider;    private void checkUserReference(UserReference userReference) throws ResetPasswordException    {        if (!this.userManager.exists(userReference)) {            String exceptionMessage =                this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.noUser\",                    userReference.toString());            throw new ResetPasswordException(exceptionMessage);        }        if (!(userReference instanceof DocumentUserReference)) {            throw new ResetPasswordException(\"Only user having a page on the wiki can reset their password.\");        }    }    @Override    public ResetPasswordRequestResponse requestResetPassword(UserReference userReference) throws ResetPasswordException    {        this.checkUserReference(userReference);        UserProperties userProperties = this.userPropertiesResolver.resolve(userReference);        InternetAddress email = userProperties.getEmail();        if (email == null) {            String exceptionMessage =                this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.noEmail\");            throw new ResetPasswordException(exceptionMessage);        }        DocumentUserReference documentUserReference = (DocumentUserReference) userReference;        DocumentReference reference = documentUserReference.getReference();        XWikiContext context = this.contextProvider.get();        try {            XWikiDocument userDocument = context.getWiki().getDocument(reference, context);            if (userDocument.getXObject(LDAP_CLASS_REFERENCE) != null) {                String exceptionMessage =                    this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.ldapUser\",                        userReference.toString());                throw new ResetPasswordException(exceptionMessage);            }            BaseObject xObject = userDocument.getXObject(RESET_PASSWORD_REQUEST_CLASS_REFERENCE, true, context);            String verificationCode = context.getWiki().generateRandomString(30);            xObject.set(VERIFICATION_PROPERTY, verificationCode, context);            String saveComment =                this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.versionComment\");            context.getWiki().saveDocument(userDocument, saveComment, true, context);            return new DefaultResetPasswordRequestResponse(userReference, email, verificationCode);        } catch (XWikiException e) {            throw new ResetPasswordException(\"Error when reading user document to perform reset password request.\", e);        }    }    @Override    public void sendResetPasswordEmailRequest(ResetPasswordRequestResponse requestResponse)        throws ResetPasswordException    {        AuthenticationResourceReference resourceReference =            new AuthenticationResourceReference(AuthenticationAction.RESET_PASSWORD);        UserReference userReference = requestResponse.getUserReference();        UserProperties userProperties = this.userPropertiesResolver.resolve(userReference);        String serializedUserReference = this.referenceSerializer.serialize(userReference);        String formattedName = \"\";        if (!StringUtils.isBlank(userProperties.getFirstName())) {            formattedName += userProperties.getFirstName();        }        if (!StringUtils.isBlank(userProperties.getLastName())) {            if (!StringUtils.isBlank(formattedName)) {                formattedName += \" \";            }            formattedName += userProperties.getLastName();        }        if (StringUtils.isBlank(formattedName)) {            formattedName = serializedUserReference;        }        resourceReference.addParameter(\"u\", serializedUserReference);        resourceReference.addParameter(\"v\", requestResponse.getVerificationCode());        XWikiContext context = contextProvider.get();        ExtendedURL extendedURL = null;        try {            extendedURL = this.resourceReferenceSerializer.serialize(resourceReference);            extendedURL = this.urlNormalizer.normalize(extendedURL);            URL serverURL = context.getURLFactory().getServerURL(context);            URL externalVerificationURL = new URL(serverURL, extendedURL.serialize());            this.resetPasswordMailSenderProvider.get()                .sendResetPasswordEmail(formattedName, requestResponse.getUserEmail(), externalVerificationURL);        } catch (SerializeResourceReferenceException | UnsupportedResourceReferenceException | MalformedURLException e)        {            throw new ResetPasswordException(\"Error when processing information for creating the email.\", e);        }    }    @Override    public ResetPasswordRequestResponse checkVerificationCode(UserReference userReference, String verificationCode)        throws ResetPasswordException    {        this.checkUserReference(userReference);        XWikiContext context = this.contextProvider.get();        UserProperties userProperties = this.userPropertiesResolver.resolve(userReference);        InternetAddress email = userProperties.getEmail();        DocumentUserReference documentUserReference = (DocumentUserReference) userReference;        DocumentReference reference = documentUserReference.getReference();        String exceptionMessage =            this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.step2.error.wrongParameters\",                userReference.toString());        try {            XWikiDocument userDocument = context.getWiki().getDocument(reference, context);            BaseObject xObject = userDocument.getXObject(RESET_PASSWORD_REQUEST_CLASS_REFERENCE);            if (xObject == null) {                throw new ResetPasswordException(exceptionMessage);            }            String storedVerificationCode = xObject.getStringValue(VERIFICATION_PROPERTY);            BaseClass xClass = xObject.getXClass(context);            PropertyInterface verification = xClass.get(VERIFICATION_PROPERTY);            if (!(verification instanceof PasswordClass)) {                throw new ResetPasswordException(\"Bad definition of ResetPassword XClass.\");            }            PasswordClass passwordClass = (PasswordClass) verification;            String equivalentPassword =                passwordClass.getEquivalentPassword(storedVerificationCode, verificationCode);            String newVerificationCode = context.getWiki().generateRandomString(30);            xObject.set(VERIFICATION_PROPERTY, newVerificationCode, context);            String saveComment = this.localizationManager                .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.changeValidationKey\");            context.getWiki().saveDocument(userDocument, saveComment, true, context);            if (!storedVerificationCode.equals(equivalentPassword)) {                throw new ResetPasswordException(exceptionMessage);            }            return new DefaultResetPasswordRequestResponse(userReference, email, newVerificationCode);        } catch (XWikiException e) {            throw new ResetPasswordException(\"Cannot open user document to check verification code.\", e);        }    }    @Override    public void resetPassword(UserReference userReference, String newPassword)        throws ResetPasswordException    {        this.checkUserReference(userReference);        XWikiContext context = this.contextProvider.get();        DocumentUserReference documentUserReference = (DocumentUserReference) userReference;        DocumentReference reference = documentUserReference.getReference();        try {            XWikiDocument userDocument = context.getWiki().getDocument(reference, context);            userDocument.removeXObjects(RESET_PASSWORD_REQUEST_CLASS_REFERENCE);            BaseObject userXObject = userDocument.getXObject(USER_CLASS_REFERENCE);            userXObject.setStringValue(\"password\", newPassword);            String saveComment = this.localizationManager.getTranslationPlain(                \"xe.admin.passwordReset.step2.versionComment.passwordReset\");            context.getWiki().saveDocument(userDocument, saveComment, true, context);        } catch (XWikiException e) {            throw new ResetPasswordException(\"Cannot open user document to perform reset password.\", e);        }    }}"}
{"code": "import org.apache.commons.lang3.builder.EqualsBuilder;import org.apache.commons.lang3.builder.HashCodeBuilder;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.user.UserReference;public final class DefaultResetPasswordRequestResponse implements ResetPasswordRequestResponse{    private final UserReference userReference;    private final String verificationCode;    DefaultResetPasswordRequestResponse(UserReference reference, String verificationCode)    {        this.userReference = reference;        this.verificationCode = verificationCode;    }    public UserReference getUserReference()    {        return userReference;    }    public String getVerificationCode()    {        return verificationCode;    }    @Override    public boolean equals(Object o)    {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        DefaultResetPasswordRequestResponse that = (DefaultResetPasswordRequestResponse) o;        return new EqualsBuilder()            .append(userReference, that.userReference)            .append(verificationCode, that.verificationCode)            .isEquals();    }    @Override    public int hashCode()    {        return new HashCodeBuilder(17, 37)            .append(userReference)            .append(verificationCode)            .toHashCode();    }}", "nl": "import javax.mail.internet.InternetAddress;import org.apache.commons.lang3.builder.EqualsBuilder;import org.apache.commons.lang3.builder.HashCodeBuilder;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.user.UserReference;public final class DefaultResetPasswordRequestResponse implements ResetPasswordRequestResponse{    private final UserReference userReference;    private final InternetAddress userEmail;    private final String verificationCode;    DefaultResetPasswordRequestResponse(UserReference reference, InternetAddress userEmail, String verificationCode)    {        this.userReference = reference;        this.userEmail = userEmail;        this.verificationCode = verificationCode;    }    public UserReference getUserReference()    {        return userReference;    }    public InternetAddress getUserEmail()    {        return userEmail;    }    public String getVerificationCode()    {        return verificationCode;    }    @Override    public boolean equals(Object o)    {        if (this == o) {            return true;        }        if (o == null || getClass() != o.getClass()) {            return false;        }        DefaultResetPasswordRequestResponse that = (DefaultResetPasswordRequestResponse) o;        return new EqualsBuilder()            .append(userReference, that.userReference)            .append(userEmail, that.userEmail)            .append(verificationCode, that.verificationCode)            .isEquals();    }    @Override    public int hashCode()    {        return new HashCodeBuilder(17, 37)            .append(userReference)            .append(userEmail)            .append(verificationCode)            .toHashCode();    }}"}
{"code": "import java.net.URL;import java.util.Arrays;import javax.inject.Named;import javax.inject.Provider;import javax.mail.internet.InternetAddress;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.RegisterExtension;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.model.reference.DocumentReference;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.test.LogLevel;import org.xwiki.test.junit5.LogCaptureExtension;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserManager;import org.xwiki.user.UserProperties;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.user.UserReference;import org.xwiki.user.UserReferenceSerializer;import org.xwiki.user.internal.document.DocumentUserReference;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;import com.xpn.xwiki.web.XWikiURLFactory;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.anyBoolean;import static org.mockito.ArgumentMatchers.anyString;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentTestclass DefaultResetPasswordManagerTest{    @InjectMockComponents    private DefaultResetPasswordManager resetPasswordManager;    @MockComponent    private UserManager userManager;    @MockComponent    private UserPropertiesResolver userPropertiesResolver;    @MockComponent    private ContextualLocalizationManager localizationManager;    @MockComponent    private Provider<XWikiContext> contextProvider;    @MockComponent    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> resourceReferenceSerializer;    @MockComponent    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @MockComponent    private UserReferenceSerializer<String> referenceSerializer;    @MockComponent    private Provider<ResetPasswordMailSender> resetPasswordMailSenderProvider;    @RegisterExtension    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.INFO);    private ResetPasswordMailSender resetPasswordMailSender;    private DocumentUserReference userReference;    private DocumentReference userDocumentReference;    private UserProperties userProperties;    private XWikiContext context;    private XWiki xWiki;    private XWikiDocument userDocument;    @BeforeEach    void setup() throws Exception    {        this.userReference = mock(DocumentUserReference.class);        this.userDocumentReference = mock(DocumentReference.class);        this.userProperties = mock(UserProperties.class);        when(this.userPropertiesResolver.resolve(this.userReference)).thenReturn(this.userProperties);        when(this.userReference.getReference()).thenReturn(this.userDocumentReference);        this.context = mock(XWikiContext.class);        when(this.contextProvider.get()).thenReturn(this.context);        this.xWiki = mock(XWiki.class);        when(this.context.getWiki()).thenReturn(this.xWiki);        this.userDocument = mock(XWikiDocument.class);        when(this.xWiki.getDocument(this.userDocumentReference, this.context)).thenReturn(this.userDocument);        this.resetPasswordMailSender = mock(ResetPasswordMailSender.class);        when(this.resetPasswordMailSenderProvider.get()).thenReturn(this.resetPasswordMailSender);    }    @Test    void requestResetPassword() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE, true, this.context))            .thenReturn(xObject);        String verificationCode = \"abcde1234\";        when(this.xWiki.generateRandomString(30)).thenReturn(verificationCode);        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.versionComment\"))            .thenReturn(\"Save verification code 42\");        ResetPasswordRequestResponse expectedResult =            new DefaultResetPasswordRequestResponse(this.userReference, verificationCode);        assertEquals(expectedResult, this.resetPasswordManager.requestResetPassword(this.userReference));        verify(xObject).set(DefaultResetPasswordManager.VERIFICATION_PROPERTY, verificationCode, context);        verify(this.xWiki).saveDocument(this.userDocument, \"Save verification code 42\", true, this.context);    }    @Test    void requestResetPasswordUnexistingUser() throws ResetPasswordException    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(false);        assertEquals(new DefaultResetPasswordRequestResponse(this.userReference, null),            this.resetPasswordManager.requestResetPassword(this.userReference));    }    @Test    void requestResetPasswordNotDocumentReferenceUser()    {        UserReference otherUserReference = mock(UserReference.class);        when(this.userManager.exists(otherUserReference)).thenReturn(true);        String exceptionMessage = \"Only user having a page on the wiki can reset their password.\";        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.requestResetPassword(otherUserReference));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void requestResetPasswordNoEmail() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        assertEquals(new DefaultResetPasswordRequestResponse(this.userReference, null),            this.resetPasswordManager.requestResetPassword(this.userReference));        when(this.userReference.toString()).thenReturn(\"foo\");        assertEquals(\"User [foo] asked to reset their password, but did not have any email configured.\",            logCapture.getMessage(0));    }    @Test    void requestResetPasswordLdapUser() throws Exception    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.LDAP_CLASS_REFERENCE))            .thenReturn(xObject);        String exceptionMessage = \"User [user:Foobar] is an LDAP user.\";        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.ldapUser\",            \"user:Foobar\")).thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.requestResetPassword(this.userReference));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void sendResetPasswordEmailRequest() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        when(this.referenceSerializer.serialize(this.userReference)).thenReturn(\"user:Foobar\");        when(this.userProperties.getFirstName()).thenReturn(\"Foo\");        when(this.userProperties.getLastName()).thenReturn(\"Bar\");        AuthenticationResourceReference resourceReference =            new AuthenticationResourceReference(AuthenticationAction.RESET_PASSWORD);        String verificationCode = \"foobar4242\";        resourceReference.addParameter(\"u\", \"user:Foobar\");        resourceReference.addParameter(\"v\", verificationCode);        ExtendedURL firstExtendedURL =            new ExtendedURL(Arrays.asList(\"authenticate\", \"reset\"), resourceReference.getParameters());        when(this.resourceReferenceSerializer.serialize(resourceReference)).thenReturn(firstExtendedURL);        when(this.urlNormalizer.normalize(firstExtendedURL)).thenReturn(            new ExtendedURL(Arrays.asList(\"xwiki\", \"authenticate\", \"reset\"), resourceReference.getParameters())        );        XWikiURLFactory urlFactory = mock(XWikiURLFactory.class);        when(this.context.getURLFactory()).thenReturn(urlFactory);        when(urlFactory.getServerURL(this.context)).thenReturn(new URL(\"http:        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        DefaultResetPasswordRequestResponse requestResponse =            new DefaultResetPasswordRequestResponse(this.userReference, verificationCode);        this.resetPasswordManager.sendResetPasswordEmailRequest(requestResponse);        verify(this.resetPasswordMailSender).sendResetPasswordEmail(\"Foo Bar\", email,            new URL(\"http:    }    @Test    void checkVerificationCode() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        String verificationCode = \"abcd1245\";        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE))            .thenReturn(xObject);        String encodedVerificationCode = \"encodedVerificationCode\";        when(xObject.getStringValue(DefaultResetPasswordManager.VERIFICATION_PROPERTY))            .thenReturn(encodedVerificationCode);        BaseClass baseClass = mock(BaseClass.class);        when(xObject.getXClass(context)).thenReturn(baseClass);        PasswordClass passwordClass = mock(PasswordClass.class);        when(baseClass.get(DefaultResetPasswordManager.VERIFICATION_PROPERTY)).thenReturn(passwordClass);        when(passwordClass.getEquivalentPassword(encodedVerificationCode, verificationCode))            .thenReturn(encodedVerificationCode);        String newVerificationCode = \"foobartest\";        when(xWiki.generateRandomString(30)).thenReturn(newVerificationCode);        String saveComment = \"Save new verification code\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.changeValidationKey\"))            .thenReturn(saveComment);        DefaultResetPasswordRequestResponse expected =            new DefaultResetPasswordRequestResponse(this.userReference, newVerificationCode);        assertEquals(expected, this.resetPasswordManager.checkVerificationCode(this.userReference, verificationCode));        verify(this.xWiki).saveDocument(this.userDocument, saveComment, true, context);    }    @Test    void checkVerificationCodeUnexistingUser() throws ResetPasswordException    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(false);        ResetPasswordRequestResponse resetPasswordRequestResponse =            this.resetPasswordManager.checkVerificationCode(this.userReference, \"some code\");        assertEquals(new DefaultResetPasswordRequestResponse(this.userReference, null), resetPasswordRequestResponse);    }    @Test    void checkVerificationCodeWrongCode() throws Exception    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        String verificationCode = \"abcd1245\";        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE))            .thenReturn(xObject);        String encodedVerificationCode = \"encodedVerificationCode\";        when(xObject.getStringValue(DefaultResetPasswordManager.VERIFICATION_PROPERTY))            .thenReturn(encodedVerificationCode);        BaseClass baseClass = mock(BaseClass.class);        when(xObject.getXClass(context)).thenReturn(baseClass);        PasswordClass passwordClass = mock(PasswordClass.class);        when(baseClass.get(DefaultResetPasswordManager.VERIFICATION_PROPERTY)).thenReturn(passwordClass);        when(passwordClass.getEquivalentPassword(encodedVerificationCode, verificationCode))            .thenReturn(\"anotherCode\");        String newVerificationCode = \"foobartest\";        when(xWiki.generateRandomString(30)).thenReturn(newVerificationCode);        String saveComment = \"Save new verification code\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.changeValidationKey\"))            .thenReturn(saveComment);        String exceptionMessage = \"Wrong verification code\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.error.wrongParameters\", \"user:Foobar\"))            .thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.checkVerificationCode(this.userReference, verificationCode));        assertEquals(exceptionMessage, resetPasswordException.getMessage());        verify(this.xWiki).saveDocument(this.userDocument, saveComment, true, context);    }    @Test    void checkVerificationCodeNotDocumentReferenceUser() throws Exception    {        UserReference otherUserReference = mock(UserReference.class);        when(this.userManager.exists(otherUserReference)).thenReturn(true);        String exceptionMessage = \"Only user having a page on the wiki can reset their password.\";        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.checkVerificationCode(otherUserReference, \"some code\"));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void resetPassword() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.USER_CLASS_REFERENCE))            .thenReturn(xObject);        String saveComment = \"Change password\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.passwordReset\"))            .thenReturn(saveComment);        String newPassword = \"mypassword\";        this.resetPasswordManager.resetPassword(this.userReference, newPassword);        verify(this.userDocument).removeXObjects(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE);        verify(xObject).setStringValue(\"password\", newPassword);    }    @Test    void resetPasswordUnexistingUser() throws Exception    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(false);        this.resetPasswordManager.resetPassword(this.userReference, \"some password\");        verify(this.xWiki, never()).getDocument(any(DocumentReference.class), any(XWikiContext.class));        verify(this.xWiki, never()).saveDocument(any(XWikiDocument.class), anyString(), anyBoolean(),            any(XWikiContext.class));    }    @Test    void resetPasswordNotDocumentReferenceUser() throws Exception    {        UserReference otherUserReference = mock(UserReference.class);        when(this.userManager.exists(otherUserReference)).thenReturn(true);        String exceptionMessage = \"Only user having a page on the wiki can reset their password.\";        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.resetPassword(otherUserReference, \"some password\"));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }}", "nl": "import java.net.URL;import java.util.Arrays;import javax.inject.Named;import javax.inject.Provider;import javax.mail.internet.InternetAddress;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.model.reference.DocumentReference;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserManager;import org.xwiki.user.UserProperties;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.user.UserReference;import org.xwiki.user.UserReferenceSerializer;import org.xwiki.user.internal.document.DocumentUserReference;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;import com.xpn.xwiki.web.XWikiURLFactory;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentTestclass DefaultResetPasswordManagerTest{    @InjectMockComponents    private DefaultResetPasswordManager resetPasswordManager;    @MockComponent    private UserManager userManager;    @MockComponent    private UserPropertiesResolver userPropertiesResolver;    @MockComponent    private ContextualLocalizationManager localizationManager;    @MockComponent    private Provider<XWikiContext> contextProvider;    @MockComponent    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> resourceReferenceSerializer;    @MockComponent    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @MockComponent    private UserReferenceSerializer<String> referenceSerializer;    @MockComponent    private Provider<ResetPasswordMailSender> resetPasswordMailSenderProvider;    private ResetPasswordMailSender resetPasswordMailSender;    private DocumentUserReference userReference;    private DocumentReference userDocumentReference;    private UserProperties userProperties;    private XWikiContext context;    private XWiki xWiki;    private XWikiDocument userDocument;    @BeforeEach    void setup() throws Exception    {        this.userReference = mock(DocumentUserReference.class);        this.userDocumentReference = mock(DocumentReference.class);        this.userProperties = mock(UserProperties.class);        when(this.userPropertiesResolver.resolve(this.userReference)).thenReturn(this.userProperties);        when(this.userReference.getReference()).thenReturn(this.userDocumentReference);        this.context = mock(XWikiContext.class);        when(this.contextProvider.get()).thenReturn(this.context);        this.xWiki = mock(XWiki.class);        when(this.context.getWiki()).thenReturn(this.xWiki);        this.userDocument = mock(XWikiDocument.class);        when(this.xWiki.getDocument(this.userDocumentReference, this.context)).thenReturn(this.userDocument);        this.resetPasswordMailSender = mock(ResetPasswordMailSender.class);        when(this.resetPasswordMailSenderProvider.get()).thenReturn(this.resetPasswordMailSender);    }    @Test    void requestResetPassword() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE, true, this.context))            .thenReturn(xObject);        String verificationCode = \"abcde1234\";        when(this.xWiki.generateRandomString(30)).thenReturn(verificationCode);        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.versionComment\"))            .thenReturn(\"Save verification code 42\");        ResetPasswordRequestResponse expectedResult =            new DefaultResetPasswordRequestResponse(this.userReference, email,                verificationCode);        assertEquals(expectedResult, this.resetPasswordManager.requestResetPassword(this.userReference));        verify(xObject).set(DefaultResetPasswordManager.VERIFICATION_PROPERTY, verificationCode, context);        verify(this.xWiki).saveDocument(this.userDocument, \"Save verification code 42\", true, this.context);    }    @Test    void requestResetPasswordUnexistingUser()    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(false);        String exceptionMessage = \"User [user:Foobar] doesn't exist\";        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.noUser\",            \"user:Foobar\")).thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.requestResetPassword(this.userReference));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void requestResetPasswordNotDocumentReferenceUser()    {        UserReference otherUserReference = mock(UserReference.class);        when(this.userManager.exists(otherUserReference)).thenReturn(true);        String exceptionMessage = \"Only user having a page on the wiki can reset their password.\";        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.requestResetPassword(otherUserReference));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void requestResetPasswordNoEmail() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        String exceptionMessage = \"User has no email address.\";        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.noEmail\"))            .thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.requestResetPassword(this.userReference));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void requestResetPasswordLdapUser() throws Exception    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.LDAP_CLASS_REFERENCE))            .thenReturn(xObject);        String exceptionMessage = \"User [user:Foobar] is an LDAP user.\";        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.ldapUser\",            \"user:Foobar\")).thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.requestResetPassword(this.userReference));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void sendResetPasswordEmailRequest() throws Exception    {        when(this.referenceSerializer.serialize(this.userReference)).thenReturn(\"user:Foobar\");        when(this.userProperties.getFirstName()).thenReturn(\"Foo\");        when(this.userProperties.getLastName()).thenReturn(\"Bar\");        AuthenticationResourceReference resourceReference =            new AuthenticationResourceReference(AuthenticationAction.RESET_PASSWORD);        String verificationCode = \"foobar4242\";        resourceReference.addParameter(\"u\", \"user:Foobar\");        resourceReference.addParameter(\"v\", verificationCode);        ExtendedURL firstExtendedURL =            new ExtendedURL(Arrays.asList(\"authenticate\", \"reset\"), resourceReference.getParameters());        when(this.resourceReferenceSerializer.serialize(resourceReference)).thenReturn(firstExtendedURL);        when(this.urlNormalizer.normalize(firstExtendedURL)).thenReturn(            new ExtendedURL(Arrays.asList(\"xwiki\", \"authenticate\", \"reset\"), resourceReference.getParameters())        );        XWikiURLFactory urlFactory = mock(XWikiURLFactory.class);        when(this.context.getURLFactory()).thenReturn(urlFactory);        when(urlFactory.getServerURL(this.context)).thenReturn(new URL(\"http:        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        DefaultResetPasswordRequestResponse requestResponse =            new DefaultResetPasswordRequestResponse(this.userReference, email,                verificationCode);        this.resetPasswordManager.sendResetPasswordEmailRequest(requestResponse);        verify(this.resetPasswordMailSender).sendResetPasswordEmail(\"Foo Bar\", email,            new URL(\"http:    }    @Test    void checkVerificationCode() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        String verificationCode = \"abcd1245\";        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE))            .thenReturn(xObject);        String encodedVerificationCode = \"encodedVerificationCode\";        when(xObject.getStringValue(DefaultResetPasswordManager.VERIFICATION_PROPERTY))            .thenReturn(encodedVerificationCode);        BaseClass baseClass = mock(BaseClass.class);        when(xObject.getXClass(context)).thenReturn(baseClass);        PasswordClass passwordClass = mock(PasswordClass.class);        when(baseClass.get(DefaultResetPasswordManager.VERIFICATION_PROPERTY)).thenReturn(passwordClass);        when(passwordClass.getEquivalentPassword(encodedVerificationCode, verificationCode))            .thenReturn(encodedVerificationCode);        String newVerificationCode = \"foobartest\";        when(xWiki.generateRandomString(30)).thenReturn(newVerificationCode);        String saveComment = \"Save new verification code\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.changeValidationKey\"))            .thenReturn(saveComment);        DefaultResetPasswordRequestResponse expected =            new DefaultResetPasswordRequestResponse(this.userReference, email,                newVerificationCode);        assertEquals(expected, this.resetPasswordManager.checkVerificationCode(this.userReference, verificationCode));        verify(this.xWiki).saveDocument(this.userDocument, saveComment, true, context);    }    @Test    void checkVerificationCodeUnexistingUser()    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(false);        String exceptionMessage = \"User [user:Foobar] doesn't exist\";        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.noUser\",            \"user:Foobar\")).thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.checkVerificationCode(this.userReference, \"some code\"));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void checkVerificationCodeWrongCode() throws Exception    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(true);        InternetAddress email = new InternetAddress(\"foobar@xwiki.org\");        when(this.userProperties.getEmail()).thenReturn(email);        String verificationCode = \"abcd1245\";        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE))            .thenReturn(xObject);        String encodedVerificationCode = \"encodedVerificationCode\";        when(xObject.getStringValue(DefaultResetPasswordManager.VERIFICATION_PROPERTY))            .thenReturn(encodedVerificationCode);        BaseClass baseClass = mock(BaseClass.class);        when(xObject.getXClass(context)).thenReturn(baseClass);        PasswordClass passwordClass = mock(PasswordClass.class);        when(baseClass.get(DefaultResetPasswordManager.VERIFICATION_PROPERTY)).thenReturn(passwordClass);        when(passwordClass.getEquivalentPassword(encodedVerificationCode, verificationCode))            .thenReturn(\"anotherCode\");        String newVerificationCode = \"foobartest\";        when(xWiki.generateRandomString(30)).thenReturn(newVerificationCode);        String saveComment = \"Save new verification code\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.changeValidationKey\"))            .thenReturn(saveComment);        String exceptionMessage = \"Wrong verification code\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.error.wrongParameters\", \"user:Foobar\"))            .thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.checkVerificationCode(this.userReference, verificationCode));        assertEquals(exceptionMessage, resetPasswordException.getMessage());        verify(this.xWiki).saveDocument(this.userDocument, saveComment, true, context);    }    @Test    void checkVerificationCodeNotDocumentReferenceUser() throws Exception    {        UserReference otherUserReference = mock(UserReference.class);        when(this.userManager.exists(otherUserReference)).thenReturn(true);        String exceptionMessage = \"Only user having a page on the wiki can reset their password.\";        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.checkVerificationCode(otherUserReference, \"some code\"));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void resetPassword() throws Exception    {        when(this.userManager.exists(this.userReference)).thenReturn(true);        BaseObject xObject = mock(BaseObject.class);        when(this.userDocument            .getXObject(DefaultResetPasswordManager.USER_CLASS_REFERENCE))            .thenReturn(xObject);        String saveComment = \"Change password\";        when(this.localizationManager            .getTranslationPlain(\"xe.admin.passwordReset.step2.versionComment.passwordReset\"))            .thenReturn(saveComment);        String newPassword = \"mypassword\";        this.resetPasswordManager.resetPassword(this.userReference, newPassword);        verify(this.userDocument).removeXObjects(DefaultResetPasswordManager.RESET_PASSWORD_REQUEST_CLASS_REFERENCE);        verify(xObject).setStringValue(\"password\", newPassword);    }    @Test    void resetPasswordUnexistingUser() throws Exception    {        when(this.userReference.toString()).thenReturn(\"user:Foobar\");        when(this.userManager.exists(this.userReference)).thenReturn(false);        String exceptionMessage = \"User [user:Foobar] doesn't exist\";        when(this.localizationManager.getTranslationPlain(\"xe.admin.passwordReset.error.noUser\",            \"user:Foobar\")).thenReturn(exceptionMessage);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.resetPassword(this.userReference, \"some password\"));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }    @Test    void resetPasswordNotDocumentReferenceUser() throws Exception    {        UserReference otherUserReference = mock(UserReference.class);        when(this.userManager.exists(otherUserReference)).thenReturn(true);        String exceptionMessage = \"Only user having a page on the wiki can reset their password.\";        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.resetPasswordManager.resetPassword(otherUserReference, \"some password\"));        assertEquals(exceptionMessage, resetPasswordException.getMessage());    }}"}
{"code": "import java.util.Collections;import java.util.Map;import java.util.Set;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import org.slf4j.Logger;import org.xwiki.component.annotation.Component;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.resource.SerializeResourceReferenceException;import org.xwiki.resource.UnsupportedResourceReferenceException;import org.xwiki.script.service.ScriptService;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.security.authentication.AuthenticationConfiguration;import org.xwiki.security.authentication.AuthenticationFailureManager;import org.xwiki.security.authentication.AuthenticationFailureStrategy;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.security.script.SecurityScriptService;import org.xwiki.stability.Unstable;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserReference;import com.xpn.xwiki.XWikiContext;@Component@Named(SecurityScriptService.ROLEHINT + '.' + AuthenticationScriptService.ID)@Singletonpublic class AuthenticationScriptService implements ScriptService{    public static final String ID = \"authentication\";    @Inject    private AuthenticationFailureManager authenticationFailureManager;    @Inject    private AuthenticationConfiguration authenticationConfiguration;    @Inject    private ComponentManager componentManager;    @Inject    private Provider<XWikiContext> contextProvider;    @Inject    private ContextualAuthorizationManager authorizationManager;    @Inject    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> defaultResourceReferenceSerializer;    @Inject    private ResetPasswordManager resetPasswordManager;    @Inject    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @Inject    private Logger logger;    public String getForm(String username)    {        return this.authenticationFailureManager.getForm(username, contextProvider.get().getRequest());    }    public String getErrorMessage(String username)    {        return this.authenticationFailureManager.getErrorMessage(username);    }    public Set<String> getAuthenticationFailureAvailableStrategies()    {        try {            return this.componentManager.getInstanceMap(AuthenticationFailureStrategy.class).keySet();        } catch (ComponentLookupException e) {            logger.error(\"Error while getting the list of available authentication strategies.\");            return Collections.emptySet();        }    }    public AuthenticationConfiguration getAuthenticationConfiguration()    {        return this.authenticationConfiguration;    }    public void resetAuthenticationFailureCounter(String username)    {        if (this.authorizationManager.hasAccess(Right.PROGRAM)) {            this.authenticationFailureManager.resetAuthenticationFailureCounter(username);        }    }    @Unstable    public String getAuthenticationURL(String action, Map<String, Object> params)    {        try {            AuthenticationAction authenticationAction = AuthenticationAction.getFromRequestParameter(action);            AuthenticationResourceReference resourceReference =                new AuthenticationResourceReference(authenticationAction);            if (params != null) {                for (Map.Entry<String, Object> entry : params.entrySet()) {                    resourceReference.addParameter(entry.getKey(), entry.getValue());                }            }            ExtendedURL extendedURL = this.defaultResourceReferenceSerializer.serialize(resourceReference);            return this.urlNormalizer.normalize(extendedURL).serialize();        } catch (IllegalArgumentException | SerializeResourceReferenceException            | UnsupportedResourceReferenceException e)        {            logger.error(\"Error while getting authentication URL for action [{}].\", action, e);            return null;        }    }    @Unstable    public void requestResetPassword(UserReference user) throws ResetPasswordException    {        if (this.authorizationManager.hasAccess(Right.PROGRAM)) {            ResetPasswordRequestResponse resetPasswordRequestResponse =                this.resetPasswordManager.requestResetPassword(user);            this.resetPasswordManager.sendResetPasswordEmailRequest(resetPasswordRequestResponse);        }    }    @Unstable    public String checkVerificationCode(UserReference user, String verificationCode)        throws ResetPasswordException    {        return this.resetPasswordManager.checkVerificationCode(user, verificationCode).getVerificationCode();    }    @Unstable    public void resetPassword(UserReference user, String verificationCode, String newPassword)        throws ResetPasswordException    {        this.resetPasswordManager.checkVerificationCode(user, verificationCode);        this.resetPasswordManager.resetPassword(user, newPassword);    }}", "nl": "import java.util.Collections;import java.util.Map;import java.util.Set;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import javax.mail.internet.InternetAddress;import org.slf4j.Logger;import org.xwiki.component.annotation.Component;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.resource.SerializeResourceReferenceException;import org.xwiki.resource.UnsupportedResourceReferenceException;import org.xwiki.script.service.ScriptService;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.security.authentication.AuthenticationConfiguration;import org.xwiki.security.authentication.AuthenticationFailureManager;import org.xwiki.security.authentication.AuthenticationFailureStrategy;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.security.script.SecurityScriptService;import org.xwiki.stability.Unstable;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserReference;import com.xpn.xwiki.XWikiContext;@Component@Named(SecurityScriptService.ROLEHINT + '.' + AuthenticationScriptService.ID)@Singletonpublic class AuthenticationScriptService implements ScriptService{    public static final String ID = \"authentication\";    @Inject    private AuthenticationFailureManager authenticationFailureManager;    @Inject    private AuthenticationConfiguration authenticationConfiguration;    @Inject    private ComponentManager componentManager;    @Inject    private Provider<XWikiContext> contextProvider;    @Inject    private ContextualAuthorizationManager authorizationManager;    @Inject    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> defaultResourceReferenceSerializer;    @Inject    private ResetPasswordManager resetPasswordManager;    @Inject    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @Inject    private Logger logger;    public String getForm(String username)    {        return this.authenticationFailureManager.getForm(username, contextProvider.get().getRequest());    }    public String getErrorMessage(String username)    {        return this.authenticationFailureManager.getErrorMessage(username);    }    public Set<String> getAuthenticationFailureAvailableStrategies()    {        try {            return this.componentManager.getInstanceMap(AuthenticationFailureStrategy.class).keySet();        } catch (ComponentLookupException e) {            logger.error(\"Error while getting the list of available authentication strategies.\");            return Collections.emptySet();        }    }    public AuthenticationConfiguration getAuthenticationConfiguration()    {        return this.authenticationConfiguration;    }    public void resetAuthenticationFailureCounter(String username)    {        if (this.authorizationManager.hasAccess(Right.PROGRAM)) {            this.authenticationFailureManager.resetAuthenticationFailureCounter(username);        }    }    @Unstable    public String getAuthenticationURL(String action, Map<String, Object> params)    {        try {            AuthenticationAction authenticationAction = AuthenticationAction.getFromRequestParameter(action);            AuthenticationResourceReference resourceReference =                new AuthenticationResourceReference(authenticationAction);            if (params != null) {                for (Map.Entry<String, Object> entry : params.entrySet()) {                    resourceReference.addParameter(entry.getKey(), entry.getValue());                }            }            ExtendedURL extendedURL = this.defaultResourceReferenceSerializer.serialize(resourceReference);            return this.urlNormalizer.normalize(extendedURL).serialize();        } catch (IllegalArgumentException | SerializeResourceReferenceException            | UnsupportedResourceReferenceException e)        {            logger.error(\"Error while getting authentication URL for action [{}].\", action, e);            return null;        }    }    @Unstable    public InternetAddress requestResetPassword(UserReference user) throws ResetPasswordException    {        if (this.authorizationManager.hasAccess(Right.PROGRAM)) {            ResetPasswordRequestResponse resetPasswordRequestResponse =                this.resetPasswordManager.requestResetPassword(user);            this.resetPasswordManager.sendResetPasswordEmailRequest(resetPasswordRequestResponse);            return resetPasswordRequestResponse.getUserEmail();        } else {            return null;        }    }    @Unstable    public String checkVerificationCode(UserReference user, String verificationCode)        throws ResetPasswordException    {        return this.resetPasswordManager.checkVerificationCode(user, verificationCode).getVerificationCode();    }    @Unstable    public void resetPassword(UserReference user, String verificationCode, String newPassword)        throws ResetPasswordException    {        this.resetPasswordManager.checkVerificationCode(user, verificationCode);        this.resetPasswordManager.resetPassword(user, newPassword);    }}"}
{"code": "import java.util.Arrays;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import javax.inject.Named;import javax.inject.Provider;import javax.mail.internet.InternetAddress;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.RegisterExtension;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.security.authentication.AuthenticationConfiguration;import org.xwiki.security.authentication.AuthenticationFailureManager;import org.xwiki.security.authentication.AuthenticationFailureStrategy;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.test.LogLevel;import org.xwiki.test.junit5.LogCaptureExtension;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.test.mockito.MockitoComponentManager;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserReference;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.web.XWikiRequest;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentTestclass AuthenticationScriptServiceTest{    @InjectMockComponents    private AuthenticationScriptService scriptService;    @MockComponent    private AuthenticationFailureManager authenticationFailureManager;    @MockComponent    private AuthenticationConfiguration authenticationConfiguration;    @MockComponent    private Provider<XWikiContext> contextProvider;    @MockComponent    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> defaultResourceReferenceSerializer;    @MockComponent    private ResetPasswordManager resetPasswordManager;    @MockComponent    private ContextualAuthorizationManager authorizationManager;    @MockComponent    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @RegisterExtension    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.WARN);    private XWikiContext xWikiContext;    @BeforeEach    void setup()    {        this.xWikiContext = mock(XWikiContext.class);        when(this.contextProvider.get()).thenReturn(this.xWikiContext);    }    @Test    void getForm()    {        String username = \"foobar\";        XWikiRequest xWikiRequest = mock(XWikiRequest.class);        when(this.xWikiContext.getRequest()).thenReturn(xWikiRequest);        when(this.authenticationFailureManager.getForm(username, xWikiRequest)).thenReturn(\"my specific form\");        assertEquals(\"my specific form\", this.scriptService.getForm(username));    }    @Test    void getErrorMessage()    {        String username = \"foobar\";        when(this.authenticationFailureManager.getErrorMessage(username)).thenReturn(\"Some error message\");        assertEquals(\"Some error message\", this.scriptService.getErrorMessage(username));    }    @Test    void getAuthenticationConfiguration()    {        assertEquals(this.authenticationConfiguration, this.scriptService.getAuthenticationConfiguration());    }    @Test    void getAuthenticationFailureAvailableStrategies(MockitoComponentManager componentManager) throws Exception    {        componentManager.registerMockComponent(AuthenticationFailureStrategy.class, \"instance1\");        componentManager.registerMockComponent(AuthenticationFailureStrategy.class, \"instance2\");        Set<String> expectedResult = new HashSet<>(Arrays.asList(\"instance1\", \"instance2\"));        assertEquals(expectedResult, this.scriptService.getAuthenticationFailureAvailableStrategies());    }    @Test    void resetAuthenticationFailureCounter()    {        String username = \"foobar\";        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(true);        this.scriptService.resetAuthenticationFailureCounter(username);        verify(this.authenticationFailureManager).resetAuthenticationFailureCounter(username);    }    @Test    void resetAuthenticationFailureCounterWithoutPR()    {        String username = \"foobar\";        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(false);        this.scriptService.resetAuthenticationFailureCounter(username);        verify(this.authenticationFailureManager, never()).resetAuthenticationFailureCounter(username);    }    @Test    void getAuthenticationURL() throws Exception    {        String action = AuthenticationAction.FORGOT_USERNAME.getRequestParameter();        Map<String, Object> parameters = new HashMap<>();        parameters.put(\"u\", \"foo\");        parameters.put(\"v\", \"bar\");        AuthenticationResourceReference resourceReference =            new AuthenticationResourceReference(AuthenticationAction.FORGOT_USERNAME);        resourceReference.addParameter(\"u\", \"foo\");        resourceReference.addParameter(\"v\", \"bar\");        ExtendedURL extendedURL = mock(ExtendedURL.class);        when(this.defaultResourceReferenceSerializer.serialize(resourceReference)).thenReturn(extendedURL);        ExtendedURL extendedURLNormalized = mock(ExtendedURL.class);        when(this.urlNormalizer.normalize(extendedURL)).thenReturn(extendedURLNormalized);        when(extendedURLNormalized.serialize()).thenReturn(\"http:        assertEquals(\"http:    }    @Test    void requestResetPassword() throws Exception    {        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(true);        UserReference userReference = mock(UserReference.class);        ResetPasswordRequestResponse requestResponse = mock(ResetPasswordRequestResponse.class);        when(this.resetPasswordManager.requestResetPassword(userReference)).thenReturn(requestResponse);        InternetAddress userEmail = new InternetAddress(\"acme@xwiki.org\");        this.scriptService.requestResetPassword(userReference);        verify(this.resetPasswordManager).sendResetPasswordEmailRequest(requestResponse);    }    @Test    void requestResetPasswordWithoutPR() throws Exception    {        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(false);        this.scriptService.requestResetPassword(mock(UserReference.class));        verify(this.resetPasswordManager, never()).requestResetPassword(any());        verify(this.resetPasswordManager, never()).sendResetPasswordEmailRequest(any());    }    @Test    void checkVerificationCode() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"verificationCode\";        ResetPasswordRequestResponse requestResponse = mock(ResetPasswordRequestResponse.class);        String newVerificationCode = \"4242\";        when(this.resetPasswordManager.checkVerificationCode(userReference, verificationCode))            .thenReturn(requestResponse);        when(requestResponse.getVerificationCode()).thenReturn(newVerificationCode);        assertEquals(newVerificationCode, this.scriptService.checkVerificationCode(userReference, verificationCode));    }    @Test    void checkVerificationCodeBadCode() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"verificationCode\";        ResetPasswordException expectedException = new ResetPasswordException(\"Bad verification code\");        when(this.resetPasswordManager.checkVerificationCode(userReference, verificationCode))            .thenThrow(expectedException);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.scriptService.checkVerificationCode(userReference, verificationCode));        assertEquals(expectedException, resetPasswordException);    }    @Test    void resetPassword() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"code\";        String newPassword = \"foobar\";        this.scriptService.resetPassword(userReference, verificationCode, newPassword);        verify(this.resetPasswordManager).checkVerificationCode(userReference, verificationCode);        verify(this.resetPasswordManager).resetPassword(userReference, newPassword);    }    @Test    void resetPasswordBadCode() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"verificationCode\";        ResetPasswordException expectedException = new ResetPasswordException(\"Bad verification code\");        when(this.resetPasswordManager.checkVerificationCode(userReference, verificationCode))            .thenThrow(expectedException);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.scriptService.resetPassword(userReference, verificationCode, \"some password\"));        assertEquals(expectedException, resetPasswordException);        verify(this.resetPasswordManager, never()).resetPassword(eq(userReference), any());    }}", "nl": "import java.util.Arrays;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import javax.inject.Named;import javax.inject.Provider;import javax.mail.internet.InternetAddress;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.RegisterExtension;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceSerializer;import org.xwiki.security.authentication.AuthenticationAction;import org.xwiki.security.authentication.ResetPasswordRequestResponse;import org.xwiki.security.authentication.AuthenticationConfiguration;import org.xwiki.security.authentication.AuthenticationFailureManager;import org.xwiki.security.authentication.AuthenticationFailureStrategy;import org.xwiki.security.authentication.AuthenticationResourceReference;import org.xwiki.security.authentication.ResetPasswordException;import org.xwiki.security.authentication.ResetPasswordManager;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.test.LogLevel;import org.xwiki.test.junit5.LogCaptureExtension;import org.xwiki.test.junit5.mockito.ComponentTest;import org.xwiki.test.junit5.mockito.InjectMockComponents;import org.xwiki.test.junit5.mockito.MockComponent;import org.xwiki.test.mockito.MockitoComponentManager;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLNormalizer;import org.xwiki.user.UserReference;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.web.XWikiRequest;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;@ComponentTestclass AuthenticationScriptServiceTest{    @InjectMockComponents    private AuthenticationScriptService scriptService;    @MockComponent    private AuthenticationFailureManager authenticationFailureManager;    @MockComponent    private AuthenticationConfiguration authenticationConfiguration;    @MockComponent    private Provider<XWikiContext> contextProvider;    @MockComponent    private ResourceReferenceSerializer<ResourceReference, ExtendedURL> defaultResourceReferenceSerializer;    @MockComponent    private ResetPasswordManager resetPasswordManager;    @MockComponent    private ContextualAuthorizationManager authorizationManager;    @MockComponent    @Named(\"contextpath\")    private URLNormalizer<ExtendedURL> urlNormalizer;    @RegisterExtension    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.WARN);    private XWikiContext xWikiContext;    @BeforeEach    void setup()    {        this.xWikiContext = mock(XWikiContext.class);        when(this.contextProvider.get()).thenReturn(this.xWikiContext);    }    @Test    void getForm()    {        String username = \"foobar\";        XWikiRequest xWikiRequest = mock(XWikiRequest.class);        when(this.xWikiContext.getRequest()).thenReturn(xWikiRequest);        when(this.authenticationFailureManager.getForm(username, xWikiRequest)).thenReturn(\"my specific form\");        assertEquals(\"my specific form\", this.scriptService.getForm(username));    }    @Test    void getErrorMessage()    {        String username = \"foobar\";        when(this.authenticationFailureManager.getErrorMessage(username)).thenReturn(\"Some error message\");        assertEquals(\"Some error message\", this.scriptService.getErrorMessage(username));    }    @Test    void getAuthenticationConfiguration()    {        assertEquals(this.authenticationConfiguration, this.scriptService.getAuthenticationConfiguration());    }    @Test    void getAuthenticationFailureAvailableStrategies(MockitoComponentManager componentManager) throws Exception    {        componentManager.registerMockComponent(AuthenticationFailureStrategy.class, \"instance1\");        componentManager.registerMockComponent(AuthenticationFailureStrategy.class, \"instance2\");        Set<String> expectedResult = new HashSet<>(Arrays.asList(\"instance1\", \"instance2\"));        assertEquals(expectedResult, this.scriptService.getAuthenticationFailureAvailableStrategies());    }    @Test    void resetAuthenticationFailureCounter()    {        String username = \"foobar\";        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(true);        this.scriptService.resetAuthenticationFailureCounter(username);        verify(this.authenticationFailureManager).resetAuthenticationFailureCounter(username);    }    @Test    void resetAuthenticationFailureCounterWithoutPR()    {        String username = \"foobar\";        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(false);        this.scriptService.resetAuthenticationFailureCounter(username);        verify(this.authenticationFailureManager, never()).resetAuthenticationFailureCounter(username);    }    @Test    void getAuthenticationURL() throws Exception    {        String action = AuthenticationAction.FORGOT_USERNAME.getRequestParameter();        Map<String, Object> parameters = new HashMap<>();        parameters.put(\"u\", \"foo\");        parameters.put(\"v\", \"bar\");        AuthenticationResourceReference resourceReference =            new AuthenticationResourceReference(AuthenticationAction.FORGOT_USERNAME);        resourceReference.addParameter(\"u\", \"foo\");        resourceReference.addParameter(\"v\", \"bar\");        ExtendedURL extendedURL = mock(ExtendedURL.class);        when(this.defaultResourceReferenceSerializer.serialize(resourceReference)).thenReturn(extendedURL);        ExtendedURL extendedURLNormalized = mock(ExtendedURL.class);        when(this.urlNormalizer.normalize(extendedURL)).thenReturn(extendedURLNormalized);        when(extendedURLNormalized.serialize()).thenReturn(\"http:        assertEquals(\"http:    }    @Test    void requestResetPassword() throws Exception    {        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(true);        UserReference userReference = mock(UserReference.class);        ResetPasswordRequestResponse requestResponse = mock(ResetPasswordRequestResponse.class);        when(this.resetPasswordManager.requestResetPassword(userReference)).thenReturn(requestResponse);        InternetAddress userEmail = new InternetAddress(\"acme@xwiki.org\");        when(requestResponse.getUserEmail()).thenReturn(userEmail);        assertEquals(userEmail, this.scriptService.requestResetPassword(userReference));        verify(this.resetPasswordManager).sendResetPasswordEmailRequest(requestResponse);    }    @Test    void requestResetPasswordWithoutPR() throws Exception    {        when(this.authorizationManager.hasAccess(Right.PROGRAM)).thenReturn(false);        assertNull(this.scriptService.requestResetPassword(mock(UserReference.class)));        verify(this.resetPasswordManager, never()).requestResetPassword(any());        verify(this.resetPasswordManager, never()).sendResetPasswordEmailRequest(any());    }    @Test    void checkVerificationCode() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"verificationCode\";        ResetPasswordRequestResponse requestResponse = mock(ResetPasswordRequestResponse.class);        String newVerificationCode = \"4242\";        when(this.resetPasswordManager.checkVerificationCode(userReference, verificationCode))            .thenReturn(requestResponse);        when(requestResponse.getVerificationCode()).thenReturn(newVerificationCode);        assertEquals(newVerificationCode, this.scriptService.checkVerificationCode(userReference, verificationCode));    }    @Test    void checkVerificationCodeBadCode() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"verificationCode\";        ResetPasswordException expectedException = new ResetPasswordException(\"Bad verification code\");        when(this.resetPasswordManager.checkVerificationCode(userReference, verificationCode))            .thenThrow(expectedException);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.scriptService.checkVerificationCode(userReference, verificationCode));        assertEquals(expectedException, resetPasswordException);    }    @Test    void resetPassword() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"code\";        String newPassword = \"foobar\";        this.scriptService.resetPassword(userReference, verificationCode, newPassword);        verify(this.resetPasswordManager).checkVerificationCode(userReference, verificationCode);        verify(this.resetPasswordManager).resetPassword(userReference, newPassword);    }    @Test    void resetPasswordBadCode() throws Exception    {        UserReference userReference = mock(UserReference.class);        String verificationCode = \"verificationCode\";        ResetPasswordException expectedException = new ResetPasswordException(\"Bad verification code\");        when(this.resetPasswordManager.checkVerificationCode(userReference, verificationCode))            .thenThrow(expectedException);        ResetPasswordException resetPasswordException = assertThrows(ResetPasswordException.class,            () -> this.scriptService.resetPassword(userReference, verificationCode, \"some password\"));        assertEquals(expectedException, resetPasswordException);        verify(this.resetPasswordManager, never()).resetPassword(eq(userReference), any());    }}"}
{"code": "import java.io.File;import java.io.IOException;import java.net.URL;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.inject.Inject;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.apache.http.NameValuePair;import org.apache.http.client.utils.URLEncodedUtils;import org.xwiki.model.reference.DocumentReference;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.url.filesystem.FilesystemExportContext;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.model.LegacySpaceResolver;import com.xpn.xwiki.web.ExportURLFactoryActionHandler;import com.xpn.xwiki.web.sx.Extension;import com.xpn.xwiki.web.sx.SxDocumentSource;import com.xpn.xwiki.web.sx.SxResourceSource;import com.xpn.xwiki.web.sx.SxSource;public abstract class AbstractSxExportURLFactoryActionHandler implements ExportURLFactoryActionHandler{    private static final String JAR_RESOURCE_REQUEST_PARAMETER = \"resource\";    private static final char URL_PATH_SEPARATOR = '/';    @Inject    private LegacySpaceResolver legacySpaceResolve;    @Inject    private ContextualAuthorizationManager authorizationManager;    protected abstract String getSxPrefix();    protected abstract String getFileSuffix();    public abstract Extension getExtensionType();    @Override    public URL createURL(String spaces, String name, String queryString, String anchor, String wikiId,        XWikiContext context, FilesystemExportContext exportContext) throws Exception    {        List<String> spaceNames = this.legacySpaceResolve.resolve(spaces);        DocumentReference sxDocumentReference = new DocumentReference(wikiId, spaceNames, name);        this.authorizationManager.checkAccess(Right.VIEW, sxDocumentReference);        XWikiDocument sxDocument = context.getWiki().getDocument(sxDocumentReference, context);        Map<String, Object> backup = new HashMap<>();        XWikiDocument.backupContext(backup, context);        try {            sxDocument.setAsContextDoc(context);            return processSx(sxDocument.getId(), queryString, context, exportContext);        } finally {            XWikiDocument.restoreContext(backup, context);        }    }    private URL processSx(long id, String queryString, XWikiContext context,        FilesystemExportContext exportContext) throws Exception    {        SxSource sxSource = null;        List<NameValuePair> params = URLEncodedUtils.parse(queryString, StandardCharsets.UTF_8);        for (NameValuePair param : params) {            if (param.getName().equals(JAR_RESOURCE_REQUEST_PARAMETER)) {                sxSource = new SxResourceSource(param.getValue());                break;            }        }        if (sxSource == null) {            sxSource = new SxDocumentSource(context, getExtensionType());        }        String content = getContent(sxSource, exportContext);        String targetPath = String.format(\"%s/%s\", getSxPrefix(), id);        File targetDirectory = new File(exportContext.getExportDir(), targetPath);        if (!targetDirectory.exists()) {            targetDirectory.mkdirs();        }        File targetLocation = File.createTempFile(getSxPrefix(), \".\" + getFileSuffix(), targetDirectory);        FileUtils.writeStringToFile(targetLocation, content);        StringBuilder path = new StringBuilder(\"file:        path.append(StringUtils.repeat(\"../\", exportContext.getDocParentLevel()));        path.append(getSxPrefix());        path.append(URL_PATH_SEPARATOR);        path.append(id);        path.append(URL_PATH_SEPARATOR);        path.append(encodeURLPart(targetLocation.getName()));        return new URL(path.toString());    }    protected String getContent(SxSource sxSource, FilesystemExportContext exportContext)    {        String content;        int originalDocParentLevel = exportContext.getDocParentLevel();        try {            exportContext.setDocParentLevels(2);            content = sxSource.getContent();        } finally {            exportContext.setDocParentLevels(originalDocParentLevel);        }        return content;    }    private String encodeURLPart(String part) throws IOException    {        return URLEncoder.encode(part, \"UTF-8\");    }}", "nl": "import java.io.File;import java.io.IOException;import java.net.URL;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.inject.Inject;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.apache.http.NameValuePair;import org.apache.http.client.utils.URLEncodedUtils;import org.xwiki.model.reference.DocumentReference;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.url.filesystem.FilesystemExportContext;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.model.LegacySpaceResolver;import com.xpn.xwiki.web.ExportURLFactoryActionHandler;import com.xpn.xwiki.web.sx.Extension;import com.xpn.xwiki.web.sx.SxDocumentSource;import com.xpn.xwiki.web.sx.SxResourceSource;import com.xpn.xwiki.web.sx.SxSource;public abstract class AbstractSxExportURLFactoryActionHandler implements ExportURLFactoryActionHandler{    private static final String JAR_RESOURCE_REQUEST_PARAMETER = \"resource\";    private static final char URL_PATH_SEPARATOR = '/';    @Inject    private LegacySpaceResolver legacySpaceResolve;    @Inject    private ContextualAuthorizationManager authorizationManager;    protected abstract String getSxPrefix();    protected abstract String getFileSuffix();    public abstract Extension getExtensionType();    @Override    public URL createURL(String spaces, String name, String queryString, String anchor, String wikiId,        XWikiContext context, FilesystemExportContext exportContext) throws Exception    {        List<String> spaceNames = this.legacySpaceResolve.resolve(spaces);        DocumentReference sxDocumentReference = new DocumentReference(wikiId, spaceNames, name);        this.authorizationManager.checkAccess(Right.VIEW, sxDocumentReference);        XWikiDocument sxDocument = context.getWiki().getDocument(sxDocumentReference, context);        Map<String, Object> backup = new HashMap<>();        XWikiDocument.backupContext(backup, context);        try {            sxDocument.setAsContextDoc(context);            return processSx(spaceNames, name, queryString, context, exportContext);        } finally {            XWikiDocument.restoreContext(backup, context);        }    }    private URL processSx(List<String> spaceNames, String name, String queryString, XWikiContext context,        FilesystemExportContext exportContext) throws Exception    {        SxSource sxSource = null;        List<NameValuePair> params = URLEncodedUtils.parse(queryString, StandardCharsets.UTF_8);        for (NameValuePair param : params) {            if (param.getName().equals(JAR_RESOURCE_REQUEST_PARAMETER)) {                sxSource = new SxResourceSource(param.getValue());                break;            }        }        if (sxSource == null) {            sxSource = new SxDocumentSource(context, getExtensionType());        }        String content = getContent(sxSource, exportContext);        String targetPath = String.format(\"%s/%s/%s\", getSxPrefix(), StringUtils.join(spaceNames, '/'), name);        File targetDirectory = new File(exportContext.getExportDir(), targetPath);        if (!targetDirectory.exists()) {            targetDirectory.mkdirs();        }        File targetLocation = File.createTempFile(getSxPrefix(), \".\" + getFileSuffix(), targetDirectory);        FileUtils.writeStringToFile(targetLocation, content);        StringBuilder path = new StringBuilder(\"file:        path.append(StringUtils.repeat(\"../\", exportContext.getDocParentLevel()));        path.append(getSxPrefix());        path.append(URL_PATH_SEPARATOR);        for (String spaceName : spaceNames) {            path.append(encodeURLPart(spaceName));            path.append(URL_PATH_SEPARATOR);        }        path.append(encodeURLPart(name));        path.append(URL_PATH_SEPARATOR);        path.append(encodeURLPart(targetLocation.getName()));        return new URL(path.toString());    }    protected String getContent(SxSource sxSource, FilesystemExportContext exportContext)    {        String content;        int originalDocParentLevel = exportContext.getDocParentLevel();        try {            exportContext.setDocParentLevels(3);            content = sxSource.getContent();        } finally {            exportContext.setDocParentLevels(originalDocParentLevel);        }        return content;    }    private String encodeURLPart(String part) throws IOException    {        return URLEncoder.encode(part, \"UTF-8\");    }}"}
{"code": "import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Type;import java.net.MalformedURLException;import java.net.URL;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.attribute.FileTime;import java.text.DateFormatSymbols;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.Enumeration;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Set;import java.util.TimeZone;import java.util.Vector;import java.util.concurrent.ConcurrentHashMap;import java.util.zip.ZipOutputStream;import javax.annotation.Priority;import javax.inject.Provider;import javax.mail.Message;import javax.mail.Session;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.naming.NamingException;import javax.script.ScriptContext;import javax.servlet.http.Cookie;import org.apache.commons.httpclient.Credentials;import org.apache.commons.httpclient.HttpClient;import org.apache.commons.httpclient.URIException;import org.apache.commons.httpclient.UsernamePasswordCredentials;import org.apache.commons.httpclient.auth.AuthScope;import org.apache.commons.httpclient.methods.GetMethod;import org.apache.commons.httpclient.util.URIUtil;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.ArrayUtils;import org.apache.commons.lang3.RandomStringUtils;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.commons.lang3.math.NumberUtils;import org.apache.commons.lang3.reflect.FieldUtils;import org.apache.velocity.VelocityContext;import org.hibernate.HibernateException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.bridge.event.DocumentCreatedEvent;import org.xwiki.bridge.event.DocumentCreatingEvent;import org.xwiki.bridge.event.DocumentDeletedEvent;import org.xwiki.bridge.event.DocumentDeletingEvent;import org.xwiki.bridge.event.DocumentRolledBackEvent;import org.xwiki.bridge.event.DocumentRollingBackEvent;import org.xwiki.bridge.event.DocumentUpdatedEvent;import org.xwiki.bridge.event.DocumentUpdatingEvent;import org.xwiki.bridge.event.DocumentVersionRangeDeletedEvent;import org.xwiki.bridge.event.DocumentVersionRangeDeletingEvent;import org.xwiki.bridge.event.WikiCopiedEvent;import org.xwiki.bridge.event.WikiDeletedEvent;import org.xwiki.cache.Cache;import org.xwiki.classloader.ClassLoaderManager;import org.xwiki.component.event.ComponentDescriptorAddedEvent;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.manager.NamespacedComponentManager;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.container.servlet.HttpServletUtils;import org.xwiki.context.Execution;import org.xwiki.edit.EditConfiguration;import org.xwiki.extension.job.internal.InstallJob;import org.xwiki.job.Job;import org.xwiki.job.JobException;import org.xwiki.job.JobExecutor;import org.xwiki.job.annotation.Serializable;import org.xwiki.job.event.JobFinishedEvent;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.event.status.JobStatus.State;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.mail.MailListener;import org.xwiki.mail.MailSender;import org.xwiki.mail.MailSenderConfiguration;import org.xwiki.mail.MailStatusResultSerializer;import org.xwiki.mail.XWikiAuthenticator;import org.xwiki.model.EntityType;import org.xwiki.model.reference.AttachmentReference;import org.xwiki.model.reference.AttachmentReferenceResolver;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.LocalDocumentReference;import org.xwiki.model.reference.ObjectReference;import org.xwiki.model.reference.PageReference;import org.xwiki.model.reference.PageReferenceResolver;import org.xwiki.model.reference.RegexEntityReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.observation.EventListener;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.event.CancelableEvent;import org.xwiki.observation.event.Event;import org.xwiki.query.QueryException;import org.xwiki.query.QueryFilter;import org.xwiki.refactoring.ReferenceRenamer;import org.xwiki.refactoring.batch.BatchOperationExecutor;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.Block.Axes;import org.xwiki.rendering.block.MetaDataBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.block.match.MetadataBlockMatcher;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.listener.MetaData;import org.xwiki.rendering.parser.ParseException;import org.xwiki.rendering.renderer.BlockRenderer;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.syntax.SyntaxContent;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceReferenceResolver;import org.xwiki.resource.ResourceType;import org.xwiki.resource.ResourceTypeResolver;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.script.ScriptContextManager;import org.xwiki.skin.Resource;import org.xwiki.skin.Skin;import org.xwiki.skin.SkinManager;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLConfiguration;import org.xwiki.user.CurrentUserReference;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.velocity.VelocityContextFactory;import org.xwiki.velocity.VelocityManager;import org.xwiki.velocity.XWikiVelocityContext;import org.xwiki.velocity.XWikiVelocityException;import org.xwiki.wiki.descriptor.WikiDescriptor;import org.xwiki.wiki.descriptor.WikiDescriptorManager;import org.xwiki.wiki.manager.WikiManager;import org.xwiki.wiki.manager.WikiManagerException;import org.xwiki.xml.XMLUtils;import com.xpn.xwiki.api.Api;import com.xpn.xwiki.api.Document;import com.xpn.xwiki.api.User;import com.xpn.xwiki.criteria.api.XWikiCriteriaService;import com.xpn.xwiki.doc.DeletedAttachment;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MandatoryDocumentInitializer;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiAttachmentArchive;import com.xpn.xwiki.doc.XWikiDeletedDocument;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;import com.xpn.xwiki.doc.XWikiDocumentArchive;import com.xpn.xwiki.internal.WikiInitializerJob;import com.xpn.xwiki.internal.WikiInitializerRequest;import com.xpn.xwiki.internal.XWikiCfgConfigurationSource;import com.xpn.xwiki.internal.XWikiConfigDelegate;import com.xpn.xwiki.internal.XWikiInitializerJob;import com.xpn.xwiki.internal.debug.DebugConfiguration;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;import com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;import com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;import com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;import com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyEvent;import com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;import com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;import com.xpn.xwiki.internal.render.OldRendering;import com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;import com.xpn.xwiki.internal.skin.InternalSkinConfiguration;import com.xpn.xwiki.internal.skin.InternalSkinManager;import com.xpn.xwiki.internal.skin.WikiSkin;import com.xpn.xwiki.internal.skin.WikiSkinUtils;import com.xpn.xwiki.internal.store.StoreConfiguration;import com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;import com.xpn.xwiki.internal.velocity.VelocityEvaluator;import com.xpn.xwiki.job.JobRequestContext;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.PropertyInterface;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;import com.xpn.xwiki.objects.classes.PropertyClass;import com.xpn.xwiki.objects.meta.MetaClass;import com.xpn.xwiki.plugin.XWikiPluginInterface;import com.xpn.xwiki.plugin.XWikiPluginManager;import com.xpn.xwiki.render.groovy.XWikiPageClassLoader;import com.xpn.xwiki.stats.api.XWikiStatsService;import com.xpn.xwiki.stats.impl.SearchEngineRule;import com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;import com.xpn.xwiki.store.AttachmentRecycleBinStore;import com.xpn.xwiki.store.AttachmentVersioningStore;import com.xpn.xwiki.store.XWikiAttachmentStoreInterface;import com.xpn.xwiki.store.XWikiCacheStoreInterface;import com.xpn.xwiki.store.XWikiHibernateStore;import com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;import com.xpn.xwiki.store.XWikiStoreInterface;import com.xpn.xwiki.store.XWikiVersioningStoreInterface;import com.xpn.xwiki.user.api.XWikiAuthService;import com.xpn.xwiki.user.api.XWikiGroupService;import com.xpn.xwiki.user.api.XWikiRightService;import com.xpn.xwiki.user.api.XWikiUser;import com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;import com.xpn.xwiki.util.Util;import com.xpn.xwiki.util.XWikiStubContextProvider;import com.xpn.xwiki.web.Utils;import com.xpn.xwiki.web.XWikiEngineContext;import com.xpn.xwiki.web.XWikiMessageTool;import com.xpn.xwiki.web.XWikiRequest;import com.xpn.xwiki.web.XWikiServletRequestStub;import com.xpn.xwiki.web.XWikiURLFactory;import com.xpn.xwiki.web.XWikiURLFactoryService;import com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;@Serializable(false)public class XWiki implements EventListener{    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";    public static final String DEFAULT_HOME_SPACE = \"Main\";    public static final String SYSTEM_SPACE = \"XWiki\";    public static final EntityReference SYSTEM_SPACE_REFERENCE = new EntityReference(\"XWiki\", EntityType.SPACE);    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;    public static final String CACHE_VERSION = \"cache-version\";    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");    public static final String DEFAULT_ENCODING = \"UTF-8\";    private static final String NO_VALUE = \"---\";    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");    private XWikiStoreInterface store;    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;    private AttachmentVersioningStore defaultAttachmentArchiveStore;    private XWikiVersioningStoreInterface versioningStore;    private XWikiRecycleBinStoreInterface recycleBinStore;    private AttachmentRecycleBinStore attachmentRecycleBinStore;    private XWikiPluginManager pluginManager;    private XWikiAuthService authService;    private XWikiRightService rightService;    private XWikiGroupService groupService;    private XWikiStatsService statsService;    private XWikiURLFactoryService urlFactoryService;    private XWikiCriteriaService criteriaService;    private final Object AUTH_SERVICE_LOCK = new Object();    private final Object RIGHT_SERVICE_LOCK = new Object();    private final Object GROUP_SERVICE_LOCK = new Object();    private final Object STATS_SERVICE_LOCK = new Object();    private final Object URLFACTORY_SERVICE_LOCK = new Object();    private MetaClass metaclass;    private String version;    private XWikiEngineContext engine_context;    private String database;    private String fullNameSQL;    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();    private boolean isReadOnly = false;    @Deprecated    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;    public static final String MACROS_FILE = \"/templates/macros.txt\";    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";    private static final String VERSION_FILE_PROPERTY = \"version\";    private static XWikiInitializerJob job;    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;    private EntityReferenceResolver<String> relativeEntityReferenceResolver;    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;    private ResourceReferenceManager resourceReferenceManager;    private JobExecutor jobExecutor;    private InternalSkinManager internalSkinManager;    private TemplateManager templateManager;    private RenderingContext renderingContext;    private VelocityEvaluator velocityEvaluator;    private Boolean hasBacklinks;    private ConfigurationSource xwikicfg;    private ConfigurationSource wikiConfiguration;    private UserPropertiesResolver userPropertiesResolver;    private ConfigurationSource spaceConfiguration;    private EditConfiguration editConfiguration;    private URLConfiguration urlConfiguration;    private StoreConfiguration storeConfiguration;    private HibernateConfiguration hibernateConfiguration;    private ObservationManager observationManager;    private Provider<XWikiContext> xcontextProvider;    private ContextualLocalizationManager localization;    private Provider<OldRendering> oldRenderingProvider;    private ParseGroovyFromString parseGroovyFromString;    private JobProgressManager progress;    private Provider<DocumentReference> defaultDocumentReferenceProvider;    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;    private PageReferenceResolver<EntityReference> currentgetpageResolver;    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;    private WikiSkinUtils wikiSkinUtils;    private DocumentRevisionProvider documentRevisionProvider;    private VelocityContextFactory velocityContextFactory;    private WikiDescriptorManager wikiDescriptorManager;    private AsyncContext asyncContext;    private ConfigurationSource getConfiguration()    {        if (this.xwikicfg == null) {            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);        }        return this.xwikicfg;    }    private ConfigurationSource getWikiConfiguration()    {        if (this.wikiConfiguration == null) {            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");        }        return this.wikiConfiguration;    }    private ConfigurationSource getSpaceConfiguration()    {        if (this.spaceConfiguration == null) {            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");        }        return this.spaceConfiguration;    }    private UserPropertiesResolver getAllUserPropertiesResolver()    {        if (this.userPropertiesResolver == null) {            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");        }        return this.userPropertiesResolver;    }    private EditConfiguration getEditConfiguration()    {        if (this.editConfiguration == null) {            this.editConfiguration = Utils.getComponent(EditConfiguration.class);        }        return this.editConfiguration;    }    private URLConfiguration getURLConfiguration()    {        if (this.urlConfiguration == null) {            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);        }        return this.urlConfiguration;    }    private StoreConfiguration getStoreConfiguration()    {        if (this.storeConfiguration == null) {            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);        }        return this.storeConfiguration;    }    private HibernateConfiguration getHibernateConfiguration()    {        if (this.hibernateConfiguration == null) {            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);        }        return this.hibernateConfiguration;    }    private InternalSkinManager getInternalSkinManager()    {        if (this.internalSkinManager == null) {            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);        }        return this.internalSkinManager;    }    private TemplateManager getTemplateManager()    {        if (this.templateManager == null) {            this.templateManager = Utils.getComponent(TemplateManager.class);        }        return this.templateManager;    }    private RenderingContext getRenderingContext()    {        if (this.renderingContext == null) {            this.renderingContext = Utils.getComponent(RenderingContext.class);        }        return this.renderingContext;    }    private MutableRenderingContext getMutableRenderingContext()    {        return getRenderingContext() instanceof MutableRenderingContext            ? (MutableRenderingContext) getRenderingContext() : null;    }    private VelocityEvaluator getVelocityEvaluator()    {        if (this.velocityEvaluator == null) {            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);        }        return this.velocityEvaluator;    }    private ObservationManager getObservationManager()    {        if (this.observationManager == null) {            this.observationManager = Utils.getComponent(ObservationManager.class);        }        return this.observationManager;    }    private XWikiContext getXWikiContext()    {        if (this.xcontextProvider == null) {            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);        }        return this.xcontextProvider.get();    }    private ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    private OldRendering getOldRendering()    {        if (this.oldRenderingProvider == null) {            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);        }        return this.oldRenderingProvider.get();    }    private ParseGroovyFromString getParseGroovyFromString()    {        if (this.parseGroovyFromString == null) {            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);        }        return this.parseGroovyFromString;    }    private JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()    {        if (this.defaultDocumentReferenceProvider == null) {            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);        }        return this.defaultDocumentReferenceProvider;    }    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()    {        if (this.currentgetdocumentResolver == null) {            this.currentgetdocumentResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");        }        return this.currentgetdocumentResolver;    }    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()    {        if (this.currentgetpageResolver == null) {            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");        }        return this.currentgetpageResolver;    }    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()    {        if (this.currentAttachmentReferenceResolver == null) {            this.currentAttachmentReferenceResolver =                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentAttachmentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()    {        if (this.defaultEntityReferenceSerializer == null) {            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultEntityReferenceSerializer;    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()    {        if (this.currentReferenceDocumentReferenceResolver == null) {            this.currentReferenceDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentReferenceDocumentReferenceResolver;    }    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()    {        if (this.currentMixedEntityReferenceResolver == null) {            this.currentMixedEntityReferenceResolver =                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedEntityReferenceResolver;    }    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()    {        if (this.relativeEntityReferenceResolver == null) {            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");        }        return this.relativeEntityReferenceResolver;    }    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()    {        if (this.localStringEntityReferenceSerializer == null) {            this.localStringEntityReferenceSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localStringEntityReferenceSerializer;    }    private ResourceReferenceManager getResourceReferenceManager()    {        if (this.resourceReferenceManager == null) {            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);        }        return this.resourceReferenceManager;    }    private JobExecutor getJobExecutor()    {        if (this.jobExecutor == null) {            this.jobExecutor = Utils.getComponent(JobExecutor.class);        }        return this.jobExecutor;    }    private DocumentReference getDefaultDocumentReference()    {        return getDefaultDocumentReferenceProvider().get();    }    private WikiSkinUtils getWikiSkinUtils()    {        if (this.wikiSkinUtils == null) {            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);        }        return this.wikiSkinUtils;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    private VelocityContextFactory getVelocityContextFactory()    {        if (this.velocityContextFactory == null) {            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);        }        return this.velocityContextFactory;    }    private WikiDescriptorManager getWikiDescriptorManager()    {        if (this.wikiDescriptorManager == null) {            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);        }        return this.wikiDescriptorManager;    }    private AsyncContext getAsyncContext()    {        if (this.asyncContext == null) {            this.asyncContext = Utils.getComponent(AsyncContext.class);        }        return this.asyncContext;    }    private String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException    {        return getMainXWiki(true, context);    }    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException    {        String xwikiname = DEFAULT_MAIN_WIKI;        context.setMainXWiki(xwikiname);        XWiki xwiki;        try {            XWikiEngineContext econtext = context.getEngineContext();            xwiki = (XWiki) econtext.getAttribute(xwikiname);            if (xwiki == null) {                synchronized (XWiki.class) {                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                    if (xwiki == null && job == null) {                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);                        if (job.getStatus() == null) {                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)                                .initialize(context);                            job.startAsync();                        }                    }                }                if (wait) {                    job.join();                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                }            }            context.setWiki(xwiki);            return xwiki;        } catch (Exception e) {            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,                \"Could not initialize main XWiki instance\", e);        }    }    public static boolean isInitializing(XWikiContext xcontext)    {        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));    }    public static XWiki getXWiki(XWikiContext context) throws XWikiException    {        return getXWiki(true, context);    }    /**     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.     * <p>     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.     *     * @param wait wait until XWiki is initialized     * @param xcon", "nl": "import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Type;import java.net.MalformedURLException;import java.net.URL;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.attribute.FileTime;import java.text.DateFormatSymbols;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.Date;import java.util.Enumeration;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Set;import java.util.TimeZone;import java.util.Vector;import java.util.concurrent.ConcurrentHashMap;import java.util.zip.ZipOutputStream;import javax.annotation.Priority;import javax.inject.Provider;import javax.mail.Message;import javax.mail.Session;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import javax.naming.NamingException;import javax.script.ScriptContext;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.httpclient.Credentials;import org.apache.commons.httpclient.HttpClient;import org.apache.commons.httpclient.URIException;import org.apache.commons.httpclient.UsernamePasswordCredentials;import org.apache.commons.httpclient.auth.AuthScope;import org.apache.commons.httpclient.methods.GetMethod;import org.apache.commons.httpclient.util.URIUtil;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.ArrayUtils;import org.apache.commons.lang3.RandomStringUtils;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.commons.lang3.math.NumberUtils;import org.apache.commons.lang3.reflect.FieldUtils;import org.apache.velocity.VelocityContext;import org.hibernate.HibernateException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.suigeneris.jrcs.rcs.Version;import org.xwiki.bridge.event.DocumentCreatedEvent;import org.xwiki.bridge.event.DocumentCreatingEvent;import org.xwiki.bridge.event.DocumentDeletedEvent;import org.xwiki.bridge.event.DocumentDeletingEvent;import org.xwiki.bridge.event.DocumentRolledBackEvent;import org.xwiki.bridge.event.DocumentRollingBackEvent;import org.xwiki.bridge.event.DocumentUpdatedEvent;import org.xwiki.bridge.event.DocumentUpdatingEvent;import org.xwiki.bridge.event.DocumentVersionRangeDeletedEvent;import org.xwiki.bridge.event.DocumentVersionRangeDeletingEvent;import org.xwiki.bridge.event.WikiCopiedEvent;import org.xwiki.bridge.event.WikiDeletedEvent;import org.xwiki.cache.Cache;import org.xwiki.classloader.ClassLoaderManager;import org.xwiki.component.event.ComponentDescriptorAddedEvent;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.manager.NamespacedComponentManager;import org.xwiki.component.util.DefaultParameterizedType;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.container.servlet.HttpServletUtils;import org.xwiki.context.Execution;import org.xwiki.edit.EditConfiguration;import org.xwiki.extension.job.internal.InstallJob;import org.xwiki.job.Job;import org.xwiki.job.JobException;import org.xwiki.job.JobExecutor;import org.xwiki.job.annotation.Serializable;import org.xwiki.job.event.JobFinishedEvent;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.job.event.status.JobStatus.State;import org.xwiki.localization.ContextualLocalizationManager;import org.xwiki.localization.LocaleUtils;import org.xwiki.mail.MailListener;import org.xwiki.mail.MailSender;import org.xwiki.mail.MailSenderConfiguration;import org.xwiki.mail.MailStatusResultSerializer;import org.xwiki.mail.XWikiAuthenticator;import org.xwiki.model.EntityType;import org.xwiki.model.reference.AttachmentReference;import org.xwiki.model.reference.AttachmentReferenceResolver;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceResolver;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.LocalDocumentReference;import org.xwiki.model.reference.ObjectReference;import org.xwiki.model.reference.PageReference;import org.xwiki.model.reference.PageReferenceResolver;import org.xwiki.model.reference.RegexEntityReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.observation.EventListener;import org.xwiki.observation.ObservationManager;import org.xwiki.observation.event.CancelableEvent;import org.xwiki.observation.event.Event;import org.xwiki.query.QueryException;import org.xwiki.query.QueryFilter;import org.xwiki.refactoring.ReferenceRenamer;import org.xwiki.refactoring.batch.BatchOperationExecutor;import org.xwiki.rendering.async.AsyncContext;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.Block.Axes;import org.xwiki.rendering.block.MetaDataBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.block.match.MetadataBlockMatcher;import org.xwiki.rendering.internal.transformation.MutableRenderingContext;import org.xwiki.rendering.listener.MetaData;import org.xwiki.rendering.parser.ParseException;import org.xwiki.rendering.renderer.BlockRenderer;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.syntax.SyntaxContent;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.resource.ResourceReference;import org.xwiki.resource.ResourceReferenceManager;import org.xwiki.resource.ResourceReferenceResolver;import org.xwiki.resource.ResourceType;import org.xwiki.resource.ResourceTypeResolver;import org.xwiki.resource.entity.EntityResourceReference;import org.xwiki.script.ScriptContextManager;import org.xwiki.skin.Resource;import org.xwiki.skin.Skin;import org.xwiki.skin.SkinManager;import org.xwiki.stability.Unstable;import org.xwiki.template.TemplateManager;import org.xwiki.url.ExtendedURL;import org.xwiki.url.URLConfiguration;import org.xwiki.user.CurrentUserReference;import org.xwiki.user.UserPropertiesResolver;import org.xwiki.velocity.VelocityContextFactory;import org.xwiki.velocity.VelocityManager;import org.xwiki.velocity.XWikiVelocityContext;import org.xwiki.velocity.XWikiVelocityException;import org.xwiki.wiki.descriptor.WikiDescriptor;import org.xwiki.wiki.descriptor.WikiDescriptorManager;import org.xwiki.wiki.manager.WikiManager;import org.xwiki.wiki.manager.WikiManagerException;import org.xwiki.xml.XMLUtils;import com.xpn.xwiki.api.Api;import com.xpn.xwiki.api.Document;import com.xpn.xwiki.api.User;import com.xpn.xwiki.criteria.api.XWikiCriteriaService;import com.xpn.xwiki.doc.DeletedAttachment;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.MandatoryDocumentInitializer;import com.xpn.xwiki.doc.XWikiAttachment;import com.xpn.xwiki.doc.XWikiAttachmentArchive;import com.xpn.xwiki.doc.XWikiDeletedDocument;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;import com.xpn.xwiki.doc.XWikiDocumentArchive;import com.xpn.xwiki.internal.WikiInitializerJob;import com.xpn.xwiki.internal.WikiInitializerRequest;import com.xpn.xwiki.internal.XWikiCfgConfigurationSource;import com.xpn.xwiki.internal.XWikiConfigDelegate;import com.xpn.xwiki.internal.XWikiInitializerJob;import com.xpn.xwiki.internal.debug.DebugConfiguration;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;import com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;import com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;import com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;import com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;import com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;import com.xpn.xwiki.internal.event.XObjectPropertyEvent;import com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;import com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;import com.xpn.xwiki.internal.render.OldRendering;import com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;import com.xpn.xwiki.internal.skin.InternalSkinConfiguration;import com.xpn.xwiki.internal.skin.InternalSkinManager;import com.xpn.xwiki.internal.skin.WikiSkin;import com.xpn.xwiki.internal.skin.WikiSkinUtils;import com.xpn.xwiki.internal.store.StoreConfiguration;import com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;import com.xpn.xwiki.internal.velocity.VelocityEvaluator;import com.xpn.xwiki.job.JobRequestContext;import com.xpn.xwiki.objects.BaseObject;import com.xpn.xwiki.objects.PropertyInterface;import com.xpn.xwiki.objects.classes.BaseClass;import com.xpn.xwiki.objects.classes.PasswordClass;import com.xpn.xwiki.objects.classes.PropertyClass;import com.xpn.xwiki.objects.meta.MetaClass;import com.xpn.xwiki.plugin.XWikiPluginInterface;import com.xpn.xwiki.plugin.XWikiPluginManager;import com.xpn.xwiki.render.groovy.XWikiPageClassLoader;import com.xpn.xwiki.stats.api.XWikiStatsService;import com.xpn.xwiki.stats.impl.SearchEngineRule;import com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;import com.xpn.xwiki.store.AttachmentRecycleBinStore;import com.xpn.xwiki.store.AttachmentVersioningStore;import com.xpn.xwiki.store.XWikiAttachmentStoreInterface;import com.xpn.xwiki.store.XWikiCacheStoreInterface;import com.xpn.xwiki.store.XWikiHibernateStore;import com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;import com.xpn.xwiki.store.XWikiStoreInterface;import com.xpn.xwiki.store.XWikiVersioningStoreInterface;import com.xpn.xwiki.user.api.XWikiAuthService;import com.xpn.xwiki.user.api.XWikiGroupService;import com.xpn.xwiki.user.api.XWikiRightService;import com.xpn.xwiki.user.api.XWikiUser;import com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;import com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;import com.xpn.xwiki.util.Util;import com.xpn.xwiki.util.XWikiStubContextProvider;import com.xpn.xwiki.web.Utils;import com.xpn.xwiki.web.XWikiEngineContext;import com.xpn.xwiki.web.XWikiMessageTool;import com.xpn.xwiki.web.XWikiRequest;import com.xpn.xwiki.web.XWikiServletRequestStub;import com.xpn.xwiki.web.XWikiURLFactory;import com.xpn.xwiki.web.XWikiURLFactoryService;import com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;import com.xpn.xwiki.web.includeservletasstring.IncludeServletAsString;@Serializable(false)public class XWiki implements EventListener{    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";    public static final String DEFAULT_HOME_SPACE = \"Main\";    public static final String SYSTEM_SPACE = \"XWiki\";    public static final EntityReference SYSTEM_SPACE_REFERENCE = new EntityReference(\"XWiki\", EntityType.SPACE);    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;    public static final String CACHE_VERSION = \"cache-version\";    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");    public static final String DEFAULT_ENCODING = \"UTF-8\";    private static final String NO_VALUE = \"---\";    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");    private XWikiStoreInterface store;    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;    private AttachmentVersioningStore defaultAttachmentArchiveStore;    private XWikiVersioningStoreInterface versioningStore;    private XWikiRecycleBinStoreInterface recycleBinStore;    private AttachmentRecycleBinStore attachmentRecycleBinStore;    private XWikiPluginManager pluginManager;    private XWikiAuthService authService;    private XWikiRightService rightService;    private XWikiGroupService groupService;    private XWikiStatsService statsService;    private XWikiURLFactoryService urlFactoryService;    private XWikiCriteriaService criteriaService;    private final Object AUTH_SERVICE_LOCK = new Object();    private final Object RIGHT_SERVICE_LOCK = new Object();    private final Object GROUP_SERVICE_LOCK = new Object();    private final Object STATS_SERVICE_LOCK = new Object();    private final Object URLFACTORY_SERVICE_LOCK = new Object();    private MetaClass metaclass;    private String version;    private XWikiEngineContext engine_context;    private String database;    private String fullNameSQL;    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();    private boolean isReadOnly = false;    @Deprecated    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;    public static final String MACROS_FILE = \"/templates/macros.txt\";    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";    private static final String VERSION_FILE_PROPERTY = \"version\";    private static XWikiInitializerJob job;    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;    private EntityReferenceResolver<String> relativeEntityReferenceResolver;    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;    private ResourceReferenceManager resourceReferenceManager;    private JobExecutor jobExecutor;    private InternalSkinManager internalSkinManager;    private TemplateManager templateManager;    private RenderingContext renderingContext;    private VelocityEvaluator velocityEvaluator;    private Boolean hasBacklinks;    private ConfigurationSource xwikicfg;    private ConfigurationSource wikiConfiguration;    private UserPropertiesResolver userPropertiesResolver;    private ConfigurationSource spaceConfiguration;    private EditConfiguration editConfiguration;    private URLConfiguration urlConfiguration;    private StoreConfiguration storeConfiguration;    private HibernateConfiguration hibernateConfiguration;    private ObservationManager observationManager;    private Provider<XWikiContext> xcontextProvider;    private ContextualLocalizationManager localization;    private Provider<OldRendering> oldRenderingProvider;    private ParseGroovyFromString parseGroovyFromString;    private JobProgressManager progress;    private Provider<DocumentReference> defaultDocumentReferenceProvider;    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;    private PageReferenceResolver<EntityReference> currentgetpageResolver;    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;    private WikiSkinUtils wikiSkinUtils;    private DocumentRevisionProvider documentRevisionProvider;    private VelocityContextFactory velocityContextFactory;    private WikiDescriptorManager wikiDescriptorManager;    private AsyncContext asyncContext;    private ConfigurationSource getConfiguration()    {        if (this.xwikicfg == null) {            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);        }        return this.xwikicfg;    }    private ConfigurationSource getWikiConfiguration()    {        if (this.wikiConfiguration == null) {            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");        }        return this.wikiConfiguration;    }    private ConfigurationSource getSpaceConfiguration()    {        if (this.spaceConfiguration == null) {            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");        }        return this.spaceConfiguration;    }    private UserPropertiesResolver getAllUserPropertiesResolver()    {        if (this.userPropertiesResolver == null) {            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");        }        return this.userPropertiesResolver;    }    private EditConfiguration getEditConfiguration()    {        if (this.editConfiguration == null) {            this.editConfiguration = Utils.getComponent(EditConfiguration.class);        }        return this.editConfiguration;    }    private URLConfiguration getURLConfiguration()    {        if (this.urlConfiguration == null) {            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);        }        return this.urlConfiguration;    }    private StoreConfiguration getStoreConfiguration()    {        if (this.storeConfiguration == null) {            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);        }        return this.storeConfiguration;    }    private HibernateConfiguration getHibernateConfiguration()    {        if (this.hibernateConfiguration == null) {            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);        }        return this.hibernateConfiguration;    }    private InternalSkinManager getInternalSkinManager()    {        if (this.internalSkinManager == null) {            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);        }        return this.internalSkinManager;    }    private TemplateManager getTemplateManager()    {        if (this.templateManager == null) {            this.templateManager = Utils.getComponent(TemplateManager.class);        }        return this.templateManager;    }    private RenderingContext getRenderingContext()    {        if (this.renderingContext == null) {            this.renderingContext = Utils.getComponent(RenderingContext.class);        }        return this.renderingContext;    }    private MutableRenderingContext getMutableRenderingContext()    {        return getRenderingContext() instanceof MutableRenderingContext            ? (MutableRenderingContext) getRenderingContext() : null;    }    private VelocityEvaluator getVelocityEvaluator()    {        if (this.velocityEvaluator == null) {            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);        }        return this.velocityEvaluator;    }    private ObservationManager getObservationManager()    {        if (this.observationManager == null) {            this.observationManager = Utils.getComponent(ObservationManager.class);        }        return this.observationManager;    }    private XWikiContext getXWikiContext()    {        if (this.xcontextProvider == null) {            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);        }        return this.xcontextProvider.get();    }    private ContextualLocalizationManager getLocalization()    {        if (this.localization == null) {            this.localization = Utils.getComponent(ContextualLocalizationManager.class);        }        return this.localization;    }    private OldRendering getOldRendering()    {        if (this.oldRenderingProvider == null) {            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);        }        return this.oldRenderingProvider.get();    }    private ParseGroovyFromString getParseGroovyFromString()    {        if (this.parseGroovyFromString == null) {            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);        }        return this.parseGroovyFromString;    }    private JobProgressManager getProgress()    {        if (this.progress == null) {            this.progress = Utils.getComponent(JobProgressManager.class);        }        return this.progress;    }    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()    {        if (this.defaultDocumentReferenceProvider == null) {            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);        }        return this.defaultDocumentReferenceProvider;    }    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()    {        if (this.currentgetdocumentResolver == null) {            this.currentgetdocumentResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");        }        return this.currentgetdocumentResolver;    }    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()    {        if (this.currentgetpageResolver == null) {            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");        }        return this.currentgetpageResolver;    }    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()    {        if (this.currentAttachmentReferenceResolver == null) {            this.currentAttachmentReferenceResolver =                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentAttachmentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()    {        if (this.defaultEntityReferenceSerializer == null) {            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultEntityReferenceSerializer;    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()    {        if (this.currentReferenceDocumentReferenceResolver == null) {            this.currentReferenceDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");        }        return this.currentReferenceDocumentReferenceResolver;    }    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()    {        if (this.currentMixedEntityReferenceResolver == null) {            this.currentMixedEntityReferenceResolver =                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedEntityReferenceResolver;    }    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()    {        if (this.relativeEntityReferenceResolver == null) {            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");        }        return this.relativeEntityReferenceResolver;    }    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()    {        if (this.localStringEntityReferenceSerializer == null) {            this.localStringEntityReferenceSerializer =                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");        }        return this.localStringEntityReferenceSerializer;    }    private ResourceReferenceManager getResourceReferenceManager()    {        if (this.resourceReferenceManager == null) {            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);        }        return this.resourceReferenceManager;    }    private JobExecutor getJobExecutor()    {        if (this.jobExecutor == null) {            this.jobExecutor = Utils.getComponent(JobExecutor.class);        }        return this.jobExecutor;    }    private DocumentReference getDefaultDocumentReference()    {        return getDefaultDocumentReferenceProvider().get();    }    private WikiSkinUtils getWikiSkinUtils()    {        if (this.wikiSkinUtils == null) {            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);        }        return this.wikiSkinUtils;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    private VelocityContextFactory getVelocityContextFactory()    {        if (this.velocityContextFactory == null) {            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);        }        return this.velocityContextFactory;    }    private WikiDescriptorManager getWikiDescriptorManager()    {        if (this.wikiDescriptorManager == null) {            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);        }        return this.wikiDescriptorManager;    }    private AsyncContext getAsyncContext()    {        if (this.asyncContext == null) {            this.asyncContext = Utils.getComponent(AsyncContext.class);        }        return this.asyncContext;    }    private String localizePlainOrKey(String key, Object... parameters)    {        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);    }    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException    {        return getMainXWiki(true, context);    }    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException    {        String xwikiname = DEFAULT_MAIN_WIKI;        context.setMainXWiki(xwikiname);        XWiki xwiki;        try {            XWikiEngineContext econtext = context.getEngineContext();            xwiki = (XWiki) econtext.getAttribute(xwikiname);            if (xwiki == null) {                synchronized (XWiki.class) {                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                    if (xwiki == null && job == null) {                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);                        if (job.getStatus() == null) {                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)                                .initialize(context);                            job.startAsync();                        }                    }                }                if (wait) {                    job.join();                    xwiki = (XWiki) econtext.getAttribute(xwikiname);                }            }            context.setWiki(xwiki);            return xwiki;        } catch (Exception e) {            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,                \"Could not initialize main XWiki instance\", e);        }    }    public static boolean isInitializing(XWikiContext xcontext)    {        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));    }    public static XWiki getXWiki(XWikiContext context) throws XWikiException    {        return getXWiki(true, context);    }    /**     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.     * <p>     * Unless <code"}
{"code": "import java.io.IOException;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collections;import java.util.Date;import java.util.List;import java.util.Locale;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.commons.lang3.math.NumberUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.job.Job;import org.xwiki.job.event.status.JobStatus;import org.xwiki.job.event.status.JobStatus.State;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.PageReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.rendering.renderer.PrintRendererFactory;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.XWikiDeletedDocument;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.XWikiInitializerJob;import com.xpn.xwiki.internal.XWikiInitializerJobStatus;import com.xpn.xwiki.objects.meta.MetaClass;import com.xpn.xwiki.user.api.XWikiUser;import com.xpn.xwiki.util.Programming;import com.xpn.xwiki.web.Utils;import com.xpn.xwiki.web.XWikiEngineContext;import com.xpn.xwiki.web.XWikiURLFactory;public class XWiki extends Api{    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);    private com.xpn.xwiki.XWiki xwiki;    private StatsService statsService;    private CriteriaService criteriaService;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;    private EntityReferenceSerializer<String> defaultStringEntityReferenceSerializer;    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;    private DocumentRevisionProvider documentRevisionProvider;    private ContextualAuthorizationManager contextualAuthorizationManager;    public XWiki(com.xpn.xwiki.XWiki xwiki, XWikiContext context)    {        super(context);        this.xwiki = xwiki;        this.statsService = new StatsService(context);        this.criteriaService = new CriteriaService(context);    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private DocumentReferenceResolver<EntityReference> getCurrentgetdocumentResolver()    {        if (this.currentgetdocumentResolver == null) {            this.currentgetdocumentResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");        }        return this.currentgetdocumentResolver;    }    private DocumentReferenceResolver<String> getDefaultDocumentReferenceResolver()    {        if (this.defaultDocumentReferenceResolver == null) {            this.defaultDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);        }        return this.defaultDocumentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultStringEntityReferenceSerializer()    {        if (this.defaultStringEntityReferenceSerializer == null) {            this.defaultStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultStringEntityReferenceSerializer;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    @Programming    public com.xpn.xwiki.XWiki getXWiki()    {        if (hasProgrammingRights()) {            return this.xwiki;        }        return null;    }    public XWikiInitializerJobStatus getJobStatus()    {        XWikiInitializerJob job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);        return job != null ? job.getStatus() : null;    }    public JobStatus getCurrentInitializerJobStatus()    {        JobStatus jobStatus = getJobStatus();        if (jobStatus == null) {            return null;        }        if (jobStatus.getState() != State.FINISHED) {            return jobStatus;        }        if (this.xwiki != null) {            Job wikiJob = this.xwiki.getWikiInitializerJob(this.context.getWikiId());            jobStatus = wikiJob != null ? wikiJob.getStatus() : null;        }        return jobStatus;    }    public String getVersion()    {        return this.xwiki.getVersion();    }    public String getRequestURL() throws XWikiException    {        return getXWikiContext().getURLFactory().getRequestURL(getXWikiContext()).toString();    }    public String getRelativeRequestURL() throws XWikiException    {        XWikiURLFactory urlFactory = getXWikiContext().getURLFactory();        return urlFactory.getURL(urlFactory.getRequestURL(getXWikiContext()), getXWikiContext());    }    public Document getDocument(String documentReference) throws XWikiException    {        DocumentReference reference;        if (documentReference != null) {            reference = getCurrentMixedDocumentReferenceResolver().resolve(documentReference);        } else {            reference = getDefaultDocumentReferenceResolver().resolve(\"\");        }        return getDocument(reference);    }    public Document getEntityDocument(String reference, EntityType type) throws XWikiException    {        XWikiDocument doc = this.xwiki.getDocument(reference, type, getXWikiContext());        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {            return null;        }        return doc.newDocument(getXWikiContext());    }    public Document getDocument(DocumentReference reference) throws XWikiException    {        try {            XWikiDocument doc = this.xwiki.getDocument(reference, getXWikiContext());            if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(),                doc.getPrefixedFullName(), getXWikiContext()) == false) {                return null;            }            return doc.newDocument(getXWikiContext());        } catch (Exception ex) {            LOGGER.warn(\"Failed to access document [{}]. Root reason: [{}]\", reference,                ExceptionUtils.getRootCauseMessage(ex));            return new Document(new XWikiDocument(reference), getXWikiContext());        }    }    public Document getDocument(EntityReference reference) throws XWikiException    {        return getDocument(this.xwiki.getDocumentReference(reference, getXWikiContext()));    }    public Document getDocumentAsAuthor(String fullName) throws XWikiException    {        DocumentReference reference;        if (fullName != null) {            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);        } else {            reference = getDefaultDocumentReferenceResolver().resolve(\"\");        }        return getDocumentAsAuthor(reference);    }    public Document getDocumentAsAuthor(DocumentReference reference) throws XWikiException    {        if (!getAuthorizationManager().hasAccess(Right.VIEW, getEffectiveAuthorReference(), reference)) {            return null;        }        return this.xwiki.getDocument(reference, getXWikiContext()).newDocument(getXWikiContext());    }    public List<DeletedDocument> getDeletedDocuments(String fullname, String locale) throws XWikiException    {        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(fullname, locale, this.context);        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);        return result;    }    public List<DeletedDocument> getDeletedDocuments(String batchId) throws XWikiException    {        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(batchId, this.context);        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);        return result;    }    private List<DeletedDocument> wrapDeletedDocuments(XWikiDeletedDocument[] deletedDocuments)    {        if (deletedDocuments == null || deletedDocuments.length == 0) {            return Collections.emptyList();        }        List<DeletedDocument> result = new ArrayList<>(deletedDocuments.length);        for (XWikiDeletedDocument deletedDocument : deletedDocuments) {            result.add(new DeletedDocument(deletedDocument, this.context));        }        return result;    }    @Deprecated    public DeletedDocument getDeletedDocument(String fullname, String locale, String index) throws XWikiException    {        return getDeletedDocument(index);    }    public DeletedDocument getDeletedDocument(String index) throws XWikiException    {        if (!NumberUtils.isDigits(index)) {            return null;        }        XWikiDeletedDocument dd = this.xwiki.getDeletedDocument(Long.parseLong(index), this.context);        if (dd == null) {            return null;        }        return new DeletedDocument(dd, this.context);    }    public List<DeletedAttachment> getDeletedAttachments(String docName)    {        try {            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =                this.xwiki.getDeletedAttachments(docName, this.context);            if (attachments == null || attachments.isEmpty()) {                attachments = Collections.emptyList();            }            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {                result.add(new DeletedAttachment(attachment, this.context));            }            return result;        } catch (Exception ex) {            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);        }        return Collections.emptyList();    }    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename)    {        try {            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =                this.xwiki.getDeletedAttachments(docName, filename, this.context);            if (attachments == null) {                attachments = Collections.emptyList();            }            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {                result.add(new DeletedAttachment(attachment, this.context));            }            return result;        } catch (Exception ex) {            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);        }        return Collections.emptyList();    }    public DeletedAttachment getDeletedAttachment(String id)    {        try {            com.xpn.xwiki.doc.DeletedAttachment attachment = this.xwiki.getDeletedAttachment(id, this.context);            if (attachment != null) {                return new DeletedAttachment(attachment, this.context);            }        } catch (Exception ex) {            LOGGER.warn(\"Failed to retrieve deleted attachment\", ex);        }        return null;    }    public boolean exists(String fullname) throws XWikiException    {        return this.xwiki.exists(fullname, getXWikiContext());    }    public boolean exists(DocumentReference reference) throws XWikiException    {        return this.xwiki.exists(reference, getXWikiContext());    }    @Unstable    public boolean exists(PageReference reference)    {        return this.xwiki.exists(reference, getXWikiContext());    }    public boolean checkAccess(String docname, String right)    {        try {            DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);            XWikiDocument doc = getXWikiContext().getWiki().getDocument(docReference, this.context);            return getXWikiContext().getWiki().checkAccess(right, doc, getXWikiContext());        } catch (XWikiException e) {            return false;        }    }    public Document getDocument(String space, String fullname) throws XWikiException    {        XWikiDocument doc = this.xwiki.getDocument(space, fullname, getXWikiContext());        if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(), doc.getFullName(),            getXWikiContext()) == false) {            return null;        }        return doc.newDocument(getXWikiContext());    }    public Document getDocument(Document doc, String rev) throws XWikiException    {        if (doc == null || doc.getDoc() == null) {            return null;        }        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {            return null;        }        return doc.getDocumentRevision(rev);    }    public Document getDocument(DocumentReference reference, String revision) throws XWikiException    {        try {            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {                XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(reference, revision);                if (documentRevision != null) {                    return new Document(documentRevision, this.context);                }            }        } catch (Exception e) {            LOGGER.error(\"Failed to access revision [{}] of document {}\", revision, reference, e);        }        return null;    }    public String getTextArea(String content)    {        return com.xpn.xwiki.XWiki.getTextArea(content, getXWikiContext());    }    public List<String> getClassList() throws XWikiException    {        return this.xwiki.getClassList(getXWikiContext());    }    public MetaClass getMetaclass()    {        return this.xwiki.getMetaclass();    }    @Deprecated    public List<String> searchDocuments(String wheresql) throws XWikiException    {        return this.xwiki.getStore().searchDocumentsNames(wheresql, getXWikiContext());    }    @Deprecated    public List<String> searchDocuments(String wheresql, int nb, int start) throws XWikiException    {        return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, getXWikiContext());    }    @Deprecated    public List<String> searchDocuments(String wheresql, int nb, int start, String selectColumns) throws XWikiException    {        if (hasProgrammingRights()) {            return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, selectColumns, getXWikiContext());        }        return Collections.emptyList();    }    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale) throws XWikiException    {        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, getXWikiContext()));    }    public", "nl": "import java.io.IOException;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collections;import java.util.Date;import java.util.List;import java.util.Locale;import org.apache.commons.lang3.StringUtils;import org.apache.commons.lang3.exception.ExceptionUtils;import org.apache.commons.lang3.math.NumberUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.job.Job;import org.xwiki.job.event.status.JobStatus;import org.xwiki.job.event.status.JobStatus.State;import org.xwiki.model.EntityType;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.model.reference.EntityReference;import org.xwiki.model.reference.EntityReferenceSerializer;import org.xwiki.model.reference.PageReference;import org.xwiki.model.reference.SpaceReference;import org.xwiki.model.reference.WikiReference;import org.xwiki.rendering.renderer.PrintRendererFactory;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.security.authorization.ContextualAuthorizationManager;import org.xwiki.security.authorization.Right;import org.xwiki.stability.Unstable;import com.xpn.xwiki.XWikiContext;import com.xpn.xwiki.XWikiException;import com.xpn.xwiki.doc.DocumentRevisionProvider;import com.xpn.xwiki.doc.XWikiDeletedDocument;import com.xpn.xwiki.doc.XWikiDocument;import com.xpn.xwiki.internal.XWikiInitializerJob;import com.xpn.xwiki.internal.XWikiInitializerJobStatus;import com.xpn.xwiki.objects.meta.MetaClass;import com.xpn.xwiki.user.api.XWikiUser;import com.xpn.xwiki.util.Programming;import com.xpn.xwiki.web.Utils;import com.xpn.xwiki.web.XWikiEngineContext;import com.xpn.xwiki.web.XWikiURLFactory;public class XWiki extends Api{    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);    private com.xpn.xwiki.XWiki xwiki;    private StatsService statsService;    private CriteriaService criteriaService;    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;    private EntityReferenceSerializer<String> defaultStringEntityReferenceSerializer;    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;    private DocumentRevisionProvider documentRevisionProvider;    private ContextualAuthorizationManager contextualAuthorizationManager;    public XWiki(com.xpn.xwiki.XWiki xwiki, XWikiContext context)    {        super(context);        this.xwiki = xwiki;        this.statsService = new StatsService(context);        this.criteriaService = new CriteriaService(context);    }    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()    {        if (this.currentMixedDocumentReferenceResolver == null) {            this.currentMixedDocumentReferenceResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");        }        return this.currentMixedDocumentReferenceResolver;    }    private DocumentReferenceResolver<EntityReference> getCurrentgetdocumentResolver()    {        if (this.currentgetdocumentResolver == null) {            this.currentgetdocumentResolver =                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");        }        return this.currentgetdocumentResolver;    }    private DocumentReferenceResolver<String> getDefaultDocumentReferenceResolver()    {        if (this.defaultDocumentReferenceResolver == null) {            this.defaultDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);        }        return this.defaultDocumentReferenceResolver;    }    private EntityReferenceSerializer<String> getDefaultStringEntityReferenceSerializer()    {        if (this.defaultStringEntityReferenceSerializer == null) {            this.defaultStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);        }        return this.defaultStringEntityReferenceSerializer;    }    private DocumentRevisionProvider getDocumentRevisionProvider()    {        if (this.documentRevisionProvider == null) {            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);        }        return this.documentRevisionProvider;    }    @Programming    public com.xpn.xwiki.XWiki getXWiki()    {        if (hasProgrammingRights()) {            return this.xwiki;        }        return null;    }    public XWikiInitializerJobStatus getJobStatus()    {        XWikiInitializerJob job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);        return job != null ? job.getStatus() : null;    }    public JobStatus getCurrentInitializerJobStatus()    {        JobStatus jobStatus = getJobStatus();        if (jobStatus == null) {            return null;        }        if (jobStatus.getState() != State.FINISHED) {            return jobStatus;        }        if (this.xwiki != null) {            Job wikiJob = this.xwiki.getWikiInitializerJob(this.context.getWikiId());            jobStatus = wikiJob != null ? wikiJob.getStatus() : null;        }        return jobStatus;    }    public String getVersion()    {        return this.xwiki.getVersion();    }    public String getRequestURL() throws XWikiException    {        return getXWikiContext().getURLFactory().getRequestURL(getXWikiContext()).toString();    }    public String getRelativeRequestURL() throws XWikiException    {        XWikiURLFactory urlFactory = getXWikiContext().getURLFactory();        return urlFactory.getURL(urlFactory.getRequestURL(getXWikiContext()), getXWikiContext());    }    public Document getDocument(String documentReference) throws XWikiException    {        DocumentReference reference;        if (documentReference != null) {            reference = getCurrentMixedDocumentReferenceResolver().resolve(documentReference);        } else {            reference = getDefaultDocumentReferenceResolver().resolve(\"\");        }        return getDocument(reference);    }    public Document getEntityDocument(String reference, EntityType type) throws XWikiException    {        XWikiDocument doc = this.xwiki.getDocument(reference, type, getXWikiContext());        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {            return null;        }        return doc.newDocument(getXWikiContext());    }    public Document getDocument(DocumentReference reference) throws XWikiException    {        try {            XWikiDocument doc = this.xwiki.getDocument(reference, getXWikiContext());            if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(),                doc.getPrefixedFullName(), getXWikiContext()) == false) {                return null;            }            return doc.newDocument(getXWikiContext());        } catch (Exception ex) {            LOGGER.warn(\"Failed to access document [{}]. Root reason: [{}]\", reference,                ExceptionUtils.getRootCauseMessage(ex));            return new Document(new XWikiDocument(reference), getXWikiContext());        }    }    public Document getDocument(EntityReference reference) throws XWikiException    {        return getDocument(this.xwiki.getDocumentReference(reference, getXWikiContext()));    }    public Document getDocumentAsAuthor(String fullName) throws XWikiException    {        DocumentReference reference;        if (fullName != null) {            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);        } else {            reference = getDefaultDocumentReferenceResolver().resolve(\"\");        }        return getDocumentAsAuthor(reference);    }    public Document getDocumentAsAuthor(DocumentReference reference) throws XWikiException    {        if (!getAuthorizationManager().hasAccess(Right.VIEW, getEffectiveAuthorReference(), reference)) {            return null;        }        return this.xwiki.getDocument(reference, getXWikiContext()).newDocument(getXWikiContext());    }    public List<DeletedDocument> getDeletedDocuments(String fullname, String locale) throws XWikiException    {        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(fullname, locale, this.context);        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);        return result;    }    public List<DeletedDocument> getDeletedDocuments(String batchId) throws XWikiException    {        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(batchId, this.context);        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);        return result;    }    private List<DeletedDocument> wrapDeletedDocuments(XWikiDeletedDocument[] deletedDocuments)    {        if (deletedDocuments == null || deletedDocuments.length == 0) {            return Collections.emptyList();        }        List<DeletedDocument> result = new ArrayList<>(deletedDocuments.length);        for (XWikiDeletedDocument deletedDocument : deletedDocuments) {            result.add(new DeletedDocument(deletedDocument, this.context));        }        return result;    }    @Deprecated    public DeletedDocument getDeletedDocument(String fullname, String locale, String index) throws XWikiException    {        return getDeletedDocument(index);    }    public DeletedDocument getDeletedDocument(String index) throws XWikiException    {        if (!NumberUtils.isDigits(index)) {            return null;        }        XWikiDeletedDocument dd = this.xwiki.getDeletedDocument(Long.parseLong(index), this.context);        if (dd == null) {            return null;        }        return new DeletedDocument(dd, this.context);    }    public List<DeletedAttachment> getDeletedAttachments(String docName)    {        try {            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =                this.xwiki.getDeletedAttachments(docName, this.context);            if (attachments == null || attachments.isEmpty()) {                attachments = Collections.emptyList();            }            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {                result.add(new DeletedAttachment(attachment, this.context));            }            return result;        } catch (Exception ex) {            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);        }        return Collections.emptyList();    }    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename)    {        try {            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =                this.xwiki.getDeletedAttachments(docName, filename, this.context);            if (attachments == null) {                attachments = Collections.emptyList();            }            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {                result.add(new DeletedAttachment(attachment, this.context));            }            return result;        } catch (Exception ex) {            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);        }        return Collections.emptyList();    }    public DeletedAttachment getDeletedAttachment(String id)    {        try {            com.xpn.xwiki.doc.DeletedAttachment attachment = this.xwiki.getDeletedAttachment(id, this.context);            if (attachment != null) {                return new DeletedAttachment(attachment, this.context);            }        } catch (Exception ex) {            LOGGER.warn(\"Failed to retrieve deleted attachment\", ex);        }        return null;    }    public boolean exists(String fullname) throws XWikiException    {        return this.xwiki.exists(fullname, getXWikiContext());    }    public boolean exists(DocumentReference reference) throws XWikiException    {        return this.xwiki.exists(reference, getXWikiContext());    }    @Unstable    public boolean exists(PageReference reference)    {        return this.xwiki.exists(reference, getXWikiContext());    }    public boolean checkAccess(String docname, String right)    {        try {            DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);            XWikiDocument doc = getXWikiContext().getWiki().getDocument(docReference, this.context);            return getXWikiContext().getWiki().checkAccess(right, doc, getXWikiContext());        } catch (XWikiException e) {            return false;        }    }    public Document getDocument(String space, String fullname) throws XWikiException    {        XWikiDocument doc = this.xwiki.getDocument(space, fullname, getXWikiContext());        if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(), doc.getFullName(),            getXWikiContext()) == false) {            return null;        }        return doc.newDocument(getXWikiContext());    }    public Document getDocument(Document doc, String rev) throws XWikiException    {        if (doc == null || doc.getDoc() == null) {            return null;        }        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {            return null;        }        return doc.getDocumentRevision(rev);    }    public Document getDocument(DocumentReference reference, String revision) throws XWikiException    {        try {            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {                XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(reference, revision);                if (documentRevision != null) {                    return new Document(documentRevision, this.context);                }            }        } catch (Exception e) {            LOGGER.error(\"Failed to access revision [{}] of document {}\", revision, reference, e);        }        return null;    }    public String getTextArea(String content)    {        return com.xpn.xwiki.XWiki.getTextArea(content, getXWikiContext());    }    public List<String> getClassList() throws XWikiException    {        return this.xwiki.getClassList(getXWikiContext());    }    public MetaClass getMetaclass()    {        return this.xwiki.getMetaclass();    }    @Deprecated    public List<String> searchDocuments(String wheresql) throws XWikiException    {        return this.xwiki.getStore().searchDocumentsNames(wheresql, getXWikiContext());    }    @Deprecated    public List<String> searchDocuments(String wheresql, int nb, int start) throws XWikiException    {        return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, getXWikiContext());    }    @Deprecated    public List<String> searchDocuments(String wheresql, int nb, int start, String selectColumns) throws XWikiException    {        if (hasProgrammingRights()) {            return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, selectColumns, getXWikiContext());        }        return Collections.emptyList();    }    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale) throws XWikiException    {        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, getXWikiContext()));    }    public"}
{"code": "import java.net.URL;import java.nio.file.Path;import java.nio.file.Paths;import org.apache.commons.configuration2.BaseConfiguration;import org.apache.commons.configuration2.Configuration;import org.apache.commons.configuration2.builder.fluent.Configurations;import org.apache.commons.configuration2.ex.ConfigurationException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.filter.input.InputSource;import org.xwiki.skin.Resource;import org.xwiki.skin.Skin;import static org.apache.commons.lang3.exception.ExceptionUtils.getRootCauseMessage;public abstract class AbstractResourceSkin extends AbstractSkin{    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractResourceSkin.class);    private Configuration properties;    public AbstractResourceSkin(String id, InternalSkinManager skinManager,        InternalSkinConfiguration configuration, Logger logger)    {        super(id, skinManager, configuration, logger);    }    abstract AbstractResource<InputSource> createResource(String resourcePath, String resourceName);    abstract URL getResourceURL(String resourcePath);    @Override    public String getOutputSyntaxString()    {        return getProperties().getString(\"outputSyntax\");    }    @Override    protected Skin createParent()    {        Skin skin;        String parentId = getProperties().getString(\"parent\");        if (parentId != null) {            if (parentId.isEmpty()) {                skin = VOID;            } else {                skin = this.skinManager.getSkin(parentId);            }        } else {            skin = null;        }        return skin;    }    @Override    public Resource<?> getLocalResource(String resourceName)    {        String resourcePath = getSkinResourcePath(resourceName);        if (resourcePath != null && getResourceURL(resourcePath) != null) {            return createResource(resourcePath, resourceName);        }        return null;    }    protected String getPropertiesPath()    {        return getSkinFolder() + \"skin.properties\";    }    protected String getSkinFolder()    {        return \"skins/\" + this.id + '/';    }    protected Configuration getProperties()    {        if (this.properties == null) {            URL url = getResourceURL(getPropertiesPath());            if (url != null) {                try {                    this.properties = new Configurations().properties(url);                } catch (ConfigurationException e) {                    LOGGER.error(\"Failed to load skin [{}] properties file ([])\", this.id, url,                        getRootCauseMessage(e));                    this.properties = new BaseConfiguration();                }            } else {                LOGGER.debug(\"No properties found for skin [{}]\", this.id);                this.properties = new BaseConfiguration();            }        }        return this.properties;    }    private String getSkinResourcePath(String resource)    {        String skinFolder = getSkinFolder();        String resourcePath = skinFolder + resource;        Path normalizedResource = Paths.get(resourcePath).normalize();        if (!normalizedResource.startsWith(skinFolder)) {            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);            return null;        }        return resourcePath;    }}", "nl": "import java.net.URL;import java.nio.file.Path;import java.nio.file.Paths;import org.apache.commons.configuration2.BaseConfiguration;import org.apache.commons.configuration2.Configuration;import org.apache.commons.configuration2.builder.fluent.Configurations;import org.apache.commons.configuration2.ex.ConfigurationException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.xwiki.filter.input.InputSource;import org.xwiki.skin.Resource;import org.xwiki.skin.Skin;import static org.apache.commons.lang3.exception.ExceptionUtils.getRootCauseMessage;public abstract class AbstractResourceSkin extends AbstractSkin{    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractResourceSkin.class);    private Configuration properties;    public AbstractResourceSkin(String id, InternalSkinManager skinManager,        InternalSkinConfiguration configuration, Logger logger)    {        super(id, skinManager, configuration, logger);    }    abstract AbstractResource<InputSource> createResource(String resourcePath, String resourceName);    abstract URL getResourceURL(String resourcePath);    @Override    public String getOutputSyntaxString()    {        return getProperties().getString(\"outputSyntax\");    }    @Override    protected Skin createParent()    {        Skin skin;        String parentId = getProperties().getString(\"parent\");        if (parentId != null) {            if (parentId.isEmpty()) {                skin = VOID;            } else {                skin = this.skinManager.getSkin(parentId);            }        } else {            skin = null;        }        return skin;    }    @Override    public Resource<?> getLocalResource(String resourceName)    {        String resourcePath = getSkinResourcePath(resourceName);        if (resourcePath != null && getResourceURL(resourcePath) != null) {            return createResource(resourcePath, resourceName);        }        return null;    }    protected String getPropertiesPath()    {        return getSkinFolder() + \"skin.properties\";    }    protected String getSkinFolder()    {        return \"skins/\" + this.id + '/';    }    protected Configuration getProperties()    {        if (this.properties == null) {            URL url = getResourceURL(getPropertiesPath());            if (url != null) {                try {                    this.properties = new Configurations().properties(url);                } catch (ConfigurationException e) {                    LOGGER.error(\"Failed to load skin [{}] properties file ([])\", this.id, url,                        getRootCauseMessage(e));                    this.properties = new BaseConfiguration();                }            } else {                LOGGER.debug(\"No properties found for skin [{}]\", this.id);                this.properties = new BaseConfiguration();            }        }        return this.properties;    }    private String getSkinResourcePath(String resource)    {        String skinFolder = getSkinFolder();        String resourcePath = skinFolder + resource;        Path normalizedResource = Paths.get(resourcePath).normalize();        if (!normalizedResource.startsWith(skinFolder)) {            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);            return null;        }        return resourcePath;    }}"}
{"code": "import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Type;import java.net.URL;import java.nio.charset.StandardCharsets;import java.nio.file.Path;import java.nio.file.Paths;import java.util.AbstractSet;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.Callable;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.xwiki.component.annotation.Component;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.phase.Initializable;import org.xwiki.component.phase.InitializationException;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.environment.Environment;import org.xwiki.filter.input.InputSource;import org.xwiki.filter.input.InputStreamInputSource;import org.xwiki.filter.input.ReaderInputSource;import org.xwiki.filter.input.StringInputSource;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.properties.BeanManager;import org.xwiki.properties.ConverterManager;import org.xwiki.properties.PropertyException;import org.xwiki.properties.RawProperties;import org.xwiki.properties.annotation.PropertyHidden;import org.xwiki.properties.annotation.PropertyId;import org.xwiki.rendering.async.internal.AsyncRendererConfiguration;import org.xwiki.rendering.async.internal.block.BlockAsyncRendererExecutor;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.CompositeBlock;import org.xwiki.rendering.block.RawBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.parser.ContentParser;import org.xwiki.rendering.renderer.BlockRenderer;import org.xwiki.rendering.renderer.printer.WikiPrinter;import org.xwiki.rendering.renderer.printer.WriterWikiPrinter;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.rendering.util.ErrorBlockGenerator;import org.xwiki.skin.Resource;import org.xwiki.skin.ResourceRepository;import org.xwiki.skin.Skin;import org.xwiki.template.Template;import org.xwiki.template.TemplateContent;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.internal.skin.AbstractSkinResource;import com.xpn.xwiki.internal.skin.InternalSkinManager;import com.xpn.xwiki.internal.skin.WikiResource;import com.xpn.xwiki.user.api.XWikiRightService;@Component(roles = InternalTemplateManager.class)@Singletonpublic class InternalTemplateManager implements Initializable{    public static final DocumentReference SUPERADMIN_REFERENCE =        new DocumentReference(\"xwiki\", XWiki.SYSTEM_SPACE, XWikiRightService.SUPERADMIN_USER);    private static final Pattern PROPERTY_LINE = Pattern.compile(\"^##!(.+)=(.*)$\\r?\\n?\", Pattern.MULTILINE);    private static final String TEMPLATE_RESOURCE_SUFFIX = \"/templates/\";    @Inject    private Environment environment;    @Inject    private ContentParser parser;    @Inject    @Named(\"context\")    private Provider<ComponentManager> componentManagerProvider;    @Inject    private RenderingContext renderingContext;    @Inject    @Named(\"plain/1.0\")    private BlockRenderer plainRenderer;    @Inject    @Named(\"xwikicfg\")    private ConfigurationSource xwikicfg;    @Inject    @Named(\"all\")    private ConfigurationSource allConfiguration;    @Inject    @Named(\"currentmixed\")    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    @Inject    private BeanManager beanManager;    @Inject    private ConverterManager converter;    @Inject    private InternalSkinManager skins;    @Inject    private JobProgressManager progress;    @Inject    private Provider<TemplateAsyncRenderer> rendererProvider;    @Inject    private BlockAsyncRendererExecutor asyncExecutor;    @Inject    private TemplateContext templateContext;    @Inject    private VelocityTemplateEvaluator evaluator;    @Inject    private Provider<ErrorBlockGenerator> errorBlockGeneratorProvider;    @Inject    private Logger logger;    private String templateRootURL;    private static abstract class AbtractTemplate<T extends TemplateContent, R extends Resource<?>> implements Template    {        protected R resource;        protected T content;        public AbtractTemplate(R resource)        {            this.resource = resource;        }        @Override        public String getId()        {            return this.resource.getId();        }        @Override        public String getPath()        {            return this.resource.getPath();        }        @Override        public TemplateContent getContent() throws Exception        {            if (this.content == null) {                String strinContent;                try (InputSource source = this.resource.getInputSource()) {                    if (source instanceof StringInputSource) {                        strinContent = source.toString();                    } else if (source instanceof ReaderInputSource) {                        strinContent = IOUtils.toString(((ReaderInputSource) source).getReader());                    } else if (source instanceof InputStreamInputSource) {                        strinContent = IOUtils.toString(((InputStreamInputSource) source).getInputStream(),                            StandardCharsets.UTF_8);                    } else {                        return null;                    }                }                this.content = getContentInternal(strinContent);            }            return this.content;        }        protected abstract T getContentInternal(String content) throws Exception;        @Override        public String toString()        {            return this.resource.getId();        }    }    private class EnvironmentTemplate extends AbtractTemplate<FilesystemTemplateContent, AbstractSkinResource>    {        EnvironmentTemplate(AbstractSkinResource resource)        {            super(resource);        }        @Override        protected FilesystemTemplateContent getContentInternal(String content)        {            return new FilesystemTemplateContent(content);        }    }    private class ClassloaderTemplate extends AbtractTemplate<FilesystemTemplateContent, ClassloaderResource>    {        ClassloaderTemplate(ClassloaderResource resource)        {            super(resource);        }        @Override        protected FilesystemTemplateContent getContentInternal(String content)        {            return new FilesystemTemplateContent(content);        }    }    private class DefaultTemplate extends AbtractTemplate<DefaultTemplateContent, Resource<?>>    {        DefaultTemplate(Resource<?> resource)        {            super(resource);        }        @Override        protected DefaultTemplateContent getContentInternal(String content)        {            if (this.resource instanceof WikiResource) {                WikiResource<?> wikiResource = ((WikiResource<?>) this.resource);                return new DefaultTemplateContent(content, wikiResource.getAuthorReference(),                    wikiResource.getDocumentReference());            } else {                return new DefaultTemplateContent(content);            }        }    }    private class StringTemplate extends DefaultTemplate    {        StringTemplate(String content, DocumentReference authorReference, DocumentReference documentReference)            throws Exception        {            super(new StringResource(content));            ((DefaultTemplateContent) this.getContent()).setAuthorReference(authorReference);            ((DefaultTemplateContent) this.getContent()).setDocumentReference(documentReference);        }    }    private class DefaultTemplateContent implements RawProperties, TemplateContent    {        protected String content;        protected boolean authorProvided;        protected DocumentReference authorReference;        protected DocumentReference documentReference;        @PropertyId(\"source.syntax\")        public Syntax sourceSyntax;        @PropertyId(\"raw.syntax\")        public Syntax rawSyntax;        public boolean cacheAllowed;        public boolean asyncAllowed;        public Set<String> contextEntries;        public UniqueContext unique;        protected Map<String, Object> properties = new HashMap<>();        DefaultTemplateContent(String content)        {            this.content = content;            init();        }        DefaultTemplateContent(String content, DocumentReference authorReference)        {            this(content);            setAuthorReference(authorReference);        }        DefaultTemplateContent(String content, DocumentReference authorReference, DocumentReference sourceReference)        {            this(content, authorReference);            setDocumentReference(sourceReference);        }        @Override        public Syntax getSourceSyntax()        {            return this.sourceSyntax;        }        @Override        public Syntax getRawSyntax()        {            return this.rawSyntax;        }        @Override        public boolean isAsyncAllowed()        {            return this.asyncAllowed;        }        @Override        public boolean isCacheAllowed()        {            return this.cacheAllowed;        }        @Override        public UniqueContext getUnique()        {            return this.unique;        }        @Override        public Set<String> getContextEntries()        {            if (this.contextEntries == null) {                return Collections.emptySet();            }            if (this.contextEntries instanceof AbstractSet) {                this.contextEntries = Collections.unmodifiableSet(this.contextEntries);            }            return this.contextEntries;        }        @Override        public <T> T getProperty(String name, T def)        {            if (!this.properties.containsKey(name)) {                return def;            }            if (def != null) {                return getProperty(name, def.getClass());            }            return (T) this.properties.get(name);        }        @Override        public <T> T getProperty(String name, Type type)        {            return converter.convert(type, this.properties.get(name));        }        protected void init()        {            Matcher matcher = PROPERTY_LINE.matcher(this.content);            Map<String, String> map = new HashMap<>();            while (matcher.find()) {                String key = matcher.group(1);                String value = matcher.group(2);                map.put(key, value);                this.content = this.content.substring(matcher.end());            }            try {                InternalTemplateManager.this.beanManager.populate(this, map);            } catch (PropertyException e) {                InternalTemplateManager.this.logger.error(\"Failed to populate properties of template\", e);            }        }        @Override        public String getContent()        {            return this.content;        }        @PropertyHidden        @Override        public boolean isAuthorProvided()        {            return this.authorProvided;        }        @PropertyId(\"author\")        @Override        public DocumentReference getAuthorReference()        {            return this.authorReference;        }        protected void setAuthorReference(DocumentReference authorReference)        {            this.authorReference = authorReference;            this.authorProvided = true;        }        @Override        public DocumentReference getDocumentReference()        {            return this.documentReference;        }        protected void setDocumentReference(DocumentReference documentReference)        {            this.documentReference = documentReference;        }        @Override        public void set(String propertyName, Object value)        {            this.properties.put(propertyName, value);        }    }    private class FilesystemTemplateContent extends DefaultTemplateContent    {        public FilesystemTemplateContent(String content)        {            super(content);            setPrivileged(true);        }        @Override        public void setAuthorReference(DocumentReference authorReference)        {            super.setAuthorReference(authorReference);        }        @SuppressWarnings(\"unused\")        public boolean isPrivileged()        {            return SUPERADMIN_REFERENCE.equals(getAuthorReference());        }        public void setPrivileged(boolean privileged)        {            if (privileged) {                setAuthorReference(SUPERADMIN_REFERENCE);            } else {                this.authorReference = null;                this.authorProvided = false;            }        }    }    @Override    public void initialize() throws InitializationException    {        getTemplateRootPath();    }    private String getTemplateRootPath()    {        if (this.templateRootURL == null) {            URL url = this.environment.getResource(TEMPLATE_RESOURCE_SUFFIX);            if (url != null) {                this.templateRootURL = url.toString();            }        }        return this.templateRootURL;    }    private String getTemplateResourcePath(String templateName)    {        String templatePath = TEMPLATE_RESOURCE_SUFFIX + templateName;        URL templateURL = this.environment.getResource(templatePath);        if (templateURL == null) {            return null;        }        String rootTemplate = getTemplateRootPath();        if (rootTemplate != null) {            String templateURLString = templateURL.toString();            if (!templateURLString.startsWith(getTemplateRootPath())) {                this.logger.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\",                    templateURLString);                return null;            }        }        return templatePath;    }    private void renderError(Throwable throwable, boolean inline, Writer writer)    {        Block block = generateError(throwable, inline);        render(block, writer);    }    private Block generateError(Throwable throwable, boolean inline)    {        List<Block> errorBlocks = this.errorBlockGeneratorProvider.get().generateErrorBlocks(inline, null,            \"Failed to execute template\", null, throwable);        if (inline) {            if (errorBlocks.size() == 1) {                return errorBlocks.get(0);            } else {                return new CompositeBlock(errorBlocks);            }        } else {            return new XDOM(errorBlocks);        }    }    public XDOM getXDOMNoException(String templateName)    {        XDOM xdom;        try {            xdom = getXDOM(templateName);        } catch (Throwable e) {            this.logger.error(\"Error while getting template [{}] XDOM\", templateName, e);            xdom = (XDOM) generateError(e, false);        }        return xdom;    }    public XDOM getXDOMNoException(Template template)    {        XDOM xdom;        try {            xdom = getXDOM(template);        } catch (Throwable e) {            this.logger.error(\"Error while getting template [{}] XDOM\", template.getId(), e);            xdom = (XDOM) generateError(e, false);        }        return xdom;    }    public XDOM getXDOM(Template template) throws Exception    {        XDOM xdom;        if (template != null) {            xdom = getXDOM(template, template.getContent());        } else {            xdom = new XDOM(Collections.<Block>emptyList());        }        return xdom;    }    private XDOM getXDOM(Template template, TemplateContent content) throws Exception    {        XDOM xdom;        if (content.getSourceSyntax() != null) {            xdom = this.parser.parse(content.getContent(), content.getSourceSyntax());        } else {            String result = evaluateContent(template, content);            if (StringUtils.isEmpty(result)) {                xdom = new XDOM(Collections.emptyList());            } else {                xdom = new XDOM(Arrays.asList(new RawBlock(result, content.getRawSyntax() != null                    ? content.getRawSyntax() : this.renderingContext.getTargetSyntax())));            }        }        return xdom;    }    public XDOM getXDOM(String templateName) throws Exception    {        Template template = getTemplate(templateName);        return getXDOM(template);    }    public String renderNoException(String template, boolean inline)    {        Writer writer = new StringWriter();        renderNoException(template, inline, writer);        return writer.toString();    }    public void renderNoException(String templateName, boolean inline, Writer writer)    {        try {            render(templateName, inline, writer);        } catch (Exception e) {            this.logger.error(\"Error while rendering template [{}]\", templateName, e);            renderError(e, inline, writer);        }    }    public void renderNoException(Template template, boolean inline, Writer writer)    {        try {            render(template, inline, writer);        } catch (Exception e) {            this.logger.error(\"Error while rendering template [{}]\", template, e);            renderError(e, inline, writer);        }    }    public String render(String templateName, boolean inline) throws Exception    {        return renderFromSkin(templateName, (Skin) null, inline);    }    public String renderFromSkin(String templateName, String skinId, boolean inline) throws Exception    {        Skin skin = this.skins.getSkin(skinId);        return skin != null ? renderFromSkin(templateName, skin, inline) : null;    }    public String renderFromSkin(String templateName, Skin skin, boolean inline) throws Exception    {        Writer writer = new StringWriter();        renderFromSkin(templateName, skin, inline, writer);        return writer.toString();    }    public void render(String templateName, boolean inline, Writer writer) throws Exception    {        renderFromSkin(templateName, null, inline, writer);    }    public void renderFromSkin(final String templateName, ResourceRepository repository, boolean inline,        final Writer writer) throws Exception    {        this.progress.startStep(templateName, \"template.render.message\", \"Render template [{}]\", templateName);        try {            final Template template =                repository != null ? getTemplate(templateName, repository) : getTemplate(templateName);            if (template != null) {                render(template, inline, writer);            }        } finally {            this.progress.endStep(templateName);        }    }    public void render(Template template, boolean inline, Writer writer) throws Exception    {        if (!shouldExecute(template)) {            return;        }        TemplateAsyncRenderer renderer = this.rendererProvider.get();        Set<String> contextEntries = renderer.initialize(template, inline, false);        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();        configuration.setContextEntries(contextEntries);        TemplateContent templateContent = template.getContent();        if (templateContent.isAuthorProvided()) {            configuration.setSecureReference(templateContent.getDocumentReference(),                templateContent.getAuthorReference());        }        String result = this.asyncExecutor.render(renderer, configuration);        writer.append(result);    }    private boolean shouldExecute(Template template) throws Exception    {        return template != null            && (template.getContent().getUnique() == null || !this.templateContext.isExecuted(template));    }    private void render(Block block, Writer writer)    {        WikiPrinter printer = new WriterWikiPrinter(writer);        BlockRenderer blockRenderer;        try {            blockRenderer =                this.componentManagerProvider.get().getInstance(BlockRenderer.class, getTargetSyntax().toIdString());        } catch (ComponentLookupException e) {            blockRenderer = this.plainRenderer;        }        blockRenderer.render(block, printer);    }    public Block executeNoException(String templateName, boolean inline)    {        Block block;        try {            block = execute(templateName, inline);        } catch (Throwable e) {            this.logger.error(\"Error while executing template [{}]\", templateName, e);            block = generateError(e, inline);        }        return block;    }    public Block executeNoException(Template template, boolean inline)    {        Block block;        try {            block = execute(template, inline);        } catch (Throwable e) {            this.logger.error(\"Error while executing template [{}]\", template.getId(), e);            block = generateError(e, inline);        }        return block;    }    public Block execute(String templateName, boolean inline) throws Exception    {        final Template template = getTemplate(templateName);        return execute(template, inline);    }    public Block execute(Template template, boolean inline) throws Exception    {        if (!shouldExecute(template)) {            return new XDOM(Collections.emptyList());        }        TemplateAsyncRenderer renderer = this.rendererProvider.get();        Set<String> contextEntries = renderer.initialize(template, inline, true);        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();        configuration.setContextEntries(contextEntries);        if (template.getContent().isAuthorProvided()) {            configuration.setSecureReference(template.getContent().getDocumentReference(),                template.getContent().getAuthorReference());        }        Block block = this.asyncExecutor.execute(renderer, configuration);        if (inline) {            return block;        }        if (block instanceof XDOM) {            return (XDOM) block;        }        return new XDOM(Collections.singletonList(block));    }    private String evaluateContent(Template template, TemplateContent content) throws Exception    {        Writer writer = new StringWriter();        this.evaluator.evaluateContent(template, content, writer);        return writer.toString();    }    private Syntax getTargetSyntax()    {        Syntax targetSyntax = this.renderingContext.getTargetSyntax();        return targetSyntax != null ? targetSyntax : Syntax.PLAIN_1_0;    }    private EnvironmentTemplate getFileSystemTemplate(String templateName)    {        String path = getTemplateResourcePath(templateName);        return path != null ? new EnvironmentTemplate(new TemplateSkinResource(path, templateName, this.environment))            : null;    }    private Template getClassloaderTemplate(String prefixPath, String templateName)    {        return getClassloaderTemplate(Thread.currentThread().getContextClassLoader(), prefixPath, templateName);    }    private Template getClassloaderTemplate(ClassLoader classloader, String prefixPath, String templateName)    {        String templatePath = prefixPath + templateName;        Path normalizedResource = Paths.get(templatePath).normalize();        if (!normalizedResource.startsWith(prefixPath)) {            this.logger.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);            return null;        }        URL url = classloader.getResource(templatePath);        return url != null ? new ClassloaderTemplate(new ClassloaderResource(url, templateName)) : null;    }    private Template createTemplate(Resource<?> resource)    {        Template template;        if (resource instanceof AbstractSkinResource) {            template = new EnvironmentTemplate((AbstractSkinResource) resource);        } else {            template = new DefaultTemplate(resource);        }        return template;    }    public Template getResourceTemplate(String templateName, ResourceRepository repository)    {        Resource<?> resource = repository.getLocalResource(templateName);        if (resource != null) {            return createTemplate(resource);        }        return null;    }    public Template getTemplate(String templateName, ResourceRepository repository)    {        Resource<?> resource = repository.getResource(templateName);        if (resource != null) {            return createTemplate(resource);        }        return null;    }    public Template getTemplate(String templateName)    {        Template template = null;        Skin skin = this.skins.getCurrentSkin(false);        if (skin != null) {            template = getTemplate(templateName, skin);        }        if (skin == null) {            Skin baseSkin = this.skins.getCurrentParentSkin(false);            if (baseSkin != null) {                template = getTemplate(templateName, baseSkin);            }        }        if (template == null) {            template = getFileSystemTemplate(templateName);        }        if (template == null) {            template = getClassloaderTemplate(\"templates/\", templateName);        }        return template;    }    public Template createStringTemplate(String content, DocumentReference author, DocumentReference sourceReference)        throws Exception    {        return new StringTemplate(content, author, sourceReference);    }}", "nl": "import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Type;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.AbstractSet;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.Callable;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.xwiki.component.annotation.Component;import org.xwiki.component.manager.ComponentLookupException;import org.xwiki.component.manager.ComponentManager;import org.xwiki.component.phase.Initializable;import org.xwiki.component.phase.InitializationException;import org.xwiki.configuration.ConfigurationSource;import org.xwiki.environment.Environment;import org.xwiki.filter.input.InputSource;import org.xwiki.filter.input.InputStreamInputSource;import org.xwiki.filter.input.ReaderInputSource;import org.xwiki.filter.input.StringInputSource;import org.xwiki.job.event.status.JobProgressManager;import org.xwiki.model.reference.DocumentReference;import org.xwiki.model.reference.DocumentReferenceResolver;import org.xwiki.properties.BeanManager;import org.xwiki.properties.ConverterManager;import org.xwiki.properties.PropertyException;import org.xwiki.properties.RawProperties;import org.xwiki.properties.annotation.PropertyHidden;import org.xwiki.properties.annotation.PropertyId;import org.xwiki.rendering.async.internal.AsyncRendererConfiguration;import org.xwiki.rendering.async.internal.block.BlockAsyncRendererExecutor;import org.xwiki.rendering.block.Block;import org.xwiki.rendering.block.CompositeBlock;import org.xwiki.rendering.block.RawBlock;import org.xwiki.rendering.block.XDOM;import org.xwiki.rendering.parser.ContentParser;import org.xwiki.rendering.renderer.BlockRenderer;import org.xwiki.rendering.renderer.printer.WikiPrinter;import org.xwiki.rendering.renderer.printer.WriterWikiPrinter;import org.xwiki.rendering.syntax.Syntax;import org.xwiki.rendering.transformation.RenderingContext;import org.xwiki.rendering.util.ErrorBlockGenerator;import org.xwiki.skin.Resource;import org.xwiki.skin.ResourceRepository;import org.xwiki.skin.Skin;import org.xwiki.template.Template;import org.xwiki.template.TemplateContent;import com.xpn.xwiki.XWiki;import com.xpn.xwiki.internal.skin.AbstractSkinResource;import com.xpn.xwiki.internal.skin.InternalSkinManager;import com.xpn.xwiki.internal.skin.WikiResource;import com.xpn.xwiki.user.api.XWikiRightService;@Component(roles = InternalTemplateManager.class)@Singletonpublic class InternalTemplateManager implements Initializable{    public static final DocumentReference SUPERADMIN_REFERENCE =        new DocumentReference(\"xwiki\", XWiki.SYSTEM_SPACE, XWikiRightService.SUPERADMIN_USER);    private static final Pattern PROPERTY_LINE = Pattern.compile(\"^##!(.+)=(.*)$\\r?\\n?\", Pattern.MULTILINE);    private static final String TEMPLATE_RESOURCE_SUFFIX = \"/templates/\";    @Inject    private Environment environment;    @Inject    private ContentParser parser;    @Inject    @Named(\"context\")    private Provider<ComponentManager> componentManagerProvider;    @Inject    private RenderingContext renderingContext;    @Inject    @Named(\"plain/1.0\")    private BlockRenderer plainRenderer;    @Inject    @Named(\"xwikicfg\")    private ConfigurationSource xwikicfg;    @Inject    @Named(\"all\")    private ConfigurationSource allConfiguration;    @Inject    @Named(\"currentmixed\")    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;    @Inject    private BeanManager beanManager;    @Inject    private ConverterManager converter;    @Inject    private InternalSkinManager skins;    @Inject    private JobProgressManager progress;    @Inject    private Provider<TemplateAsyncRenderer> rendererProvider;    @Inject    private BlockAsyncRendererExecutor asyncExecutor;    @Inject    private TemplateContext templateContext;    @Inject    private VelocityTemplateEvaluator evaluator;    @Inject    private Provider<ErrorBlockGenerator> errorBlockGeneratorProvider;    @Inject    private Logger logger;    private String templateRootURL;    private static abstract class AbtractTemplate<T extends TemplateContent, R extends Resource<?>> implements Template    {        protected R resource;        protected T content;        public AbtractTemplate(R resource)        {            this.resource = resource;        }        @Override        public String getId()        {            return this.resource.getId();        }        @Override        public String getPath()        {            return this.resource.getPath();        }        @Override        public TemplateContent getContent() throws Exception        {            if (this.content == null) {                String strinContent;                try (InputSource source = this.resource.getInputSource()) {                    if (source instanceof StringInputSource) {                        strinContent = source.toString();                    } else if (source instanceof ReaderInputSource) {                        strinContent = IOUtils.toString(((ReaderInputSource) source).getReader());                    } else if (source instanceof InputStreamInputSource) {                        strinContent = IOUtils.toString(((InputStreamInputSource) source).getInputStream(),                            StandardCharsets.UTF_8);                    } else {                        return null;                    }                }                this.content = getContentInternal(strinContent);            }            return this.content;        }        protected abstract T getContentInternal(String content) throws Exception;        @Override        public String toString()        {            return this.resource.getId();        }    }    private class EnvironmentTemplate extends AbtractTemplate<FilesystemTemplateContent, AbstractSkinResource>    {        EnvironmentTemplate(AbstractSkinResource resource)        {            super(resource);        }        @Override        protected FilesystemTemplateContent getContentInternal(String content)        {            return new FilesystemTemplateContent(content);        }    }    private class ClassloaderTemplate extends AbtractTemplate<FilesystemTemplateContent, ClassloaderResource>    {        ClassloaderTemplate(ClassloaderResource resource)        {            super(resource);        }        @Override        protected FilesystemTemplateContent getContentInternal(String content)        {            return new FilesystemTemplateContent(content);        }    }    private class DefaultTemplate extends AbtractTemplate<DefaultTemplateContent, Resource<?>>    {        DefaultTemplate(Resource<?> resource)        {            super(resource);        }        @Override        protected DefaultTemplateContent getContentInternal(String content)        {            if (this.resource instanceof WikiResource) {                WikiResource<?> wikiResource = ((WikiResource<?>) this.resource);                return new DefaultTemplateContent(content, wikiResource.getAuthorReference(),                    wikiResource.getDocumentReference());            } else {                return new DefaultTemplateContent(content);            }        }    }    private class StringTemplate extends DefaultTemplate    {        StringTemplate(String content, DocumentReference authorReference, DocumentReference documentReference)            throws Exception        {            super(new StringResource(content));            ((DefaultTemplateContent) this.getContent()).setAuthorReference(authorReference);            ((DefaultTemplateContent) this.getContent()).setDocumentReference(documentReference);        }    }    private class DefaultTemplateContent implements RawProperties, TemplateContent    {        protected String content;        protected boolean authorProvided;        protected DocumentReference authorReference;        protected DocumentReference documentReference;        @PropertyId(\"source.syntax\")        public Syntax sourceSyntax;        @PropertyId(\"raw.syntax\")        public Syntax rawSyntax;        public boolean cacheAllowed;        public boolean asyncAllowed;        public Set<String> contextEntries;        public UniqueContext unique;        protected Map<String, Object> properties = new HashMap<>();        DefaultTemplateContent(String content)        {            this.content = content;            init();        }        DefaultTemplateContent(String content, DocumentReference authorReference)        {            this(content);            setAuthorReference(authorReference);        }        DefaultTemplateContent(String content, DocumentReference authorReference, DocumentReference sourceReference)        {            this(content, authorReference);            setDocumentReference(sourceReference);        }        @Override        public Syntax getSourceSyntax()        {            return this.sourceSyntax;        }        @Override        public Syntax getRawSyntax()        {            return this.rawSyntax;        }        @Override        public boolean isAsyncAllowed()        {            return this.asyncAllowed;        }        @Override        public boolean isCacheAllowed()        {            return this.cacheAllowed;        }        @Override        public UniqueContext getUnique()        {            return this.unique;        }        @Override        public Set<String> getContextEntries()        {            if (this.contextEntries == null) {                return Collections.emptySet();            }            if (this.contextEntries instanceof AbstractSet) {                this.contextEntries = Collections.unmodifiableSet(this.contextEntries);            }            return this.contextEntries;        }        @Override        public <T> T getProperty(String name, T def)        {            if (!this.properties.containsKey(name)) {                return def;            }            if (def != null) {                return getProperty(name, def.getClass());            }            return (T) this.properties.get(name);        }        @Override        public <T> T getProperty(String name, Type type)        {            return converter.convert(type, this.properties.get(name));        }        protected void init()        {            Matcher matcher = PROPERTY_LINE.matcher(this.content);            Map<String, String> map = new HashMap<>();            while (matcher.find()) {                String key = matcher.group(1);                String value = matcher.group(2);                map.put(key, value);                this.content = this.content.substring(matcher.end());            }            try {                InternalTemplateManager.this.beanManager.populate(this, map);            } catch (PropertyException e) {                InternalTemplateManager.this.logger.error(\"Failed to populate properties of template\", e);            }        }        @Override        public String getContent()        {            return this.content;        }        @PropertyHidden        @Override        public boolean isAuthorProvided()        {            return this.authorProvided;        }        @PropertyId(\"author\")        @Override        public DocumentReference getAuthorReference()        {            return this.authorReference;        }        protected void setAuthorReference(DocumentReference authorReference)        {            this.authorReference = authorReference;            this.authorProvided = true;        }        @Override        public DocumentReference getDocumentReference()        {            return this.documentReference;        }        protected void setDocumentReference(DocumentReference documentReference)        {            this.documentReference = documentReference;        }        @Override        public void set(String propertyName, Object value)        {            this.properties.put(propertyName, value);        }    }    private class FilesystemTemplateContent extends DefaultTemplateContent    {        public FilesystemTemplateContent(String content)        {            super(content);            setPrivileged(true);        }        @Override        public void setAuthorReference(DocumentReference authorReference)        {            super.setAuthorReference(authorReference);        }        @SuppressWarnings(\"unused\")        public boolean isPrivileged()        {            return SUPERADMIN_REFERENCE.equals(getAuthorReference());        }        public void setPrivileged(boolean privileged)        {            if (privileged) {                setAuthorReference(SUPERADMIN_REFERENCE);            } else {                this.authorReference = null;                this.authorProvided = false;            }        }    }    @Override    public void initialize() throws InitializationException    {        getTemplateRootPath();    }    private String getTemplateRootPath()    {        if (this.templateRootURL == null) {            URL url = this.environment.getResource(TEMPLATE_RESOURCE_SUFFIX);            if (url != null) {                this.templateRootURL = url.toString();            }        }        return this.templateRootURL;    }    private String getTemplateResourcePath(String templateName)    {        String templatePath = TEMPLATE_RESOURCE_SUFFIX + templateName;        URL templateURL = this.environment.getResource(templatePath);        if (templateURL == null) {            return null;        }        String rootTemplate = getTemplateRootPath();        if (rootTemplate != null) {            String templateURLString = templateURL.toString();            if (!templateURLString.startsWith(getTemplateRootPath())) {                this.logger.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\",                    templateURLString);                return null;            }        }        return templatePath;    }    private void renderError(Throwable throwable, boolean inline, Writer writer)    {        Block block = generateError(throwable, inline);        render(block, writer);    }    private Block generateError(Throwable throwable, boolean inline)    {        List<Block> errorBlocks = this.errorBlockGeneratorProvider.get().generateErrorBlocks(inline, null,            \"Failed to execute template\", null, throwable);        if (inline) {            if (errorBlocks.size() == 1) {                return errorBlocks.get(0);            } else {                return new CompositeBlock(errorBlocks);            }        } else {            return new XDOM(errorBlocks);        }    }    public XDOM getXDOMNoException(String templateName)    {        XDOM xdom;        try {            xdom = getXDOM(templateName);        } catch (Throwable e) {            this.logger.error(\"Error while getting template [{}] XDOM\", templateName, e);            xdom = (XDOM) generateError(e, false);        }        return xdom;    }    public XDOM getXDOMNoException(Template template)    {        XDOM xdom;        try {            xdom = getXDOM(template);        } catch (Throwable e) {            this.logger.error(\"Error while getting template [{}] XDOM\", template.getId(), e);            xdom = (XDOM) generateError(e, false);        }        return xdom;    }    public XDOM getXDOM(Template template) throws Exception    {        XDOM xdom;        if (template != null) {            xdom = getXDOM(template, template.getContent());        } else {            xdom = new XDOM(Collections.<Block>emptyList());        }        return xdom;    }    private XDOM getXDOM(Template template, TemplateContent content) throws Exception    {        XDOM xdom;        if (content.getSourceSyntax() != null) {            xdom = this.parser.parse(content.getContent(), content.getSourceSyntax());        } else {            String result = evaluateContent(template, content);            if (StringUtils.isEmpty(result)) {                xdom = new XDOM(Collections.emptyList());            } else {                xdom = new XDOM(Arrays.asList(new RawBlock(result, content.getRawSyntax() != null                    ? content.getRawSyntax() : this.renderingContext.getTargetSyntax())));            }        }        return xdom;    }    public XDOM getXDOM(String templateName) throws Exception    {        Template template = getTemplate(templateName);        return getXDOM(template);    }    public String renderNoException(String template, boolean inline)    {        Writer writer = new StringWriter();        renderNoException(template, inline, writer);        return writer.toString();    }    public void renderNoException(String templateName, boolean inline, Writer writer)    {        try {            render(templateName, inline, writer);        } catch (Exception e) {            this.logger.error(\"Error while rendering template [{}]\", templateName, e);            renderError(e, inline, writer);        }    }    public void renderNoException(Template template, boolean inline, Writer writer)    {        try {            render(template, inline, writer);        } catch (Exception e) {            this.logger.error(\"Error while rendering template [{}]\", template, e);            renderError(e, inline, writer);        }    }    public String render(String templateName, boolean inline) throws Exception    {        return renderFromSkin(templateName, (Skin) null, inline);    }    public String renderFromSkin(String templateName, String skinId, boolean inline) throws Exception    {        Skin skin = this.skins.getSkin(skinId);        return skin != null ? renderFromSkin(templateName, skin, inline) : null;    }    public String renderFromSkin(String templateName, Skin skin, boolean inline) throws Exception    {        Writer writer = new StringWriter();        renderFromSkin(templateName, skin, inline, writer);        return writer.toString();    }    public void render(String templateName, boolean inline, Writer writer) throws Exception    {        renderFromSkin(templateName, null, inline, writer);    }    public void renderFromSkin(final String templateName, ResourceRepository repository, boolean inline,        final Writer writer) throws Exception    {        this.progress.startStep(templateName, \"template.render.message\", \"Render template [{}]\", templateName);        try {            final Template template =                repository != null ? getTemplate(templateName, repository) : getTemplate(templateName);            if (template != null) {                render(template, inline, writer);            }        } finally {            this.progress.endStep(templateName);        }    }    public void render(Template template, boolean inline, Writer writer) throws Exception    {        if (!shouldExecute(template)) {            return;        }        TemplateAsyncRenderer renderer = this.rendererProvider.get();        Set<String> contextEntries = renderer.initialize(template, inline, false);        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();        configuration.setContextEntries(contextEntries);        TemplateContent templateContent = template.getContent();        if (templateContent.isAuthorProvided()) {            configuration.setSecureReference(templateContent.getDocumentReference(),                templateContent.getAuthorReference());        }        String result = this.asyncExecutor.render(renderer, configuration);        writer.append(result);    }    private boolean shouldExecute(Template template) throws Exception    {        return template != null            && (template.getContent().getUnique() == null || !this.templateContext.isExecuted(template));    }    private void render(Block block, Writer writer)    {        WikiPrinter printer = new WriterWikiPrinter(writer);        BlockRenderer blockRenderer;        try {            blockRenderer =                this.componentManagerProvider.get().getInstance(BlockRenderer.class, getTargetSyntax().toIdString());        } catch (ComponentLookupException e) {            blockRenderer = this.plainRenderer;        }        blockRenderer.render(block, printer);    }    public Block executeNoException(String templateName, boolean inline)    {        Block block;        try {            block = execute(templateName, inline);        } catch (Throwable e) {            this.logger.error(\"Error while executing template [{}]\", templateName, e);            block = generateError(e, inline);        }        return block;    }    public Block executeNoException(Template template, boolean inline)    {        Block block;        try {            block = execute(template, inline);        } catch (Throwable e) {            this.logger.error(\"Error while executing template [{}]\", template.getId(), e);            block = generateError(e, inline);        }        return block;    }    public Block execute(String templateName, boolean inline) throws Exception    {        final Template template = getTemplate(templateName);        return execute(template, inline);    }    public Block execute(Template template, boolean inline) throws Exception    {        if (!shouldExecute(template)) {            return new XDOM(Collections.emptyList());        }        TemplateAsyncRenderer renderer = this.rendererProvider.get();        Set<String> contextEntries = renderer.initialize(template, inline, true);        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();        configuration.setContextEntries(contextEntries);        if (template.getContent().isAuthorProvided()) {            configuration.setSecureReference(template.getContent().getDocumentReference(),                template.getContent().getAuthorReference());        }        Block block = this.asyncExecutor.execute(renderer, configuration);        if (inline) {            return block;        }        if (block instanceof XDOM) {            return (XDOM) block;        }        return new XDOM(Collections.singletonList(block));    }    private String evaluateContent(Template template, TemplateContent content) throws Exception    {        Writer writer = new StringWriter();        this.evaluator.evaluateContent(template, content, writer);        return writer.toString();    }    private Syntax getTargetSyntax()    {        Syntax targetSyntax = this.renderingContext.getTargetSyntax();        return targetSyntax != null ? targetSyntax : Syntax.PLAIN_1_0;    }    private EnvironmentTemplate getFileSystemTemplate(String templateName)    {        String path = getTemplateResourcePath(templateName);        return path != null ? new EnvironmentTemplate(new TemplateSkinResource(path, templateName, this.environment))            : null;    }    private Template getClassloaderTemplate(String suffixPath, String templateName)    {        return getClassloaderTemplate(Thread.currentThread().getContextClassLoader(), suffixPath, templateName);    }    private Template getClassloaderTemplate(ClassLoader classloader, String suffixPath, String templateName)    {        String templatePath = suffixPath + templateName;        URL url = classloader.getResource(templatePath);        return url != null ? new ClassloaderTemplate(new ClassloaderResource(url, templateName)) : null;    }    private Template createTemplate(Resource<?> resource)    {        Template template;        if (resource instanceof AbstractSkinResource) {            template = new EnvironmentTemplate((AbstractSkinResource) resource);        } else {            template = new DefaultTemplate(resource);        }        return template;    }    public Template getResourceTemplate(String templateName, ResourceRepository repository)    {        Resource<?> resource = repository.getLocalResource(templateName);        if (resource != null) {            return createTemplate(resource);        }        return null;    }    public Template getTemplate(String templateName, ResourceRepository repository)    {        Resource<?> resource = repository.getResource(templateName);        if (resource != null) {            return createTemplate(resource);        }        return null;    }    public Template getTemplate(String templateName)    {        Template template = null;        Skin skin = this.skins.getCurrentSkin(false);        if (skin != null) {            template = getTemplate(templateName, skin);        }        if (skin == null) {            Skin baseSkin = this.skins.getCurrentParentSkin(false);            if (baseSkin != null) {                template = getTemplate(templateName, baseSkin);            }        }        if (template == null) {            template = getFileSystemTemplate(templateName);        }        if (template == null) {            template = getClassloaderTemplate(\"templates/\", templateName);        }        return template;    }    public Template createStringTemplate(String content, DocumentReference author, DocumentReference sourceReference)        throws Exception    {        return new StringTemplate(content, author, sourceReference);    }}"}
{"code": "import java.io.IOException;import java.math.BigInteger;import java.security.GeneralSecurityException;import java.util.Collection;import java.util.Date;import java.util.EnumSet;import java.util.HashSet;import java.util.List;import java.util.Set;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import org.xwiki.component.annotation.Component;import org.xwiki.crypto.KeyPairGenerator;import org.xwiki.crypto.params.cipher.asymmetric.AsymmetricKeyPair;import org.xwiki.crypto.params.cipher.asymmetric.PrivateKeyParameters;import org.xwiki.crypto.params.cipher.asymmetric.PublicKeyParameters;import org.xwiki.crypto.params.generator.asymmetric.RSAKeyGenerationParameters;import org.xwiki.crypto.pkix.CertificateChainBuilder;import org.xwiki.crypto.pkix.CertificateGeneratorFactory;import org.xwiki.crypto.pkix.CertificateProvider;import org.xwiki.crypto.pkix.CertifyingSigner;import org.xwiki.crypto.pkix.X509ExtensionBuilder;import org.xwiki.crypto.pkix.params.CertifiedKeyPair;import org.xwiki.crypto.pkix.params.CertifiedPublicKey;import org.xwiki.crypto.pkix.params.x509certificate.DistinguishedName;import org.xwiki.crypto.pkix.params.x509certificate.X509CertificateGenerationParameters;import org.xwiki.crypto.pkix.params.x509certificate.X509CertificateParameters;import org.xwiki.crypto.pkix.params.x509certificate.X509CertifiedPublicKey;import org.xwiki.crypto.pkix.params.x509certificate.extension.ExtendedKeyUsages;import org.xwiki.crypto.pkix.params.x509certificate.extension.KeyUsage;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509DnsName;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509GeneralName;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509IpAddress;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509Rfc822Name;import org.xwiki.crypto.signer.CMSSignedDataGenerator;import org.xwiki.crypto.signer.CMSSignedDataVerifier;import org.xwiki.crypto.signer.SignerFactory;import org.xwiki.crypto.signer.param.CMSSignedDataGeneratorParameters;import org.xwiki.crypto.signer.param.CMSSignedDataVerified;import org.xwiki.crypto.signer.param.CMSSignerInfo;import org.xwiki.script.service.ScriptService;@Component@Named(CryptoScriptService.ROLEHINT + '.' + RSACryptoScriptService.ROLEHINT)@Singletonpublic class RSACryptoScriptService implements ScriptService{    public static final String ROLEHINT = \"rsa\";    @Inject    @Named(\"RSA\")    private KeyPairGenerator keyPairGenerator;    @Inject    @Named(\"SHA256withRSAEncryption\")    private SignerFactory signerFactory;    @Inject    private Provider<X509ExtensionBuilder> extensionBuilder;    @Inject    @Named(\"X509\")    private CertificateGeneratorFactory certificateGeneratorFactory;    @Inject    private CMSSignedDataGenerator cmsSignedDataGenerator;    @Inject    @Named(\"X509\")    private CertificateChainBuilder certificateChainBuilder;    @Inject    private CMSSignedDataVerifier cmsSignedDataVerifier;    public AsymmetricKeyPair generateKeyPair()    {        return keyPairGenerator.generate();    }    public AsymmetricKeyPair generateKeyPair(int strength)    {        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength));    }    public AsymmetricKeyPair generateKeyPair(int strength, BigInteger publicExponent, int certainty)    {        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength, publicExponent, certainty));    }    public CertifiedKeyPair createCertifiedKeyPair(PrivateKeyParameters privateKey, CertifiedPublicKey certificate)    {        return new CertifiedKeyPair(privateKey, certificate);    }    public CertifiedKeyPair issueRootCACertificate(AsymmetricKeyPair keyPair, String dn, int validity)        throws IOException, GeneralSecurityException    {        return new CertifiedKeyPair(            keyPair.getPrivate(),            certificateGeneratorFactory.getInstance(signerFactory.getInstance(true, keyPair.getPrivate()),                new X509CertificateGenerationParameters(                    validity,                    extensionBuilder.get().addBasicConstraints(true)                        .addKeyUsage(true, EnumSet.of(KeyUsage.keyCertSign,                            KeyUsage.cRLSign))                        .build()))                .generate(new DistinguishedName(dn), keyPair.getPublic(),                    new X509CertificateParameters())        );    }    public CertifiedKeyPair issueIntermediateCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair,        String dn, int validity)        throws IOException, GeneralSecurityException    {        return new CertifiedKeyPair(            keyPair.getPrivate(),            issueIntermediateCertificate(issuer, keyPair.getPublic(), dn, validity)        );    }    public CertifiedPublicKey issueIntermediateCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,        PublicKeyParameters publicKey, String dn, int validity)        throws IOException, GeneralSecurityException    {        return issueIntermediateCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity);    }    public CertifiedPublicKey issueIntermediateCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,        String dn, int validity)        throws IOException, GeneralSecurityException    {        return certificateGeneratorFactory.getInstance(            CertifyingSigner.getInstance(true, issuer, signerFactory),            new X509CertificateGenerationParameters(                validity,                extensionBuilder.get().addBasicConstraints(0)                    .addKeyUsage(EnumSet.of(KeyUsage.keyCertSign,                        KeyUsage.cRLSign))                    .build()))                .generate(new DistinguishedName(dn), publicKey,                    new X509CertificateParameters());    }    public CertifiedKeyPair issueCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair, String dn,        int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException    {        return new CertifiedKeyPair(            keyPair.getPrivate(),            issueCertificate(issuer, keyPair.getPublic(), dn, validity, subjectAltName)        );    }    public CertifiedPublicKey issueCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,        PublicKeyParameters publicKey, String dn, int validity, List<X509GeneralName> subjectAltName)        throws IOException, GeneralSecurityException    {        return issueCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity, subjectAltName);    }    public CertifiedPublicKey issueCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,        String dn, int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException    {        X509CertificateParameters params;        X509ExtensionBuilder builder = extensionBuilder.get().addKeyUsage(EnumSet.of(KeyUsage.digitalSignature,            KeyUsage.dataEncipherment));        if (subjectAltName != null) {            params = new X509CertificateParameters(                extensionBuilder.get().addSubjectAltName(false, subjectAltName.toArray(new X509GeneralName[]{}))                    .build());            Set<String> extUsage = new HashSet<>();            for (X509GeneralName genName : subjectAltName) {                if (genName instanceof X509Rfc822Name) {                    extUsage.add(ExtendedKeyUsages.EMAIL_PROTECTION);                } else if (genName instanceof X509DnsName || genName instanceof X509IpAddress) {                    extUsage.add(ExtendedKeyUsages.SERVER_AUTH);                    extUsage.add(ExtendedKeyUsages.CLIENT_AUTH);                }                builder.addExtendedKeyUsage(false, new ExtendedKeyUsages(extUsage));            }        } else {            params = new X509CertificateParameters();        }        return certificateGeneratorFactory.getInstance(                CertifyingSigner.getInstance(true, issuer, signerFactory),                new X509CertificateGenerationParameters(validity, builder.build()))            .generate(new DistinguishedName(dn), publicKey, params);    }    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, boolean embedContent)        throws GeneralSecurityException    {        return cmsSign(data, keyPair, null, null, embedContent);    }    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,        boolean embedContent) throws GeneralSecurityException    {        return cmsSign(data, keyPair, certificateProvider, null, embedContent);    }    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,        CMSSignedDataVerified existingSignature, boolean embedContent) throws GeneralSecurityException    {        CMSSignedDataGeneratorParameters parameters = new CMSSignedDataGeneratorParameters()            .addSigner(CertifyingSigner.getInstance(true, keyPair, signerFactory));        if (existingSignature != null) {            for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {                parameters.addSignature(existingSigner);            }        }        Set<CertifiedPublicKey> certs = new HashSet<>();        if (existingSignature != null && existingSignature.getCertificates() != null) {            certs.addAll(existingSignature.getCertificates());        }        if (certificateProvider != null) {            if (existingSignature != null) {                for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {                    if (existingSigner.getSubjectKeyIdentifier() != null) {                        addCertificateChain(                            certificateProvider.getCertificate(existingSigner.getSubjectKeyIdentifier()),                            certificateProvider, certs);                    } else {                        addCertificateChain(                            certificateProvider.getCertificate(existingSigner.getIssuer(),                                existingSigner.getSerialNumber()),                            certificateProvider, certs);                    }                }            }            addCertificateChain(keyPair.getCertificate(), certificateProvider, certs);        }        if (!certs.isEmpty()) {            parameters.addCertificates(certs);        }        return cmsSignedDataGenerator.generate(data, parameters, embedContent);    }    private void addCertificateChain(CertifiedPublicKey certificate, CertificateProvider certificateProvider,        Collection<CertifiedPublicKey> certs)    {        Collection<CertifiedPublicKey> chain = certificateChainBuilder.build(certificate, certificateProvider);        if (chain != null) {            certs.addAll(chain);        }    }    public CMSSignedDataVerified cmsVerify(byte[] signature)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature);    }    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature, data);    }    public CMSSignedDataVerified cmsVerify(byte[] signature, CertificateProvider certificateProvider)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature, certificateProvider);    }    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data, CertificateProvider certificateProvider)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature, data, certificateProvider);    }    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain)    {        return checkX509CertificateChainValidity(chain, null);    }    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain, Date date)    {        if (chain == null || chain.isEmpty()) {            return false;        }        Date checkDate = (date != null) ? date : new Date();        boolean rootExpected = true;        for (CertifiedPublicKey cert : chain) {            if (!(cert instanceof X509CertifiedPublicKey)) {                return false;            }            if (rootExpected) {                if (!((X509CertifiedPublicKey) cert).isRootCA()) {                    return false;                }                rootExpected = false;            }            if (!((X509CertifiedPublicKey) cert).isValidOn(checkDate)) {                return false;            }        }        return true;    }}", "nl": "import java.io.IOException;import java.math.BigInteger;import java.security.GeneralSecurityException;import java.util.Collection;import java.util.Date;import java.util.EnumSet;import java.util.HashSet;import java.util.List;import java.util.Set;import javax.inject.Inject;import javax.inject.Named;import javax.inject.Provider;import javax.inject.Singleton;import org.xwiki.component.annotation.Component;import org.xwiki.crypto.KeyPairGenerator;import org.xwiki.crypto.params.cipher.asymmetric.AsymmetricKeyPair;import org.xwiki.crypto.params.cipher.asymmetric.PrivateKeyParameters;import org.xwiki.crypto.params.cipher.asymmetric.PublicKeyParameters;import org.xwiki.crypto.params.generator.asymmetric.RSAKeyGenerationParameters;import org.xwiki.crypto.pkix.CertificateChainBuilder;import org.xwiki.crypto.pkix.CertificateGeneratorFactory;import org.xwiki.crypto.pkix.CertificateProvider;import org.xwiki.crypto.pkix.CertifyingSigner;import org.xwiki.crypto.pkix.X509ExtensionBuilder;import org.xwiki.crypto.pkix.params.CertifiedKeyPair;import org.xwiki.crypto.pkix.params.CertifiedPublicKey;import org.xwiki.crypto.pkix.params.x509certificate.DistinguishedName;import org.xwiki.crypto.pkix.params.x509certificate.X509CertificateGenerationParameters;import org.xwiki.crypto.pkix.params.x509certificate.X509CertificateParameters;import org.xwiki.crypto.pkix.params.x509certificate.X509CertifiedPublicKey;import org.xwiki.crypto.pkix.params.x509certificate.extension.ExtendedKeyUsages;import org.xwiki.crypto.pkix.params.x509certificate.extension.KeyUsage;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509DnsName;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509GeneralName;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509IpAddress;import org.xwiki.crypto.pkix.params.x509certificate.extension.X509Rfc822Name;import org.xwiki.crypto.signer.CMSSignedDataGenerator;import org.xwiki.crypto.signer.CMSSignedDataVerifier;import org.xwiki.crypto.signer.SignerFactory;import org.xwiki.crypto.signer.param.CMSSignedDataGeneratorParameters;import org.xwiki.crypto.signer.param.CMSSignedDataVerified;import org.xwiki.crypto.signer.param.CMSSignerInfo;import org.xwiki.script.service.ScriptService;@Component@Named(CryptoScriptService.ROLEHINT + '.' + RSACryptoScriptService.ROLEHINT)@Singletonpublic class RSACryptoScriptService implements ScriptService{    public static final String ROLEHINT = \"rsa\";    @Inject    @Named(\"RSA\")    private KeyPairGenerator keyPairGenerator;    @Inject    @Named(\"SHA1withRSAEncryption\")    private SignerFactory signerFactory;    @Inject    private Provider<X509ExtensionBuilder> extensionBuilder;    @Inject    @Named(\"X509\")    private CertificateGeneratorFactory certificateGeneratorFactory;    @Inject    private CMSSignedDataGenerator cmsSignedDataGenerator;    @Inject    @Named(\"X509\")    private CertificateChainBuilder certificateChainBuilder;    @Inject    private CMSSignedDataVerifier cmsSignedDataVerifier;    public AsymmetricKeyPair generateKeyPair()    {        return keyPairGenerator.generate();    }    public AsymmetricKeyPair generateKeyPair(int strength)    {        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength));    }    public AsymmetricKeyPair generateKeyPair(int strength, BigInteger publicExponent, int certainty)    {        return keyPairGenerator.generate(new RSAKeyGenerationParameters(strength, publicExponent, certainty));    }    public CertifiedKeyPair createCertifiedKeyPair(PrivateKeyParameters privateKey, CertifiedPublicKey certificate)    {        return new CertifiedKeyPair(privateKey, certificate);    }    public CertifiedKeyPair issueRootCACertificate(AsymmetricKeyPair keyPair, String dn, int validity)        throws IOException, GeneralSecurityException    {        return new CertifiedKeyPair(            keyPair.getPrivate(),            certificateGeneratorFactory.getInstance(signerFactory.getInstance(true, keyPair.getPrivate()),                new X509CertificateGenerationParameters(                    validity,                    extensionBuilder.get().addBasicConstraints(true)                        .addKeyUsage(true, EnumSet.of(KeyUsage.keyCertSign,                            KeyUsage.cRLSign))                        .build()))                .generate(new DistinguishedName(dn), keyPair.getPublic(),                    new X509CertificateParameters())        );    }    public CertifiedKeyPair issueIntermediateCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair,        String dn, int validity)        throws IOException, GeneralSecurityException    {        return new CertifiedKeyPair(            keyPair.getPrivate(),            issueIntermediateCertificate(issuer, keyPair.getPublic(), dn, validity)        );    }    public CertifiedPublicKey issueIntermediateCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,        PublicKeyParameters publicKey, String dn, int validity)        throws IOException, GeneralSecurityException    {        return issueIntermediateCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity);    }    public CertifiedPublicKey issueIntermediateCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,        String dn, int validity)        throws IOException, GeneralSecurityException    {        return certificateGeneratorFactory.getInstance(            CertifyingSigner.getInstance(true, issuer, signerFactory),            new X509CertificateGenerationParameters(                validity,                extensionBuilder.get().addBasicConstraints(0)                    .addKeyUsage(EnumSet.of(KeyUsage.keyCertSign,                        KeyUsage.cRLSign))                    .build()))                .generate(new DistinguishedName(dn), publicKey,                    new X509CertificateParameters());    }    public CertifiedKeyPair issueCertificate(CertifiedKeyPair issuer, AsymmetricKeyPair keyPair, String dn,        int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException    {        return new CertifiedKeyPair(            keyPair.getPrivate(),            issueCertificate(issuer, keyPair.getPublic(), dn, validity, subjectAltName)        );    }    public CertifiedPublicKey issueCertificate(PrivateKeyParameters privateKey, CertifiedPublicKey issuer,        PublicKeyParameters publicKey, String dn, int validity, List<X509GeneralName> subjectAltName)        throws IOException, GeneralSecurityException    {        return issueCertificate(new CertifiedKeyPair(privateKey, issuer), publicKey, dn, validity, subjectAltName);    }    public CertifiedPublicKey issueCertificate(CertifiedKeyPair issuer, PublicKeyParameters publicKey,        String dn, int validity, List<X509GeneralName> subjectAltName) throws IOException, GeneralSecurityException    {        X509CertificateParameters params;        X509ExtensionBuilder builder = extensionBuilder.get().addKeyUsage(EnumSet.of(KeyUsage.digitalSignature,            KeyUsage.dataEncipherment));        if (subjectAltName != null) {            params = new X509CertificateParameters(                extensionBuilder.get().addSubjectAltName(false, subjectAltName.toArray(new X509GeneralName[]{}))                    .build());            Set<String> extUsage = new HashSet<>();            for (X509GeneralName genName : subjectAltName) {                if (genName instanceof X509Rfc822Name) {                    extUsage.add(ExtendedKeyUsages.EMAIL_PROTECTION);                } else if (genName instanceof X509DnsName || genName instanceof X509IpAddress) {                    extUsage.add(ExtendedKeyUsages.SERVER_AUTH);                    extUsage.add(ExtendedKeyUsages.CLIENT_AUTH);                }                builder.addExtendedKeyUsage(false, new ExtendedKeyUsages(extUsage));            }        } else {            params = new X509CertificateParameters();        }        return certificateGeneratorFactory.getInstance(                CertifyingSigner.getInstance(true, issuer, signerFactory),                new X509CertificateGenerationParameters(validity, builder.build()))            .generate(new DistinguishedName(dn), publicKey, params);    }    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, boolean embedContent)        throws GeneralSecurityException    {        return cmsSign(data, keyPair, null, null, embedContent);    }    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,        boolean embedContent) throws GeneralSecurityException    {        return cmsSign(data, keyPair, certificateProvider, null, embedContent);    }    public byte[] cmsSign(byte[] data, CertifiedKeyPair keyPair, CertificateProvider certificateProvider,        CMSSignedDataVerified existingSignature, boolean embedContent) throws GeneralSecurityException    {        CMSSignedDataGeneratorParameters parameters = new CMSSignedDataGeneratorParameters()            .addSigner(CertifyingSigner.getInstance(true, keyPair, signerFactory));        if (existingSignature != null) {            for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {                parameters.addSignature(existingSigner);            }        }        Set<CertifiedPublicKey> certs = new HashSet<>();        if (existingSignature != null && existingSignature.getCertificates() != null) {            certs.addAll(existingSignature.getCertificates());        }        if (certificateProvider != null) {            if (existingSignature != null) {                for (CMSSignerInfo existingSigner : existingSignature.getSignatures()) {                    if (existingSigner.getSubjectKeyIdentifier() != null) {                        addCertificateChain(                            certificateProvider.getCertificate(existingSigner.getSubjectKeyIdentifier()),                            certificateProvider, certs);                    } else {                        addCertificateChain(                            certificateProvider.getCertificate(existingSigner.getIssuer(),                                existingSigner.getSerialNumber()),                            certificateProvider, certs);                    }                }            }            addCertificateChain(keyPair.getCertificate(), certificateProvider, certs);        }        if (!certs.isEmpty()) {            parameters.addCertificates(certs);        }        return cmsSignedDataGenerator.generate(data, parameters, embedContent);    }    private void addCertificateChain(CertifiedPublicKey certificate, CertificateProvider certificateProvider,        Collection<CertifiedPublicKey> certs)    {        Collection<CertifiedPublicKey> chain = certificateChainBuilder.build(certificate, certificateProvider);        if (chain != null) {            certs.addAll(chain);        }    }    public CMSSignedDataVerified cmsVerify(byte[] signature)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature);    }    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature, data);    }    public CMSSignedDataVerified cmsVerify(byte[] signature, CertificateProvider certificateProvider)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature, certificateProvider);    }    public CMSSignedDataVerified cmsVerify(byte[] signature, byte[] data, CertificateProvider certificateProvider)        throws GeneralSecurityException    {        return cmsSignedDataVerifier.verify(signature, data, certificateProvider);    }    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain)    {        return checkX509CertificateChainValidity(chain, null);    }    public boolean checkX509CertificateChainValidity(Collection<CertifiedPublicKey> chain, Date date)    {        if (chain == null || chain.isEmpty()) {            return false;        }        Date checkDate = (date != null) ? date : new Date();        boolean rootExpected = true;        for (CertifiedPublicKey cert : chain) {            if (!(cert instanceof X509CertifiedPublicKey)) {                return false;            }            if (rootExpected) {                if (!((X509CertifiedPublicKey) cert).isRootCA()) {                    return false;                }                rootExpected = false;            }            if (!((X509CertifiedPublicKey) cert).isValidOn(checkDate)) {                return false;            }        }        return true;    }}"}
{"code": "import com.fasterxml.jackson.core.type.TypeReference;import eu.nimble.utility.JsonSerializationUtility;import eu.nimble.utility.exception.AuthenticationException;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import org.apache.commons.codec.binary.Base64;import org.jose4j.keys.RsaKeyUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;import java.io.IOException;import java.security.PublicKey;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.stream.Collectors;@Component@Profile(\"!test\")public class ValidationUtil implements IValidationUtil {    private static final Logger logger = LoggerFactory.getLogger(ValidationUtil.class);    @Value(\"${nimble.keycloak.public-key}\")    private String keycloakPublicKey;    public Claims validateToken(String token) throws AuthenticationException {        try {            RsaKeyUtil rsaKeyUtil = new RsaKeyUtil();            PublicKey publicKey = rsaKeyUtil.fromPemEncoded(keycloakPublicKey);            return Jwts.parser().setSigningKey(publicKey).parseJws(token.replace(\"Bearer \", \"\")).getBody();        } catch (Exception e){            throw new AuthenticationException(String.format(\"Failed to check user authorization for token: %s\", token), e);        }    }    public boolean validateRole(String token,List<String> userRoles, NimbleRole[] requiredRoles) {        for (NimbleRole requiredRole : requiredRoles) {            for (String userRole : userRoles) {                if (userRole.contentEquals(requiredRole.getName())) {                    return true;                }            }        }        logger.warn(\"Token: {} does not include one of the roles: {}\",token,                Arrays.asList(requiredRoles).stream().map(role -> role.getName()).collect(Collectors.joining(\", \",\"[\",\"]\")));        return false;    }    public Claims getClaims(String token) throws AuthenticationException {        try {            String[] split_string = token.split(\"\\\\.\");            String base64EncodedBody = split_string[1];            Base64 base64Url = new Base64(true);            String body = new String(base64Url.decode(base64EncodedBody));            Map<String, Object> map = JsonSerializationUtility.getObjectMapper().readValue(body,new TypeReference<Map<String, Object>>() {            });            return Jwts.claims(map);        } catch (IOException e) {            throw new AuthenticationException(String.format(\"Failed to get Claims for token: %s\", token), e);        }    }}", "nl": "import com.fasterxml.jackson.core.type.TypeReference;import eu.nimble.utility.JsonSerializationUtility;import eu.nimble.utility.exception.AuthenticationException;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import org.apache.commons.codec.binary.Base64;import org.jose4j.keys.RsaKeyUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;import java.io.IOException;import java.security.PublicKey;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.stream.Collectors;@Component@Profile(\"!test\")public class ValidationUtil implements IValidationUtil {    private static final Logger logger = LoggerFactory.getLogger(ValidationUtil.class);    @Value(\"${nimble.keycloak.public-key}\")    private String keycloakPublicKey;    public Claims validateToken(String token) throws AuthenticationException {        try {            RsaKeyUtil rsaKeyUtil = new RsaKeyUtil();            PublicKey publicKey = rsaKeyUtil.fromPemEncoded(keycloakPublicKey);            return (Claims) Jwts.parser().setSigningKey(publicKey).parse(token.replace(\"Bearer \", \"\")).getBody();        } catch (Exception e){            throw new AuthenticationException(String.format(\"Failed to check user authorization for token: %s\", token), e);        }    }    public boolean validateRole(String token,List<String> userRoles, NimbleRole[] requiredRoles) {        for (NimbleRole requiredRole : requiredRoles) {            for (String userRole : userRoles) {                if (userRole.contentEquals(requiredRole.getName())) {                    return true;                }            }        }        logger.warn(\"Token: {} does not include one of the roles: {}\",token,                Arrays.asList(requiredRoles).stream().map(role -> role.getName()).collect(Collectors.joining(\", \",\"[\",\"]\")));        return false;    }    public Claims getClaims(String token) throws AuthenticationException {        try {            String[] split_string = token.split(\"\\\\.\");            String base64EncodedBody = split_string[1];            Base64 base64Url = new Base64(true);            String body = new String(base64Url.decode(base64EncodedBody));            Map<String, Object> map = JsonSerializationUtility.getObjectMapper().readValue(body,new TypeReference<Map<String, Object>>() {            });            return Jwts.claims(map);        } catch (IOException e) {            throw new AuthenticationException(String.format(\"Failed to get Claims for token: %s\", token), e);        }    }}"}
{"code": "import com.fasterxml.jackson.core.type.TypeReference;import eu.nimble.utility.JsonSerializationUtility;import eu.nimble.utility.exception.AuthenticationException;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import org.apache.commons.codec.binary.Base64;import org.jose4j.keys.RsaKeyUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;import java.io.IOException;import java.security.PublicKey;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.stream.Collectors;@Component@Profile(\"!test\")public class ValidationUtil implements IValidationUtil {    private static final Logger logger = LoggerFactory.getLogger(ValidationUtil.class);    @Value(\"${nimble.keycloak.public-key}\")    private String keycloakPublicKey;    public Claims validateToken(String token) throws AuthenticationException {        try {            RsaKeyUtil rsaKeyUtil = new RsaKeyUtil();            PublicKey publicKey = rsaKeyUtil.fromPemEncoded(keycloakPublicKey);            return Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token.replace(\"Bearer \", \"\")).getBody();        } catch (Exception e){            throw new AuthenticationException(String.format(\"Failed to check user authorization for token: %s\", token), e);        }    }    public boolean validateRole(String token,List<String> userRoles, NimbleRole[] requiredRoles) {        for (NimbleRole requiredRole : requiredRoles) {            for (String userRole : userRoles) {                if (userRole.contentEquals(requiredRole.getName())) {                    return true;                }            }        }        logger.warn(\"Token: {} does not include one of the roles: {}\",token,                Arrays.asList(requiredRoles).stream().map(role -> role.getName()).collect(Collectors.joining(\", \",\"[\",\"]\")));        return false;    }    public Claims getClaims(String token) throws AuthenticationException {        try {            String[] split_string = token.split(\"\\\\.\");            String base64EncodedBody = split_string[1];            Base64 base64Url = new Base64(true);            String body = new String(base64Url.decode(base64EncodedBody));            Map<String, Object> map = JsonSerializationUtility.getObjectMapper().readValue(body,new TypeReference<Map<String, Object>>() {            });            return Jwts.claims(map);        } catch (IOException e) {            throw new AuthenticationException(String.format(\"Failed to get Claims for token: %s\", token), e);        }    }}", "nl": "import com.fasterxml.jackson.core.type.TypeReference;import eu.nimble.utility.JsonSerializationUtility;import eu.nimble.utility.exception.AuthenticationException;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import org.apache.commons.codec.binary.Base64;import org.jose4j.keys.RsaKeyUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Component;import java.io.IOException;import java.security.PublicKey;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.stream.Collectors;@Component@Profile(\"!test\")public class ValidationUtil implements IValidationUtil {    private static final Logger logger = LoggerFactory.getLogger(ValidationUtil.class);    @Value(\"${nimble.keycloak.public-key}\")    private String keycloakPublicKey;    public Claims validateToken(String token) throws AuthenticationException {        try {            RsaKeyUtil rsaKeyUtil = new RsaKeyUtil();            PublicKey publicKey = rsaKeyUtil.fromPemEncoded(keycloakPublicKey);            return Jwts.parser().setSigningKey(publicKey).parseJws(token.replace(\"Bearer \", \"\")).getBody();        } catch (Exception e){            throw new AuthenticationException(String.format(\"Failed to check user authorization for token: %s\", token), e);        }    }    public boolean validateRole(String token,List<String> userRoles, NimbleRole[] requiredRoles) {        for (NimbleRole requiredRole : requiredRoles) {            for (String userRole : userRoles) {                if (userRole.contentEquals(requiredRole.getName())) {                    return true;                }            }        }        logger.warn(\"Token: {} does not include one of the roles: {}\",token,                Arrays.asList(requiredRoles).stream().map(role -> role.getName()).collect(Collectors.joining(\", \",\"[\",\"]\")));        return false;    }    public Claims getClaims(String token) throws AuthenticationException {        try {            String[] split_string = token.split(\"\\\\.\");            String base64EncodedBody = split_string[1];            Base64 base64Url = new Base64(true);            String body = new String(base64Url.decode(base64EncodedBody));            Map<String, Object> map = JsonSerializationUtility.getObjectMapper().readValue(body,new TypeReference<Map<String, Object>>() {            });            return Jwts.claims(map);        } catch (IOException e) {            throw new AuthenticationException(String.format(\"Failed to get Claims for token: %s\", token), e);        }    }}"}
{"code": "import java.io.Serializable;import java.util.List;public interface IMobileAgent extends Serializable, Runnable {    String agentID();    emissary.core.IBaseDataObject getPayload();    void go(Object payload, emissary.place.IServiceProviderPlace sourcePlace);    void arrive(Object payload, emissary.place.IServiceProviderPlace arrivalPlace, int mec, List<emissary.directory.DirectoryEntry> iq)            throws Exception;    int getMoveErrorCount();    emissary.directory.DirectoryEntry[] getItineraryQueueItems();    boolean isInUse();    Object getPayloadForTransport();    String getName();    String getLastPlaceProcessed();    void killAgent();    void killAgentAsync();    boolean isZombie();    void interrupt();    int getMaxMoveErrors();    void setMaxMoveErrors(int value);    int getMaxItinerarySteps();    void setMaxItinerarySteps(int value);    default public int payloadCount() {        return 1;    }}", "nl": "import java.io.Serializable;import java.util.List;import emissary.server.mvc.adapters.MoveToAdapter;public interface IMobileAgent extends Serializable, Runnable {    String agentID();    emissary.core.IBaseDataObject getPayload();    void go(Object payload, emissary.place.IServiceProviderPlace sourcePlace);    void arrive(Object payload, emissary.place.IServiceProviderPlace arrivalPlace, int mec, List<emissary.directory.DirectoryEntry> iq)            throws Exception;    int getMoveErrorCount();    emissary.directory.DirectoryEntry[] getItineraryQueueItems();    boolean isInUse();    Object getPayloadForTransport();    String getName();    String getLastPlaceProcessed();    void killAgent();    void killAgentAsync();    boolean isZombie();    void interrupt();    int getMaxMoveErrors();    void setMaxMoveErrors(int value);    int getMaxItinerarySteps();    void setMaxItinerarySteps(int value);    default public int payloadCount() {        return 1;    }}"}
{"code": "import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.UUID;import emissary.util.xml.JDOMUtil;import org.jdom2.Document;import org.jdom2.Element;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public final class WorkBundle implements Comparable<WorkBundle> {    private static final Logger logger = LoggerFactory.getLogger(WorkBundle.class);    static final int MAX_UNITS = 1024;    String bundleId;    String outputRoot;    String eatPrefix;    String caseId = null;    int priority = Priority.DEFAULT;    boolean simpleMode = false;    List<WorkUnit> workUnitList = new ArrayList<>();    String sentTo;    int errorCount = 0;    long oldestFileModificationTime = Long.MAX_VALUE;    long youngestFileModificationTime = Long.MIN_VALUE;    long totalFileSize = 0L;    public WorkBundle() {        bundleId = generateId();    }    public WorkBundle(String outputRoot, String eatPrefix) {        bundleId = generateId();        this.outputRoot = outputRoot;        this.eatPrefix = eatPrefix;    }    public WorkBundle(WorkBundle that) {        this.bundleId = that.bundleId;        this.outputRoot = that.getOutputRoot();        this.eatPrefix = that.getEatPrefix();        this.caseId = that.getCaseId();        this.sentTo = that.sentTo;        this.errorCount = that.errorCount;        this.priority = that.getPriority();        this.simpleMode = that.getSimpleMode();        this.oldestFileModificationTime = that.oldestFileModificationTime;        this.youngestFileModificationTime = that.youngestFileModificationTime;        this.totalFileSize = that.totalFileSize;        if (that.getWorkUnitList().size() > 0) {            this.addWorkUnits(that.getWorkUnitList());        }        resetBundleId();    }    public static WorkBundle readFromStream(DataInputStream in) throws IOException {        WorkBundle wb = new WorkBundle();        wb.bundleId = readUTFOrNull(in);        wb.outputRoot = readUTFOrNull(in);        wb.eatPrefix = readUTFOrNull(in);        wb.caseId = readUTFOrNull(in);        wb.sentTo = readUTFOrNull(in);        wb.errorCount = in.readInt();        wb.priority = in.readInt();        wb.simpleMode = in.readBoolean();        wb.oldestFileModificationTime = in.readLong();        wb.youngestFileModificationTime = in.readLong();        wb.totalFileSize = in.readLong();        int workUnitSize = in.readInt();        if (workUnitSize > MAX_UNITS) {            throw new IOException(                    \"Exception when reading: WorkBundle may not contain more then \" + MAX_UNITS + \" WorkUnits (saw: \" + workUnitSize + \").\");        }        for (int i = 0; i < workUnitSize; i++) {            wb.addWorkUnit(WorkUnit.readFromStream(in));        }        return wb;    }    public void writeToStream(DataOutputStream out) throws IOException {        writeUTFOrNull(bundleId, out);        writeUTFOrNull(outputRoot, out);        writeUTFOrNull(eatPrefix, out);        writeUTFOrNull(caseId, out);        writeUTFOrNull(sentTo, out);        out.writeInt(errorCount);        out.writeInt(priority);        out.writeBoolean(simpleMode);        out.writeLong(oldestFileModificationTime);        out.writeLong(youngestFileModificationTime);        out.writeLong(totalFileSize);        out.writeInt(workUnitList.size());        if (workUnitList.size() > MAX_UNITS) {            throw new IOException(                    \"Exception when writing: WorkBundle may not contain more then \" + MAX_UNITS + \" WorkUnits (saw: \" + workUnitList.size() + \").\");        }        for (WorkUnit u : workUnitList) {            u.writeToStream(out);        }    }    static String readUTFOrNull(DataInputStream in) throws IOException {        if (in.readBoolean()) {            return in.readUTF();        }        return null;    }    static void writeUTFOrNull(String s, DataOutputStream out) throws IOException {        out.writeBoolean(s != null);        if (s != null) {            out.writeUTF(s);        }    }    public void setBundleId(String val) {        this.bundleId = val;    }    public String resetBundleId() {        bundleId = generateId();        return bundleId;    }    public String getBundleId() {        return bundleId;    }    protected static String generateId() {        return UUID.randomUUID().toString();    }    public String getOutputRoot() {        return this.outputRoot;    }    public void setOutputRoot(String argOutputRoot) {        this.outputRoot = argOutputRoot;    }    public String getEatPrefix() {        return this.eatPrefix;    }    public void setEatPrefix(String argEatPrefix) {        this.eatPrefix = argEatPrefix;    }    public List<WorkUnit> getWorkUnitList() {        return new ArrayList<>(workUnitList);    }    public Iterator<WorkUnit> getWorkUnitIterator() {        return workUnitList.iterator();    }    public int addWorkUnit(WorkUnit workUnit) {        if (workUnitList.size() >= MAX_UNITS) {            throw new IllegalStateException(\"WorkBundle may not contain more than \" + MAX_UNITS + \" WorkUnits.\");        }        workUnitList.add(workUnit);        return size();    }    public int addWorkUnit(WorkUnit workUnit, long fileModificationTimeInMillis, long fileSize) {        addWorkUnit(workUnit);        if (fileModificationTimeInMillis < oldestFileModificationTime) {            oldestFileModificationTime = fileModificationTimeInMillis;        }        if (fileModificationTimeInMillis > youngestFileModificationTime) {            youngestFileModificationTime = fileModificationTimeInMillis;        }        totalFileSize += fileSize;        return size();    }    protected int addWorkUnits(List<WorkUnit> list) {         if (workUnitList.size() + list.size() > MAX_UNITS) {            throw new IllegalStateException(\"WorkBundle may not contain more than \" + MAX_UNITS + \" WorkUnits.\");        }        workUnitList.addAll(list);        return workUnitList.size();    }    public List<String> getFileNameList() {        ArrayList<String> fileNameList = new ArrayList<>(workUnitList.size());        for (WorkUnit workUnit : workUnitList) {            fileNameList.add(workUnit.getFileName());        }        return fileNameList;    }    public Iterator<String> getFileNameIterator() {        return getFileNameList().iterator();    }    public int addFileName(String file) {        return addWorkUnit(new WorkUnit(file));    }    public int addFileName(String file, long fileModificationTimeInMillis, long fileSize) {        return addWorkUnit(new WorkUnit(file), fileModificationTimeInMillis, fileSize);    }    protected int addFileNames(String[] file) {         for (String f : file) {            addWorkUnit(new WorkUnit(f));        }        return size();    }    protected int addFileNames(List<String> list) {         for (String file : list) {            addWorkUnit(new WorkUnit(file));        }        return size();    }    public int size() {        return workUnitList.size();    }    protected void clearFiles() {        workUnitList.clear();        oldestFileModificationTime = Long.MAX_VALUE;        youngestFileModificationTime = Long.MIN_VALUE;        totalFileSize = 0L;    }    public String getCaseId() {        return this.caseId;    }    public void setCaseId(String argCaseId) {        this.caseId = argCaseId;    }    public void setSentTo(String place) {        this.sentTo = place;    }    public String getSentTo() {        return sentTo;    }    public int getErrorCount() {        return errorCount;    }    public int incrementErrorCount() {        return ++errorCount;    }    public void setErrorCount(int val) {        errorCount = val;    }    public void setPriority(int val) {        priority = val;    }    public int getPriority() {        return priority;    }    public void setSimpleMode(boolean val) {        simpleMode = val;    }    public boolean getSimpleMode() {        return simpleMode;    }    public long getOldestFileModificationTime() {        return oldestFileModificationTime;    }    public void setOldestFileModificationTime(long oldestFileModificationTime) {        this.oldestFileModificationTime = oldestFileModificationTime;    }    public long getYoungestFileModificationTime() {        return youngestFileModificationTime;    }    public void setYoungestFileModificationTime(long youngestFileModificationTime) {        this.youngestFileModificationTime = youngestFileModificationTime;    }    public long getTotalFileSize() {        return totalFileSize;    }    public void setTotalFileSize(long totalFileSize) {        this.totalFileSize = totalFileSize;    }    @Override    public int compareTo(WorkBundle that) {        if (this.getPriority() < that.getPriority()) {            return -1;        } else if (that.getPriority() < this.getPriority()) {            return 1;        } else {            return 0;        }    }    @Override    public String toString() {        return \"WorkBundle[id=\" + getBundleId() + \", pri=\" + getPriority() + \", files=\" + getFileNameList().toString() + \", eatPrefix=\"                + getEatPrefix()                + \", outputRoot=\" + getOutputRoot() + \", sentTo=\" + getSentTo() + \", errorCount=\" + getErrorCount() + \", totalFileSize=\"                + getTotalFileSize() + \", oldestModTime=\" + getOldestFileModificationTime() + \", youngModTime=\" + getYoungestFileModificationTime()                + \", simple=\" + getSimpleMode() + \", caseId=\" + getCaseId() + \", size=\" + size() + \"]\";    }    public String toXml() {        Element root = new Element(\"workBundle\");        root.addContent(JDOMUtil.simpleElement(\"bundleId\", getBundleId()));        root.addContent(JDOMUtil.simpleElement(\"outputRoot\", getOutputRoot()));        root.addContent(JDOMUtil.simpleElement(\"eatPrefix\", getEatPrefix()));        root.addContent(JDOMUtil.simpleElement(\"caseId\", getCaseId()));        root.addContent(JDOMUtil.simpleElement(\"sentTo\", getSentTo()));        root.addContent(JDOMUtil.simpleElement(\"errorCount\", getErrorCount()));        root.addContent(JDOMUtil.simpleElement(\"priority\", getPriority()));        root.addContent(JDOMUtil.simpleElement(\"simpleMode\", getSimpleMode()));        root.addContent(JDOMUtil.simpleElement(\"oldestFileModificationTime\", getOldestFileModificationTime()));        root.addContent(JDOMUtil.simpleElement(\"youngestFileModificationTime\", getYoungestFileModificationTime()));        root.addContent(JDOMUtil.simpleElement(\"totalFileSize\", getTotalFileSize()));        for (WorkUnit wu : workUnitList) {            Element workunit = new Element(\"workUnit\");            workunit.addContent(JDOMUtil.simpleElement(\"workFileName\", wu.getFileName()));            if (wu.getTransactionId() != null) {                workunit.addContent(JDOMUtil.simpleElement(\"transactionId\", wu.getTransactionId()));            }            workunit.addContent(JDOMUtil.simpleElement(\"failedToParse\", wu.failedToParse()));            workunit.addContent(JDOMUtil.simpleElement(\"failedToProcess\", wu.failedToProcess()));            root.addContent(workunit);        }        Document jdom = new Document(root);        return JDOMUtil.toString(jdom);    }    public static WorkBundle buildWorkBundle(String xml) {        Document jdoc;        try {            jdoc = JDOMUtil.createDocument(xml, false);            return buildWorkBundle(jdoc);        } catch (Exception ex) {            logger.error(\"Cannot make WorkBundle from \" + xml, ex);            return null;        }    }    private static WorkBundle buildWorkBundle(Document jdom) {        Element root = jdom.getRootElement();        if (root == null) {            logger.error(\"Document does not have a root element!\");            return null;        }        WorkBundle wb = new WorkBundle();        wb.setBundleId(root.getChildTextTrim(\"bundleId\"));        String s = root.getChildTextTrim(\"outputRoot\");        if (s != null && s.length() > 0) {            wb.setOutputRoot(s);        } else {            wb.setOutputRoot(null);        }        s = root.getChildTextTrim(\"eatPrefix\");        if (s != null && s.length() > 0) {            wb.setEatPrefix(s);        } else {            wb.setEatPrefix(null);        }        s = root.getChildTextTrim(\"caseId\");        if (s != null && s.length() > 0) {            wb.setCaseId(s);        } else {            wb.setCaseId(null);        }        s = root.getChildTextTrim(\"sentTo\");        if (s != null && s.length() > 0) {            wb.setSentTo(s);        } else {            wb.setSentTo(null);        }        wb.setPriority(JDOMUtil.getChildIntValue(root, \"priority\"));        wb.setSimpleMode(JDOMUtil.getChildBooleanValue(root, \"simpleMode\"));        wb.setOldestFileModificationTime(JDOMUtil.getChildLongValue(root, \"oldestFileModificationTime\"));        wb.setYoungestFileModificationTime(JDOMUtil.getChildLongValue(root, \"youngestFileModificationTime\"));        wb.setTotalFileSize(JDOMUtil.getChildLongValue(root, \"totalFileSize\"));        String serr = root.getChildTextTrim(\"errorCount\");        if (serr != null && serr.length() > 0) {            wb.setErrorCount(Integer.parseInt(serr));        }        for (Element wu : root.getChildren(\"workUnit\")) {            String filename = wu.getChildTextTrim(\"workFileName\");            String transactionId = wu.getChildTextTrim(\"transactionId\");            boolean failedToParse = Boolean.valueOf(wu.getChildTextTrim(\"failedToParse\"));            boolean failedToProcess = Boolean.valueOf(wu.getChildTextTrim(\"failedToProcess\"));            wb.addWorkUnit(new WorkUnit(filename, transactionId, failedToParse, failedToProcess));        }        return wb;    }}", "nl": "import java.io.Serializable;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.UUID;import emissary.util.xml.JDOMUtil;import org.jdom2.Document;import org.jdom2.Element;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class WorkBundle implements Serializable, Comparable<WorkBundle> {    static final long serialVersionUID = 6339812801001572532L;    private static final Logger logger = LoggerFactory.getLogger(WorkBundle.class);    String bundleId;    String outputRoot;    String eatPrefix;    String caseId = null;    int priority = Priority.DEFAULT;    boolean simpleMode = false;    List<WorkUnit> workUnitList = new ArrayList<>();    String sentTo;    int errorCount = 0;    long oldestFileModificationTime = Long.MAX_VALUE;    long youngestFileModificationTime = Long.MIN_VALUE;    long totalFileSize = 0L;    public WorkBundle() {        bundleId = generateId();    }    public WorkBundle(String outputRoot, String eatPrefix) {        bundleId = generateId();        this.outputRoot = outputRoot;        this.eatPrefix = eatPrefix;    }    public WorkBundle(WorkBundle that) {        this.bundleId = that.bundleId;        this.outputRoot = that.getOutputRoot();        this.eatPrefix = that.getEatPrefix();        this.caseId = that.getCaseId();        this.sentTo = that.sentTo;        this.errorCount = that.errorCount;        this.priority = that.getPriority();        this.simpleMode = that.getSimpleMode();        this.oldestFileModificationTime = that.oldestFileModificationTime;        this.youngestFileModificationTime = that.youngestFileModificationTime;        this.totalFileSize = that.totalFileSize;        if (that.getWorkUnitList().size() > 0) {            this.addWorkUnits(that.getWorkUnitList());        }        resetBundleId();    }    public void setBundleId(String val) {        this.bundleId = val;    }    public String resetBundleId() {        bundleId = generateId();        return bundleId;    }    public String getBundleId() {        return bundleId;    }    protected static String generateId() {        return UUID.randomUUID().toString();    }    public String getOutputRoot() {        return this.outputRoot;    }    public void setOutputRoot(String argOutputRoot) {        this.outputRoot = argOutputRoot;    }    public String getEatPrefix() {        return this.eatPrefix;    }    public void setEatPrefix(String argEatPrefix) {        this.eatPrefix = argEatPrefix;    }    public List<WorkUnit> getWorkUnitList() {        return new ArrayList<>(workUnitList);    }    public Iterator<WorkUnit> getWorkUnitIterator() {        return workUnitList.iterator();    }    public int addWorkUnit(WorkUnit workUnit) {        workUnitList.add(workUnit);        return size();    }    public int addWorkUnit(WorkUnit workUnit, long fileModificationTimeInMillis, long fileSize) {        workUnitList.add(workUnit);        if (fileModificationTimeInMillis < oldestFileModificationTime) {            oldestFileModificationTime = fileModificationTimeInMillis;        }        if (fileModificationTimeInMillis > youngestFileModificationTime) {            youngestFileModificationTime = fileModificationTimeInMillis;        }        totalFileSize += fileSize;        return size();    }    protected int addWorkUnits(List<WorkUnit> list) {         workUnitList.addAll(list);        return workUnitList.size();    }    public List<String> getFileNameList() {        ArrayList<String> fileNameList = new ArrayList<>(workUnitList.size());        for (WorkUnit workUnit : workUnitList) {            fileNameList.add(workUnit.getFileName());        }        return fileNameList;    }    public Iterator<String> getFileNameIterator() {        return getFileNameList().iterator();    }    public int addFileName(String file) {        workUnitList.add(new WorkUnit(file));        return size();    }    public int addFileName(String file, long fileModificationTimeInMillis, long fileSize) {        return addWorkUnit(new WorkUnit(file), fileModificationTimeInMillis, fileSize);    }    protected int addFileNames(String[] file) {         for (int i = 0; file != null && i < file.length; i++) {            workUnitList.add(new WorkUnit(file[i]));        }        return size();    }    protected int addFileNames(List<String> list) {         for (String file : list) {            workUnitList.add(new WorkUnit(file));        }        return size();    }    public int size() {        return workUnitList.size();    }    protected void clearFiles() {        workUnitList.clear();        oldestFileModificationTime = Long.MAX_VALUE;        youngestFileModificationTime = Long.MIN_VALUE;        totalFileSize = 0L;    }    public String getCaseId() {        return this.caseId;    }    public void setCaseId(String argCaseId) {        this.caseId = argCaseId;    }    public void setSentTo(String place) {        this.sentTo = place;    }    public String getSentTo() {        return sentTo;    }    public int getErrorCount() {        return errorCount;    }    public int incrementErrorCount() {        return ++errorCount;    }    public void setErrorCount(int val) {        errorCount = val;    }    public void setPriority(int val) {        priority = val;    }    public int getPriority() {        return priority;    }    public void setSimpleMode(boolean val) {        simpleMode = val;    }    public boolean getSimpleMode() {        return simpleMode;    }    public long getOldestFileModificationTime() {        return oldestFileModificationTime;    }    public void setOldestFileModificationTime(long oldestFileModificationTime) {        this.oldestFileModificationTime = oldestFileModificationTime;    }    public long getYoungestFileModificationTime() {        return youngestFileModificationTime;    }    public void setYoungestFileModificationTime(long youngestFileModificationTime) {        this.youngestFileModificationTime = youngestFileModificationTime;    }    public long getTotalFileSize() {        return totalFileSize;    }    public void setTotalFileSize(long totalFileSize) {        this.totalFileSize = totalFileSize;    }    @Override    public int compareTo(WorkBundle that) {        if (this.getPriority() < that.getPriority()) {            return -1;        } else if (that.getPriority() < this.getPriority()) {            return 1;        } else {            return 0;        }    }    @Override    public String toString() {        return \"WorkBundle[id=\" + getBundleId() + \", pri=\" + getPriority() + \", files=\" + getFileNameList().toString() + \", eatPrefix=\"                + getEatPrefix()                + \", outputRoot=\" + getOutputRoot() + \", sentTo=\" + getSentTo() + \", errorCount=\" + getErrorCount() + \", totalFileSize=\"                + getTotalFileSize() + \", oldestModTime=\" + getOldestFileModificationTime() + \", youngModTime=\" + getYoungestFileModificationTime()                + \", simple=\" + getSimpleMode() + \", caseId=\" + getCaseId() + \", size=\" + size() + \"]\";    }    public String toXml() {        Element root = new Element(\"workBundle\");        root.addContent(JDOMUtil.simpleElement(\"bundleId\", getBundleId()));        root.addContent(JDOMUtil.simpleElement(\"outputRoot\", getOutputRoot()));        root.addContent(JDOMUtil.simpleElement(\"eatPrefix\", getEatPrefix()));        root.addContent(JDOMUtil.simpleElement(\"caseId\", getCaseId()));        root.addContent(JDOMUtil.simpleElement(\"sentTo\", getSentTo()));        root.addContent(JDOMUtil.simpleElement(\"errorCount\", getErrorCount()));        root.addContent(JDOMUtil.simpleElement(\"priority\", getPriority()));        root.addContent(JDOMUtil.simpleElement(\"simpleMode\", getSimpleMode()));        root.addContent(JDOMUtil.simpleElement(\"oldestFileModificationTime\", getOldestFileModificationTime()));        root.addContent(JDOMUtil.simpleElement(\"youngestFileModificationTime\", getYoungestFileModificationTime()));        root.addContent(JDOMUtil.simpleElement(\"totalFileSize\", getTotalFileSize()));        for (WorkUnit wu : workUnitList) {            Element workunit = new Element(\"workUnit\");            workunit.addContent(JDOMUtil.simpleElement(\"workFileName\", wu.getFileName()));            if (wu.getTransactionId() != null) {                workunit.addContent(JDOMUtil.simpleElement(\"transactionId\", wu.getTransactionId()));            }            workunit.addContent(JDOMUtil.simpleElement(\"failedToParse\", wu.failedToParse()));            workunit.addContent(JDOMUtil.simpleElement(\"failedToProcess\", wu.failedToProcess()));            root.addContent(workunit);        }        Document jdom = new Document(root);        return JDOMUtil.toString(jdom);    }    public static WorkBundle buildWorkBundle(String xml) {        Document jdoc;        try {            jdoc = JDOMUtil.createDocument(xml, false);            return buildWorkBundle(jdoc);        } catch (Exception ex) {            logger.error(\"Cannot make WorkBundle from \" + xml, ex);            return null;        }    }    private static WorkBundle buildWorkBundle(Document jdom) {        Element root = jdom.getRootElement();        if (root == null) {            logger.error(\"Document does not have a root element!\");            return null;        }        WorkBundle wb = new WorkBundle();        wb.setBundleId(root.getChildTextTrim(\"bundleId\"));        String s = root.getChildTextTrim(\"outputRoot\");        if (s != null && s.length() > 0) {            wb.setOutputRoot(s);        } else {            wb.setOutputRoot(null);        }        s = root.getChildTextTrim(\"eatPrefix\");        if (s != null && s.length() > 0) {            wb.setEatPrefix(s);        } else {            wb.setEatPrefix(null);        }        s = root.getChildTextTrim(\"caseId\");        if (s != null && s.length() > 0) {            wb.setCaseId(s);        } else {            wb.setCaseId(null);        }        s = root.getChildTextTrim(\"sentTo\");        if (s != null && s.length() > 0) {            wb.setSentTo(s);        } else {            wb.setSentTo(null);        }        wb.setPriority(JDOMUtil.getChildIntValue(root, \"priority\"));        wb.setSimpleMode(JDOMUtil.getChildBooleanValue(root, \"simpleMode\"));        wb.setOldestFileModificationTime(JDOMUtil.getChildLongValue(root, \"oldestFileModificationTime\"));        wb.setYoungestFileModificationTime(JDOMUtil.getChildLongValue(root, \"youngestFileModificationTime\"));        wb.setTotalFileSize(JDOMUtil.getChildLongValue(root, \"totalFileSize\"));        String serr = root.getChildTextTrim(\"errorCount\");        if (serr != null && serr.length() > 0) {            wb.setErrorCount(Integer.parseInt(serr));        }        for (Element wu : root.getChildren(\"workUnit\")) {            String filename = wu.getChildTextTrim(\"workFileName\");            String transactionId = wu.getChildTextTrim(\"transactionId\");            boolean failedToParse = Boolean.valueOf(wu.getChildTextTrim(\"failedToParse\"));            boolean failedToProcess = Boolean.valueOf(wu.getChildTextTrim(\"failedToProcess\"));            wb.addWorkUnit(new WorkUnit(filename, transactionId, failedToParse, failedToProcess));        }        return wb;    }}"}
{"code": "import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;public final class WorkUnit {    private String fileName;    private String transactionId;    private boolean failedToParse = false;    private boolean failedToProcess = false;    WorkUnit(String fileName) {        this.fileName = fileName;    }    WorkUnit(String fileName, String transactionId, boolean failedToParse, boolean failedToProcess) {        this.fileName = fileName;        this.transactionId = transactionId;        this.failedToParse = failedToParse;        this.failedToProcess = failedToProcess;    }    public static WorkUnit readFromStream(DataInputStream in) throws IOException {        final WorkUnit u = new WorkUnit(null);        u.fileName = WorkBundle.readUTFOrNull(in);        u.transactionId = WorkBundle.readUTFOrNull(in);        u.failedToParse = in.readBoolean();        u.failedToProcess = in.readBoolean();        return u;    }    public void writeToStream(DataOutputStream out) throws IOException {        WorkBundle.writeUTFOrNull(fileName, out);        WorkBundle.writeUTFOrNull(transactionId, out);        out.writeBoolean(failedToParse);        out.writeBoolean(failedToProcess);    }    public String getFileName() {        return fileName;    }    public void setFilename(String fileName) {        this.fileName = fileName;    }    public String getTransactionId() {        return transactionId;    }    public void setTransactionId(String transactionId) {        this.transactionId = transactionId;    }    public void setFailedToParse() {        this.failedToParse = true;    }    public boolean failedToParse() {        return failedToParse;    }    public void setFailedToProcess() {        this.failedToProcess = true;    }    public boolean failedToProcess() {        return failedToProcess;    }}", "nl": "public class WorkUnit {    private String fileName;    private String transactionId;    private boolean failedToParse = false;    private boolean failedToProcess = false;    WorkUnit(String fileName) {        this.fileName = fileName;    }    WorkUnit(String fileName, String transactionId, boolean failedToParse, boolean failedToProcess) {        this.fileName = fileName;        this.transactionId = transactionId;        this.failedToParse = failedToParse;        this.failedToProcess = failedToProcess;    }    public String getFileName() {        return fileName;    }    public void setFilename(String fileName) {        this.fileName = fileName;    }    public String getTransactionId() {        return transactionId;    }    public void setTransactionId(String transactionId) {        this.transactionId = transactionId;    }    public void setFailedToParse() {        this.failedToParse = true;    }    public boolean failedToParse() {        return failedToParse;    }    public void setFailedToProcess() {        this.failedToProcess = true;    }    public boolean failedToProcess() {        return failedToProcess;    }}"}
{"code": "None", "nl": "import java.io.IOException;import java.nio.charset.Charset;import java.rmi.RemoteException;import java.util.ArrayList;import java.util.Collections;import java.util.List;import javax.servlet.http.HttpServletRequest;import javax.ws.rs.core.MediaType;import emissary.client.EmissaryClient;import emissary.client.EmissaryResponse;import emissary.config.ConfigUtil;import emissary.config.Configurator;import emissary.core.EmissaryException;import emissary.core.IMobileAgent;import emissary.core.Namespace;import emissary.core.NamespaceException;import emissary.directory.DirectoryEntry;import emissary.directory.KeyManipulator;import emissary.log.MDCConstants;import emissary.place.IServiceProviderPlace;import emissary.pool.AgentPool;import emissary.util.PayloadUtil;import org.apache.http.HttpStatus;import org.apache.http.HttpVersion;import org.apache.http.NameValuePair;import org.apache.http.client.entity.EntityBuilder;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.cookie.BasicClientCookie;import org.apache.http.message.BasicHttpResponse;import org.apache.http.message.BasicNameValuePair;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.slf4j.MDC;public class MoveToAdapter extends EmissaryClient {    private static final Logger logger = LoggerFactory.getLogger(MoveToAdapter.class);    public static final String PLACE_NAME = \"mtPlaceName\";    public static final String AGENT_OBJECT = \"mtAgentObject\";    public static final String AGENT_SERIAL = \"mtAgentSerialized\";    public static final String MOVE_ERROR_COUNT = \"agentMoveErrorCount\";    public static final String ITINERARY_ITEM = \"agentItineraryItem\";    private static String COOKIE_NAME = \"PLACE\";    private static String COOKIE_DOMAIN = \"www.example.com\";    private static String COOKIE_PATH = \"/\";    private static String VIRTUAL_MOVETO_PROTOCOL = \"http\";    private static String VIRTUAL_MOVETO_ADDR = null;    static {        reconfigure();    }    public static void reconfigure() {        try {            final Configurator conf = ConfigUtil.getConfigInfo(AgentPool.class);            VIRTUAL_MOVETO_ADDR = conf.findStringEntry(\"VIRTUAL_MOVETO_ADDR\", null);            VIRTUAL_MOVETO_PROTOCOL = conf.findStringEntry(\"VIRTUAL_MOVETO_PROTOCOL\", \"http\");            COOKIE_NAME = conf.findStringEntry(\"VIRTUAL_COOKIE_NAME\", COOKIE_NAME);            COOKIE_DOMAIN = conf.findStringEntry(\"VIRTUAL_COOKIE_DOMAIN\", COOKIE_DOMAIN);            COOKIE_PATH = conf.findStringEntry(\"VIRTUAL_COOKIE_PATH\", COOKIE_PATH);        } catch (IOException e) {            logger.warn(\"Cannot read config file, virtual hosting capability not available \" + e.getMessage());        }    }    public MoveToAdapter() {}    public boolean inboundMoveTo(final HttpServletRequest req) throws RemoteException, NamespaceException {        final MoveToRequestBean bean = new MoveToRequestBean(req);        String placeKey = KeyManipulator.getServiceLocation(bean.getPlaceName());        if (VIRTUAL_MOVETO_ADDR != null) {            placeKey = KeyManipulator.getServiceClassname(bean.getPlaceName());        }        final IServiceProviderPlace place = (IServiceProviderPlace) Namespace.lookup(placeKey);        if (place == null) {            throw new NamespaceException(\"Nothing found for \" + bean.getPlaceName() + \" using \" + placeKey + \" as the lookup key\");        }        try {            emissary.pool.PayloadLauncher.launch(bean.getPayload(), place, bean.getErrorCount(), bean.getItineraryItems());        } catch (EmissaryException ex) {            logger.debug(\"Cannot launch incoming payload\", ex);            throw new RemoteException(\"Cannot launch payload\", ex);        } finally {            MDC.remove(MDCConstants.SERVICE_LOCATION);        }        return true;    }    public EmissaryResponse outboundMoveTo(final String place, final IMobileAgent agent) {        String url = null;        if (VIRTUAL_MOVETO_ADDR != null) {            url = VIRTUAL_MOVETO_PROTOCOL + \":        } else {            url = KeyManipulator.getServiceHostURL(place);        }        url += CONTEXT + \"/MoveTo.action\";        final HttpPost method = createHttpPost(url, CONTEXT, \"/MoveTo.action\");        method.setHeader(\"Content-type\", \"application/x-www-form-urlencoded; charset=ISO-8859-1\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(PLACE_NAME, place));        nvps.add(new BasicNameValuePair(MOVE_ERROR_COUNT, Integer.toString(agent.getMoveErrorCount())));        final DirectoryEntry[] iq = agent.getItineraryQueueItems();        for (int j = 0; j < iq.length; j++) {            nvps.add(new BasicNameValuePair(ITINERARY_ITEM, iq[j].getKey()));        }        try {            final String agentData = PayloadUtil.serializeToString(agent.getPayloadForTransport());            nvps.add(new BasicNameValuePair(AGENT_SERIAL, agentData));        } catch (IOException iox) {            logger.error(\"Cannot serialize agent data\", iox);            BasicHttpResponse response =                    new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_INTERNAL_SERVER_ERROR, \"Cannot serialize agent data\");            response.setEntity(EntityBuilder.create().setText(\"\").setContentEncoding(MediaType.TEXT_PLAIN).build());            return new EmissaryResponse(response);        }        method.setEntity(new UrlEncodedFormEntity(nvps, Charset.forName(\"8859_1\")));        if (VIRTUAL_MOVETO_ADDR != null) {            final BasicClientCookie cookie = new BasicClientCookie(COOKIE_NAME, KeyManipulator.getServiceClassname(place));            cookie.setDomain(VIRTUAL_MOVETO_ADDR.substring(0, VIRTUAL_MOVETO_ADDR.indexOf(\":\")));            cookie.setPath(COOKIE_PATH);            return send(method, cookie);        }        return send(method);    }    static class MoveToRequestBean {        String placeName;        Object payload;        int errorCount;        List<DirectoryEntry> itineraryItems = null;        MoveToRequestBean() {}        MoveToRequestBean(final HttpServletRequest req) {            setPlaceName(RequestUtil.getParameter(req, PLACE_NAME));            if (getPlaceName() == null) {                throw new IllegalArgumentException(\"Missing place name\");            }            final String agentData = RequestUtil.getParameter(req, AGENT_SERIAL);            if (agentData == null) {                throw new IllegalArgumentException(\"Missing serialized agent data\");            }            setPayload(agentData);            setErrorCount(RequestUtil.getIntParam(req, MOVE_ERROR_COUNT, 0));            final String[] p = req.getParameterValues(ITINERARY_ITEM);            if (p != null && p.length > 0) {                this.itineraryItems = new ArrayList<DirectoryEntry>();                for (int i = 0; i < p.length; i++) {                    this.itineraryItems.add(new DirectoryEntry(p[i]));                }            }        }        void setPayload(final String s) {            this.payload = PayloadUtil.deserialize(s);        }        String getPlaceName() {            return this.placeName;        }        void setPlaceName(final String argPlaceName) {            this.placeName = argPlaceName;        }        Object getPayload() {            return this.payload;        }        void setErrorCount(final int c) {            this.errorCount = c;        }        int getErrorCount() {            return this.errorCount;        }        int getItineraryItemCount() {            return this.itineraryItems == null ? 0 : this.itineraryItems.size();        }        @SuppressWarnings(\"unchecked\")        List<DirectoryEntry> getItineraryItems() {            return this.itineraryItems == null ? Collections.EMPTY_LIST : this.itineraryItems;        }    }}"}
{"code": "import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.DataInputStream;import java.io.ObjectOutputStream;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import emissary.client.EmissaryClient;import emissary.client.EmissaryResponse;import emissary.core.Namespace;import emissary.core.NamespaceException;import emissary.directory.KeyManipulator;import emissary.pickup.IPickUpSpace;import emissary.pickup.WorkBundle;import emissary.pickup.WorkSpace;import org.apache.http.HttpStatus;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpPost;import org.apache.http.message.BasicNameValuePair;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class WorkSpaceAdapter extends EmissaryClient {    private static final Logger logger = LoggerFactory.getLogger(WorkSpaceAdapter.class);    public static final String CLIENT_NAME = \"pickUpClientName\";    public static final String SPACE_NAME = \"workSpaceName\";    public static final String WORK_BUNDLE_OBJ = \"tpObj\";    public static final String WORK_BUNDLE_XML = \"tpXml\";    public static final String WORK_BUNDLE_ID = \"tpId\";    public static final String WORK_BUNDLE_STATUS = \"tpStatus\";    public static final String DATA_IDENTIFIER = \"tdataId\";    public boolean inboundEnque(final HttpServletRequest req) throws NamespaceException {        logger.debug(\"TPA incoming elements! check prio={}\", Thread.currentThread().getPriority());        final EnqueRequestBean bean = new EnqueRequestBean(req);        final String nsName = KeyManipulator.getServiceLocation(bean.getPlace());        final IPickUpSpace place = lookupPlace(nsName);        if (place == null) {            throw new IllegalArgumentException(\"No client place found using name \" + bean.getPlace());        }        return place.enque(bean.getPaths());    }    private Object lookup(final String name) throws NamespaceException {        final String nsName = KeyManipulator.getServiceLocation(name);        try {            return Namespace.lookup(nsName);        } catch (NamespaceException ne) {            logger.error(\"Could not lookup place using \" + nsName, ne);            throw ne;        }    }    private IPickUpSpace lookupPlace(final String name) throws NamespaceException {        return (IPickUpSpace) lookup(name);    }    private WorkSpace lookupSpace(final String name) throws NamespaceException {        return (WorkSpace) lookup(name);    }    public EmissaryResponse outboundEnque(final String place, final WorkBundle path) {        final String placeUrl = KeyManipulator.getServiceHostURL(place);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkSpaceClientEnqueue.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        String pathData = null;        try {            final ByteArrayOutputStream bos = new ByteArrayOutputStream();            final ObjectOutputStream oos = new ObjectOutputStream(bos);            oos.writeObject(path);            oos.close();            try {                pathData = bos.toString(\"8859_1\");            } catch (UnsupportedEncodingException e) {                pathData = bos.toString();            }        } catch (Exception e) {            logger.error(\"Cannot serialize WorkBundle object\", e);            throw new IllegalArgumentException(\"Cannot serialize WorkBundle object: \" + e.getMessage());        }        nvps.add(new BasicNameValuePair(WORK_BUNDLE_OBJ, pathData));        logger.debug(\"Sending {} file names to {} as {}\", path.size(), place, path);        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.forName(\"8859_1\")));        return send(method);    }    public EmissaryResponse outboundOpenWorkSpace(final String place, final String space) {        final String placeUrl = KeyManipulator.getServiceHostURL(place);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkSpaceClientOpenWorkSpace.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        nvps.add(new BasicNameValuePair(SPACE_NAME, space));        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.defaultCharset()));        method.setConfig(RequestConfig.custom().setConnectTimeout(60000).setSocketTimeout(60000).build());        return send(method);    }    public boolean inboundOpenWorkSpace(final HttpServletRequest req) throws NamespaceException {        final String placeName = RequestUtil.getParameter(req, CLIENT_NAME);        final String spaceName = RequestUtil.getParameter(req, SPACE_NAME);        final IPickUpSpace place = lookupPlace(placeName);        if (place == null) {            throw new IllegalArgumentException(\"No client place found using name \" + placeName);        }        logger.info(\"Notified {} to open space at {}\", placeName, spaceName);        place.openSpace(spaceName);        return true;    }    public WorkBundle outboundWorkSpaceTake(final String space, final String place) {        final String placeUrl = KeyManipulator.getServiceHostURL(space);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkSpaceClientSpaceTake.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        nvps.add(new BasicNameValuePair(SPACE_NAME, space));        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.defaultCharset()));        final EmissaryResponse status = send(method);        WorkBundle path = null;        if (status.getStatus() != HttpStatus.SC_OK) {            logger.debug(\"Take from space {} was an error: {}\", space, status.getContentString());        } else {            path = WorkBundle.buildWorkBundle(status.getContentString());        }        return path;    }    public WorkBundle inboundSpaceTake(final HttpServletRequest req) throws NamespaceException {        final String spaceName = RequestUtil.getParameter(req, SPACE_NAME);        final WorkSpace space = lookupSpace(spaceName);        if (space == null) {            throw new IllegalArgumentException(\"No WorkSpace found using name \" + spaceName);        }        String placeName = RequestUtil.getParameter(req, CLIENT_NAME);        if (placeName == null) {            placeName = req.getRemoteHost();        }        return space.take(placeName);    }    public boolean outboundBundleCompletion(final String space, final String place, final String bundleId, final boolean itWorked) {        final String placeUrl = KeyManipulator.getServiceHostURL(space);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkBundleCompleted.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        nvps.add(new BasicNameValuePair(SPACE_NAME, space));        nvps.add(new BasicNameValuePair(WORK_BUNDLE_ID, bundleId));        nvps.add(new BasicNameValuePair(WORK_BUNDLE_STATUS, Boolean.toString(itWorked)));        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.defaultCharset()));        final EmissaryResponse status = send(method);        return (status.getStatus() == HttpStatus.SC_OK);    }    public boolean inboundBundleCompletion(final HttpServletRequest req) throws NamespaceException {        final String spaceName = RequestUtil.getParameter(req, SPACE_NAME);        final WorkSpace space = lookupSpace(spaceName);        if (space == null) {            throw new IllegalArgumentException(\"No WorkSpace found using name \" + spaceName);        }        String placeName = RequestUtil.getParameter(req, CLIENT_NAME);        if (placeName == null) {            placeName = req.getRemoteHost();        }        final String bundleId = RequestUtil.getParameter(req, WORK_BUNDLE_ID);        final boolean itWorked = RequestUtil.getBooleanParam(req, WORK_BUNDLE_STATUS);        if (bundleId == null) {            throw new IllegalArgumentException(\"Notice of bundle completion with no bundle id\");        }        return space.workCompleted(placeName, bundleId, itWorked);    }    static class EnqueRequestBean {        String place;        WorkBundle paths;        EnqueRequestBean(final HttpServletRequest req) {            setPlace(RequestUtil.getParameter(req, CLIENT_NAME));            if (getPlace() == null) {                throw new IllegalArgumentException(\"No 'place' specified\");            }            setPaths(RequestUtil.getParameter(req, WORK_BUNDLE_OBJ));        }        public String getPlace() {            return this.place;        }        public void setPlace(final String argPlace) {            this.place = argPlace;        }        void setPaths(final String s) {            try {                final DataInputStream dis = new DataInputStream(new ByteArrayInputStream(s.getBytes(\"8859_1\")));                this.paths = WorkBundle.readFromStream(dis);            } catch (Exception e) {                logger.error(\"Cannot deserialize WorkBundle using {} bytes\", s.length(), e);                throw new IllegalArgumentException(\"Cannot deserialize WorkBundle\");            }        }        public void setPaths(final WorkBundle argPaths) {            this.paths = argPaths;        }        public WorkBundle getPaths() {            return this.paths;        }    }}", "nl": "import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.List;import javax.servlet.http.HttpServletRequest;import emissary.client.EmissaryClient;import emissary.client.EmissaryResponse;import emissary.core.Namespace;import emissary.core.NamespaceException;import emissary.directory.KeyManipulator;import emissary.pickup.IPickUpSpace;import emissary.pickup.WorkBundle;import emissary.pickup.WorkSpace;import org.apache.http.HttpStatus;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpPost;import org.apache.http.message.BasicNameValuePair;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class WorkSpaceAdapter extends EmissaryClient {    private static final Logger logger = LoggerFactory.getLogger(WorkSpaceAdapter.class);    public static final String CLIENT_NAME = \"pickUpClientName\";    public static final String SPACE_NAME = \"workSpaceName\";    public static final String WORK_BUNDLE_OBJ = \"tpObj\";    public static final String WORK_BUNDLE_XML = \"tpXml\";    public static final String WORK_BUNDLE_ID = \"tpId\";    public static final String WORK_BUNDLE_STATUS = \"tpStatus\";    public static final String DATA_IDENTIFIER = \"tdataId\";    public boolean inboundEnque(final HttpServletRequest req) throws NamespaceException {        logger.debug(\"TPA incoming elements! check prio={}\", Thread.currentThread().getPriority());        final EnqueRequestBean bean = new EnqueRequestBean(req);        final String nsName = KeyManipulator.getServiceLocation(bean.getPlace());        final IPickUpSpace place = lookupPlace(nsName);        if (place == null) {            throw new IllegalArgumentException(\"No client place found using name \" + bean.getPlace());        }        return place.enque(bean.getPaths());    }    private Object lookup(final String name) throws NamespaceException {        final String nsName = KeyManipulator.getServiceLocation(name);        try {            return Namespace.lookup(nsName);        } catch (NamespaceException ne) {            logger.error(\"Could not lookup place using \" + nsName, ne);            throw ne;        }    }    private IPickUpSpace lookupPlace(final String name) throws NamespaceException {        return (IPickUpSpace) lookup(name);    }    private WorkSpace lookupSpace(final String name) throws NamespaceException {        return (WorkSpace) lookup(name);    }    public EmissaryResponse outboundEnque(final String place, final WorkBundle path) {        final String placeUrl = KeyManipulator.getServiceHostURL(place);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkSpaceClientEnqueue.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        String pathData = null;        try {            final ByteArrayOutputStream bos = new ByteArrayOutputStream();            final ObjectOutputStream oos = new ObjectOutputStream(bos);            oos.writeObject(path);            oos.close();            try {                pathData = bos.toString(\"8859_1\");            } catch (UnsupportedEncodingException e) {                pathData = bos.toString();            }        } catch (Exception e) {            logger.error(\"Cannot serialize WorkBundle object\", e);            throw new IllegalArgumentException(\"Cannot serialize WorkBundle object: \" + e.getMessage());        }        nvps.add(new BasicNameValuePair(WORK_BUNDLE_OBJ, pathData));        logger.debug(\"Sending {} file names to {} as {}\", path.size(), place, path);        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.forName(\"8859_1\")));        return send(method);    }    public EmissaryResponse outboundOpenWorkSpace(final String place, final String space) {        final String placeUrl = KeyManipulator.getServiceHostURL(place);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkSpaceClientOpenWorkSpace.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        nvps.add(new BasicNameValuePair(SPACE_NAME, space));        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.defaultCharset()));        method.setConfig(RequestConfig.custom().setConnectTimeout(60000).setSocketTimeout(60000).build());        return send(method);    }    public boolean inboundOpenWorkSpace(final HttpServletRequest req) throws NamespaceException {        final String placeName = RequestUtil.getParameter(req, CLIENT_NAME);        final String spaceName = RequestUtil.getParameter(req, SPACE_NAME);        final IPickUpSpace place = lookupPlace(placeName);        if (place == null) {            throw new IllegalArgumentException(\"No client place found using name \" + placeName);        }        logger.info(\"Notified {} to open space at {}\", placeName, spaceName);        place.openSpace(spaceName);        return true;    }    public WorkBundle outboundWorkSpaceTake(final String space, final String place) {        final String placeUrl = KeyManipulator.getServiceHostURL(space);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkSpaceClientSpaceTake.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        nvps.add(new BasicNameValuePair(SPACE_NAME, space));        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.defaultCharset()));        final EmissaryResponse status = send(method);        WorkBundle path = null;        if (status.getStatus() != HttpStatus.SC_OK) {            logger.debug(\"Take from space {} was an error: {}\", space, status.getContentString());        } else {            path = WorkBundle.buildWorkBundle(status.getContentString());        }        return path;    }    public WorkBundle inboundSpaceTake(final HttpServletRequest req) throws NamespaceException {        final String spaceName = RequestUtil.getParameter(req, SPACE_NAME);        final WorkSpace space = lookupSpace(spaceName);        if (space == null) {            throw new IllegalArgumentException(\"No WorkSpace found using name \" + spaceName);        }        String placeName = RequestUtil.getParameter(req, CLIENT_NAME);        if (placeName == null) {            placeName = req.getRemoteHost();        }        return space.take(placeName);    }    public boolean outboundBundleCompletion(final String space, final String place, final String bundleId, final boolean itWorked) {        final String placeUrl = KeyManipulator.getServiceHostURL(space);        final HttpPost method = createHttpPost(placeUrl, CONTEXT, \"/WorkBundleCompleted.action\");        final List<NameValuePair> nvps = new ArrayList<NameValuePair>();        nvps.add(new BasicNameValuePair(CLIENT_NAME, place));        nvps.add(new BasicNameValuePair(SPACE_NAME, space));        nvps.add(new BasicNameValuePair(WORK_BUNDLE_ID, bundleId));        nvps.add(new BasicNameValuePair(WORK_BUNDLE_STATUS, Boolean.toString(itWorked)));        method.setEntity(new UrlEncodedFormEntity(nvps, java.nio.charset.Charset.defaultCharset()));        final EmissaryResponse status = send(method);        return (status.getStatus() == HttpStatus.SC_OK);    }    public boolean inboundBundleCompletion(final HttpServletRequest req) throws NamespaceException {        final String spaceName = RequestUtil.getParameter(req, SPACE_NAME);        final WorkSpace space = lookupSpace(spaceName);        if (space == null) {            throw new IllegalArgumentException(\"No WorkSpace found using name \" + spaceName);        }        String placeName = RequestUtil.getParameter(req, CLIENT_NAME);        if (placeName == null) {            placeName = req.getRemoteHost();        }        final String bundleId = RequestUtil.getParameter(req, WORK_BUNDLE_ID);        final boolean itWorked = RequestUtil.getBooleanParam(req, WORK_BUNDLE_STATUS);        if (bundleId == null) {            throw new IllegalArgumentException(\"Notice of bundle completion with no bundle id\");        }        return space.workCompleted(placeName, bundleId, itWorked);    }    static class EnqueRequestBean {        String place;        WorkBundle paths;        EnqueRequestBean(final HttpServletRequest req) {            setPlace(RequestUtil.getParameter(req, CLIENT_NAME));            if (getPlace() == null) {                throw new IllegalArgumentException(\"No 'place' specified\");            }            setPaths(RequestUtil.getParameter(req, WORK_BUNDLE_OBJ));        }        public String getPlace() {            return this.place;        }        public void setPlace(final String argPlace) {            this.place = argPlace;        }        void setPaths(final String s) {            try {                final ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(s.getBytes(\"8859_1\")));                this.paths = (WorkBundle) ois.readObject();            } catch (Exception e) {                logger.error(\"Cannot deserialize WorkBundle using {} bytes\", s.length(), e);                throw new IllegalArgumentException(\"Cannot deserialize WorkBundle\");            }        }        public void setPaths(final WorkBundle argPaths) {            this.paths = argPaths;        }        public WorkBundle getPaths() {            return this.paths;        }    }}"}
{"code": "None", "nl": "import javax.servlet.http.HttpServletRequest;import javax.ws.rs.core.Context;import javax.ws.rs.core.Response;import emissary.server.mvc.adapters.MoveToAdapter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class MoveToAction {    private final Logger logger = LoggerFactory.getLogger(this.getClass());    public Response moveTo(@Context HttpServletRequest request) {        final MoveToAdapter mt = new MoveToAdapter();        try {            final boolean status = mt.inboundMoveTo(request);            if (!status) {                logger.error(\"MoveTo failed!\");                return Response.serverError().entity(\"MoveTo failed\").build();            }        } catch (Exception e) {            logger.error(\"Could not call moveTo\", e);            return Response.serverError().entity(\"Could not call moveTo\").build();        }        logger.debug(\"MoveTo succeeded\");        return Response.ok().entity(\"MoveTo succeeded\").build();    }}"}
{"code": "import java.io.ByteArrayInputStream;import java.io.DataInputStream;import javax.ws.rs.Consumes;import javax.ws.rs.FormParam;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.Produces;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import emissary.core.Namespace;import emissary.directory.KeyManipulator;import emissary.pickup.IPickUpSpace;import emissary.pickup.WorkBundle;import emissary.server.mvc.adapters.WorkSpaceAdapter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;@Path(\"\")public class WorkSpaceClientEnqueueAction {    private final Logger logger = LoggerFactory.getLogger(this.getClass());    @POST    @Path(\"/WorkSpaceClientEnqueue.action\")    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)    @Produces(MediaType.TEXT_PLAIN)    public Response workspaceClientEnqueue(@FormParam(WorkSpaceAdapter.CLIENT_NAME) String clientName,            @FormParam(WorkSpaceAdapter.WORK_BUNDLE_OBJ) String workBundleString) {        logger.debug(\"TPWorker incoming execute! check prio={}\", Thread.currentThread().getPriority());        final boolean success;        try {            final String nsName = KeyManipulator.getServiceLocation(clientName);            final IPickUpSpace place = (IPickUpSpace) Namespace.lookup(nsName);            if (place == null) {                throw new IllegalArgumentException(\"No client place found using name \" + clientName);            }            final DataInputStream ois = new DataInputStream(new ByteArrayInputStream(workBundleString.getBytes(\"8859_1\")));            WorkBundle paths = WorkBundle.readFromStream(ois);            success = place.enque(paths);        } catch (Exception e) {            logger.warn(\"WorkSpaceClientEnqueWorker exception\", e);            return Response.serverError().entity(\"WorkSpaceClientEnqueWorker exception:\\n\" + e.getMessage()).build();        }        if (success) {            return Response.ok().entity(\"Successful add to the PickUpPlaceClient queue\").build();        } else {            return Response.serverError().entity(\"WorkSpaceClientEnqueWorker failed, queue full\").build();        }    }}", "nl": "import java.io.ByteArrayInputStream;import java.io.ObjectInputStream;import javax.ws.rs.Consumes;import javax.ws.rs.FormParam;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.Produces;import javax.ws.rs.core.MediaType;import javax.ws.rs.core.Response;import emissary.core.Namespace;import emissary.directory.KeyManipulator;import emissary.pickup.IPickUpSpace;import emissary.pickup.WorkBundle;import emissary.server.mvc.adapters.WorkSpaceAdapter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;@Path(\"\")public class WorkSpaceClientEnqueueAction {    private final Logger logger = LoggerFactory.getLogger(this.getClass());    @POST    @Path(\"/WorkSpaceClientEnqueue.action\")    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)    @Produces(MediaType.TEXT_PLAIN)    public Response workspaceClientEnqueue(@FormParam(WorkSpaceAdapter.CLIENT_NAME) String clientName,            @FormParam(WorkSpaceAdapter.WORK_BUNDLE_OBJ) String workBundleString) {        logger.debug(\"TPWorker incoming execute! check prio={}\", Thread.currentThread().getPriority());        final boolean success;        try {            final String nsName = KeyManipulator.getServiceLocation(clientName);            final IPickUpSpace place = (IPickUpSpace) Namespace.lookup(nsName);            if (place == null) {                throw new IllegalArgumentException(\"No client place found using name \" + clientName);            }            final ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(workBundleString.getBytes(\"8859_1\")));            WorkBundle paths = (WorkBundle) ois.readObject();            success = place.enque(paths);        } catch (Exception e) {            logger.warn(\"WorkSpaceClientEnqueWorker exception\", e);            return Response.serverError().entity(\"WorkSpaceClientEnqueWorker exception:\\n\" + e.getMessage()).build();        }        if (success) {            return Response.ok().entity(\"Successful add to the PickUpPlaceClient queue\").build();        } else {            return Response.serverError().entity(\"WorkSpaceClientEnqueWorker failed, queue full\").build();        }    }}"}
{"code": "import java.util.Collection;import java.util.Date;import java.util.Iterator;import java.util.List;import java.util.Map;import emissary.core.IBaseDataObject;import emissary.util.xml.JDOMUtil;import org.jdom2.Document;import org.jdom2.Element;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class PayloadUtil {    public static final Logger logger = LoggerFactory.getLogger(PayloadUtil.class);    private static final String LS = System.getProperty(\"line.separator\");    public static String getName(final Object o) {        String payloadName = o.getClass().getName();        if (o instanceof IBaseDataObject) {            payloadName = ((IBaseDataObject) o).shortName();        } else if (o instanceof Collection) {            final Iterator<?> pi = ((Collection<?>) o).iterator();            if (pi.hasNext()) {                payloadName = ((IBaseDataObject) pi.next()).shortName() + \"(\" + ((Collection<?>) o).size() + \")\";            }        }        return payloadName;    }    public static String getPayloadDisplayString(final IBaseDataObject payload, final boolean oneLine) {        return oneLine ? getPayloadOneLineString(payload) : getPayloadDisplayString(payload);    }    public static String getPayloadDisplayString(final IBaseDataObject payload) {        final StringBuilder sb = new StringBuilder();        final List<String> th = payload.transformHistory();        final String fileName = payload.getFilename();        final List<String> currentForms = payload.getAllCurrentForms();        final Date creationTimestamp = payload.getCreationTimestamp();        sb.append(\"\\n\").append(\"filename: \").append(fileName).append(\"\\n\").append(\"   creationTimestamp: \").append(creationTimestamp).append(\"\\n\")                .append(\"   currentForms: \").append(currentForms).append(\"\\n\").append(\"   filetype: \").append(payload.getFileType()).append(\"\\n\")                .append(\"   transform history (\").append(th.size()).append(\") :\").append(\"\\n\");        for (final String h : th) {            sb.append(\"     \").append(h).append(\"\\n\");        }        return sb.toString();    }    public static String getPayloadOneLineString(final IBaseDataObject payload) {        final StringBuilder sb = new StringBuilder();        final String fn = payload.getFilename();        final int attPos = fn.indexOf(emissary.core.Family.SEP);        if (attPos != -1) {            sb.append(fn.substring(attPos + 1)).append(\" \");        }        final List<String> th = payload.transformHistory();        String prev = \"\";        for (final String h : th) {            final int pos = h.indexOf(\".\");            if (pos > 0) {                final String prefix = h.substring(0, pos);                if (!prev.equals(prefix)) {                    if (prev.length() != 0) {                        sb.append(\",\");                    }                    sb.append(prefix);                    prev = prefix;                }            }        }        sb.append(\">>\").append(payload.getAllCurrentForms());        sb.append(\"        sb.append(\"        return sb.toString();    }    public static Document toXml(final IBaseDataObject d) {        final Element root = new Element(\"payload\");        root.addContent(JDOMUtil.protectedElement(\"name\", d.getFilename()));        final Element cf = new Element(\"current-forms\");        for (final String c : d.getAllCurrentForms()) {            cf.addContent(JDOMUtil.simpleElement(\"current-form\", c));        }        root.addContent(cf);        root.addContent(JDOMUtil.simpleElement(\"encoding\", d.getFontEncoding()));        root.addContent(JDOMUtil.simpleElement(\"filetype\", d.getFileType()));        root.addContent(JDOMUtil.simpleElement(\"classification\", d.getClassification()));        final Element th = new Element(\"transform-history\");        for (final String s : d.transformHistory()) {            th.addContent(JDOMUtil.simpleElement(\"itinerary-step\", s));        }        root.addContent(th);        if (d.getProcessingError() != null) {            root.addContent(JDOMUtil.simpleElement(\"processing-error\", d.getProcessingError()));        }        final Element meta = new Element(\"metadata\");        for (final String key : d.getParameters().keySet()) {            final Element m = JDOMUtil.protectedElement(\"param\", d.getStringParameter(key));            m.setAttribute(\"name\", key);            meta.addContent(m);        }        root.addContent(meta);        if (d.header() != null) {            root.addContent(JDOMUtil.protectedElement(\"header\", d.header()));        }        if (d.dataLength() > 0) {            root.addContent(JDOMUtil.protectedElement(\"data\", d.data()));        }        if (d.footer() != null) {            root.addContent(JDOMUtil.protectedElement(\"footer\", d.footer()));        }        if (d.getNumAlternateViews() > 0) {            final Element views = new Element(\"views\");            for (final String av : d.getAlternateViewNames()) {                final Element v = JDOMUtil.protectedElement(\"view\", d.getAlternateView(av));                v.setAttribute(\"name\", av);                views.addContent(v);            }            root.addContent(views);        }        logger.debug(\"Produced xml document for \" + d.shortName());        return new Document(root);    }    public static String toXmlString(final IBaseDataObject d) {        return JDOMUtil.toString(toXml(d));    }    public static Document toXml(final List<IBaseDataObject> list) {        final Element root = new Element(\"payload-list\");        for (final IBaseDataObject d : list) {            final Document doc = toXml(d);            root.addContent(doc.detachRootElement());            logger.debug(\"Adding xml content for \" + d.shortName() + \" to document\");        }        return new Document(root);    }    public static String toXmlString(final List<IBaseDataObject> list) {        return JDOMUtil.toString(toXml(list));    }    private static final String SEP = \": \";    public static String printFormattedMetadata(final IBaseDataObject payload) {        final StringBuilder out = new StringBuilder();        out.append(LS);        for (final Map.Entry<String, Collection<Object>> entry : payload.getParameters().entrySet()) {            out.append(entry.getKey()).append(SEP).append(entry.getValue()).append(LS);        }        return out.toString();    }    private PayloadUtil() {}}", "nl": "import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.io.UnsupportedEncodingException;import java.nio.ByteBuffer;import java.util.Collection;import java.util.Date;import java.util.Iterator;import java.util.List;import java.util.Map;import emissary.core.IBaseDataObject;import emissary.util.xml.JDOMUtil;import org.jdom2.Document;import org.jdom2.Element;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class PayloadUtil {    public static final Logger logger = LoggerFactory.getLogger(PayloadUtil.class);    private static final String LS = System.getProperty(\"line.separator\");    public static String getName(final Object o) {        String payloadName = o.getClass().getName();        if (o instanceof IBaseDataObject) {            payloadName = ((IBaseDataObject) o).shortName();        } else if (o instanceof Collection) {            final Iterator<?> pi = ((Collection<?>) o).iterator();            if (pi.hasNext()) {                payloadName = ((IBaseDataObject) pi.next()).shortName() + \"(\" + ((Collection<?>) o).size() + \")\";            }        }        return payloadName;    }    public static String getPayloadDisplayString(final IBaseDataObject payload, final boolean oneLine) {        return oneLine ? getPayloadOneLineString(payload) : getPayloadDisplayString(payload);    }    public static String getPayloadDisplayString(final IBaseDataObject payload) {        final StringBuilder sb = new StringBuilder();        final List<String> th = payload.transformHistory();        final String fileName = payload.getFilename();        final List<String> currentForms = payload.getAllCurrentForms();        final Date creationTimestamp = payload.getCreationTimestamp();        sb.append(\"\\n\").append(\"filename: \").append(fileName).append(\"\\n\").append(\"   creationTimestamp: \").append(creationTimestamp).append(\"\\n\")                .append(\"   currentForms: \").append(currentForms).append(\"\\n\").append(\"   filetype: \").append(payload.getFileType()).append(\"\\n\")                .append(\"   transform history (\").append(th.size()).append(\") :\").append(\"\\n\");        for (final String h : th) {            sb.append(\"     \").append(h).append(\"\\n\");        }        return sb.toString();    }    public static String getPayloadOneLineString(final IBaseDataObject payload) {        final StringBuilder sb = new StringBuilder();        final String fn = payload.getFilename();        final int attPos = fn.indexOf(emissary.core.Family.SEP);        if (attPos != -1) {            sb.append(fn.substring(attPos + 1)).append(\" \");        }        final List<String> th = payload.transformHistory();        String prev = \"\";        for (final String h : th) {            final int pos = h.indexOf(\".\");            if (pos > 0) {                final String prefix = h.substring(0, pos);                if (!prev.equals(prefix)) {                    if (prev.length() != 0) {                        sb.append(\",\");                    }                    sb.append(prefix);                    prev = prefix;                }            }        }        sb.append(\">>\").append(payload.getAllCurrentForms());        sb.append(\"        sb.append(\"        return sb.toString();    }    public static ByteBuffer serializeToByteBuffer(final Object payload) throws IOException {        return ByteBuffer.wrap(serializeToBytes(payload));    }    public static byte[] serializeToBytes(final Object payload) throws IOException {        final ByteArrayOutputStream bos = new ByteArrayOutputStream();        serializeToStream(bos, payload);        return bos.toByteArray();    }    public static String serializeToString(final Object payload) throws IOException {        final ByteArrayOutputStream bos = new ByteArrayOutputStream();        serializeToStream(bos, payload);        String agentData = null;        try {            agentData = bos.toString(\"8859_1\");        } catch (UnsupportedEncodingException e) {            logger.warn(\"Should always support 8859_1\", e);            agentData = bos.toString();        }        return agentData;    }    public static void serializeToStream(final OutputStream os, final Object payload) throws IOException {        ObjectOutputStream oos = null;        try {            oos = new ObjectOutputStream(os);            oos.writeObject(payload);        } finally {            if (oos != null) {                try {                    oos.close();                } catch (IOException ignore) {                }            }        }    }    public static Object deserialize(final String s) {        ObjectInputStream ois = null;        try {            ois = new ObjectInputStream(new ByteArrayInputStream(s.getBytes(\"8859_1\")));            return ois.readObject();        } catch (Exception e) {            logger.error(\"Cannot deserialize payload using \" + (s == null ? -1 : s.length()) + \" bytes\", e);            throw new IllegalArgumentException(\"Cannot deserialize payload\");        } finally {            if (ois != null) {                try {                    ois.close();                } catch (IOException ignore) {                }            }        }    }    public static Document toXml(final IBaseDataObject d) {        final Element root = new Element(\"payload\");        root.addContent(JDOMUtil.protectedElement(\"name\", d.getFilename()));        final Element cf = new Element(\"current-forms\");        for (final String c : d.getAllCurrentForms()) {            cf.addContent(JDOMUtil.simpleElement(\"current-form\", c));        }        root.addContent(cf);        root.addContent(JDOMUtil.simpleElement(\"encoding\", d.getFontEncoding()));        root.addContent(JDOMUtil.simpleElement(\"filetype\", d.getFileType()));        root.addContent(JDOMUtil.simpleElement(\"classification\", d.getClassification()));        final Element th = new Element(\"transform-history\");        for (final String s : d.transformHistory()) {            th.addContent(JDOMUtil.simpleElement(\"itinerary-step\", s));        }        root.addContent(th);        if (d.getProcessingError() != null) {            root.addContent(JDOMUtil.simpleElement(\"processing-error\", d.getProcessingError()));        }        final Element meta = new Element(\"metadata\");        for (final String key : d.getParameters().keySet()) {            final Element m = JDOMUtil.protectedElement(\"param\", d.getStringParameter(key));            m.setAttribute(\"name\", key.toString());            meta.addContent(m);        }        root.addContent(meta);        if (d.header() != null) {            root.addContent(JDOMUtil.protectedElement(\"header\", d.header()));        }        if (d.dataLength() > 0) {            root.addContent(JDOMUtil.protectedElement(\"data\", d.data()));        }        if (d.footer() != null) {            root.addContent(JDOMUtil.protectedElement(\"footer\", d.footer()));        }        if (d.getNumAlternateViews() > 0) {            final Element views = new Element(\"views\");            for (final String av : d.getAlternateViewNames()) {                final Element v = JDOMUtil.protectedElement(\"view\", d.getAlternateView(av));                v.setAttribute(\"name\", av);                views.addContent(v);            }            root.addContent(views);        }        logger.debug(\"Produced xml document for \" + d.shortName());        final Document doc = new Document(root);        return doc;    }    public static String toXmlString(final IBaseDataObject d) {        return JDOMUtil.toString(toXml(d));    }    public static Document toXml(final List<IBaseDataObject> list) {        final Element root = new Element(\"payload-list\");        for (final IBaseDataObject d : list) {            final Document doc = toXml(d);            root.addContent(doc.detachRootElement());            logger.debug(\"Adding xml content for \" + d.shortName() + \" to document\");        }        final Document doc = new Document(root);        return doc;    }    public static String toXmlString(final List<IBaseDataObject> list) {        return JDOMUtil.toString(toXml(list));    }    private static final String SEP = \": \";    public static String printFormattedMetadata(final IBaseDataObject payload) {        final StringBuilder out = new StringBuilder();        out.append(LS);        for (final Map.Entry<String, Collection<Object>> entry : payload.getParameters().entrySet()) {            out.append(entry.getKey() + SEP + entry.getValue() + LS);        }        return out.toString();    }    private PayloadUtil() {}}"}
{"code": "import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.UUID;import emissary.test.core.UnitTest;import org.junit.Test;public class WorkBundleTest extends UnitTest {    private boolean compareWorkerUnits(WorkUnit w1, WorkUnit w2) {        boolean matchFileNames;        if (w1.getFileName() == null && w2.getFileName() == null) {            matchFileNames = true;        } else {            matchFileNames = w1.getFileName().equals(w2.getFileName());        }        boolean matchTxid;        if (w1.getTransactionId() == null && w2.getTransactionId() == null) {            matchTxid = true;        } else {            matchTxid = w1.getTransactionId().equals(w2.getTransactionId());        }        return matchFileNames && matchTxid && (w1.failedToParse() == w2.failedToParse()) && (w1.failedToProcess() == w2.failedToProcess());    }    @Test    public void testWorkBundleWithWorkerUnits() {        WorkBundle w1 = new WorkBundle();        w1.addWorkUnit(new WorkUnit(\"file1.txt\"));        w1.addWorkUnit(new WorkUnit(\"file2.txt\", UUID.randomUUID().toString(), true, true));        w1.addWorkUnit(new WorkUnit(\"file3.txt\", UUID.randomUUID().toString(), true, false));        assertEquals(\"Size of work units\", 3, w1.getWorkUnitList().size());        int ic = 0;        for (Iterator<WorkUnit> i = w1.getWorkUnitIterator(); i.hasNext();) {            i.next();            ic++;        }        assertEquals(\"Files from iterator\", 3, ic);        WorkBundle w2 = new WorkBundle(w1);        assertNotEquals(\"Copy ctor new id\", w1.getBundleId(), w2.getBundleId());        assertEquals(\"Failed to properly copy WorkUnit list\", w1.getWorkUnitList(), w2.getWorkUnitList());        String xml = w2.toXml();        assertNotNull(\"XML failed to generate\", xml);        WorkBundle w3 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Failed to buildworkbundle from xml\", w3);        for (int i = 0; i < w2.getWorkUnitList().size(); i++) {            if (!compareWorkerUnits(w2.getWorkUnitList().get(i), w3.getWorkUnitList().get(i))) {                fail(\"BuildWorkBundle did not generate equivalent workBundle\");            }        }    }    @Test    public void testWorkBundle() {        WorkBundle w1 = new WorkBundle();        WorkBundle w2 = new WorkBundle();        assertTrue(\"Generated ids must be unique \" + w1.getBundleId(), !w1.getBundleId().equals(w2.getBundleId()));        WorkBundle w3 = new WorkBundle(\"/output/root\", \"/eat/prefix\");        assertEquals(\"Output root stored\", \"/output/root\", w3.getOutputRoot());        assertEquals(\"Eat prefix stored\", \"/eat/prefix\", w3.getEatPrefix());        w3.addFileName(\"file1.txt\");        w3.addFileName(\"file2.txt\");        w3.addFileName(\"file3.txt\");        assertEquals(\"Size of file names\", 3, w3.size());        w3.addFileNames(new String[] {\"file4.txt\", \"file5.txt\", \"file6.txt\"});        assertEquals(\"Size of file names\", 6, w3.size());        w3.addFileNames(Arrays.asList(new String[] {\"file7.txt\", \"file8.txt\"}));        assertEquals(\"Size of file names\", 8, w3.size());        assertEquals(\"Files as list\", 8, w3.getFileNameList().size());        int ic = 0;        for (Iterator<String> i = w3.getFileNameIterator(); i.hasNext();) {            i.next();            ic++;        }        assertEquals(\"Files from iterator\", 8, ic);        w3.setCaseId(\"caseid\");        w3.setSentTo(\"machine1\");        w3.setPriority(3);        assertEquals(\"Error count return should be incremented\", 1, w3.incrementErrorCount());        WorkBundle w4 = new WorkBundle(w3);        assertEquals(\"Copy constructor\", \"/output/root\", w4.getOutputRoot());        assertEquals(\"Copy constructor\", \"/eat/prefix\", w4.getEatPrefix());        assertFalse(\"Copy ctor new id\", w3.getBundleId().equals(w4.getBundleId()));        assertEquals(\"Copy constructor\", \"caseid\", w4.getCaseId());        assertEquals(\"Copy constructor\", 8, w4.size());        assertEquals(\"Copy of sentTo\", \"machine1\", w4.getSentTo());        assertEquals(\"Copy of errorCount\", 1, w4.getErrorCount());        assertEquals(\"Copy of priority\", w3.getPriority(), w4.getPriority());        assertEquals(\"Copy of simple mode flag\", w3.getSimpleMode(), w4.getSimpleMode());        String oldbid = w4.getBundleId();        w4.resetBundleId();        assertFalse(\"New id on reset\", oldbid.equals(w4.getBundleId()));        w3.clearFiles();        assertEquals(\"Size after clear\", 0, w3.size());        WorkBundle w5 = new WorkBundle(w3);        assertEquals(\"Size of copy of empty bundle\", 0, w5.size());        assertTrue(\"ToString with bundle id\", w4.toString().indexOf(w4.getBundleId()) > -1);    }    @Test    public void testBundleXml() {        WorkBundle w = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w.setCaseId(\"caseid\");        w.addFileName(\"file1.txt\", 15L, 4L);        w.addFileName(\"<file2.txt&foo=bar>\", 7L, 10L);        w.setPriority(1);        w.setSimpleMode(false);        String xml = null;        try {            xml = w.toXml();        } catch (Exception ex) {            fail(\"Cannot generate xml \" + ex);        }        assertNotNull(\"Generated xml\", xml);        WorkBundle w2 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Generated from xml\", w2);        assertEquals(\"Value across xml\", w.getOutputRoot(), w2.getOutputRoot());        assertEquals(\"Value across xml\", w.getEatPrefix(), w2.getEatPrefix());        assertEquals(\"Value across xml\", w.getCaseId(), w2.getCaseId());        assertEquals(\"Youngest time across xml\", w.getYoungestFileModificationTime(), w2.getYoungestFileModificationTime());        assertEquals(\"Oldest time across xml\", w.getOldestFileModificationTime(), w2.getOldestFileModificationTime());        assertEquals(\"Total filesize across xml\", w.getTotalFileSize(), w2.getTotalFileSize());        assertEquals(\"Files across xml\", w.size(), w2.size());        assertEquals(\"Priority across xml\", w.getPriority(), w2.getPriority());        assertEquals(\"Simple mode across xml\", w.getSimpleMode(), w2.getSimpleMode());        List<String> w2l = w2.getFileNameList();        assertNotNull(\"File list from xml\", w2l);        assertEquals(\"Size of file list from xml\", 2, w2l.size());        assertEquals(\"File values from xml\", \"file1.txt\", w2l.get(0));        assertEquals(\"File values from xml\", \"<file2.txt&foo=bar>\", w2l.get(1));    }    @Test    public void testBundleXmlWithDefaultTimes() {        WorkBundle w = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w.setCaseId(\"caseid\");        w.addFileName(\"file1.txt\");        w.addFileName(\"<file2.txt&foo=bar>\");        w.setPriority(1);        w.setSimpleMode(false);        String xml = null;        try {            xml = w.toXml();        } catch (Exception ex) {            fail(\"Cannot generate xml \" + ex);        }        assertNotNull(\"Generated xml\", xml);        WorkBundle w2 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Generated from xml\", w2);        assertEquals(\"Value across xml\", w.getOutputRoot(), w2.getOutputRoot());        assertEquals(\"Value across xml\", w.getEatPrefix(), w2.getEatPrefix());        assertEquals(\"Value across xml\", w.getCaseId(), w2.getCaseId());        assertEquals(\"Youngest time across xml\", Long.MIN_VALUE, w2.getYoungestFileModificationTime());        assertEquals(\"Oldest time across xml\", Long.MAX_VALUE, w2.getOldestFileModificationTime());        assertEquals(\"Files across xml\", w.size(), w2.size());        assertEquals(\"Priority across xml\", w.getPriority(), w2.getPriority());        assertEquals(\"Simple mode across xml\", w.getSimpleMode(), w2.getSimpleMode());        List<String> w2l = w2.getFileNameList();        assertNotNull(\"File list from xml\", w2l);        assertEquals(\"Size of file list from xml\", 2, w2l.size());        assertEquals(\"File values from xml\", \"file1.txt\", w2l.get(0));        assertEquals(\"File values from xml\", \"<file2.txt&foo=bar>\", w2l.get(1));    }    @Test    public void testBundleXmlWithNullFields() {        WorkBundle w = new WorkBundle(null, null);        w.setCaseId(null);        w.addFileName(\"file1.txt\");        w.setPriority(1);        w.setSimpleMode(false);        String xml = null;        try {            xml = w.toXml();        } catch (Exception ex) {            fail(\"Cannot generate xml \" + ex);        }        assertNotNull(\"Generated xml\", xml);        WorkBundle w2 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Generated from xml\", w2);        assertEquals(\"Value across xml\", w.getOutputRoot(), w2.getOutputRoot());        assertEquals(\"Value across xml\", w.getEatPrefix(), w2.getEatPrefix());        assertEquals(\"Value across xml\", w.getCaseId(), w2.getCaseId());    }    @Test    public void testComparator() {        WorkBundle w1 = new WorkBundle(\"/output/root\", \"/eat/prefix\");        WorkBundle w2 = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w1.setPriority(10);        w2.setPriority(20);        assertTrue(\"Comparator by priority should have lower number/higher priority first \" + w1.compareTo(w2), w1.compareTo(w2) < 0);        assertTrue(\"Comparator by priority should have lower number/higher priority first \" + w2.compareTo(w1), w2.compareTo(w1) > 0);    }    @Test    public void testAddFileNameWithTimes() {        WorkBundle w = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w.addFileName(\"file1.txt\", 15L, 4L);        w.addFileName(\"<file2.txt&foo=bar>\", 7L, 10L);        assertEquals(15L, w.getYoungestFileModificationTime());        assertEquals(7L, w.getOldestFileModificationTime());    }    @Test    public void testSerDe() throws IOException {        WorkBundle w1 = new WorkBundle(\"/output/root\", \"/etc/prefix\");        w1.addFileName(\"file1.txt\", 15L, 4L);        w1.addFileName(\"<file2.txt&foo=bar>\", 7L, 10L);        ByteArrayOutputStream bout = new ByteArrayOutputStream();        DataOutputStream out = new DataOutputStream(bout);        w1.writeToStream(out);        out.close();        bout.close();        byte[] b = bout.toByteArray();        ByteArrayInputStream bin = new ByteArrayInputStream(b);        DataInputStream in = new DataInputStream(bin);        WorkBundle w2 = WorkBundle.readFromStream(in);        assertEquals(0, w1.compareTo(w2));    }    @Test    public void testLimitAdd() throws IOException {        final List<WorkUnit> wul = new ArrayList<>();        for (int i = 0; i < WorkBundle.MAX_UNITS + 2; i++) {            String fileName = UUID.randomUUID().toString();            wul.add(new WorkUnit(fileName));        }        try {            WorkBundle wb = new WorkBundle();            wb.addWorkUnits(wul);            fail(\"Did not catch expected exception when adding work unit list.\");        } catch (IllegalStateException e) {        } catch (Throwable t) {            fail(\"Unexpected Exception caught when adding work unit list: \" + t);        }        try {            WorkBundle wb = new WorkBundle();            wul.forEach(wb::addWorkUnit);            fail(\"Did not catch expected exception when adding work unit.\");        } catch (IllegalStateException e) {        } catch (Throwable t) {            fail(\"Unexpected Exception caught when adding work unit: \" + t);        }    }    @Test    public void testLimitSerDe() throws IOException {        ByteArrayOutputStream bout = new ByteArrayOutputStream();        DataOutputStream out = new DataOutputStream(bout);        WorkBundle wb1 = new WorkBundle();        final List<WorkUnit> wul = new ArrayList<>();        for (int i = 0; i < WorkBundle.MAX_UNITS + 2; i++) {            String fileName = UUID.randomUUID().toString();            wul.add(new WorkUnit(fileName));        }        WorkBundle.writeUTFOrNull(wb1.bundleId, out);        WorkBundle.writeUTFOrNull(wb1.outputRoot, out);        WorkBundle.writeUTFOrNull(wb1.eatPrefix, out);        WorkBundle.writeUTFOrNull(wb1.caseId, out);        WorkBundle.writeUTFOrNull(wb1.sentTo, out);        out.writeInt(wb1.errorCount);        out.writeInt(wb1.priority);        out.writeBoolean(wb1.simpleMode);        out.writeLong(wb1.oldestFileModificationTime);        out.writeLong(wb1.youngestFileModificationTime);        out.writeLong(wb1.totalFileSize);        out.writeInt(WorkBundle.MAX_UNITS + 2);        for (WorkUnit u : wul) {            u.writeToStream(out);        }        out.close();        bout.close();        try {            WorkBundle wb2 = WorkBundle.readFromStream(new DataInputStream(new ByteArrayInputStream(bout.toByteArray())));            fail(\"Did not catch expected exception when deserializing work unit.\");        } catch (IOException e) {        } catch (Throwable t) {            fail(\"Unexpected Exception caught when deserializing work unit: \" + t);        }    }}", "nl": "import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.UUID;import emissary.test.core.UnitTest;import org.junit.Test;public class WorkBundleTest extends UnitTest {    private boolean compareWorkerUnits(WorkUnit w1, WorkUnit w2) {        boolean matchFileNames;        if (w1.getFileName() == null && w2.getFileName() == null) {            matchFileNames = true;        } else {            matchFileNames = w1.getFileName().equals(w2.getFileName());        }        boolean matchTxid;        if (w1.getTransactionId() == null && w2.getTransactionId() == null) {            matchTxid = true;        } else {            matchTxid = w1.getTransactionId().equals(w2.getTransactionId());        }        return matchFileNames && matchTxid && (w1.failedToParse() == w2.failedToParse()) && (w1.failedToProcess() == w2.failedToProcess());    }    @Test    public void testWorkBundleWithWorkerUnits() {        WorkBundle w1 = new WorkBundle();        w1.addWorkUnit(new WorkUnit(\"file1.txt\"));        w1.addWorkUnit(new WorkUnit(\"file2.txt\", UUID.randomUUID().toString(), true, true));        w1.addWorkUnit(new WorkUnit(\"file3.txt\", UUID.randomUUID().toString(), true, false));        assertEquals(\"Size of work units\", 3, w1.getWorkUnitList().size());        int ic = 0;        for (Iterator<WorkUnit> i = w1.getWorkUnitIterator(); i.hasNext();) {            i.next();            ic++;        }        assertEquals(\"Files from iterator\", 3, ic);        WorkBundle w2 = new WorkBundle(w1);        assertNotEquals(\"Copy ctor new id\", w1.getBundleId(), w2.getBundleId());        assertEquals(\"Failed to properly copy WorkUnit list\", w1.getWorkUnitList(), w2.getWorkUnitList());        String xml = w2.toXml();        assertNotNull(\"XML failed to generate\", xml);        WorkBundle w3 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Failed to buildworkbundle from xml\", w3);        for (int i = 0; i < w2.getWorkUnitList().size(); i++) {            if (!compareWorkerUnits(w2.getWorkUnitList().get(i), w3.getWorkUnitList().get(i))) {                fail(\"BuildWorkBundle did not generate equivalent workBundle\");            }        }    }    @Test    public void testWorkBundle() {        WorkBundle w1 = new WorkBundle();        WorkBundle w2 = new WorkBundle();        assertTrue(\"Generated ids must be unique \" + w1.getBundleId(), !w1.getBundleId().equals(w2.getBundleId()));        WorkBundle w3 = new WorkBundle(\"/output/root\", \"/eat/prefix\");        assertEquals(\"Output root stored\", \"/output/root\", w3.getOutputRoot());        assertEquals(\"Eat prefix stored\", \"/eat/prefix\", w3.getEatPrefix());        w3.addFileName(\"file1.txt\");        w3.addFileName(\"file2.txt\");        w3.addFileName(\"file3.txt\");        assertEquals(\"Size of file names\", 3, w3.size());        w3.addFileNames(new String[] {\"file4.txt\", \"file5.txt\", \"file6.txt\"});        assertEquals(\"Size of file names\", 6, w3.size());        w3.addFileNames(Arrays.asList(new String[] {\"file7.txt\", \"file8.txt\"}));        assertEquals(\"Size of file names\", 8, w3.size());        assertEquals(\"Files as list\", 8, w3.getFileNameList().size());        int ic = 0;        for (Iterator<String> i = w3.getFileNameIterator(); i.hasNext();) {            i.next();            ic++;        }        assertEquals(\"Files from iterator\", 8, ic);        w3.setCaseId(\"caseid\");        w3.setSentTo(\"machine1\");        w3.setPriority(3);        assertEquals(\"Error count return should be incremented\", 1, w3.incrementErrorCount());        WorkBundle w4 = new WorkBundle(w3);        assertEquals(\"Copy constructor\", \"/output/root\", w4.getOutputRoot());        assertEquals(\"Copy constructor\", \"/eat/prefix\", w4.getEatPrefix());        assertFalse(\"Copy ctor new id\", w3.getBundleId().equals(w4.getBundleId()));        assertEquals(\"Copy constructor\", \"caseid\", w4.getCaseId());        assertEquals(\"Copy constructor\", 8, w4.size());        assertEquals(\"Copy of sentTo\", \"machine1\", w4.getSentTo());        assertEquals(\"Copy of errorCount\", 1, w4.getErrorCount());        assertEquals(\"Copy of priority\", w3.getPriority(), w4.getPriority());        assertEquals(\"Copy of simple mode flag\", w3.getSimpleMode(), w4.getSimpleMode());        String oldbid = w4.getBundleId();        w4.resetBundleId();        assertFalse(\"New id on reset\", oldbid.equals(w4.getBundleId()));        w3.clearFiles();        assertEquals(\"Size after clear\", 0, w3.size());        WorkBundle w5 = new WorkBundle(w3);        assertEquals(\"Size of copy of empty bundle\", 0, w5.size());        assertTrue(\"ToString with bundle id\", w4.toString().indexOf(w4.getBundleId()) > -1);    }    @Test    public void testBundleXml() {        WorkBundle w = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w.setCaseId(\"caseid\");        w.addFileName(\"file1.txt\", 15L, 4L);        w.addFileName(\"<file2.txt&foo=bar>\", 7L, 10L);        w.setPriority(1);        w.setSimpleMode(false);        String xml = null;        try {            xml = w.toXml();        } catch (Exception ex) {            fail(\"Cannot generate xml \" + ex);        }        assertNotNull(\"Generated xml\", xml);        WorkBundle w2 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Generated from xml\", w2);        assertEquals(\"Value across xml\", w.getOutputRoot(), w2.getOutputRoot());        assertEquals(\"Value across xml\", w.getEatPrefix(), w2.getEatPrefix());        assertEquals(\"Value across xml\", w.getCaseId(), w2.getCaseId());        assertEquals(\"Youngest time across xml\", w.getYoungestFileModificationTime(), w2.getYoungestFileModificationTime());        assertEquals(\"Oldest time across xml\", w.getOldestFileModificationTime(), w2.getOldestFileModificationTime());        assertEquals(\"Total filesize across xml\", w.getTotalFileSize(), w2.getTotalFileSize());        assertEquals(\"Files across xml\", w.size(), w2.size());        assertEquals(\"Priority across xml\", w.getPriority(), w2.getPriority());        assertEquals(\"Simple mode across xml\", w.getSimpleMode(), w2.getSimpleMode());        List<String> w2l = w2.getFileNameList();        assertNotNull(\"File list from xml\", w2l);        assertEquals(\"Size of file list from xml\", 2, w2l.size());        assertEquals(\"File values from xml\", \"file1.txt\", w2l.get(0));        assertEquals(\"File values from xml\", \"<file2.txt&foo=bar>\", w2l.get(1));    }    @Test    public void testBundleXmlWithDefaultTimes() {        WorkBundle w = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w.setCaseId(\"caseid\");        w.addFileName(\"file1.txt\");        w.addFileName(\"<file2.txt&foo=bar>\");        w.setPriority(1);        w.setSimpleMode(false);        String xml = null;        try {            xml = w.toXml();        } catch (Exception ex) {            fail(\"Cannot generate xml \" + ex);        }        assertNotNull(\"Generated xml\", xml);        WorkBundle w2 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Generated from xml\", w2);        assertEquals(\"Value across xml\", w.getOutputRoot(), w2.getOutputRoot());        assertEquals(\"Value across xml\", w.getEatPrefix(), w2.getEatPrefix());        assertEquals(\"Value across xml\", w.getCaseId(), w2.getCaseId());        assertEquals(\"Youngest time across xml\", Long.MIN_VALUE, w2.getYoungestFileModificationTime());        assertEquals(\"Oldest time across xml\", Long.MAX_VALUE, w2.getOldestFileModificationTime());        assertEquals(\"Files across xml\", w.size(), w2.size());        assertEquals(\"Priority across xml\", w.getPriority(), w2.getPriority());        assertEquals(\"Simple mode across xml\", w.getSimpleMode(), w2.getSimpleMode());        List<String> w2l = w2.getFileNameList();        assertNotNull(\"File list from xml\", w2l);        assertEquals(\"Size of file list from xml\", 2, w2l.size());        assertEquals(\"File values from xml\", \"file1.txt\", w2l.get(0));        assertEquals(\"File values from xml\", \"<file2.txt&foo=bar>\", w2l.get(1));    }    @Test    public void testBundleXmlWithNullFields() {        WorkBundle w = new WorkBundle(null, null);        w.setCaseId(null);        w.addFileName(\"file1.txt\");        w.setPriority(1);        w.setSimpleMode(false);        String xml = null;        try {            xml = w.toXml();        } catch (Exception ex) {            fail(\"Cannot generate xml \" + ex);        }        assertNotNull(\"Generated xml\", xml);        WorkBundle w2 = WorkBundle.buildWorkBundle(xml);        assertNotNull(\"Generated from xml\", w2);        assertEquals(\"Value across xml\", w.getOutputRoot(), w2.getOutputRoot());        assertEquals(\"Value across xml\", w.getEatPrefix(), w2.getEatPrefix());        assertEquals(\"Value across xml\", w.getCaseId(), w2.getCaseId());    }    @Test    public void testComparator() {        WorkBundle w1 = new WorkBundle(\"/output/root\", \"/eat/prefix\");        WorkBundle w2 = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w1.setPriority(10);        w2.setPriority(20);        assertTrue(\"Comparator by priority should have lower number/higher priority first \" + w1.compareTo(w2), w1.compareTo(w2) < 0);        assertTrue(\"Comparator by priority should have lower number/higher priority first \" + w2.compareTo(w1), w2.compareTo(w1) > 0);    }    @Test    public void testAddFileNameWithTimes() {        WorkBundle w = new WorkBundle(\"/output/root\", \"/eat/prefix\");        w.addFileName(\"file1.txt\", 15L, 4L);        w.addFileName(\"<file2.txt&foo=bar>\", 7L, 10L);        assertEquals(15L, w.getYoungestFileModificationTime());        assertEquals(7L, w.getOldestFileModificationTime());    }}"}
{"code": "import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Date;import java.util.List;import emissary.core.DataObjectFactory;import emissary.core.Family;import emissary.core.Form;import emissary.core.IBaseDataObject;import emissary.test.core.UnitTest;import org.junit.AfterClass;import org.junit.BeforeClass;import org.junit.Test;public class PayloadUtilTest extends UnitTest {    private static String timezone = \"GMT\";    @BeforeClass    public static void setup() {        timezone = System.getProperty(\"user.timezone\");        System.setProperty(\"user.timezone\", \"GMT\");    }    @AfterClass    public static void teardown() {        System.setProperty(\"user.timezone\", timezone);    }    @Test    public void testOneLineString() {        final String fn = \"fname\" + Family.SEP + \"4\";        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), fn, Form.UNKNOWN);        d.appendTransformHistory(\"FOO.UNKNOWN.FOOPLACE.http:        d.appendTransformHistory(\"BAR.UNKNOWN.BARPLACE.http:        d.appendTransformHistory(\"BAR.BURP.BURPPLACE.http:        d.setCreationTimestamp(new Date(0));        final String expected = \"att-4 FOO,BAR>>[UNKNOWN]        final String answer = PayloadUtil.getPayloadDisplayString(d, true);        assertTrue(\"Must be one line string\", answer.indexOf(\"\\n\") == -1);        assertTrue(\"Answer string did not equal the expected string\", expected.compareTo(answer) == 0);    }    @Test    public void testOneLineStringOnTLD() {        final String fn = \"fname\";        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), fn, Form.UNKNOWN);        d.setCreationTimestamp(new Date(0));        d.appendTransformHistory(\"BOGUSKEYELEMENT\");        final String expected = \">>[UNKNOWN]        final String answer = PayloadUtil.getPayloadDisplayString(d, true);        assertTrue(\"Must be one line string\", answer.indexOf(\"\\n\") == -1);        assertTrue(\"Answer string did not equal the expected string\", expected.compareTo(answer) == 0);    }    @Test    public void testMultiLineString() {        final String fn = \"fname\" + Family.SEP + \"4\";        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), fn, Form.UNKNOWN);        d.appendTransformHistory(\"FOO.UNKNOWN.FOOPLACE.http:        d.appendTransformHistory(\"BAR.UNKNOWN.BARPLACE.http:        d.setCreationTimestamp(new Date(0));        final String answer = PayloadUtil.getPayloadDisplayString(d, false);        assertTrue(\"Must be multi-line string\", answer.indexOf(\"\\n\") > -1);        assertTrue(\"Answer did not contain the correct filename\", answer.contains(\"filename: fname-att-4\"));        assertTrue(\"Answer did not contain the creationTimestamp\", answer.contains(\"creationTimestamp: \" + (new Date(0)).toString()));        assertTrue(\"Answer did not contain the currentForms\", answer.contains(\"currentForms: [UNKNOWN]\"));        assertTrue(\"Answer did not contain the correct filetype\", answer.contains(\"filetype: UNKNOWN\"));        assertTrue(\"Answer did not contain the transform history number\", answer.contains(\"transform history (2)\"));        assertTrue(\"Answer did not contain the correct transform history entry\",                answer.contains(\"BAR.UNKNOWN.BARPLACE.http:        assertTrue(\"Answer did not contain the correct transform history entry\",                answer.contains(\"FOO.UNKNOWN.FOOPLACE.http:    }    @Test    public void testNameOfSimpleObject() {        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), \"ab/fn\", Form.UNKNOWN);        assertEquals(\"Name of simple payload is shortname\", \"fn\", PayloadUtil.getName(d));    }    @Test    public void testNameOfCollection() {        final List<IBaseDataObject> list = new ArrayList<IBaseDataObject>();        for (int i = 0; i < 3; i++) {            final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), \"ab/fn\" + i, Form.UNKNOWN);            list.add(d);        }        assertEquals(\"Name of collection payload is shortname with count\", \"fn0(3)\", PayloadUtil.getName(list));    }    @Test    public void testNameOfEmptyCollection() {        final List<IBaseDataObject> list = new ArrayList<IBaseDataObject>();        assertEquals(\"Name of empty collection is class name\", \"java.util.ArrayList\", PayloadUtil.getName(list));    }    @Test    public void testNameOfBadArgument() {        final String s = \"foo\";        assertEquals(\"Name of unexpected argument is class name\", s.getClass().getName(), PayloadUtil.getName(s));    }    @Test    public void testXmlSerizliaztion() throws Exception {        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), \"testfile\", Form.UNKNOWN);        d.addAlternateView(\"AV\", \"def\".getBytes());        d.putParameter(\"P\", \"ghi\");        d.addProcessingError(\"jkl\");        d.setHeader(\"mno\".getBytes());        d.setFooter(\"pqr\".getBytes());        d.appendTransformHistory(\"stu\");        final String xml = PayloadUtil.toXmlString(d);        assertTrue(\"Xml serizliazation must include payload data\", xml.indexOf(\"abc\") > -1);        assertTrue(\"Xml serizliazation must include av data\", xml.indexOf(\"def\") > -1);        assertTrue(\"Xml serizliazation must include param data\", xml.indexOf(\"ghi\") > -1);        assertTrue(\"Xml serizliazation must include error data\", xml.indexOf(\"jkl\") > -1);        assertTrue(\"Xml serizliazation must include header data\", xml.indexOf(\"mno\") > -1);        assertTrue(\"Xml serizliazation must include footer data\", xml.indexOf(\"pqr\") > -1);        assertTrue(\"Xml serizliazation must include history data\", xml.indexOf(\"stu\") > -1);        final List<IBaseDataObject> list = new ArrayList<IBaseDataObject>();        list.add(d);        final String lxml = PayloadUtil.toXmlString(list);        assertTrue(\"Xml serizliazation must include payload data\", lxml.indexOf(\"abc\") > -1);        assertTrue(\"Xml serizliazation must include av data\", lxml.indexOf(\"def\") > -1);        assertTrue(\"Xml serizliazation must include param data\", lxml.indexOf(\"ghi\") > -1);        assertTrue(\"Xml serizliazation must include error data\", lxml.indexOf(\"jkl\") > -1);        assertTrue(\"Xml serizliazation must include header data\", lxml.indexOf(\"mno\") > -1);        assertTrue(\"Xml serizliazation must include footer data\", lxml.indexOf(\"pqr\") > -1);        assertTrue(\"Xml serizliazation must include history data\", lxml.indexOf(\"stu\") > -1);    }}", "nl": "import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Date;import java.util.List;import emissary.core.DataObjectFactory;import emissary.core.Family;import emissary.core.Form;import emissary.core.IBaseDataObject;import emissary.test.core.UnitTest;import org.junit.AfterClass;import org.junit.BeforeClass;import org.junit.Test;public class PayloadUtilTest extends UnitTest {    private static String timezone = \"GMT\";    @BeforeClass    public static void setup() {        timezone = System.getProperty(\"user.timezone\");        System.setProperty(\"user.timezone\", \"GMT\");    }    @AfterClass    public static void teardown() {        System.setProperty(\"user.timezone\", timezone);    }    @Test    public void testOneLineString() {        final String fn = \"fname\" + Family.SEP + \"4\";        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), fn, Form.UNKNOWN);        d.appendTransformHistory(\"FOO.UNKNOWN.FOOPLACE.http:        d.appendTransformHistory(\"BAR.UNKNOWN.BARPLACE.http:        d.appendTransformHistory(\"BAR.BURP.BURPPLACE.http:        d.setCreationTimestamp(new Date(0));        final String expected = \"att-4 FOO,BAR>>[UNKNOWN]        final String answer = PayloadUtil.getPayloadDisplayString(d, true);        assertTrue(\"Must be one line string\", answer.indexOf(\"\\n\") == -1);        assertTrue(\"Answer string did not equal the expected string\", expected.compareTo(answer) == 0);    }    @Test    public void testOneLineStringOnTLD() {        final String fn = \"fname\";        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), fn, Form.UNKNOWN);        d.setCreationTimestamp(new Date(0));        d.appendTransformHistory(\"BOGUSKEYELEMENT\");        final String expected = \">>[UNKNOWN]        final String answer = PayloadUtil.getPayloadDisplayString(d, true);        assertTrue(\"Must be one line string\", answer.indexOf(\"\\n\") == -1);        assertTrue(\"Answer string did not equal the expected string\", expected.compareTo(answer) == 0);    }    @Test    public void testMultiLineString() {        final String fn = \"fname\" + Family.SEP + \"4\";        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), fn, Form.UNKNOWN);        d.appendTransformHistory(\"FOO.UNKNOWN.FOOPLACE.http:        d.appendTransformHistory(\"BAR.UNKNOWN.BARPLACE.http:        d.setCreationTimestamp(new Date(0));        final String answer = PayloadUtil.getPayloadDisplayString(d, false);        assertTrue(\"Must be multi-line string\", answer.indexOf(\"\\n\") > -1);        assertTrue(\"Answer did not contain the correct filename\", answer.contains(\"filename: fname-att-4\"));        assertTrue(\"Answer did not contain the creationTimestamp\", answer.contains(\"creationTimestamp: \" + (new Date(0)).toString()));        assertTrue(\"Answer did not contain the currentForms\", answer.contains(\"currentForms: [UNKNOWN]\"));        assertTrue(\"Answer did not contain the correct filetype\", answer.contains(\"filetype: UNKNOWN\"));        assertTrue(\"Answer did not contain the transform history number\", answer.contains(\"transform history (2)\"));        assertTrue(\"Answer did not contain the correct transform history entry\",                answer.contains(\"BAR.UNKNOWN.BARPLACE.http:        assertTrue(\"Answer did not contain the correct transform history entry\",                answer.contains(\"FOO.UNKNOWN.FOOPLACE.http:    }    @Test    public void testNameOfSimpleObject() {        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), \"ab/fn\", Form.UNKNOWN);        assertEquals(\"Name of simple payload is shortname\", \"fn\", PayloadUtil.getName(d));    }    @Test    public void testNameOfCollection() {        final List<IBaseDataObject> list = new ArrayList<IBaseDataObject>();        for (int i = 0; i < 3; i++) {            final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), \"ab/fn\" + i, Form.UNKNOWN);            list.add(d);        }        assertEquals(\"Name of collection payload is shortname with count\", \"fn0(3)\", PayloadUtil.getName(list));    }    @Test    public void testNameOfEmptyCollection() {        final List<IBaseDataObject> list = new ArrayList<IBaseDataObject>();        assertEquals(\"Name of empty collection is class name\", \"java.util.ArrayList\", PayloadUtil.getName(list));    }    @Test    public void testNameOfBadArgument() {        final String s = \"foo\";        assertEquals(\"Name of unexpected argument is class name\", s.getClass().getName(), PayloadUtil.getName(s));    }    @Test    public void testByteSerialization() throws Exception {        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), \"testfile\", Form.UNKNOWN);        final byte[] bytes = PayloadUtil.serializeToBytes(d);        final String s1 = new String(bytes);        assertTrue(\"Serializedion must include data from payload\", s1.indexOf(\"abc\") > -1);    }    @Test    public void testXmlSerizliaztion() throws Exception {        final IBaseDataObject d = DataObjectFactory.getInstance(\"abc\".getBytes(), \"testfile\", Form.UNKNOWN);        d.addAlternateView(\"AV\", \"def\".getBytes());        d.putParameter(\"P\", \"ghi\");        d.addProcessingError(\"jkl\");        d.setHeader(\"mno\".getBytes());        d.setFooter(\"pqr\".getBytes());        d.appendTransformHistory(\"stu\");        final String xml = PayloadUtil.toXmlString(d);        assertTrue(\"Xml serizliazation must include payload data\", xml.indexOf(\"abc\") > -1);        assertTrue(\"Xml serizliazation must include av data\", xml.indexOf(\"def\") > -1);        assertTrue(\"Xml serizliazation must include param data\", xml.indexOf(\"ghi\") > -1);        assertTrue(\"Xml serizliazation must include error data\", xml.indexOf(\"jkl\") > -1);        assertTrue(\"Xml serizliazation must include header data\", xml.indexOf(\"mno\") > -1);        assertTrue(\"Xml serizliazation must include footer data\", xml.indexOf(\"pqr\") > -1);        assertTrue(\"Xml serizliazation must include history data\", xml.indexOf(\"stu\") > -1);        final List<IBaseDataObject> list = new ArrayList<IBaseDataObject>();        list.add(d);        final String lxml = PayloadUtil.toXmlString(list);        assertTrue(\"Xml serizliazation must include payload data\", lxml.indexOf(\"abc\") > -1);        assertTrue(\"Xml serizliazation must include av data\", lxml.indexOf(\"def\") > -1);        assertTrue(\"Xml serizliazation must include param data\", lxml.indexOf(\"ghi\") > -1);        assertTrue(\"Xml serizliazation must include error data\", lxml.indexOf(\"jkl\") > -1);        assertTrue(\"Xml serizliazation must include header data\", lxml.indexOf(\"mno\") > -1);        assertTrue(\"Xml serizliazation must include footer data\", lxml.indexOf(\"pqr\") > -1);        assertTrue(\"Xml serizliazation must include history data\", lxml.indexOf(\"stu\") > -1);    }}"}
{"code": "import me.tongfei.progressbar.ProgressBar;import me.tongfei.progressbar.ProgressBarStyle;import org.ballerinalang.cli.module.util.ErrorUtil;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import java.io.BufferedReader;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import javax.net.ssl.HttpsURLConnection;import javax.ws.rs.core.HttpHeaders;import static org.ballerinalang.cli.module.util.CliModuleConstants.BALLERINA_PLATFORM;import static org.ballerinalang.cli.module.util.CliModuleConstants.BAL_LANG_SPEC_VERSION;import static org.ballerinalang.cli.module.util.CliModuleConstants.IDENTITY;import static org.ballerinalang.cli.module.util.CliModuleConstants.RESOLVED_REQUESTED_URI;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;import static org.ballerinalang.cli.module.util.Utils.getStatusCode;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;public class Pull {    private static final String VERSION_REGEX = \"(\\\\d+\\\\.)(\\\\d+\\\\.)(\\\\d+)\";    private static PrintStream outStream = System.out;    private static DefaultLogFormatter logFormatter = new DefaultLogFormatter();    private Pull() {    }    public static void execute(String url, String modulePathInBaloCache, String moduleNameWithOrg, String proxyHost,            int proxyPort, String proxyUsername, String proxyPassword, String supportedVersionRange, boolean isBuild,            boolean isNightlyBuild, String langSpecVersion, String platform) {        if (isBuild) {            logFormatter = new BuildLogFormatter();        }        HttpsURLConnection conn = null;        try {            conn = createHttpsUrlConnection(convertToUrl(url + supportedVersionRange), proxyHost, proxyPort,                                            proxyUsername, proxyPassword);            conn.setInstanceFollowRedirects(false);            setRequestMethod(conn, Utils.RequestMethod.GET);            conn.setRequestProperty(BALLERINA_PLATFORM, platform);            conn.setRequestProperty(BAL_LANG_SPEC_VERSION, langSpecVersion);            conn.setRequestProperty(HttpHeaders.ACCEPT_ENCODING, IDENTITY);            boolean redirect = false;            if (getStatusCode(conn) == HttpsURLConnection.HTTP_MOVED_TEMP) {                redirect = true;            } else {                handleErrorResponse(conn, url, moduleNameWithOrg);            }            if (redirect) {                String newUrl = conn.getHeaderField(HttpHeaders.LOCATION);                String contentDisposition = conn.getHeaderField(HttpHeaders.CONTENT_DISPOSITION);                conn = createHttpsUrlConnection(convertToUrl(newUrl), proxyHost, proxyPort, proxyUsername,                                                proxyPassword);                conn.setRequestProperty(HttpHeaders.CONTENT_DISPOSITION, contentDisposition);                createBaloInHomeRepo(conn, modulePathInBaloCache, moduleNameWithOrg, isNightlyBuild, newUrl,                        contentDisposition);            }        } catch (Exception e) {            throw ErrorUtil.createCommandException(e.getMessage());        } finally {            if (conn != null) {                conn.disconnect();            }            Authenticator.setDefault(null);        }    }    private static void createBaloInHomeRepo(HttpsURLConnection conn, String modulePathInBaloCache,            String moduleNameWithOrg, boolean isNightlyBuild, String newUrl, String contentDisposition) {        long responseContentLength = conn.getContentLengthLong();        if (responseContentLength <= 0) {            createError(\"invalid response from the server, please try again\");        }        String resolvedURI = conn.getHeaderField(RESOLVED_REQUESTED_URI);        if (resolvedURI == null || resolvedURI.equals(\"\")) {            resolvedURI = newUrl;        }        String[] uriParts = resolvedURI.split(\"/\");        String moduleVersion = uriParts[uriParts.length - 3];        validateModuleVersion(moduleVersion);        String baloFile = getBaloFileName(contentDisposition, uriParts[uriParts.length - 1]);        Path baloCacheWithModulePath = Paths.get(modulePathInBaloCache, moduleVersion);        Path baloPath = Paths.get(baloCacheWithModulePath.toString(), baloFile);        if (baloPath.toFile().exists()) {            createError(\"module already exists in the home repository: \" + baloPath.toString());        }        createBaloFileDirectory(baloCacheWithModulePath);        writeBaloFile(conn, baloPath, moduleNameWithOrg + \":\" + moduleVersion, responseContentLength);        handleNightlyBuild(isNightlyBuild, baloCacheWithModulePath);    }    private static void writeBaloFile(HttpsURLConnection conn, Path baloPath, String fullModuleName,            long resContentLength) {        try (InputStream inputStream = conn.getInputStream();                FileOutputStream outputStream = new FileOutputStream(baloPath.toString())) {            writeAndHandleProgress(inputStream, outputStream, resContentLength / 1024, fullModuleName);        } catch (IOException e) {            createError(\"error occurred copying the balo file: \" + e.getMessage());        }    }    private static void writeAndHandleProgress(InputStream inputStream, FileOutputStream outputStream,            long totalSizeInKB, String fullModuleName) {        int count;        byte[] buffer = new byte[1024];        try (ProgressBar progressBar = new ProgressBar(fullModuleName + \" [central.ballerina.io -> home repo] \",                totalSizeInKB, 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1)) {            while ((count = inputStream.read(buffer)) > 0) {                outputStream.write(buffer, 0, count);                progressBar.step();            }        } catch (IOException e) {            outStream.println(logFormatter.formatLog(fullModuleName + \"pulling the module from central failed\"));        } finally {            outStream.println(logFormatter.formatLog(fullModuleName + \" pulled from central successfully\"));        }    }    private static void handleNightlyBuild(boolean isNightlyBuild, Path baloCacheWithModulePath) {        if (isNightlyBuild) {            Path nightlyBuildMetaFile = Paths.get(baloCacheWithModulePath.toString(), \"nightly.build\");            if (!nightlyBuildMetaFile.toFile().exists()) {                createNightlyBuildMetaFile(nightlyBuildMetaFile);            }        }    }    private static void validateModuleVersion(String moduleVersion) {        if (!moduleVersion.matches(VERSION_REGEX)) {            createError(\"module version could not be detected\");        }    }    private static void createNightlyBuildMetaFile(Path nightlyBuildMetaFilePath) {        try {            Files.createFile(nightlyBuildMetaFilePath);        } catch (Exception e) {            createError(\"error occurred while creating nightly.build file.\");        }    }    private static void createBaloFileDirectory(Path fullPathToStoreBalo) {        try {            Files.createDirectory(fullPathToStoreBalo);        } catch (IOException e) {            createError(\"error creating directory for balo file\");        }    }    private static void handleErrorResponse(HttpsURLConnection conn, String url, String moduleFullName) {        try (BufferedReader reader = new BufferedReader(                new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {            StringBuilder result = new StringBuilder();            String line;            while ((line = reader.readLine()) != null) {                result.append(line);            }            MapValue payload = (MapValue) JSONParser.parse(result.toString());            createError(\"error: \" + payload.getStringValue(\"message\"));        } catch (IOException e) {            createError(\"failed to pull the module '\" + moduleFullName + \"' from the remote repository '\" + url + \"'\");        }    }    private static void createError(String errMessage) {        throw ErrorUtil.createCommandException(logFormatter.formatLog(errMessage));    }    private static String getBaloFileName(String contentDisposition, String baloFile) {        if (contentDisposition != null && !contentDisposition.equals(\"\")) {            return contentDisposition.substring(\"attachment; filename=\".length());        } else {            return baloFile;        }    }}class DefaultLogFormatter {    String formatLog(String msg) {        return msg;    }}class BuildLogFormatter extends DefaultLogFormatter {    @Override String formatLog(String msg) {        return \"\\t\" + msg;    }}", "nl": "import me.tongfei.progressbar.ProgressBar;import me.tongfei.progressbar.ProgressBarStyle;import org.ballerinalang.cli.module.util.ErrorUtil;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import java.io.BufferedReader;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.net.HttpURLConnection;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import javax.ws.rs.core.HttpHeaders;import static org.ballerinalang.cli.module.util.CliModuleConstants.BALLERINA_PLATFORM;import static org.ballerinalang.cli.module.util.CliModuleConstants.BAL_LANG_SPEC_VERSION;import static org.ballerinalang.cli.module.util.CliModuleConstants.IDENTITY;import static org.ballerinalang.cli.module.util.CliModuleConstants.RESOLVED_REQUESTED_URI;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;import static org.ballerinalang.cli.module.util.Utils.getStatusCode;import static org.ballerinalang.cli.module.util.Utils.initializeSsl;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;public class Pull {    private static final String VERSION_REGEX = \"(\\\\d+\\\\.)(\\\\d+\\\\.)(\\\\d+)\";    private static PrintStream outStream = System.out;    private static DefaultLogFormatter logFormatter = new DefaultLogFormatter();    private Pull() {    }    public static void execute(String url, String modulePathInBaloCache, String moduleNameWithOrg, String proxyHost,            int proxyPort, String proxyUsername, String proxyPassword, String supportedVersionRange, boolean isBuild,            boolean isNightlyBuild, String langSpecVersion, String platform) {        if (isBuild) {            logFormatter = new BuildLogFormatter();        }        HttpURLConnection conn = null;        try {            initializeSsl();            conn = createHttpUrlConnection(convertToUrl(url + supportedVersionRange), proxyHost, proxyPort,                    proxyUsername, proxyPassword);            conn.setInstanceFollowRedirects(false);            setRequestMethod(conn, Utils.RequestMethod.GET);            conn.setRequestProperty(BALLERINA_PLATFORM, platform);            conn.setRequestProperty(BAL_LANG_SPEC_VERSION, langSpecVersion);            conn.setRequestProperty(HttpHeaders.ACCEPT_ENCODING, IDENTITY);            boolean redirect = false;            if (getStatusCode(conn) == HttpURLConnection.HTTP_MOVED_TEMP) {                redirect = true;            } else {                handleErrorResponse(conn, url, moduleNameWithOrg);            }            if (redirect) {                String newUrl = conn.getHeaderField(HttpHeaders.LOCATION);                String contentDisposition = conn.getHeaderField(HttpHeaders.CONTENT_DISPOSITION);                conn = createHttpUrlConnection(convertToUrl(newUrl), proxyHost, proxyPort, proxyUsername,                        proxyPassword);                conn.setRequestProperty(HttpHeaders.CONTENT_DISPOSITION, contentDisposition);                createBaloInHomeRepo(conn, modulePathInBaloCache, moduleNameWithOrg, isNightlyBuild, newUrl,                        contentDisposition);            }        } catch (Exception e) {            throw ErrorUtil.createCommandException(e.getMessage());        } finally {            if (conn != null) {                conn.disconnect();            }            Authenticator.setDefault(null);        }    }    private static void createBaloInHomeRepo(HttpURLConnection conn, String modulePathInBaloCache,            String moduleNameWithOrg, boolean isNightlyBuild, String newUrl, String contentDisposition) {        long responseContentLength = conn.getContentLengthLong();        if (responseContentLength <= 0) {            createError(\"invalid response from the server, please try again\");        }        String resolvedURI = conn.getHeaderField(RESOLVED_REQUESTED_URI);        if (resolvedURI == null || resolvedURI.equals(\"\")) {            resolvedURI = newUrl;        }        String[] uriParts = resolvedURI.split(\"/\");        String moduleVersion = uriParts[uriParts.length - 3];        validateModuleVersion(moduleVersion);        String baloFile = getBaloFileName(contentDisposition, uriParts[uriParts.length - 1]);        Path baloCacheWithModulePath = Paths.get(modulePathInBaloCache, moduleVersion);        Path baloPath = Paths.get(baloCacheWithModulePath.toString(), baloFile);        if (baloPath.toFile().exists()) {            createError(\"module already exists in the home repository: \" + baloPath.toString());        }        createBaloFileDirectory(baloCacheWithModulePath);        writeBaloFile(conn, baloPath, moduleNameWithOrg + \":\" + moduleVersion, responseContentLength);        handleNightlyBuild(isNightlyBuild, baloCacheWithModulePath);    }    private static void writeBaloFile(HttpURLConnection conn, Path baloPath, String fullModuleName,            long resContentLength) {        try (InputStream inputStream = conn.getInputStream();                FileOutputStream outputStream = new FileOutputStream(baloPath.toString())) {            writeAndHandleProgress(inputStream, outputStream, resContentLength / 1024, fullModuleName);        } catch (IOException e) {            createError(\"error occurred copying the balo file: \" + e.getMessage());        }    }    private static void writeAndHandleProgress(InputStream inputStream, FileOutputStream outputStream,            long totalSizeInKB, String fullModuleName) {        int count;        byte[] buffer = new byte[1024];        try (ProgressBar progressBar = new ProgressBar(fullModuleName + \" [central.ballerina.io -> home repo] \",                totalSizeInKB, 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1)) {            while ((count = inputStream.read(buffer)) > 0) {                outputStream.write(buffer, 0, count);                progressBar.step();            }        } catch (IOException e) {            outStream.println(logFormatter.formatLog(fullModuleName + \"pulling the module from central failed\"));        } finally {            outStream.println(logFormatter.formatLog(fullModuleName + \" pulled from central successfully\"));        }    }    private static void handleNightlyBuild(boolean isNightlyBuild, Path baloCacheWithModulePath) {        if (isNightlyBuild) {            Path nightlyBuildMetaFile = Paths.get(baloCacheWithModulePath.toString(), \"nightly.build\");            if (!nightlyBuildMetaFile.toFile().exists()) {                createNightlyBuildMetaFile(nightlyBuildMetaFile);            }        }    }    private static void validateModuleVersion(String moduleVersion) {        if (!moduleVersion.matches(VERSION_REGEX)) {            createError(\"module version could not be detected\");        }    }    private static void createNightlyBuildMetaFile(Path nightlyBuildMetaFilePath) {        try {            Files.createFile(nightlyBuildMetaFilePath);        } catch (Exception e) {            createError(\"error occurred while creating nightly.build file.\");        }    }    private static void createBaloFileDirectory(Path fullPathToStoreBalo) {        try {            Files.createDirectory(fullPathToStoreBalo);        } catch (IOException e) {            createError(\"error creating directory for balo file\");        }    }    private static void handleErrorResponse(HttpURLConnection conn, String url, String moduleFullName) {        try (BufferedReader reader = new BufferedReader(                new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {            StringBuilder result = new StringBuilder();            String line;            while ((line = reader.readLine()) != null) {                result.append(line);            }            MapValue payload = (MapValue) JSONParser.parse(result.toString());            createError(\"error: \" + payload.getStringValue(\"message\"));        } catch (IOException e) {            createError(\"failed to pull the module '\" + moduleFullName + \"' from the remote repository '\" + url + \"'\");        }    }    private static void createError(String errMessage) {        throw ErrorUtil.createCommandException(logFormatter.formatLog(errMessage));    }    private static String getBaloFileName(String contentDisposition, String baloFile) {        if (contentDisposition != null && !contentDisposition.equals(\"\")) {            return contentDisposition.substring(\"attachment; filename=\".length());        } else {            return baloFile;        }    }}class DefaultLogFormatter {    String formatLog(String msg) {        return msg;    }}class BuildLogFormatter extends DefaultLogFormatter {    @Override String formatLog(String msg) {        return \"\\t\" + msg;    }}"}
{"code": "import me.tongfei.progressbar.ProgressBar;import me.tongfei.progressbar.ProgressBarStyle;import org.ballerinalang.cli.module.util.ErrorUtil;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import java.io.BufferedReader;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import javax.net.ssl.HttpsURLConnection;import javax.ws.rs.core.HttpHeaders;import javax.ws.rs.core.MediaType;import static org.ballerinalang.cli.module.util.CliModuleConstants.PUSH_ORGANIZATION;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;import static org.ballerinalang.cli.module.util.Utils.getStatusCode;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;public class Push {    private static PrintStream errStream = System.err;    private static PrintStream outStream = System.out;    private static final int NO_OF_BYTES = 64;    private static final int BUFFER_SIZE = 1024 * NO_OF_BYTES;    private Push() {    }    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,            String accessToken, String orgName, String moduleName, String version, Path baloPath) {        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,                                                           proxyPassword);        conn.setInstanceFollowRedirects(false);        setRequestMethod(conn, Utils.RequestMethod.POST);        conn.setRequestProperty(HttpHeaders.AUTHORIZATION, \"Bearer \" + accessToken);        conn.setRequestProperty(PUSH_ORGANIZATION, orgName);        conn.setRequestProperty(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM);        conn.setDoOutput(true);        conn.setChunkedStreamingMode(BUFFER_SIZE);        try (DataOutputStream outputStream = new DataOutputStream(conn.getOutputStream())) {            byte[] buffer = new byte[BUFFER_SIZE];            int count;            try (ProgressBar progressBar = new ProgressBar(                    orgName + \"/\" + moduleName + \":\" + version + \" [project repo -> central]\",                    getTotalFileSizeInKB(baloPath), 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1);                    FileInputStream fis = new FileInputStream(baloPath.toFile())) {                while ((count = fis.read(buffer)) > 0) {                    outputStream.write(buffer, 0, count);                    outputStream.flush();                    progressBar.stepBy((long) NO_OF_BYTES);                }            }        } catch (IOException e) {            throw ErrorUtil.createCommandException(\"error occurred while uploading balo to central: \" + e.getMessage());        }        handleResponse(conn, orgName, moduleName, version);        Authenticator.setDefault(null);    }    private static void handleResponse(HttpsURLConnection conn, String orgName, String moduleName, String version) {        try {            int statusCode = getStatusCode(conn);            if (statusCode == HttpsURLConnection.HTTP_OK) {                outStream.println(orgName + \"/\" + moduleName + \":\" + version + \" pushed to central successfully\");            } else if (statusCode == HttpsURLConnection.HTTP_UNAUTHORIZED) {                errStream.println(\"unauthorized access token for organization: \" + orgName);            } else if (statusCode == HttpsURLConnection.HTTP_BAD_REQUEST) {                try (BufferedReader reader = new BufferedReader(                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {                    StringBuilder result = new StringBuilder();                    String line;                    while ((line = reader.readLine()) != null) {                        result.append(line);                    }                    MapValue payload = (MapValue) JSONParser.parse(result.toString());                    String message = payload.getStringValue(\"message\");                    if (message.contains(\"module md file cannot be empty\")) {                        errStream.println(message);                    } else {                        throw ErrorUtil.createCommandException(message);                    }                } catch (IOException e) {                    throw ErrorUtil.createCommandException(                            \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version                                    + \"' to the remote repository '\" + conn.getURL() + \"'\");                }            } else {                throw ErrorUtil.createCommandException(                        \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version                                + \"' to the remote repository '\" + conn.getURL() + \"'\");            }        } finally {            conn.disconnect();        }    }    private static long getTotalFileSizeInKB(Path filePath) {        byte[] baloContent;        try {            baloContent = Files.readAllBytes(filePath);            return baloContent.length / 1024;        } catch (IOException e) {            throw ErrorUtil.createCommandException(\"cannot read the balo content\");        }    }}", "nl": "import me.tongfei.progressbar.ProgressBar;import me.tongfei.progressbar.ProgressBarStyle;import org.ballerinalang.cli.module.util.ErrorUtil;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import java.io.BufferedReader;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.net.HttpURLConnection;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import javax.ws.rs.core.HttpHeaders;import javax.ws.rs.core.MediaType;import static org.ballerinalang.cli.module.util.CliModuleConstants.PUSH_ORGANIZATION;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;import static org.ballerinalang.cli.module.util.Utils.getStatusCode;import static org.ballerinalang.cli.module.util.Utils.initializeSsl;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;public class Push {    private static PrintStream errStream = System.err;    private static PrintStream outStream = System.out;    private static final int NO_OF_BYTES = 64;    private static final int BUFFER_SIZE = 1024 * NO_OF_BYTES;    private Push() {    }    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,            String accessToken, String orgName, String moduleName, String version, Path baloPath) {        initializeSsl();        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,                proxyPassword);        conn.setInstanceFollowRedirects(false);        setRequestMethod(conn, Utils.RequestMethod.POST);        conn.setRequestProperty(HttpHeaders.AUTHORIZATION, \"Bearer \" + accessToken);        conn.setRequestProperty(PUSH_ORGANIZATION, orgName);        conn.setRequestProperty(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM);        conn.setDoOutput(true);        conn.setChunkedStreamingMode(BUFFER_SIZE);        try (DataOutputStream outputStream = new DataOutputStream(conn.getOutputStream())) {            byte[] buffer = new byte[BUFFER_SIZE];            int count;            try (ProgressBar progressBar = new ProgressBar(                    orgName + \"/\" + moduleName + \":\" + version + \" [project repo -> central]\",                    getTotalFileSizeInKB(baloPath), 1000, outStream, ProgressBarStyle.ASCII, \" KB\", 1);                    FileInputStream fis = new FileInputStream(baloPath.toFile())) {                while ((count = fis.read(buffer)) > 0) {                    outputStream.write(buffer, 0, count);                    outputStream.flush();                    progressBar.stepBy((long) NO_OF_BYTES);                }            }        } catch (IOException e) {            throw ErrorUtil.createCommandException(\"error occurred while uploading balo to central: \" + e.getMessage());        }        handleResponse(conn, orgName, moduleName, version);        Authenticator.setDefault(null);    }    private static void handleResponse(HttpURLConnection conn, String orgName, String moduleName, String version) {        try {            int statusCode = getStatusCode(conn);            if (statusCode == HttpURLConnection.HTTP_OK) {                outStream.println(orgName + \"/\" + moduleName + \":\" + version + \" pushed to central successfully\");            } else if (statusCode == HttpURLConnection.HTTP_UNAUTHORIZED) {                errStream.println(\"unauthorized access token for organization: \" + orgName);            } else if (statusCode == HttpURLConnection.HTTP_BAD_REQUEST) {                try (BufferedReader reader = new BufferedReader(                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {                    StringBuilder result = new StringBuilder();                    String line;                    while ((line = reader.readLine()) != null) {                        result.append(line);                    }                    MapValue payload = (MapValue) JSONParser.parse(result.toString());                    String message = payload.getStringValue(\"message\");                    if (message.contains(\"module md file cannot be empty\")) {                        errStream.println(message);                    } else {                        throw ErrorUtil.createCommandException(message);                    }                } catch (IOException e) {                    throw ErrorUtil.createCommandException(                            \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version                                    + \"' to the remote repository '\" + conn.getURL() + \"'\");                }            } else {                throw ErrorUtil.createCommandException(                        \"failed to push the module '\" + orgName + \"/\" + moduleName + \":\" + version                                + \"' to the remote repository '\" + conn.getURL() + \"'\");            }        } finally {            conn.disconnect();        }    }    private static long getTotalFileSizeInKB(Path filePath) {        byte[] baloContent;        try {            baloContent = Files.readAllBytes(filePath);            return baloContent.length / 1024;        } catch (IOException e) {            throw ErrorUtil.createCommandException(\"cannot read the balo content\");        }    }}"}
{"code": "import org.ballerinalang.cli.module.util.ErrorUtil;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.ArrayValue;import org.ballerinalang.jvm.values.MapValue;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.nio.charset.Charset;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import javax.net.ssl.HttpsURLConnection;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;import static org.ballerinalang.cli.module.util.Utils.getStatusCode;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;public class Search {    private static PrintStream outStream = System.out;    private Search() {    }    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,            String terminalWidth) {        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,                                                           proxyPassword);        conn.setInstanceFollowRedirects(false);        setRequestMethod(conn, Utils.RequestMethod.GET);        handleResponse(conn, getStatusCode(conn), terminalWidth);        Authenticator.setDefault(null);    }    private static void handleResponse(HttpsURLConnection conn, int statusCode, String terminalWidth) {        try {            MapValue payload;            if (statusCode == HttpsURLConnection.HTTP_OK) {                try (BufferedReader reader = new BufferedReader(                        new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {                    StringBuilder result = new StringBuilder();                    String line;                    while ((line = reader.readLine()) != null) {                        result.append(line);                    }                    payload = (MapValue) JSONParser.parse(result.toString());                } catch (IOException e) {                    throw ErrorUtil.createCommandException(e.getMessage());                }                if (payload.getIntValue(\"count\") > 0) {                    ArrayValue modules = payload.getArrayValue(\"modules\");                    printModules(modules, terminalWidth);                } else {                    outStream.println(\"no modules found\");                }            } else {                StringBuilder result = new StringBuilder();                try (BufferedReader reader = new BufferedReader(                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {                    String line;                    while ((line = reader.readLine()) != null) {                        result.append(line);                    }                } catch (IOException e) {                    throw ErrorUtil.createCommandException(e.getMessage());                }                payload = (MapValue) JSONParser.parse(result.toString());                throw ErrorUtil.createCommandException(payload.getStringValue(\"message\"));            }        } finally {            conn.disconnect();        }    }    public static void printModules(ArrayValue modules, String terminalWidth) {        int rightMargin = 3;        int width = Integer.parseInt(terminalWidth) - rightMargin;        int dateColWidth = 15;        int versionColWidth = 8;        int authorsColWidth = 15;        double nameColFactor = 9.0;        double descColFactor = 16.0;        int additionalSpace = 7;        double remainingWidth = (double) width - (dateColWidth + versionColWidth + additionalSpace);        int nameColWidth = (int) Math.round(remainingWidth * (nameColFactor / (nameColFactor + descColFactor)));        int descColWidth = (int) Math.round(remainingWidth * (descColFactor / (nameColFactor + descColFactor)));        int minDescColWidth = 60;        printTitle();        printTableHeader(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);        int i = 0;        while (i < modules.size()) {            printModule((MapValue) modules.get(i), dateColWidth, versionColWidth, authorsColWidth, nameColWidth,                    descColWidth, minDescColWidth);            i = i + 1;            outStream.println();        }        outStream.println();        outStream.println(modules.size() + \" modules found\");    }    private static void printModule(MapValue module, int dateColWidth, int versionColWidth, int authorsColWidth,            int nameColWidth, int descColWidth, int minDescColWidth) {        String orgName = module.getStringValue(\"orgName\");        String packageName = module.getStringValue(\"name\");        printInCLI(\"|\" + orgName + \"/\" + packageName, nameColWidth);        String summary = module.getStringValue(\"summary\");        if (descColWidth >= minDescColWidth) {            printInCLI(summary, descColWidth - authorsColWidth);            String authors = \"\";            ArrayValue authorsArr = module.getArrayValue(\"authors\");            if (authorsArr.size() > 0) {                for (int j = 0; j < authorsArr.size(); j++) {                    if (j == 0) {                        authors = (String) authorsArr.get(j);                    } else if (j == authorsArr.size() - 1) {                        authors = (String) authorsArr.get(j);                    } else {                        authors = \", \" + authorsArr.get(j);                    }                }            }            printInCLI(authors, authorsColWidth);        } else {            printInCLI(summary, descColWidth);        }        long createTimeJson = module.getIntValue(\"createdDate\");        printInCLI(getDateCreated(createTimeJson), dateColWidth);        String packageVersion = module.getStringValue(\"version\");        printInCLI(packageVersion, versionColWidth);    }    private static void printTitle() {        outStream.println();        outStream.println(\"Ballerina Central\");        outStream.println(\"=================\");        outStream.println();    }    private static void printInCLI(String element, int charactersAllowed) {        int lengthOfElement = element.length();        if (lengthOfElement > charactersAllowed || lengthOfElement == charactersAllowed) {            int margin = 3;            String trimmedElement = element.substring(0, charactersAllowed - margin) + \"...\";            outStream.print(trimmedElement + \" |\");        } else {            printCharacter(element, charactersAllowed, \" \", false);        }    }    private static void printCharacter(String element, int charactersAllowed, String separator, boolean isDashElement) {        int lengthOfElement = element.length();        StringBuilder print = new StringBuilder(element);        int i = 0;        while (i < charactersAllowed - lengthOfElement) {            print.append(separator);            i = i + 1;        }        if (isDashElement) {            outStream.print(print + \"-|\");        } else {            outStream.print(print + \" |\");        }    }    private static String getDateCreated(long timeInMillis) {        Date date = new Date(timeInMillis);        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd-E\");        return df.format(date);    }    private static void printTableHeader(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,            int minDescColWidth, int authorsColWidth) {        printHeadingRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);        printDashRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);    }    private static void printHeadingRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,            int minDescColWidth, int authorsColWidth) {        printInCLI(\"|NAME\", nameColWidth);        if (descColWidth >= minDescColWidth) {            printInCLI(\"DESCRIPTION\", descColWidth - authorsColWidth);            printInCLI(\"AUTHOR\", authorsColWidth);        } else {            printInCLI(\"DESCRIPTION\", descColWidth);        }        printInCLI(\"DATE\", dateColWidth);        printInCLI(\"VERSION\", versionColWidth);        outStream.println();    }    private static void printDashRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,            int minDescColWidth, int authorsColWidth) {        printCharacter(\"|-\", nameColWidth, \"-\", true);        if (descColWidth >= minDescColWidth) {            printCharacter(\"-\", descColWidth - authorsColWidth, \"-\", true);            printCharacter(\"-\", authorsColWidth, \"-\", true);        } else {            printCharacter(\"-\", descColWidth, \"-\", true);        }        printCharacter(\"-\", dateColWidth, \"-\", true);        printCharacter(\"-\", versionColWidth, \"-\", true);        outStream.println();    }}", "nl": "import org.ballerinalang.cli.module.util.ErrorUtil;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.ArrayValue;import org.ballerinalang.jvm.values.MapValue;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.net.HttpURLConnection;import java.nio.charset.Charset;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;import static org.ballerinalang.cli.module.util.Utils.getStatusCode;import static org.ballerinalang.cli.module.util.Utils.initializeSsl;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;public class Search {    private static PrintStream outStream = System.out;    private Search() {    }    public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,            String terminalWidth) {        initializeSsl();        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,                proxyPassword);        conn.setInstanceFollowRedirects(false);        setRequestMethod(conn, Utils.RequestMethod.GET);        handleResponse(conn, getStatusCode(conn), terminalWidth);        Authenticator.setDefault(null);    }    private static void handleResponse(HttpURLConnection conn, int statusCode, String terminalWidth) {        try {            MapValue payload;            if (statusCode == HttpURLConnection.HTTP_OK) {                try (BufferedReader reader = new BufferedReader(                        new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {                    StringBuilder result = new StringBuilder();                    String line;                    while ((line = reader.readLine()) != null) {                        result.append(line);                    }                    payload = (MapValue) JSONParser.parse(result.toString());                } catch (IOException e) {                    throw ErrorUtil.createCommandException(e.getMessage());                }                if (payload.getIntValue(\"count\") > 0) {                    ArrayValue modules = payload.getArrayValue(\"modules\");                    printModules(modules, terminalWidth);                } else {                    outStream.println(\"no modules found\");                }            } else {                StringBuilder result = new StringBuilder();                try (BufferedReader reader = new BufferedReader(                        new InputStreamReader(conn.getErrorStream(), Charset.defaultCharset()))) {                    String line;                    while ((line = reader.readLine()) != null) {                        result.append(line);                    }                } catch (IOException e) {                    throw ErrorUtil.createCommandException(e.getMessage());                }                payload = (MapValue) JSONParser.parse(result.toString());                throw ErrorUtil.createCommandException(payload.getStringValue(\"message\"));            }        } finally {            conn.disconnect();        }    }    public static void printModules(ArrayValue modules, String terminalWidth) {        int rightMargin = 3;        int width = Integer.parseInt(terminalWidth) - rightMargin;        int dateColWidth = 15;        int versionColWidth = 8;        int authorsColWidth = 15;        double nameColFactor = 9.0;        double descColFactor = 16.0;        int additionalSpace = 7;        double remainingWidth = (double) width - (dateColWidth + versionColWidth + additionalSpace);        int nameColWidth = (int) Math.round(remainingWidth * (nameColFactor / (nameColFactor + descColFactor)));        int descColWidth = (int) Math.round(remainingWidth * (descColFactor / (nameColFactor + descColFactor)));        int minDescColWidth = 60;        printTitle();        printTableHeader(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);        int i = 0;        while (i < modules.size()) {            printModule((MapValue) modules.get(i), dateColWidth, versionColWidth, authorsColWidth, nameColWidth,                    descColWidth, minDescColWidth);            i = i + 1;            outStream.println();        }        outStream.println();        outStream.println(modules.size() + \" modules found\");    }    private static void printModule(MapValue module, int dateColWidth, int versionColWidth, int authorsColWidth,            int nameColWidth, int descColWidth, int minDescColWidth) {        String orgName = module.getStringValue(\"orgName\");        String packageName = module.getStringValue(\"name\");        printInCLI(\"|\" + orgName + \"/\" + packageName, nameColWidth);        String summary = module.getStringValue(\"summary\");        if (descColWidth >= minDescColWidth) {            printInCLI(summary, descColWidth - authorsColWidth);            String authors = \"\";            ArrayValue authorsArr = module.getArrayValue(\"authors\");            if (authorsArr.size() > 0) {                for (int j = 0; j < authorsArr.size(); j++) {                    if (j == 0) {                        authors = (String) authorsArr.get(j);                    } else if (j == authorsArr.size() - 1) {                        authors = (String) authorsArr.get(j);                    } else {                        authors = \", \" + authorsArr.get(j);                    }                }            }            printInCLI(authors, authorsColWidth);        } else {            printInCLI(summary, descColWidth);        }        long createTimeJson = module.getIntValue(\"createdDate\");        printInCLI(getDateCreated(createTimeJson), dateColWidth);        String packageVersion = module.getStringValue(\"version\");        printInCLI(packageVersion, versionColWidth);    }    private static void printTitle() {        outStream.println();        outStream.println(\"Ballerina Central\");        outStream.println(\"=================\");        outStream.println();    }    private static void printInCLI(String element, int charactersAllowed) {        int lengthOfElement = element.length();        if (lengthOfElement > charactersAllowed || lengthOfElement == charactersAllowed) {            int margin = 3;            String trimmedElement = element.substring(0, charactersAllowed - margin) + \"...\";            outStream.print(trimmedElement + \" |\");        } else {            printCharacter(element, charactersAllowed, \" \", false);        }    }    private static void printCharacter(String element, int charactersAllowed, String separator, boolean isDashElement) {        int lengthOfElement = element.length();        StringBuilder print = new StringBuilder(element);        int i = 0;        while (i < charactersAllowed - lengthOfElement) {            print.append(separator);            i = i + 1;        }        if (isDashElement) {            outStream.print(print + \"-|\");        } else {            outStream.print(print + \" |\");        }    }    private static String getDateCreated(long timeInMillis) {        Date date = new Date(timeInMillis);        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd-E\");        return df.format(date);    }    private static void printTableHeader(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,            int minDescColWidth, int authorsColWidth) {        printHeadingRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);        printDashRow(dateColWidth, versionColWidth, nameColWidth, descColWidth, minDescColWidth, authorsColWidth);    }    private static void printHeadingRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,            int minDescColWidth, int authorsColWidth) {        printInCLI(\"|NAME\", nameColWidth);        if (descColWidth >= minDescColWidth) {            printInCLI(\"DESCRIPTION\", descColWidth - authorsColWidth);            printInCLI(\"AUTHOR\", authorsColWidth);        } else {            printInCLI(\"DESCRIPTION\", descColWidth);        }        printInCLI(\"DATE\", dateColWidth);        printInCLI(\"VERSION\", versionColWidth);        outStream.println();    }    private static void printDashRow(int dateColWidth, int versionColWidth, int nameColWidth, int descColWidth,            int minDescColWidth, int authorsColWidth) {        printCharacter(\"|-\", nameColWidth, \"-\", true);        if (descColWidth >= minDescColWidth) {            printCharacter(\"-\", descColWidth - authorsColWidth, \"-\", true);            printCharacter(\"-\", authorsColWidth, \"-\", true);        } else {            printCharacter(\"-\", descColWidth, \"-\", true);        }        printCharacter(\"-\", dateColWidth, \"-\", true);        printCharacter(\"-\", versionColWidth, \"-\", true);        outStream.println();    }}"}
{"code": "import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import org.ballerinalang.cli.module.util.ErrorUtil;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintStream;import java.net.InetSocketAddress;import java.nio.charset.StandardCharsets;import java.nio.file.Paths;import java.util.Collections;import javax.net.ssl.HttpsURLConnection;import javax.ws.rs.core.HttpHeaders;import static org.ballerinalang.cli.module.util.CliModuleConstants.SETTINGS_TOML_FILE;public class TokenUpdater {    private static PrintStream errStream = System.err;    private static PrintStream outStream = System.out;    private TokenUpdater() {    }    public static void execute(String settingsTomlFilePath) {        HttpServer server;        try {            server = HttpServer.create(new InetSocketAddress(9295), 0);        } catch (IOException e) {            throw ErrorUtil.createCommandException(\"error occurred while creating the server: \" + e.getMessage() +                    \"Access token is missing in \" + settingsTomlFilePath +                    \"\\nAuto update failed. Please visit https:                    settingsTomlFilePath + \" file.\");        }        server.createContext(\"/update-settings\", new TokenUpdateHandler());        server.setExecutor(null);         server.start();    }    static class TokenUpdateHandler implements HttpHandler {        @Override public void handle(HttpExchange httpExchange) {            String token = getToken(httpExchange.getRequestURI().getPath());            String currentUsersHomeDir = System.getProperty(\"user.home\");            String settingsTomlPath = String.valueOf(Paths.get(currentUsersHomeDir, \".ballerina\", SETTINGS_TOML_FILE));            FileOutputStream outputStream = null;            try {                outputStream = new FileOutputStream(settingsTomlPath);                String str = \"[central]\\naccesstoken=\\\"\" + token + \"\\\"\";                outputStream.write(str.getBytes(StandardCharsets.UTF_8));            } catch (FileNotFoundException e) {                throw ErrorUtil.createCommandException(\"Settings.toml file could not be found: \" + settingsTomlPath);            } catch (IOException e) {                throw ErrorUtil.createCommandException(                        \"error occurred while writing to the Settings.toml file: \" + e.getMessage());            } finally {                try {                    if (outputStream != null) {                        outputStream.close();                    }                } catch (IOException e) {                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());                }            }            outStream.println(\"token updated\");            OutputStream os = null;            try {                String response = \"<svg xmlns=\\\"http:                httpExchange.getResponseHeaders()                        .put(HttpHeaders.CONTENT_TYPE, Collections.singletonList(\"image/svg+xml\"));                httpExchange.sendResponseHeaders(HttpsURLConnection.HTTP_OK,                                                 response.getBytes(StandardCharsets.UTF_8).length);                os = httpExchange.getResponseBody();                os.write(response.getBytes(StandardCharsets.UTF_8));            } catch (IOException e) {                throw ErrorUtil                        .createCommandException(\"error occurred while generating the response: \" + e.getMessage());            } finally {                try {                    if (os != null) {                        os.close();                    }                } catch (IOException e) {                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());                }            }        }        private static String getToken(String uri) {            String[] uriParts = uri.split(\"/\");            return uriParts[uriParts.length - 1];        }    }}", "nl": "import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import org.ballerinalang.cli.module.util.ErrorUtil;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.io.PrintStream;import java.net.HttpURLConnection;import java.net.InetSocketAddress;import java.nio.charset.StandardCharsets;import java.nio.file.Paths;import java.util.Collections;import javax.ws.rs.core.HttpHeaders;import static org.ballerinalang.cli.module.util.CliModuleConstants.SETTINGS_TOML_FILE;public class TokenUpdater {    private static PrintStream errStream = System.err;    private static PrintStream outStream = System.out;    private TokenUpdater() {    }    public static void execute(String settingsTomlFilePath) {        HttpServer server;        try {            server = HttpServer.create(new InetSocketAddress(9295), 0);        } catch (IOException e) {            throw ErrorUtil.createCommandException(\"error occurred while creating the server: \" + e.getMessage() +                    \"Access token is missing in \" + settingsTomlFilePath +                    \"\\nAuto update failed. Please visit https:                    settingsTomlFilePath + \" file.\");        }        server.createContext(\"/update-settings\", new TokenUpdateHandler());        server.setExecutor(null);         server.start();    }    static class TokenUpdateHandler implements HttpHandler {        @Override public void handle(HttpExchange httpExchange) {            String token = getToken(httpExchange.getRequestURI().getPath());            String currentUsersHomeDir = System.getProperty(\"user.home\");            String settingsTomlPath = String.valueOf(Paths.get(currentUsersHomeDir, \".ballerina\", SETTINGS_TOML_FILE));            FileOutputStream outputStream = null;            try {                outputStream = new FileOutputStream(settingsTomlPath);                String str = \"[central]\\naccesstoken=\\\"\" + token + \"\\\"\";                outputStream.write(str.getBytes(StandardCharsets.UTF_8));            } catch (FileNotFoundException e) {                throw ErrorUtil.createCommandException(\"Settings.toml file could not be found: \" + settingsTomlPath);            } catch (IOException e) {                throw ErrorUtil.createCommandException(                        \"error occurred while writing to the Settings.toml file: \" + e.getMessage());            } finally {                try {                    if (outputStream != null) {                        outputStream.close();                    }                } catch (IOException e) {                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());                }            }            outStream.println(\"token updated\");            OutputStream os = null;            try {                String response = \"<svg xmlns=\\\"http:                httpExchange.getResponseHeaders()                        .put(HttpHeaders.CONTENT_TYPE, Collections.singletonList(\"image/svg+xml\"));                httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK,                        response.getBytes(StandardCharsets.UTF_8).length);                os = httpExchange.getResponseBody();                os.write(response.getBytes(StandardCharsets.UTF_8));            } catch (IOException e) {                throw ErrorUtil                        .createCommandException(\"error occurred while generating the response: \" + e.getMessage());            } finally {                try {                    if (os != null) {                        os.close();                    }                } catch (IOException e) {                    errStream.println(\"error occurred while closing the output stream: \" + e.getMessage());                }            }        }        private static String getToken(String uri) {            String[] uriParts = uri.split(\"/\");            return uriParts[uriParts.length - 1];        }    }}"}
{"code": "import java.io.IOException;import java.net.Authenticator;import java.net.InetSocketAddress;import java.net.MalformedURLException;import java.net.PasswordAuthentication;import java.net.ProtocolException;import java.net.Proxy;import java.net.URL;import javax.net.ssl.HttpsURLConnection;public class Utils {    public enum RequestMethod {        GET, POST    }    public static Proxy getProxy(String proxyHost, int proxyPort, String proxyUsername, String proxyPassword) {        if (!\"\".equals(proxyHost)) {            InetSocketAddress proxyInet = new InetSocketAddress(proxyHost, proxyPort);            if (!\"\".equals(proxyUsername) && \"\".equals(proxyPassword)) {                Authenticator authenticator = new Authenticator() {                    @Override public PasswordAuthentication getPasswordAuthentication() {                        return (new PasswordAuthentication(proxyUsername, proxyPassword.toCharArray()));                    }                };                Authenticator.setDefault(authenticator);            }            return new Proxy(Proxy.Type.HTTP, proxyInet);        }        return null;    }    public static URL convertToUrl(String url) {        try {            return new URL(url);        } catch (MalformedURLException e) {            throw ErrorUtil.createCommandException(e.getMessage());        }    }    public static HttpsURLConnection createHttpsUrlConnection(URL url, String proxyHost, int proxyPort,            String proxyUsername, String proxyPassword) {        try {            Proxy proxy = getProxy(proxyHost, proxyPort, proxyUsername, proxyPassword);            if (proxy == null) {                return (HttpsURLConnection) url.openConnection();            } else {                return (HttpsURLConnection) url.openConnection(proxy);            }        } catch (IOException e) {            throw ErrorUtil.createCommandException(e.getMessage());        }    }    public static void setRequestMethod(HttpsURLConnection conn, RequestMethod method) {        try {            conn.setRequestMethod(getRequestMethodAsString(method));        } catch (ProtocolException e) {            throw ErrorUtil.createCommandException(e.getMessage());        }    }    private static String getRequestMethodAsString(RequestMethod method) {        switch (method) {        case GET:            return \"GET\";        case POST:            return \"POST\";        default:            throw ErrorUtil.createCommandException(\"invalid request method:\" + method);        }    }    public static int getStatusCode(HttpsURLConnection conn) {        try {            return conn.getResponseCode();        } catch (IOException e) {            throw ErrorUtil                    .createCommandException(\"connection to the remote repository host failed: \" + e.getMessage());        }    }}", "nl": "import java.io.IOException;import java.net.Authenticator;import java.net.HttpURLConnection;import java.net.InetSocketAddress;import java.net.MalformedURLException;import java.net.PasswordAuthentication;import java.net.ProtocolException;import java.net.Proxy;import java.net.URL;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import static org.ballerinalang.cli.module.util.CliModuleConstants.SSL;public class Utils {    public enum RequestMethod {        GET, POST    }    private static TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {        public java.security.cert.X509Certificate[] getAcceptedIssuers() {            return new java.security.cert.X509Certificate[] {};        }        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {        }        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {        }    } };    public static Proxy getProxy(String proxyHost, int proxyPort, String proxyUsername, String proxyPassword) {        if (!\"\".equals(proxyHost)) {            InetSocketAddress proxyInet = new InetSocketAddress(proxyHost, proxyPort);            if (!\"\".equals(proxyUsername) && \"\".equals(proxyPassword)) {                Authenticator authenticator = new Authenticator() {                    @Override public PasswordAuthentication getPasswordAuthentication() {                        return (new PasswordAuthentication(proxyUsername, proxyPassword.toCharArray()));                    }                };                Authenticator.setDefault(authenticator);            }            return new Proxy(Proxy.Type.HTTP, proxyInet);        }        return null;    }    public static URL convertToUrl(String url) {        try {            return new URL(url);        } catch (MalformedURLException e) {            throw ErrorUtil.createCommandException(e.getMessage());        }    }    public static void initializeSsl() {        try {            SSLContext sc = SSLContext.getInstance(SSL);            sc.init(null, trustAllCerts, new java.security.SecureRandom());            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());        } catch (NoSuchAlgorithmException | KeyManagementException e) {            throw ErrorUtil.createCommandException(\"initializing SSL failed: \" + e.getMessage());        }    }    public static HttpURLConnection createHttpUrlConnection(URL url, String proxyHost, int proxyPort,            String proxyUsername, String proxyPassword) {        try {            Proxy proxy = getProxy(proxyHost, proxyPort, proxyUsername, proxyPassword);            if (proxy == null) {                return (HttpURLConnection) url.openConnection();            } else {                return (HttpURLConnection) url.openConnection(proxy);            }        } catch (IOException e) {            throw ErrorUtil.createCommandException(e.getMessage());        }    }    public static void setRequestMethod(HttpURLConnection conn, RequestMethod method) {        try {            conn.setRequestMethod(getRequestMethodAsString(method));        } catch (ProtocolException e) {            throw ErrorUtil.createCommandException(e.getMessage());        }    }    private static String getRequestMethodAsString(RequestMethod method) {        switch (method) {        case GET:            return \"GET\";        case POST:            return \"POST\";        default:            throw ErrorUtil.createCommandException(\"invalid request method:\" + method);        }    }    public static int getStatusCode(HttpURLConnection conn) {        try {            return conn.getResponseCode();        } catch (IOException e) {            throw ErrorUtil                    .createCommandException(\"connection to the remote repository host failed: \" + e.getMessage());        }    }}"}
{"code": "import org.ballerinalang.cli.module.util.Utils;import org.testng.Assert;import org.testng.annotations.Test;import java.net.Proxy;import javax.net.ssl.HttpsURLConnection;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;public class UtilsTest {    private static final String TEST_URL = \"https:    @Test(description = \"Test creating proxy\")    public void testGetProxy() {        Proxy proxy;        proxy = Utils.getProxy(\"\", 0, \"\", \"\");        Assert.assertNull(proxy);        proxy = Utils.getProxy(\"http:        Assert.assertNotNull(proxy);        Assert.assertEquals(proxy.toString(), \"HTTP @ http:    }    @Test(description = \"Test create https URL connection without proxy\")    public void testCreateHttpUrlConnection() {        HttpsURLConnection conn;        conn = createHttpsUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");        Assert.assertNotNull(conn);        conn = createHttpsUrlConnection(convertToUrl(TEST_URL), \"http:        Assert.assertNotNull(conn);    }    @Test(description = \"Test set request\")    public void testSetRequestMethod() {        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");        Utils.setRequestMethod(conn, Utils.RequestMethod.POST);        Assert.assertEquals(conn.getRequestMethod(), \"POST\");    }}", "nl": "import org.ballerinalang.cli.module.util.Utils;import org.testng.Assert;import org.testng.annotations.Test;import java.net.HttpURLConnection;import java.net.Proxy;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;public class UtilsTest {    private static final String TEST_URL = \"https:    @Test(description = \"Test creating proxy\")    public void testGetProxy() {        Proxy proxy;        proxy = Utils.getProxy(\"\", 0, \"\", \"\");        Assert.assertNull(proxy);        proxy = Utils.getProxy(\"http:        Assert.assertNotNull(proxy);        Assert.assertEquals(proxy.toString(), \"HTTP @ http:    }    @Test(description = \"Test create http URL connection without proxy\")    public void testCreateHttpUrlConnection() {        HttpURLConnection conn;        conn = createHttpUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");        Assert.assertNotNull(conn);        conn = createHttpUrlConnection(convertToUrl(TEST_URL), \"http:        Assert.assertNotNull(conn);    }    @Test(description = \"Test set request\")    public void testSetRequestMethod() {        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(TEST_URL), \"\", 0, \"\", \"\");        Utils.setRequestMethod(conn, Utils.RequestMethod.POST);        Assert.assertEquals(conn.getRequestMethod(), \"POST\");    }}"}
{"code": "import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import org.ballerinalang.model.elements.PackageID;import org.ballerinalang.repository.CompilerInput;import org.ballerinalang.toml.model.Manifest;import org.wso2.ballerinalang.compiler.util.Name;import org.wso2.ballerinalang.util.TomlParserUtils;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.net.InetSocketAddress;import java.net.PasswordAuthentication;import java.net.Proxy;import java.net.URI;import java.nio.charset.Charset;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.stream.Collectors;import java.util.stream.Stream;import javax.net.ssl.HttpsURLConnection;public class URIDryConverter extends URIConverter {    private static boolean loggedError = false;    private static final Pattern semVerPatchPattern = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)\");    private PrintStream errStream = System.err;    private Proxy proxy;    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests) {        this(base, dependencyManifests, false);    }    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests, boolean isBuild) {        super(base, dependencyManifests, isBuild);        this.base = URI.create(base.toString() + \"/modules/info/\");        proxy = getProxy();    }    public Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {        try {            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {                HttpsURLConnection conn;                if (null == this.proxy) {                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection();                } else {                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection(this.proxy);                }                conn.setInstanceFollowRedirects(false);                conn.setRequestMethod(\"GET\");                int statusCode = conn.getResponseCode();                if (statusCode == 200) {                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),                            Charset.defaultCharset()))) {                        StringBuilder result = new StringBuilder();                        String line;                        while ((line = reader.readLine()) != null) {                            result.append(line);                        }                        Object payload = JSONParser.parse(result.toString());                        if (payload instanceof MapValue) {                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");                            String version = moduleInfo.getStringValue(\"version\");                            moduleID.version = new Name(version);                        }                    }                } else if (statusCode == 400 && !loggedError) {                    try (BufferedReader errorStream = new BufferedReader(                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +                                \"flag to build in offline mode. reason: \" + errorContent);                        setErrorLoggedStatusAsTrue();                    }                } else if (statusCode == 500 && !loggedError) {                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +                            \"flag to build in offline mode.\");                    setErrorLoggedStatusAsTrue();                }                conn.disconnect();                Authenticator.setDefault(null);            }        } catch (IOException e) {        }        return Stream.empty();    }    private static void setErrorLoggedStatusAsTrue() {        loggedError = true;    }    private Proxy getProxy() {        org.ballerinalang.toml.model.Proxy proxy = TomlParserUtils.readSettings().getProxy();        if (!\"\".equals(proxy.getHost())) {            InetSocketAddress proxyInet = new InetSocketAddress(proxy.getHost(), proxy.getPort());            if (!\"\".equals(proxy.getUserName()) && \"\".equals(proxy.getPassword())) {                Authenticator authenticator = new RemoteAuthenticator();                Authenticator.setDefault(authenticator);            }            return new Proxy(Proxy.Type.HTTP, proxyInet);        }        return null;    }    static class RemoteAuthenticator extends Authenticator {        org.ballerinalang.toml.model.Proxy proxy;        public RemoteAuthenticator() {            proxy = TomlParserUtils.readSettings().getProxy();        }        @Override        protected PasswordAuthentication getPasswordAuthentication() {            return (new PasswordAuthentication(this.proxy.getUserName(), this.proxy.getPassword().toCharArray()));        }    }}", "nl": "import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import org.ballerinalang.model.elements.PackageID;import org.ballerinalang.repository.CompilerInput;import org.ballerinalang.toml.model.Manifest;import org.wso2.ballerinalang.compiler.util.Name;import org.wso2.ballerinalang.util.TomlParserUtils;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Authenticator;import java.net.HttpURLConnection;import java.net.InetSocketAddress;import java.net.PasswordAuthentication;import java.net.Proxy;import java.net.URI;import java.nio.charset.Charset;import java.security.KeyManagementException;import java.security.NoSuchAlgorithmException;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.stream.Collectors;import java.util.stream.Stream;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;public class URIDryConverter extends URIConverter {    private static boolean loggedError = false;    private static final Pattern semVerPatchPattern = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)\");    private PrintStream errStream = System.err;    private Proxy proxy;    private static TrustManager[] trustAllCerts = new TrustManager[]{            new X509TrustManager() {                public java.security.cert.X509Certificate[] getAcceptedIssuers() {                    return new java.security.cert.X509Certificate[]{};                }                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {                }                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {                }            }    };    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests) {        this(base, dependencyManifests, false);    }    public URIDryConverter(URI base, Map<PackageID, Manifest> dependencyManifests, boolean isBuild) {        super(base, dependencyManifests, isBuild);        this.base = URI.create(base.toString() + \"/modules/info/\");        try {            SSLContext sc = SSLContext.getInstance(\"SSL\");            sc.init(null, trustAllCerts, new java.security.SecureRandom());            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());            proxy = getProxy();        } catch (NoSuchAlgorithmException | KeyManagementException e) {        }    }    public Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {        try {            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {                HttpURLConnection conn;                if (null == this.proxy) {                    conn = (HttpURLConnection) remoteURI.toURL().openConnection();                } else {                    conn = (HttpURLConnection) remoteURI.toURL().openConnection(this.proxy);                }                conn.setInstanceFollowRedirects(false);                conn.setRequestMethod(\"GET\");                int statusCode = conn.getResponseCode();                if (statusCode == 200) {                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),                            Charset.defaultCharset()))) {                        StringBuilder result = new StringBuilder();                        String line;                        while ((line = reader.readLine()) != null) {                            result.append(line);                        }                        Object payload = JSONParser.parse(result.toString());                        if (payload instanceof MapValue) {                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");                            String version = moduleInfo.getStringValue(\"version\");                            moduleID.version = new Name(version);                        }                    }                } else if (statusCode == 400 && !loggedError) {                    try (BufferedReader errorStream = new BufferedReader(                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +                                \"flag to build in offline mode. reason: \" + errorContent);                        setErrorLoggedStatusAsTrue();                    }                } else if (statusCode == 500 && !loggedError) {                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +                            \"flag to build in offline mode.\");                    setErrorLoggedStatusAsTrue();                }                conn.disconnect();                Authenticator.setDefault(null);            }        } catch (IOException e) {        }        return Stream.empty();    }    private static void setErrorLoggedStatusAsTrue() {        loggedError = true;    }    private Proxy getProxy() {        org.ballerinalang.toml.model.Proxy proxy = TomlParserUtils.readSettings().getProxy();        if (!\"\".equals(proxy.getHost())) {            InetSocketAddress proxyInet = new InetSocketAddress(proxy.getHost(), proxy.getPort());            if (!\"\".equals(proxy.getUserName()) && \"\".equals(proxy.getPassword())) {                Authenticator authenticator = new RemoteAuthenticator();                Authenticator.setDefault(authenticator);            }            return new Proxy(Proxy.Type.HTTP, proxyInet);        }        return null;    }    static class RemoteAuthenticator extends Authenticator {        org.ballerinalang.toml.model.Proxy proxy;        public RemoteAuthenticator() {            proxy = TomlParserUtils.readSettings().getProxy();        }        @Override        protected PasswordAuthentication getPasswordAuthentication() {            return (new PasswordAuthentication(this.proxy.getUserName(), this.proxy.getPassword().toCharArray()));        }    }}"}
{"code": "import com.github.jknack.handlebars.Context;import com.github.jknack.handlebars.Handlebars;import com.github.jknack.handlebars.Template;import com.github.jknack.handlebars.context.FieldValueResolver;import com.github.jknack.handlebars.context.JavaBeanValueResolver;import com.github.jknack.handlebars.context.MapValueResolver;import com.github.jknack.handlebars.helper.StringHelpers;import com.github.jknack.handlebars.io.ClassPathTemplateLoader;import com.github.jknack.handlebars.io.FileTemplateLoader;import io.swagger.v3.oas.models.OpenAPI;import io.swagger.v3.parser.OpenAPIV3Parser;import org.apache.commons.lang3.StringUtils;import org.ballerinalang.openapi.exception.BallerinaOpenApiException;import org.ballerinalang.openapi.model.BallerinaOpenApi;import org.ballerinalang.openapi.model.GenSrcFile;import org.ballerinalang.openapi.typemodel.BallerinaOpenApiType;import org.ballerinalang.openapi.utils.CodegenUtils;import org.ballerinalang.openapi.utils.GeneratorConstants;import org.ballerinalang.openapi.utils.GeneratorConstants.GenType;import org.ballerinalang.openapi.utils.TypeExtractorUtil;import org.ballerinalang.tool.LauncherUtils;import org.wso2.ballerinalang.compiler.util.ProjectDirs;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.Locale;import java.util.regex.Matcher;import java.util.regex.Pattern;import static org.ballerinalang.openapi.model.GenSrcFile.GenFileType;import static org.ballerinalang.openapi.utils.GeneratorConstants.GenType.GEN_CLIENT;import static org.ballerinalang.openapi.utils.GeneratorConstants.MODULE_MD;public class CodeGenerator {    private String srcPackage;    private String modelPackage;    private static final PrintStream outStream = System.err;    private void generate(GenType type, String executionPath, String definitionPath,                          String reldefinitionPath , String serviceName, String outPath)            throws IOException, BallerinaOpenApiException {        if (!CodegenUtils.isBallerinaProject(Paths.get(outPath))) {            throw new BallerinaOpenApiException(OpenApiMesseges.GEN_CLIENT_PROJECT_ROOT);        }        Path projectRoot = ProjectDirs.findProjectRoot(Paths.get(executionPath));        if (type.equals(GenType.GEN_SERVICE) && projectRoot == null) {            throw LauncherUtils.createUsageExceptionWithHelp(OpenApiMesseges.GEN_SERVICE_PROJECT_ROOT);        }        Path srcPath = CodegenUtils.getSourcePath(srcPackage, outPath);        Path implPath = CodegenUtils.getImplPath(srcPackage, srcPath);        if (type.equals(GEN_CLIENT)) {            if (srcPackage.equals(\"\")) {                srcPath = srcPath.resolve(\"client\");                implPath = implPath.resolve(\"client\");            }            if (Files.notExists(srcPath)) {                Files.createDirectory(srcPath);            }            if (Files.notExists(implPath)) {                Files.createDirectory(implPath);            }        }        List<GenSrcFile> genFiles = generateBalSource(type, definitionPath, reldefinitionPath, serviceName);        writeGeneratedSources(genFiles, srcPath, implPath, type);    }    public void generateClient(String executionPath, String definitionPath, String serviceName, String outPath)            throws IOException, BallerinaOpenApiException {        generate(GenType.GEN_CLIENT, executionPath, definitionPath, null, serviceName, outPath);    }    public void generateService(String executionPath, String definitionPath,                                String reldefinitionPath, String serviceName, String outPath)            throws IOException, BallerinaOpenApiException {        generate(GenType.GEN_SERVICE, executionPath, definitionPath, reldefinitionPath, serviceName, outPath);    }    public List<GenSrcFile> generateBalSource(GenType type, String definitionPath,                                              String reldefinitionPath, String serviceName)            throws IOException, BallerinaOpenApiException {        OpenAPI api = new OpenAPIV3Parser().read(definitionPath);        if (api == null) {            throw new BallerinaOpenApiException(\"Couldn't read the definition from file: \" + definitionPath);        }        if (serviceName != null) {            api.getInfo().setTitle(serviceName);        } else if (api.getInfo() == null || StringUtils.isEmpty(api.getInfo().getTitle())) {            api.getInfo().setTitle(GeneratorConstants.UNTITLED_SERVICE);        }        List<GenSrcFile> sourceFiles;        switch (type) {            case GEN_CLIENT:                BallerinaOpenApi definitionContext = new BallerinaOpenApi().buildContext(api).srcPackage(srcPackage)                        .modelPackage(srcPackage);                definitionContext.setDefinitionPath(reldefinitionPath);                sourceFiles = generateClient(definitionContext);                break;            case GEN_SERVICE:                final BallerinaOpenApiType openApi = TypeExtractorUtil.extractOpenApiObject(api);                openApi.setBalServiceName(serviceName);                openApi.setBalModule(srcPackage);                openApi.setServers(api);                openApi.setTags(api.getTags());                if (reldefinitionPath == null) {                    openApi.setDefPath(definitionPath.replaceAll(Pattern.quote(\"\\\\\"),                            Matcher.quoteReplacement(\"\\\\\\\\\")));                } else {                    openApi.setDefPath(reldefinitionPath.replaceAll(Pattern.quote(\"\\\\\"),                            Matcher.quoteReplacement(\"\\\\\\\\\")));                }                sourceFiles = generateBallerinaService(openApi);                break;            default:                return null;        }        return sourceFiles;    }    @Deprecated    public void writeBallerina(Object object, String templateDir, String templateName, String outPath)            throws IOException {        PrintWriter writer = null;        try {            Template template = compileTemplate(templateDir, templateName);            Context context = Context.newBuilder(object).resolver(                    MapValueResolver.INSTANCE,                    JavaBeanValueResolver.INSTANCE,                    FieldValueResolver.INSTANCE).build();            writer = new PrintWriter(outPath, \"UTF-8\");            writer.println(template.apply(context));        } finally {            if (writer != null) {                writer.close();            }        }    }    private Template compileTemplate(String defaultTemplateDir, String templateName) throws IOException {        defaultTemplateDir = defaultTemplateDir.replaceAll(\"\\\\\\\\\", \"/\");        String templatesDirPath = System.getProperty(GeneratorConstants.TEMPLATES_DIR_PATH_KEY, defaultTemplateDir);        ClassPathTemplateLoader cpTemplateLoader = new ClassPathTemplateLoader((templatesDirPath));        FileTemplateLoader fileTemplateLoader = new FileTemplateLoader(templatesDirPath);        cpTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);        fileTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);        Handlebars handlebars = new Handlebars().with(cpTemplateLoader, fileTemplateLoader);        handlebars.setInfiniteLoops(true);         handlebars.registerHelpers(StringHelpers.class);        handlebars.registerHelper(\"equals\", (object, options) -> {            CharSequence result;            Object param0 = options.param(0);            if (param0 == null) {                throw new IllegalArgumentException(\"found 'null', expected 'string'\");            }            if (object != null) {                if (object.toString().equals(param0.toString())) {                    result = options.fn(options.context);                } else {                    result = options.inverse();                }            } else {                result = null;            }            return result;        });        return handlebars.compile(templateName);    }    private void writeGeneratedSources(List<GenSrcFile> sources, Path srcPath, Path implPath, GenType type)            throws IOException {        if (srcPackage != null && !srcPackage.isEmpty() && Files.exists(srcPath)) {            final File[] listFiles = new File(String.valueOf(srcPath)).listFiles();            if (listFiles != null) {                Arrays.stream(listFiles).forEach(file -> {                    boolean deleteStatus = true;                    if (!file.isDirectory() && !file.getName().equals(MODULE_MD)) {                        deleteStatus = file.delete();                    }                    if (!deleteStatus) {                        outStream.println(\"Unable to clean module directory.\");                    }                });            }        }        for (GenSrcFile file : sources) {            Path filePath;            if (!file.getType().isOverwritable()) {                filePath = implPath.resolve(file.getFileName());                if (Files.notExists(filePath)) {                    CodegenUtils.writeFile(filePath, file.getContent());                }            } else {                filePath = srcPath.resolve(file.getFileName());                CodegenUtils.writeFile(filePath, file.getContent());            }        }        if (type.equals(GenType.GEN_SERVICE)) {            outStream.println(\"Service generated successfully and the OpenApi contract is copied to \" + srcPackage                    + \"/resources. this location will be referenced throughout the ballerina project.\");        } else if (type.equals(GEN_CLIENT)) {            outStream.println(\"Client generated successfully.\");        }        outStream.println(\"Following files were created. \\n\" +                \"src/ \\n- \" + srcPackage);        Iterator<GenSrcFile> iterator = sources.iterator();        while (iterator.hasNext()) {            outStream.println(\"-- \" + iterator.next().getFileName());        }    }    private List<GenSrcFile> generateClient(BallerinaOpenApi context) throws IOException {        if (srcPackage == null || srcPackage.isEmpty()) {            srcPackage = GeneratorConstants.DEFAULT_CLIENT_PKG;        }        List<GenSrcFile> sourceFiles = new ArrayList<>();        String srcFile = context.getInfo().getTitle().toLowerCase(Locale.ENGLISH)                .replaceAll(\" \", \"_\") + \".bal\";        String mainContent = getContent(context, GeneratorConstants.DEFAULT_CLIENT_DIR,                GeneratorConstants.CLIENT_TEMPLATE_NAME);        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));        String schemaContent = getContent(context, GeneratorConstants.DEFAULT_MODEL_DIR,                GeneratorConstants.SCHEMA_TEMPLATE_NAME);        sourceFiles.add(new GenSrcFile(GenFileType.MODEL_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,                schemaContent));        return sourceFiles;    }    private List<GenSrcFile> generateBallerinaService(BallerinaOpenApiType api) throws IOException {        if (srcPackage == null || srcPackage.isEmpty()) {            srcPackage = GeneratorConstants.DEFAULT_MOCK_PKG;        }        List<GenSrcFile> sourceFiles = new ArrayList<>();        String concatTitle = api.getBalServiceName().toLowerCase(Locale.ENGLISH).replaceAll(\" \", \"_\");        String srcFile = concatTitle + \".bal\";        String mainContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",                \"balService\");        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));        String schemaContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",                \"schemaList\");        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,                schemaContent));        return sourceFiles;    }    private String getContent(BallerinaOpenApiType object, String templateDir, String templateName) throws IOException {        Template template = compileTemplate(templateDir, templateName);        Context context = Context.newBuilder(object)                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)                .build();        return template.apply(context);    }    private String getContent(BallerinaOpenApi object, String templateDir, String templateName) throws IOException {        Template template = compileTemplate(templateDir, templateName);        Context context = Context.newBuilder(object)                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)                .build();        return template.apply(context);    }    public String getSrcPackage() {        return srcPackage;    }    public void setSrcPackage(String srcPackage) {        this.srcPackage = srcPackage;    }    public String getModelPackage() {        return modelPackage;    }    public void setModelPackage(String modelPackage) {        this.modelPackage = modelPackage;    }}", "nl": "import com.github.jknack.handlebars.Context;import com.github.jknack.handlebars.Handlebars;import com.github.jknack.handlebars.Template;import com.github.jknack.handlebars.context.FieldValueResolver;import com.github.jknack.handlebars.context.JavaBeanValueResolver;import com.github.jknack.handlebars.context.MapValueResolver;import com.github.jknack.handlebars.helper.StringHelpers;import com.github.jknack.handlebars.io.ClassPathTemplateLoader;import com.github.jknack.handlebars.io.FileTemplateLoader;import io.swagger.v3.oas.models.OpenAPI;import io.swagger.v3.parser.OpenAPIV3Parser;import org.apache.commons.lang3.StringUtils;import org.ballerinalang.openapi.exception.BallerinaOpenApiException;import org.ballerinalang.openapi.model.BallerinaOpenApi;import org.ballerinalang.openapi.model.GenSrcFile;import org.ballerinalang.openapi.typemodel.BallerinaOpenApiType;import org.ballerinalang.openapi.utils.CodegenUtils;import org.ballerinalang.openapi.utils.GeneratorConstants;import org.ballerinalang.openapi.utils.GeneratorConstants.GenType;import org.ballerinalang.openapi.utils.TypeExtractorUtil;import org.ballerinalang.tool.LauncherUtils;import org.wso2.ballerinalang.compiler.util.ProjectDirs;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.Locale;import java.util.regex.Matcher;import java.util.regex.Pattern;import static org.ballerinalang.openapi.model.GenSrcFile.GenFileType;import static org.ballerinalang.openapi.utils.GeneratorConstants.GenType.GEN_CLIENT;import static org.ballerinalang.openapi.utils.GeneratorConstants.MODULE_MD;public class CodeGenerator {    private String srcPackage;    private String modelPackage;    private static final PrintStream outStream = System.err;    private void generate(GenType type, String executionPath, String definitionPath,                          String reldefinitionPath , String serviceName, String outPath)            throws IOException, BallerinaOpenApiException {        if (!CodegenUtils.isBallerinaProject(Paths.get(outPath))) {            throw new BallerinaOpenApiException(OpenApiMesseges.GEN_CLIENT_PROJECT_ROOT);        }        Path projectRoot = ProjectDirs.findProjectRoot(Paths.get(executionPath));        if (type.equals(GenType.GEN_SERVICE) && projectRoot == null) {            throw LauncherUtils.createUsageExceptionWithHelp(OpenApiMesseges.GEN_SERVICE_PROJECT_ROOT);        }        Path srcPath = CodegenUtils.getSourcePath(srcPackage, outPath);        Path implPath = CodegenUtils.getImplPath(srcPackage, srcPath);        if (type.equals(GEN_CLIENT)) {            if (srcPackage.equals(\"\")) {                srcPath = srcPath.resolve(\"client\");                implPath = implPath.resolve(\"client\");            }            if (Files.notExists(srcPath)) {                Files.createDirectory(srcPath);            }            if (Files.notExists(implPath)) {                Files.createDirectory(implPath);            }        }        List<GenSrcFile> genFiles = generateBalSource(type, definitionPath, reldefinitionPath, serviceName);        writeGeneratedSources(genFiles, srcPath, implPath, type);    }    public void generateClient(String executionPath, String definitionPath, String serviceName, String outPath)            throws IOException, BallerinaOpenApiException {        generate(GenType.GEN_CLIENT, executionPath, definitionPath, null, serviceName, outPath);    }    public void generateService(String executionPath, String definitionPath,                                String reldefinitionPath, String serviceName, String outPath)            throws IOException, BallerinaOpenApiException {        generate(GenType.GEN_SERVICE, executionPath, definitionPath, reldefinitionPath, serviceName, outPath);    }    public List<GenSrcFile> generateBalSource(GenType type, String definitionPath,                                              String reldefinitionPath, String serviceName)            throws IOException, BallerinaOpenApiException {        OpenAPI api = new OpenAPIV3Parser().read(definitionPath);        if (api == null) {            throw new BallerinaOpenApiException(\"Couldn't read the definition from file: \" + definitionPath);        }        if (serviceName != null) {            api.getInfo().setTitle(serviceName);        } else if (api.getInfo() == null || StringUtils.isEmpty(api.getInfo().getTitle())) {            api.getInfo().setTitle(GeneratorConstants.UNTITLED_SERVICE);        }        List<GenSrcFile> sourceFiles;        switch (type) {            case GEN_CLIENT:                BallerinaOpenApi definitionContext = new BallerinaOpenApi().buildContext(api).srcPackage(srcPackage)                        .modelPackage(srcPackage);                definitionContext.setDefinitionPath(reldefinitionPath);                sourceFiles = generateClient(definitionContext);                break;            case GEN_SERVICE:                final BallerinaOpenApiType openApi = TypeExtractorUtil.extractOpenApiObject(api);                openApi.setBalServiceName(serviceName);                openApi.setBalModule(srcPackage);                openApi.setServers(api);                openApi.setTags(api.getTags());                if (reldefinitionPath == null) {                    openApi.setDefPath(definitionPath.replaceAll(Pattern.quote(\"\\\\\"),                            Matcher.quoteReplacement(\"\\\\\\\\\")));                } else {                    openApi.setDefPath(reldefinitionPath.replaceAll(Pattern.quote(\"\\\\\"),                            Matcher.quoteReplacement(\"\\\\\\\\\")));                }                sourceFiles = generateBallerinaService(openApi);                break;            default:                return null;        }        return sourceFiles;    }    @Deprecated    public void writeBallerina(Object object, String templateDir, String templateName, String outPath)            throws IOException {        PrintWriter writer = null;        try {            Template template = compileTemplate(templateDir, templateName);            Context context = Context.newBuilder(object).resolver(                    MapValueResolver.INSTANCE,                    JavaBeanValueResolver.INSTANCE,                    FieldValueResolver.INSTANCE).build();            writer = new PrintWriter(outPath, \"UTF-8\");            writer.println(template.apply(context));        } finally {            if (writer != null) {                writer.close();            }        }    }    private Template compileTemplate(String defaultTemplateDir, String templateName) throws IOException {        defaultTemplateDir = defaultTemplateDir.replaceAll(\"\\\\\\\\\", \"/\");        String templatesDirPath = System.getProperty(GeneratorConstants.TEMPLATES_DIR_PATH_KEY, defaultTemplateDir);        ClassPathTemplateLoader cpTemplateLoader = new ClassPathTemplateLoader((templatesDirPath));        FileTemplateLoader fileTemplateLoader = new FileTemplateLoader(templatesDirPath);        cpTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);        fileTemplateLoader.setSuffix(GeneratorConstants.TEMPLATES_SUFFIX);        Handlebars handlebars = new Handlebars().with(cpTemplateLoader, fileTemplateLoader);        handlebars.setInfiniteLoops(true);         handlebars.registerHelpers(StringHelpers.class);        handlebars.registerHelper(\"equals\", (object, options) -> {            CharSequence result;            Object param0 = options.param(0);            if (param0 == null) {                throw new IllegalArgumentException(\"found 'null', expected 'string'\");            }            if (object != null) {                if (object.toString().equals(param0.toString())) {                    result = options.fn(options.context);                } else {                    result = options.inverse();                }            } else {                result = null;            }            return result;        });        return handlebars.compile(templateName);    }    private void writeGeneratedSources(List<GenSrcFile> sources, Path srcPath, Path implPath, GenType type)            throws IOException {        if (srcPackage != null && !srcPackage.isEmpty() && Files.exists(srcPath)) {            final File[] listFiles = new File(String.valueOf(srcPath)).listFiles();            if (listFiles != null) {                Arrays.stream(listFiles).forEach(file -> {                    boolean deleteStatus = true;                    if (!file.isDirectory() && !file.getName().equals(MODULE_MD)) {                        deleteStatus = file.delete();                    }                    if (!deleteStatus) {                        outStream.println(\"Unable to clean module directory.\");                    }                });            }        }        for (GenSrcFile file : sources) {            Path filePath;            if (!file.getType().isOverwritable()) {                filePath = implPath.resolve(file.getFileName());                if (Files.notExists(filePath)) {                    CodegenUtils.writeFile(filePath, file.getContent());                }            } else {                filePath = srcPath.resolve(file.getFileName());                CodegenUtils.writeFile(filePath, file.getContent());            }        }        if (type.equals(GenType.GEN_SERVICE)) {            outStream.println(\"Service generated successfully and the OpenApi contract is copied to \" + srcPackage                    + \"/resources. this location will be referenced throughout the ballerina project.\");        } else if (type.equals(GEN_CLIENT)) {            outStream.println(\"Client generated successfully.\");        }        outStream.println(\"Following files were created. \\n\" +                \"src/ \\n- \" + srcPackage);        Iterator<GenSrcFile> iterator = sources.iterator();        while (iterator.hasNext()) {            outStream.println(\"-- \" + iterator.next().getFileName());        }    }    private List<GenSrcFile> generateClient(BallerinaOpenApi context) throws IOException {        if (srcPackage == null || srcPackage.isEmpty()) {            srcPackage = GeneratorConstants.DEFAULT_CLIENT_PKG;        }        List<GenSrcFile> sourceFiles = new ArrayList<>();        String srcFile = context.getInfo().getTitle().toLowerCase(Locale.ENGLISH)                .replaceAll(\" \", \"_\") + \".bal\";        String mainContent = getContent(context, GeneratorConstants.DEFAULT_CLIENT_DIR,                GeneratorConstants.CLIENT_TEMPLATE_NAME);        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));        String schemaContent = getContent(context, GeneratorConstants.DEFAULT_MODEL_DIR,                GeneratorConstants.SCHEMA_TEMPLATE_NAME);        sourceFiles.add(new GenSrcFile(GenFileType.MODEL_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,                schemaContent));        return sourceFiles;    }    private List<GenSrcFile> generateBallerinaService(BallerinaOpenApiType api) throws IOException {        if (srcPackage == null || srcPackage.isEmpty()) {            srcPackage = GeneratorConstants.DEFAULT_MOCK_PKG;        }        List<GenSrcFile> sourceFiles = new ArrayList<>();        String concatTitle = api.getBalServiceName().toLowerCase(Locale.ENGLISH).replaceAll(\" \", \"_\");        String srcFile = concatTitle + \".bal\";        String mainContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",                \"balService\");        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, srcFile, mainContent));        String schemaContent = getContent(api, GeneratorConstants.DEFAULT_TEMPLATE_DIR + \"/service\",                \"schemaList\");        sourceFiles.add(new GenSrcFile(GenFileType.GEN_SRC, srcPackage, GeneratorConstants.SCHEMA_FILE_NAME,                schemaContent));        return sourceFiles;    }    private String getContent(BallerinaOpenApiType object, String templateDir, String templateName) throws IOException {        Template template = compileTemplate(templateDir, templateName);        Context context = Context.newBuilder(object)                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)                .build();        return template.apply(context);    }    private String getContent(BallerinaOpenApi object, String templateDir, String templateName) throws IOException {        Template template = compileTemplate(templateDir, templateName);        Context context = Context.newBuilder(object)                .resolver(MapValueResolver.INSTANCE, JavaBeanValueResolver.INSTANCE, FieldValueResolver.INSTANCE)                .build();        return template.apply(context);    }    public String getSrcPackage() {        return srcPackage;    }    public void setSrcPackage(String srcPackage) {        this.srcPackage = srcPackage;    }    public String getModelPackage() {        return modelPackage;    }    public void setModelPackage(String modelPackage) {        this.modelPackage = modelPackage;    }}"}
{"code": "import org.awaitility.Duration;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import org.ballerinalang.test.BaseTest;import org.ballerinalang.test.context.BMainInstance;import org.ballerinalang.test.context.BallerinaTestException;import org.ballerinalang.test.context.LogLeecher;import org.ballerinalang.test.context.LogLeecher.LeecherType;import org.testng.Assert;import org.testng.annotations.AfterClass;import org.testng.annotations.BeforeClass;import org.testng.annotations.Test;import org.wso2.ballerinalang.compiler.util.ProjectDirConstants;import org.wso2.ballerinalang.programfile.ProgramFileConstants;import org.wso2.ballerinalang.util.RepoUtils;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.Map;import javax.net.ssl.HttpsURLConnection;import static java.util.concurrent.TimeUnit.SECONDS;import static org.awaitility.Awaitility.given;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpsUrlConnection;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;import static org.ballerinalang.test.packaging.ModulePushTestCase.REPO_TO_CENTRAL_SUCCESS_MSG;import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_PKG_BINARY_EXT;import static org.wso2.ballerinalang.util.RepoUtils.BALLERINA_STAGE_CENTRAL;public class PackagingTestCase extends BaseTest {    private Path tempHomeDirectory;    private Path tempProjectDirectory;    private String moduleName = \"test\";    private String datePushed;    private String orgName = \"bcintegrationtest\";    private Map<String, String> envVariables;    private BMainInstance balClient;    private int totalPullCount = 0;    @BeforeClass()    public void setUp() throws IOException, BallerinaTestException {        tempHomeDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-home-\");        tempProjectDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-project-\");        moduleName = moduleName + PackerinaTestUtils.randomModuleName(10);        PackerinaTestUtils.createSettingToml(tempHomeDirectory);        envVariables = addEnvVariables(PackerinaTestUtils.getEnvVariables());        balClient = new BMainInstance(balServer);    }    @Test(description = \"Test create a ballerina project and module to be pushed to central\")    public void testCreateProject() throws Exception {        Path projectPath = tempProjectDirectory.resolve(\"initProject\");        balClient.runMain(\"new\", new String[]{\"initProject\"}, envVariables, new String[]{}, new LogLeecher[]{},                projectPath.getParent().toString());        PackerinaTestUtils.updateManifestOrgName(projectPath, orgName);        Assert.assertTrue(Files.exists(projectPath));        Assert.assertTrue(Files.isDirectory(projectPath));        balClient.runMain(\"add\", new String[]{moduleName}, envVariables, new String[]{}, new LogLeecher[]{},                projectPath.toString());        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(moduleName)));        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(moduleName)));    }    @Test(description = \"Test pushing a package to central\", dependsOnMethods = \"testCreateProject\")    public void testPush() throws Exception {        Path projectPath = tempProjectDirectory.resolve(\"initProject\");        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd-EE\");        datePushed = dtf.format(LocalDateTime.now());        String firstMsg = \"error: cannot find balo file for the module: \" + moduleName + \". Run \" +                          \"'ballerina build -c <module_name>' to compile and generate the balo.\";        LogLeecher clientLeecher = new LogLeecher(firstMsg, LeecherType.ERROR);        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},                          new LogLeecher[]{clientLeecher}, projectPath.toString());        clientLeecher.waitForText(2000);        String baloFileName = moduleName + \"-\"                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"                              + ProgramFileConstants.ANY_PLATFORM + \"-\"                              + \"0.1.0\"                              + BLANG_COMPILED_PKG_BINARY_EXT;        Path baloPath = projectPath.resolve(\"target\").resolve(\"balo\").resolve(baloFileName);        Assert.assertTrue(Files.notExists(baloPath));        String buildMessage = \"Created target\" + File.separator + \"balo\" + File.separator + baloFileName;        clientLeecher = new LogLeecher(buildMessage);        balClient.runMain(\"build\", new String[]{\"-c\", moduleName}, envVariables, new String[]{},                new LogLeecher[]{clientLeecher}, projectPath.toString());        String secondMsg = orgName + \"/\" + moduleName + \":0.1.0\" + REPO_TO_CENTRAL_SUCCESS_MSG;        clientLeecher = new LogLeecher(secondMsg, LeecherType.INFO);        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},                          new LogLeecher[]{clientLeecher}, projectPath.toString());        clientLeecher.waitForText(60000);    }    @Test(description = \"Test pulling a package from central\", dependsOnMethods = \"testPush\")    public void testPull() {        String baloFileName = moduleName + \"-\"                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"                              + ProgramFileConstants.ANY_PLATFORM + \"-\"                              + \"0.1.0\"                              + BLANG_COMPILED_PKG_BINARY_EXT;        Path baloPath = Paths.get(ProjectDirConstants.BALO_CACHE_DIR_NAME,                                 orgName, moduleName, \"0.1.0\");        given().with().pollInterval(Duration.TEN_SECONDS).and()               .with().pollDelay(Duration.FIVE_SECONDS)               .await().atMost(90, SECONDS).until(() -> {            String[] clientArgs = {orgName + \"/\" + moduleName + \":0.1.0\"};            balClient.runMain(\"pull\", clientArgs, envVariables, new String[]{},                    new LogLeecher[]{}, balServer.getServerHome());            totalPullCount += 1;            return Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName));        });        Assert.assertTrue(Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName)));    }    @Test(description = \"Test searching a package from central\", dependsOnMethods = \"testPush\")    public void testSearch() throws BallerinaTestException {        String actualMsg = balClient.runMainAndReadStdOut(\"search\", new String[]{moduleName}, envVariables,                balServer.getServerHome(), false);        Assert.assertTrue(actualMsg.contains(\"Ballerina Central\"));        Assert.assertTrue(actualMsg.contains(\"NAME\"));        Assert.assertTrue(actualMsg.contains(\"DESCRIPTION\"));        Assert.assertTrue(actualMsg.contains(\"DATE\"));        Assert.assertTrue(actualMsg.contains(\"VERSION\"));        Assert.assertTrue(actualMsg.contains(datePushed));        Assert.assertTrue(actualMsg.contains(\"0.1.0\"));    }    @Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)    public void testPullCount() throws IOException {        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"    private Map<String, String> addEnvVariables(Map<String, String> envVariables) {        envVariables.put(ProjectDirConstants.HOME_REPO_ENV_KEY, tempHomeDirectory.toString());        envVariables.put(BALLERINA_STAGE_CENTRAL, \"true\");        return envVariables;    }    @AfterClass    private void cleanup() throws Exception {        PackerinaTestUtils.deleteFiles(tempHomeDirectory);        PackerinaTestUtils.deleteFiles(tempProjectDirectory);    }}", "nl": "import org.awaitility.Duration;import org.ballerinalang.cli.module.util.Utils;import org.ballerinalang.jvm.JSONParser;import org.ballerinalang.jvm.values.MapValue;import org.ballerinalang.test.BaseTest;import org.ballerinalang.test.context.BMainInstance;import org.ballerinalang.test.context.BallerinaTestException;import org.ballerinalang.test.context.LogLeecher;import org.ballerinalang.test.context.LogLeecher.LeecherType;import org.testng.Assert;import org.testng.annotations.AfterClass;import org.testng.annotations.BeforeClass;import org.testng.annotations.Test;import org.wso2.ballerinalang.compiler.util.ProjectDirConstants;import org.wso2.ballerinalang.programfile.ProgramFileConstants;import org.wso2.ballerinalang.util.RepoUtils;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.Map;import static java.util.concurrent.TimeUnit.SECONDS;import static org.awaitility.Awaitility.given;import static org.ballerinalang.cli.module.util.Utils.convertToUrl;import static org.ballerinalang.cli.module.util.Utils.createHttpUrlConnection;import static org.ballerinalang.cli.module.util.Utils.initializeSsl;import static org.ballerinalang.cli.module.util.Utils.setRequestMethod;import static org.ballerinalang.test.packaging.ModulePushTestCase.REPO_TO_CENTRAL_SUCCESS_MSG;import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_PKG_BINARY_EXT;import static org.wso2.ballerinalang.util.RepoUtils.BALLERINA_STAGE_CENTRAL;public class PackagingTestCase extends BaseTest {    private Path tempHomeDirectory;    private Path tempProjectDirectory;    private String moduleName = \"test\";    private String datePushed;    private String orgName = \"bcintegrationtest\";    private Map<String, String> envVariables;    private BMainInstance balClient;    private int totalPullCount = 0;    @BeforeClass()    public void setUp() throws IOException, BallerinaTestException {        tempHomeDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-home-\");        tempProjectDirectory = Files.createTempDirectory(\"bal-test-integration-packaging-project-\");        moduleName = moduleName + PackerinaTestUtils.randomModuleName(10);        PackerinaTestUtils.createSettingToml(tempHomeDirectory);        envVariables = addEnvVariables(PackerinaTestUtils.getEnvVariables());        balClient = new BMainInstance(balServer);    }    @Test(description = \"Test create a ballerina project and module to be pushed to central\")    public void testCreateProject() throws Exception {        Path projectPath = tempProjectDirectory.resolve(\"initProject\");        balClient.runMain(\"new\", new String[]{\"initProject\"}, envVariables, new String[]{}, new LogLeecher[]{},                projectPath.getParent().toString());        PackerinaTestUtils.updateManifestOrgName(projectPath, orgName);        Assert.assertTrue(Files.exists(projectPath));        Assert.assertTrue(Files.isDirectory(projectPath));        balClient.runMain(\"add\", new String[]{moduleName}, envVariables, new String[]{}, new LogLeecher[]{},                projectPath.toString());        Assert.assertTrue(Files.exists(projectPath.resolve(\"src\").resolve(moduleName)));        Assert.assertTrue(Files.isDirectory(projectPath.resolve(\"src\").resolve(moduleName)));    }    @Test(description = \"Test pushing a package to central\", dependsOnMethods = \"testCreateProject\")    public void testPush() throws Exception {        Path projectPath = tempProjectDirectory.resolve(\"initProject\");        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd-EE\");        datePushed = dtf.format(LocalDateTime.now());        String firstMsg = \"error: cannot find balo file for the module: \" + moduleName + \". Run \" +                          \"'ballerina build -c <module_name>' to compile and generate the balo.\";        LogLeecher clientLeecher = new LogLeecher(firstMsg, LeecherType.ERROR);        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},                          new LogLeecher[]{clientLeecher}, projectPath.toString());        clientLeecher.waitForText(2000);        String baloFileName = moduleName + \"-\"                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"                              + ProgramFileConstants.ANY_PLATFORM + \"-\"                              + \"0.1.0\"                              + BLANG_COMPILED_PKG_BINARY_EXT;        Path baloPath = projectPath.resolve(\"target\").resolve(\"balo\").resolve(baloFileName);        Assert.assertTrue(Files.notExists(baloPath));        String buildMessage = \"Created target\" + File.separator + \"balo\" + File.separator + baloFileName;        clientLeecher = new LogLeecher(buildMessage);        balClient.runMain(\"build\", new String[]{\"-c\", moduleName}, envVariables, new String[]{},                new LogLeecher[]{clientLeecher}, projectPath.toString());        String secondMsg = orgName + \"/\" + moduleName + \":0.1.0\" + REPO_TO_CENTRAL_SUCCESS_MSG;        clientLeecher = new LogLeecher(secondMsg, LeecherType.INFO);        balClient.runMain(\"push\", new String[]{moduleName}, envVariables, new String[]{},                          new LogLeecher[]{clientLeecher}, projectPath.toString());        clientLeecher.waitForText(60000);    }    @Test(description = \"Test pulling a package from central\", dependsOnMethods = \"testPush\")    public void testPull() {        String baloFileName = moduleName + \"-\"                              + ProgramFileConstants.IMPLEMENTATION_VERSION + \"-\"                              + ProgramFileConstants.ANY_PLATFORM + \"-\"                              + \"0.1.0\"                              + BLANG_COMPILED_PKG_BINARY_EXT;        Path baloPath = Paths.get(ProjectDirConstants.BALO_CACHE_DIR_NAME,                                 orgName, moduleName, \"0.1.0\");        given().with().pollInterval(Duration.TEN_SECONDS).and()               .with().pollDelay(Duration.FIVE_SECONDS)               .await().atMost(90, SECONDS).until(() -> {            String[] clientArgs = {orgName + \"/\" + moduleName + \":0.1.0\"};            balClient.runMain(\"pull\", clientArgs, envVariables, new String[]{},                    new LogLeecher[]{}, balServer.getServerHome());            totalPullCount += 1;            return Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName));        });        Assert.assertTrue(Files.exists(tempHomeDirectory.resolve(baloPath).resolve(baloFileName)));    }    @Test(description = \"Test searching a package from central\", dependsOnMethods = \"testPush\")    public void testSearch() throws BallerinaTestException {        String actualMsg = balClient.runMainAndReadStdOut(\"search\", new String[]{moduleName}, envVariables,                balServer.getServerHome(), false);        Assert.assertTrue(actualMsg.contains(\"Ballerina Central\"));        Assert.assertTrue(actualMsg.contains(\"NAME\"));        Assert.assertTrue(actualMsg.contains(\"DESCRIPTION\"));        Assert.assertTrue(actualMsg.contains(\"DATE\"));        Assert.assertTrue(actualMsg.contains(\"VERSION\"));        Assert.assertTrue(actualMsg.contains(datePushed));        Assert.assertTrue(actualMsg.contains(\"0.1.0\"));    }    @Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)    public void testPullCount() throws IOException {        initializeSsl();        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"    private Map<String, String> addEnvVariables(Map<String, String> envVariables) {        envVariables.put(ProjectDirConstants.HOME_REPO_ENV_KEY, tempHomeDirectory.toString());        envVariables.put(BALLERINA_STAGE_CENTRAL, \"true\");        return envVariables;    }    @AfterClass    private void cleanup() throws Exception {        PackerinaTestUtils.deleteFiles(tempHomeDirectory);        PackerinaTestUtils.deleteFiles(tempProjectDirectory);    }}"}
{"code": "import io.undertow.websockets.core.AbstractReceiveListener;import io.undertow.websockets.core.BufferedBinaryMessage;import io.undertow.websockets.core.BufferedTextMessage;import io.undertow.websockets.core.StreamSourceFrameChannel;import io.undertow.websockets.core.UTF8Output;import io.undertow.websockets.core.WebSocketCallback;import io.undertow.websockets.core.WebSocketChannel;import io.undertow.websockets.core.WebSockets;import io.undertow.websockets.jsr.util.ClassUtils;import org.xnio.Buffers;import org.xnio.Pooled;import javax.websocket.CloseReason;import javax.websocket.Endpoint;import javax.websocket.MessageHandler;import javax.websocket.PongMessage;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.io.Reader;import java.io.StringReader;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;import java.util.concurrent.Executor;class FrameHandler extends AbstractReceiveListener {    private final Endpoint endpoint;    private final UndertowSession session;    protected static final byte[] EMPTY = new byte[0];    private final ConcurrentMap<FrameType, HandlerWrapper> handlers = new ConcurrentHashMap<>();    private final Executor executor;    enum FrameType {        PONG,        BYTE,        TEXT    }    protected FrameHandler(UndertowSession session, Endpoint endpoint) {        this.session = session;        this.endpoint = endpoint;        final Executor executor;        if (session.getContainer().isDispatchToWorker()) {            executor = new OrderedExecutor(session.getWebSocketChannel().getWorker());        } else {            executor = session.getWebSocketChannel().getIoThread();        }        this.executor = executor;    }    @Override    protected void onFullCloseMessage(final WebSocketChannel channel, final BufferedBinaryMessage message) {        if(session.isSessionClosed()) {            message.getData().free();            return;        }        final Pooled<ByteBuffer[]> pooled = message.getData();        final ByteBuffer singleBuffer = toBuffer(pooled.getResource());        final ByteBuffer toSend = singleBuffer.duplicate();        WebSockets.sendClose(toSend, channel, null);        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                try {                    if (singleBuffer.remaining() > 1) {                        final CloseReason.CloseCode code = CloseReason.CloseCodes.getCloseCode(singleBuffer.getShort());                        final String reasonPhrase = singleBuffer.remaining() > 1 ? new UTF8Output(singleBuffer).extract() : null;                        session.closeInternal(new CloseReason(code, reasonPhrase));                    } else {                        session.closeInternal(new CloseReason(CloseReason.CloseCodes.NO_STATUS_CODE, null));                    }                } catch (IOException e) {                    invokeOnError(e);                } finally {                    pooled.close();                }            }        });    }    private void invokeOnError(final Throwable e) {        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                getEndpoint().onError(session, e);            }        });    }    @Override    protected void onFullPongMessage(final WebSocketChannel webSocketChannel, BufferedBinaryMessage bufferedBinaryMessage) {        if(session.isSessionClosed()) {            bufferedBinaryMessage.getData().free();            return;        }        final HandlerWrapper handler = getHandler(FrameType.PONG);        if (handler != null) {            final Pooled<ByteBuffer[]> pooled = bufferedBinaryMessage.getData();            final PongMessage message = DefaultPongMessage.create(toBuffer(pooled.getResource()));            session.getContainer().invokeEndpointMethod(executor, new Runnable() {                @Override                public void run() {                    try {                        ((MessageHandler.Whole) handler.getHandler()).onMessage(message);                    } catch (Exception e) {                        invokeOnError(e);                    } finally {                        pooled.close();                    }                }            });        } else {            bufferedBinaryMessage.getData().free();        }    }    @Override    protected void onText(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {        if(session.isSessionClosed()) {            messageChannel.close();            return;        }        final HandlerWrapper handler = getHandler(FrameType.TEXT);        if (handler != null && handler.isPartialHandler()) {            BufferedTextMessage data = new BufferedTextMessage(false);            data.read(messageChannel, new WebSocketCallback<BufferedTextMessage>() {                @Override                public void complete(WebSocketChannel channel, BufferedTextMessage context) {                    invokeTextHandler(context, handler, context.isComplete());                }                @Override                public void onError(WebSocketChannel channel, BufferedTextMessage context, Throwable throwable) {                    invokeOnError(throwable);                }            });        } else {            bufferFullMessage(messageChannel);        }    }    @Override    protected void onBinary(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {        if(session.isSessionClosed()) {            messageChannel.close();            return;        }        final HandlerWrapper handler = getHandler(FrameType.BYTE);        if (handler != null && handler.isPartialHandler()) {            BufferedBinaryMessage data = new BufferedBinaryMessage(session.getMaxBinaryMessageBufferSize(), false);            data.read(messageChannel, new WebSocketCallback<BufferedBinaryMessage>() {                @Override                public void complete(WebSocketChannel channel, BufferedBinaryMessage context) {                    invokeBinaryHandler(context, handler, context.isComplete());                }                @Override                public void onError(WebSocketChannel channel, BufferedBinaryMessage context, Throwable throwable) {                    invokeOnError(throwable);                }            });        } else {            bufferFullMessage(messageChannel);        }    }    private void invokeBinaryHandler(final BufferedBinaryMessage context, final HandlerWrapper handler, final boolean finalFragment) {        final Pooled<ByteBuffer[]> pooled = context.getData();        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                try {                    if (handler.isPartialHandler()) {                        MessageHandler.Partial mHandler = (MessageHandler.Partial) handler.getHandler();                        ByteBuffer[] payload = pooled.getResource();                        if(handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));                            mHandler.onMessage(object, finalFragment);                        } else if (handler.getMessageType() == ByteBuffer.class) {                            mHandler.onMessage(toBuffer(payload), finalFragment);                        } else if (handler.getMessageType() == byte[].class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(data, finalFragment);                        } else if (handler.getMessageType() == InputStream.class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(new ByteArrayInputStream(data), finalFragment);                        }                    } else {                        MessageHandler.Whole mHandler = (MessageHandler.Whole) handler.getHandler();                        ByteBuffer[] payload = pooled.getResource();                        if(handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));                            mHandler.onMessage(object);                        } else if (handler.getMessageType() == ByteBuffer.class) {                            mHandler.onMessage(toBuffer(payload));                        } else if (handler.getMessageType() == byte[].class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(data);                        } else if (handler.getMessageType() == InputStream.class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(new ByteArrayInputStream(data));                        }                    }                } catch (Exception e) {                    invokeOnError(e);                } finally {                    pooled.close();                }            }        });    }    private void invokeTextHandler(final BufferedTextMessage data, final HandlerWrapper handler, final boolean finalFragment) {        final String message = data.getData();        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                MessageHandler mHandler = handler.getHandler();                try {                    if (mHandler instanceof MessageHandler.Partial) {                        if (handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);                            ((MessageHandler.Partial) handler.getHandler()).onMessage(object, finalFragment);                        } else if (handler.getMessageType() == String.class) {                            ((MessageHandler.Partial) handler.getHandler()).onMessage(message, finalFragment);                        } else if (handler.getMessageType() == Reader.class) {                            ((MessageHandler.Partial) handler.getHandler()).onMessage(new StringReader(message), finalFragment);                        }                    } else {                        if(handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);                            ((MessageHandler.Whole) handler.getHandler()).onMessage(object);                        } else if (handler.getMessageType() == String.class) {                            ((MessageHandler.Whole) handler.getHandler()).onMessage(message);                        } else if (handler.getMessageType() == Reader.class) {                            ((MessageHandler.Whole) handler.getHandler()).onMessage(new StringReader(message));                        }                    }                } catch (Exception e) {                    invokeOnError(e);                }            }        });    }    @Override    protected void onError(WebSocketChannel channel, Throwable error) {        try {            getEndpoint().onError(session, error);        } finally {            session.forceClose();        }    }    @Override    protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) {        if(session.isSessionClosed()) {            return;        }        HandlerWrapper handler = getHandler(FrameType.TEXT);        if (handler != null) {            invokeTextHandler(message, handler, true);        }    }    @Override    protected void onFullBinaryMessage(WebSocketChannel channel, BufferedBinaryMessage message) {        if(session.isSessionClosed()) {            message.getData().close();            return;        }        HandlerWrapper handler = getHandler(FrameType.BYTE);        if (handler != null) {            invokeBinaryHandler(message, handler, true);        } else {            message.getData().close();        }    }    protected static ByteBuffer toBuffer(ByteBuffer... payload) {        if (payload.length == 1) {            return payload[0];        }        int size = (int) Buffers.remaining(payload);        if (size == 0) {            return Buffers.EMPTY_BYTE_BUFFER;        }        ByteBuffer buffer = ByteBuffer.allocate(size);        for (ByteBuffer buf : payload) {            buffer.put(buf);        }        buffer.flip();        return buffer;    }    protected static byte[] toArray(ByteBuffer... payload) {        if (payload.length == 1) {            ByteBuffer buf = payload[0];            if (buf.hasArray()                    && buf.arrayOffset() == 0                    && buf.position() == 0                    && buf.array().length == buf.remaining()) {                return buf.array();            }        }        return Buffers.take(payload, 0, payload.length);    }    public final void addHandler(Class<?> messageType, MessageHandler handler) {        addHandlerInternal(handler, messageType, handler instanceof MessageHandler.Partial);    }    public final void addHandler(MessageHandler handler) {        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());        for (Entry<Class<?>, Boolean> e : types.entrySet()) {            Class<?> type = e.getKey();            boolean partial = e.getValue();            addHandlerInternal(handler, type, partial);        }    }    private void addHandlerInternal(MessageHandler handler, Class<?> type, boolean partial) {        verify(type, handler);        List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, partial);        for(HandlerWrapper handlerWrapper : handlerWrappers) {            if (handlers.containsKey(handlerWrapper.getFrameType())) {                throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());            } else {                if (handlers.putIfAbsent(handlerWrapper.getFrameType(), handlerWrapper) != null) {                    throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());                }            }        }    }    protected List<HandlerWrapper> createHandlerWrappers(Class<?> type, MessageHandler handler, boolean partialHandler) {        Encoding encoding = session.getEncoding();        List<HandlerWrapper> ret = new ArrayList<>(2);        if (encoding.canDecodeText(type)) {            ret.add(new HandlerWrapper(FrameType.TEXT, handler, type, true, false));        }        if (encoding.canDecodeBinary(type)) {            ret.add(new HandlerWrapper(FrameType.BYTE, handler, type, true, false));        }        if(!ret.isEmpty()) {            return ret;        }        if (partialHandler) {            if (type == String.class) {                return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, true));            }            if (type == byte[].class || type == ByteBuffer.class) {                return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, true));            }            throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);        }        if (type == byte[].class || type == ByteBuffer.class || type == InputStream.class) {            return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, false));        }        if (type == String.class || type == Reader.class) {            return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, false));        }        if (type == PongMessage.class) {            return Collections.singletonList(new HandlerWrapper(FrameType.PONG, handler, type, false, false));        }        throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);    }    protected void verify(Class<?> type, MessageHandler handler) {    }    public final void removeHandler(MessageHandler handler) {        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());        for (Entry<Class<?>, Boolean> e : types.entrySet()) {            Class<?> type = e.getKey();            List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, e.getValue());            for(HandlerWrapper handlerWrapper : handlerWrappers) {                FrameType frameType = handlerWrapper.getFrameType();                HandlerWrapper wrapper = handlers.get(frameType);                if (wrapper != null && wrapper.getMessageType() == type) {                    handlers.remove(frameType, wrapper);                }            }        }    }    public final Set<MessageHandler> getHandlers() {        Set<MessageHandler> msgHandlers = new HashSet<>();        for (HandlerWrapper handler : handlers.values()) {            msgHandlers.add(handler.getHandler());        }        return msgHandlers;    }    protected final HandlerWrapper getHandler(FrameType type) {        return handlers.get(type);    }    @Override    protected long getMaxTextBufferSize() {        return session.getMaxTextMessageBufferSize();    }    protected long getMaxBinaryBufferSize() {        return session.getMaxBinaryMessageBufferSize();    }    static final class HandlerWrapper {        private final FrameType frameType;        private final MessageHandler handler;        private final Class<?> msgType;        private final boolean decodingNeeded;        private final boolean partialHandler;        private HandlerWrapper(final FrameType frameType, MessageHandler handler, final Class<?> msgType, final boolean decodingNeeded, final boolean partialHandler) {            this.frameType = frameType;            this.handler = handler;            this.msgType = msgType;            this.decodingNeeded = decodingNeeded;            this.partialHandler = partialHandler;        }        public MessageHandler getHandler() {            return handler;        }        public Class<?> getMessageType() {            return msgType;        }        FrameType getFrameType() {            return frameType;        }        boolean isDecodingNeeded() {            return decodingNeeded;        }        boolean isPartialHandler() {            return partialHandler;        }    }    public Executor getExecutor() {        return executor;    }    UndertowSession getSession() {        return session;    }    Endpoint getEndpoint() {        return endpoint;    }}", "nl": "import io.undertow.websockets.core.AbstractReceiveListener;import io.undertow.websockets.core.BufferedBinaryMessage;import io.undertow.websockets.core.BufferedTextMessage;import io.undertow.websockets.core.StreamSourceFrameChannel;import io.undertow.websockets.core.UTF8Output;import io.undertow.websockets.core.WebSocketCallback;import io.undertow.websockets.core.WebSocketChannel;import io.undertow.websockets.core.WebSockets;import io.undertow.websockets.jsr.util.ClassUtils;import org.xnio.Buffers;import org.xnio.Pooled;import javax.websocket.CloseReason;import javax.websocket.Endpoint;import javax.websocket.MessageHandler;import javax.websocket.PongMessage;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.io.Reader;import java.io.StringReader;import java.nio.ByteBuffer;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;import java.util.concurrent.Executor;class FrameHandler extends AbstractReceiveListener {    private final Endpoint endpoint;    private final UndertowSession session;    protected static final byte[] EMPTY = new byte[0];    private final ConcurrentMap<FrameType, HandlerWrapper> handlers = new ConcurrentHashMap<>();    private final Executor executor;    enum FrameType {        PONG,        BYTE,        TEXT    }    protected FrameHandler(UndertowSession session, Endpoint endpoint) {        this.session = session;        this.endpoint = endpoint;        final Executor executor;        if (session.getContainer().isDispatchToWorker()) {            executor = new OrderedExecutor(session.getWebSocketChannel().getWorker());        } else {            executor = session.getWebSocketChannel().getIoThread();        }        this.executor = executor;    }    @Override    protected void onFullCloseMessage(final WebSocketChannel channel, final BufferedBinaryMessage message) {        if(session.isSessionClosed()) {            message.getData().free();            return;        }        final Pooled<ByteBuffer[]> pooled = message.getData();        final ByteBuffer singleBuffer = toBuffer(pooled.getResource());        final ByteBuffer toSend = singleBuffer.duplicate();        WebSockets.sendClose(toSend, channel, null);        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                try {                    if (singleBuffer.remaining() > 1) {                        final CloseReason.CloseCode code = CloseReason.CloseCodes.getCloseCode(singleBuffer.getShort());                        final String reasonPhrase = singleBuffer.remaining() > 1 ? new UTF8Output(singleBuffer).extract() : null;                        session.closeInternal(new CloseReason(code, reasonPhrase));                    } else {                        session.closeInternal(new CloseReason(CloseReason.CloseCodes.NO_STATUS_CODE, null));                    }                } catch (IOException e) {                    invokeOnError(e);                } finally {                    pooled.close();                }            }        });    }    private void invokeOnError(final Throwable e) {        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                getEndpoint().onError(session, e);            }        });    }    @Override    protected void onFullPongMessage(final WebSocketChannel webSocketChannel, BufferedBinaryMessage bufferedBinaryMessage) {        if(session.isSessionClosed()) {            bufferedBinaryMessage.getData().free();            return;        }        final HandlerWrapper handler = getHandler(FrameType.PONG);        if (handler != null) {            final Pooled<ByteBuffer[]> pooled = bufferedBinaryMessage.getData();            final PongMessage message = DefaultPongMessage.create(toBuffer(pooled.getResource()));            session.getContainer().invokeEndpointMethod(executor, new Runnable() {                @Override                public void run() {                    try {                        ((MessageHandler.Whole) handler.getHandler()).onMessage(message);                    } catch (Exception e) {                        invokeOnError(e);                    } finally {                        pooled.close();                    }                }            });        }    }    @Override    protected void onText(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {        if(session.isSessionClosed()) {            messageChannel.close();            return;        }        final HandlerWrapper handler = getHandler(FrameType.TEXT);        if (handler != null && handler.isPartialHandler()) {            BufferedTextMessage data = new BufferedTextMessage(false);            data.read(messageChannel, new WebSocketCallback<BufferedTextMessage>() {                @Override                public void complete(WebSocketChannel channel, BufferedTextMessage context) {                    invokeTextHandler(context, handler, context.isComplete());                }                @Override                public void onError(WebSocketChannel channel, BufferedTextMessage context, Throwable throwable) {                    invokeOnError(throwable);                }            });        } else {            bufferFullMessage(messageChannel);        }    }    @Override    protected void onBinary(WebSocketChannel webSocketChannel, StreamSourceFrameChannel messageChannel) throws IOException {        if(session.isSessionClosed()) {            messageChannel.close();            return;        }        final HandlerWrapper handler = getHandler(FrameType.BYTE);        if (handler != null && handler.isPartialHandler()) {            BufferedBinaryMessage data = new BufferedBinaryMessage(session.getMaxBinaryMessageBufferSize(), false);            data.read(messageChannel, new WebSocketCallback<BufferedBinaryMessage>() {                @Override                public void complete(WebSocketChannel channel, BufferedBinaryMessage context) {                    invokeBinaryHandler(context, handler, context.isComplete());                }                @Override                public void onError(WebSocketChannel channel, BufferedBinaryMessage context, Throwable throwable) {                    invokeOnError(throwable);                }            });        } else {            bufferFullMessage(messageChannel);        }    }    private void invokeBinaryHandler(final BufferedBinaryMessage context, final HandlerWrapper handler, final boolean finalFragment) {        final Pooled<ByteBuffer[]> pooled = context.getData();        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                try {                    if (handler.isPartialHandler()) {                        MessageHandler.Partial mHandler = (MessageHandler.Partial) handler.getHandler();                        ByteBuffer[] payload = pooled.getResource();                        if(handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));                            mHandler.onMessage(object, finalFragment);                        } else if (handler.getMessageType() == ByteBuffer.class) {                            mHandler.onMessage(toBuffer(payload), finalFragment);                        } else if (handler.getMessageType() == byte[].class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(data, finalFragment);                        } else if (handler.getMessageType() == InputStream.class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(new ByteArrayInputStream(data), finalFragment);                        }                    } else {                        MessageHandler.Whole mHandler = (MessageHandler.Whole) handler.getHandler();                        ByteBuffer[] payload = pooled.getResource();                        if(handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeBinary(handler.getMessageType(), toArray(payload));                            mHandler.onMessage(object);                        } else if (handler.getMessageType() == ByteBuffer.class) {                            mHandler.onMessage(toBuffer(payload));                        } else if (handler.getMessageType() == byte[].class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(data);                        } else if (handler.getMessageType() == InputStream.class) {                            byte[] data = toArray(payload);                            mHandler.onMessage(new ByteArrayInputStream(data));                        }                    }                } catch (Exception e) {                    invokeOnError(e);                } finally {                    pooled.close();                }            }        });    }    private void invokeTextHandler(final BufferedTextMessage data, final HandlerWrapper handler, final boolean finalFragment) {        final String message = data.getData();        session.getContainer().invokeEndpointMethod(executor, new Runnable() {            @Override            public void run() {                MessageHandler mHandler = handler.getHandler();                try {                    if (mHandler instanceof MessageHandler.Partial) {                        if (handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);                            ((MessageHandler.Partial) handler.getHandler()).onMessage(object, finalFragment);                        } else if (handler.getMessageType() == String.class) {                            ((MessageHandler.Partial) handler.getHandler()).onMessage(message, finalFragment);                        } else if (handler.getMessageType() == Reader.class) {                            ((MessageHandler.Partial) handler.getHandler()).onMessage(new StringReader(message), finalFragment);                        }                    } else {                        if(handler.decodingNeeded) {                            Object object = getSession().getEncoding().decodeText(handler.getMessageType(), message);                            ((MessageHandler.Whole) handler.getHandler()).onMessage(object);                        } else if (handler.getMessageType() == String.class) {                            ((MessageHandler.Whole) handler.getHandler()).onMessage(message);                        } else if (handler.getMessageType() == Reader.class) {                            ((MessageHandler.Whole) handler.getHandler()).onMessage(new StringReader(message));                        }                    }                } catch (Exception e) {                    invokeOnError(e);                }            }        });    }    @Override    protected void onError(WebSocketChannel channel, Throwable error) {        try {            getEndpoint().onError(session, error);        } finally {            session.forceClose();        }    }    @Override    protected void onFullTextMessage(WebSocketChannel channel, BufferedTextMessage message) {        if(session.isSessionClosed()) {            return;        }        HandlerWrapper handler = getHandler(FrameType.TEXT);        if (handler != null) {            invokeTextHandler(message, handler, true);        }    }    @Override    protected void onFullBinaryMessage(WebSocketChannel channel, BufferedBinaryMessage message) {        if(session.isSessionClosed()) {            message.getData().close();            return;        }        HandlerWrapper handler = getHandler(FrameType.BYTE);        if (handler != null) {            invokeBinaryHandler(message, handler, true);        } else {            message.getData().close();        }    }    protected static ByteBuffer toBuffer(ByteBuffer... payload) {        if (payload.length == 1) {            return payload[0];        }        int size = (int) Buffers.remaining(payload);        if (size == 0) {            return Buffers.EMPTY_BYTE_BUFFER;        }        ByteBuffer buffer = ByteBuffer.allocate(size);        for (ByteBuffer buf : payload) {            buffer.put(buf);        }        buffer.flip();        return buffer;    }    protected static byte[] toArray(ByteBuffer... payload) {        if (payload.length == 1) {            ByteBuffer buf = payload[0];            if (buf.hasArray()                    && buf.arrayOffset() == 0                    && buf.position() == 0                    && buf.array().length == buf.remaining()) {                return buf.array();            }        }        return Buffers.take(payload, 0, payload.length);    }    public final void addHandler(Class<?> messageType, MessageHandler handler) {        addHandlerInternal(handler, messageType, handler instanceof MessageHandler.Partial);    }    public final void addHandler(MessageHandler handler) {        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());        for (Entry<Class<?>, Boolean> e : types.entrySet()) {            Class<?> type = e.getKey();            boolean partial = e.getValue();            addHandlerInternal(handler, type, partial);        }    }    private void addHandlerInternal(MessageHandler handler, Class<?> type, boolean partial) {        verify(type, handler);        List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, partial);        for(HandlerWrapper handlerWrapper : handlerWrappers) {            if (handlers.containsKey(handlerWrapper.getFrameType())) {                throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());            } else {                if (handlers.putIfAbsent(handlerWrapper.getFrameType(), handlerWrapper) != null) {                    throw JsrWebSocketMessages.MESSAGES.handlerAlreadyRegistered(handlerWrapper.getFrameType());                }            }        }    }    protected List<HandlerWrapper> createHandlerWrappers(Class<?> type, MessageHandler handler, boolean partialHandler) {        Encoding encoding = session.getEncoding();        List<HandlerWrapper> ret = new ArrayList<>(2);        if (encoding.canDecodeText(type)) {            ret.add(new HandlerWrapper(FrameType.TEXT, handler, type, true, false));        }        if (encoding.canDecodeBinary(type)) {            ret.add(new HandlerWrapper(FrameType.BYTE, handler, type, true, false));        }        if(!ret.isEmpty()) {            return ret;        }        if (partialHandler) {            if (type == String.class) {                return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, true));            }            if (type == byte[].class || type == ByteBuffer.class) {                return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, true));            }            throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);        }        if (type == byte[].class || type == ByteBuffer.class || type == InputStream.class) {            return Collections.singletonList(new HandlerWrapper(FrameType.BYTE, handler, type, false, false));        }        if (type == String.class || type == Reader.class) {            return Collections.singletonList(new HandlerWrapper(FrameType.TEXT, handler, type, false, false));        }        if (type == PongMessage.class) {            return Collections.singletonList(new HandlerWrapper(FrameType.PONG, handler, type, false, false));        }        throw JsrWebSocketMessages.MESSAGES.unsupportedFrameType(type);    }    protected void verify(Class<?> type, MessageHandler handler) {    }    public final void removeHandler(MessageHandler handler) {        Map<Class<?>, Boolean> types = ClassUtils.getHandlerTypes(handler.getClass());        for (Entry<Class<?>, Boolean> e : types.entrySet()) {            Class<?> type = e.getKey();            List<HandlerWrapper> handlerWrappers = createHandlerWrappers(type, handler, e.getValue());            for(HandlerWrapper handlerWrapper : handlerWrappers) {                FrameType frameType = handlerWrapper.getFrameType();                HandlerWrapper wrapper = handlers.get(frameType);                if (wrapper != null && wrapper.getMessageType() == type) {                    handlers.remove(frameType, wrapper);                }            }        }    }    public final Set<MessageHandler> getHandlers() {        Set<MessageHandler> msgHandlers = new HashSet<>();        for (HandlerWrapper handler : handlers.values()) {            msgHandlers.add(handler.getHandler());        }        return msgHandlers;    }    protected final HandlerWrapper getHandler(FrameType type) {        return handlers.get(type);    }    @Override    protected long getMaxTextBufferSize() {        return session.getMaxTextMessageBufferSize();    }    protected long getMaxBinaryBufferSize() {        return session.getMaxBinaryMessageBufferSize();    }    static final class HandlerWrapper {        private final FrameType frameType;        private final MessageHandler handler;        private final Class<?> msgType;        private final boolean decodingNeeded;        private final boolean partialHandler;        private HandlerWrapper(final FrameType frameType, MessageHandler handler, final Class<?> msgType, final boolean decodingNeeded, final boolean partialHandler) {            this.frameType = frameType;            this.handler = handler;            this.msgType = msgType;            this.decodingNeeded = decodingNeeded;            this.partialHandler = partialHandler;        }        public MessageHandler getHandler() {            return handler;        }        public Class<?> getMessageType() {            return msgType;        }        FrameType getFrameType() {            return frameType;        }        boolean isDecodingNeeded() {            return decodingNeeded;        }        boolean isPartialHandler() {            return partialHandler;        }    }    public Executor getExecutor() {        return executor;    }    UndertowSession getSession() {        return session;    }    Endpoint getEndpoint() {        return endpoint;    }}"}
{"code": "import io.undertow.util.HeaderMap;import io.undertow.util.HeaderValues;import io.undertow.util.Headers;import io.undertow.util.HttpString;import java.nio.ByteBuffer;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Collections;import java.util.Deque;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;import static io.undertow.protocols.http2.Hpack.HeaderField;import static io.undertow.protocols.http2.Hpack.STATIC_TABLE;import static io.undertow.protocols.http2.Hpack.STATIC_TABLE_LENGTH;import static io.undertow.protocols.http2.Hpack.encodeInteger;public class HpackEncoder {    private static final Set<HttpString> SKIP;    static {        Set<HttpString> set = new HashSet<>();        set.add(Headers.CONNECTION);        set.add(Headers.TRANSFER_ENCODING);        set.add(Headers.KEEP_ALIVE);        set.add(Headers.UPGRADE);        SKIP = Collections.unmodifiableSet(set);    }    public static final HpackHeaderFunction DEFAULT_HEADER_FUNCTION = new HpackHeaderFunction() {        @Override        public boolean shouldUseIndexing(HttpString headerName, String value) {            return !headerName.equals(Headers.CONTENT_LENGTH) && !headerName.equals(Headers.DATE);        }        @Override        public boolean shouldUseHuffman(HttpString header, String value) {            return value.length() > 10;         }        @Override        public boolean shouldUseHuffman(HttpString header) {            return header.length() > 10;         }    };    private long headersIterator = -1;    private boolean firstPass = true;    private HeaderMap currentHeaders;    private int entryPositionCounter;    private int newMaxHeaderSize = -1;     private int minNewMaxHeaderSize = -1;     private static final Map<HttpString, TableEntry[]> ENCODING_STATIC_TABLE;    private final Deque<TableEntry> evictionQueue = new ArrayDeque<>();    private final Map<HttpString, List<TableEntry>> dynamicTable = new HashMap<>();    private byte[] overflowData;    private int overflowPos;    private int overflowLength;    static {        Map<HttpString, TableEntry[]> map = new HashMap<>();        for (int i = 1; i < STATIC_TABLE.length; ++i) {            HeaderField m = STATIC_TABLE[i];            TableEntry[] existing = map.get(m.name);            if (existing == null) {                map.put(m.name, new TableEntry[]{new TableEntry(m.name, m.value, i)});            } else {                TableEntry[] newEntry = new TableEntry[existing.length + 1];                System.arraycopy(existing, 0, newEntry, 0, existing.length);                newEntry[existing.length] = new TableEntry(m.name, m.value, i);                map.put(m.name, newEntry);            }        }        ENCODING_STATIC_TABLE = Collections.unmodifiableMap(map);    }    private int maxTableSize;    private int currentTableSize;    private final HpackHeaderFunction hpackHeaderFunction;    public HpackEncoder(int maxTableSize, HpackHeaderFunction headerFunction) {        this.maxTableSize = maxTableSize;        this.hpackHeaderFunction = headerFunction;    }    public HpackEncoder(int maxTableSize) {        this(maxTableSize, DEFAULT_HEADER_FUNCTION);    }    public State encode(HeaderMap headers, ByteBuffer target) {        if(overflowData != null) {            for(int i = overflowPos; i < overflowLength; ++i) {                if(!target.hasRemaining()) {                    overflowPos = i;                    return State.OVERFLOW;                }                target.put(overflowData[i]);            }            overflowData = null;        }        long it = headersIterator;        if (headersIterator == -1) {            handleTableSizeChange(target);            it = headers.fastIterate();            currentHeaders = headers;        } else {            if (headers != currentHeaders) {                throw new IllegalStateException();            }            it = headers.fiNext(it);        }        while (it != -1) {            HeaderValues values = headers.fiCurrent(it);            boolean skip = false;            if (firstPass) {                if (values.getHeaderName().byteAt(0) != ':') {                    skip = true;                }            } else {                if (values.getHeaderName().byteAt(0) == ':') {                    skip = true;                }            }            if(SKIP.contains(values.getHeaderName())) {                skip = true;            }            if (!skip) {                for (int i = 0; i < values.size(); ++i) {                    HttpString headerName = values.getHeaderName();                    int required = 11 + headerName.length();                     String val = values.get(i);                    for(int v = 0; v < val.length(); ++v) {                        char c = val.charAt(v);                        if(c == '\\r' || c == '\\n') {                            val = val.replace('\\r', ' ').replace('\\n', ' ');                            break;                        }                    }                    TableEntry tableEntry = findInTable(headerName, val);                    required += (1 + val.length());                    boolean overflowing = false;                    ByteBuffer current = target;                    if (current.remaining() < required) {                        overflowing = true;                        current = ByteBuffer.wrap(overflowData = new byte[required]);                        overflowPos = 0;                    }                    boolean canIndex = hpackHeaderFunction.shouldUseIndexing(headerName, val) && (headerName.length() + val.length() + 32) < maxTableSize;                     if (tableEntry == null && canIndex) {                        current.put((byte) (1 << 6));                        writeHuffmanEncodableName(current, headerName);                        writeHuffmanEncodableValue(current, headerName, val);                        addToDynamicTable(headerName, val);                    } else if (tableEntry == null) {                        current.put((byte) (1 << 4));                        writeHuffmanEncodableName(current, headerName);                        writeHuffmanEncodableValue(current, headerName, val);                    } else {                        if (val.equals(tableEntry.value)) {                            current.put((byte) (1 << 7));                            encodeInteger(current, tableEntry.getPosition(), 7);                        } else {                            if (canIndex) {                                current.put((byte) (1 << 6));                                encodeInteger(current, tableEntry.getPosition(), 6);                                writeHuffmanEncodableValue(current, headerName, val);                                addToDynamicTable(headerName, val);                            } else {                                current.put((byte) (1 << 4));                                encodeInteger(current, tableEntry.getPosition(), 4);                                writeHuffmanEncodableValue(current, headerName, val);                            }                        }                    }                    if(overflowing) {                        this.headersIterator = it;                        this.overflowLength = current.position();                        return State.OVERFLOW;                    }                }            }            it = headers.fiNext(it);            if (it == -1 && firstPass) {                firstPass = false;                it = headers.fastIterate();            }        }        headersIterator = -1;        firstPass = true;        return State.COMPLETE;    }    private void writeHuffmanEncodableName(ByteBuffer target, HttpString headerName) {        if (hpackHeaderFunction.shouldUseHuffman(headerName)) {            if(HPackHuffman.encode(target, headerName.toString(), true)) {                return;            }        }        target.put((byte) 0);         encodeInteger(target, headerName.length(), 7);        for (int j = 0; j < headerName.length(); ++j) {            target.put(Hpack.toLower(headerName.byteAt(j)));        }    }    private void writeHuffmanEncodableValue(ByteBuffer target, HttpString headerName, String val) {        if (hpackHeaderFunction.shouldUseHuffman(headerName, val)) {            if (!HPackHuffman.encode(target, val, false)) {                writeValueString(target, val);            }        } else {            writeValueString(target, val);        }    }    private void writeValueString(ByteBuffer target, String val) {        target.put((byte) 0);         encodeInteger(target, val.length(), 7);        for (int j = 0; j < val.length(); ++j) {            target.put((byte) val.charAt(j));        }    }    private void addToDynamicTable(HttpString headerName, String val) {        int pos = entryPositionCounter++;        DynamicTableEntry d = new DynamicTableEntry(headerName, val, -pos);        List<TableEntry> existing = dynamicTable.get(headerName);        if (existing == null) {            dynamicTable.put(headerName, existing = new ArrayList<>(1));        }        existing.add(d);        evictionQueue.add(d);        currentTableSize += d.size;        runEvictionIfRequired();        if (entryPositionCounter == Integer.MAX_VALUE) {            preventPositionRollover();        }    }    private void preventPositionRollover() {        for (Map.Entry<HttpString, List<TableEntry>> entry : dynamicTable.entrySet()) {            for (TableEntry t : entry.getValue()) {                t.position = t.getPosition();            }        }        entryPositionCounter = 0;    }    private void runEvictionIfRequired() {        while (currentTableSize > maxTableSize) {            TableEntry next = evictionQueue.poll();            if (next == null) {                return;            }            currentTableSize -= next.size;            List<TableEntry> list = dynamicTable.get(next.name);            list.remove(next);            if (list.isEmpty()) {                dynamicTable.remove(next.name);            }        }    }    private TableEntry findInTable(HttpString headerName, String value) {        TableEntry[] staticTable = ENCODING_STATIC_TABLE.get(headerName);        if (staticTable != null) {            for (TableEntry st : staticTable) {                if (st.value != null && st.value.equals(value)) {                     return st;                }            }        }        List<TableEntry> dynamic = dynamicTable.get(headerName);        if (dynamic != null) {            for (int i = 0; i < dynamic.size(); ++i) {                TableEntry st = dynamic.get(i);                if (st.value.equals(value)) {                     return st;                }            }        }        if (staticTable != null) {            return staticTable[0];        }        return null;    }    public void setMaxTableSize(int newSize) {        this.newMaxHeaderSize = newSize;        if (minNewMaxHeaderSize == -1) {            minNewMaxHeaderSize = newSize;        } else {            minNewMaxHeaderSize = Math.min(newSize, minNewMaxHeaderSize);        }    }    private void handleTableSizeChange(ByteBuffer target) {        if (newMaxHeaderSize == -1) {            return;        }        if (minNewMaxHeaderSize != newMaxHeaderSize) {            target.put((byte) (1 << 5));            encodeInteger(target, minNewMaxHeaderSize, 5);        }        target.put((byte) (1 << 5));        encodeInteger(target, newMaxHeaderSize, 5);        maxTableSize = newMaxHeaderSize;        runEvictionIfRequired();        newMaxHeaderSize = -1;        minNewMaxHeaderSize = -1;    }    public enum State {        COMPLETE,        OVERFLOW,    }    static class TableEntry {        final HttpString name;        final String value;        final int size;        int position;        TableEntry(HttpString name, String value, int position) {            this.name = name;            this.value = value;            this.position = position;            if (value != null) {                this.size = 32 + name.length() + value.length();            } else {                this.size = -1;            }        }        public int getPosition() {            return position;        }    }    class DynamicTableEntry extends TableEntry {        DynamicTableEntry(HttpString name, String value, int position) {            super(name, value, position);        }        @Override        public int getPosition() {            return super.getPosition() + entryPositionCounter + STATIC_TABLE_LENGTH;        }    }    public interface HpackHeaderFunction {        boolean shouldUseIndexing(HttpString header, String value);        boolean shouldUseHuffman(HttpString header, String value);        boolean shouldUseHuffman(HttpString header);    }}", "nl": "import io.undertow.util.HeaderMap;import io.undertow.util.HeaderValues;import io.undertow.util.Headers;import io.undertow.util.HttpString;import java.nio.ByteBuffer;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Collections;import java.util.Deque;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;import static io.undertow.protocols.http2.Hpack.HeaderField;import static io.undertow.protocols.http2.Hpack.STATIC_TABLE;import static io.undertow.protocols.http2.Hpack.STATIC_TABLE_LENGTH;import static io.undertow.protocols.http2.Hpack.encodeInteger;public class HpackEncoder {    private static final Set<HttpString> SKIP;    static {        Set<HttpString> set = new HashSet<>();        set.add(Headers.CONNECTION);        set.add(Headers.TRANSFER_ENCODING);        set.add(Headers.KEEP_ALIVE);        set.add(Headers.UPGRADE);        SKIP = Collections.unmodifiableSet(set);    }    public static final HpackHeaderFunction DEFAULT_HEADER_FUNCTION = new HpackHeaderFunction() {        @Override        public boolean shouldUseIndexing(HttpString headerName, String value) {            return !headerName.equals(Headers.CONTENT_LENGTH) && !headerName.equals(Headers.DATE);        }        @Override        public boolean shouldUseHuffman(HttpString header, String value) {            return value.length() > 10;         }        @Override        public boolean shouldUseHuffman(HttpString header) {            return header.length() > 10;         }    };    private long headersIterator = -1;    private boolean firstPass = true;    private HeaderMap currentHeaders;    private int entryPositionCounter;    private int newMaxHeaderSize = -1;     private int minNewMaxHeaderSize = -1;     private static final Map<HttpString, TableEntry[]> ENCODING_STATIC_TABLE;    private final Deque<TableEntry> evictionQueue = new ArrayDeque<>();    private final Map<HttpString, List<TableEntry>> dynamicTable = new HashMap<>();    private byte[] overflowData;    private int overflowPos;    private int overflowLength;    static {        Map<HttpString, TableEntry[]> map = new HashMap<>();        for (int i = 1; i < STATIC_TABLE.length; ++i) {            HeaderField m = STATIC_TABLE[i];            TableEntry[] existing = map.get(m.name);            if (existing == null) {                map.put(m.name, new TableEntry[]{new TableEntry(m.name, m.value, i)});            } else {                TableEntry[] newEntry = new TableEntry[existing.length + 1];                System.arraycopy(existing, 0, newEntry, 0, existing.length);                newEntry[existing.length] = new TableEntry(m.name, m.value, i);                map.put(m.name, newEntry);            }        }        ENCODING_STATIC_TABLE = Collections.unmodifiableMap(map);    }    private int maxTableSize;    private int currentTableSize;    private final HpackHeaderFunction hpackHeaderFunction;    public HpackEncoder(int maxTableSize, HpackHeaderFunction headerFunction) {        this.maxTableSize = maxTableSize;        this.hpackHeaderFunction = headerFunction;    }    public HpackEncoder(int maxTableSize) {        this(maxTableSize, DEFAULT_HEADER_FUNCTION);    }    public State encode(HeaderMap headers, ByteBuffer target) {        if(overflowData != null) {            for(int i = overflowPos; i < overflowLength; ++i) {                if(!target.hasRemaining()) {                    overflowPos = i;                    return State.OVERFLOW;                }                target.put(overflowData[i]);            }            overflowData = null;        }        long it = headersIterator;        if (headersIterator == -1) {            handleTableSizeChange(target);            it = headers.fastIterate();            currentHeaders = headers;        } else {            if (headers != currentHeaders) {                throw new IllegalStateException();            }        }        while (it != -1) {            HeaderValues values = headers.fiCurrent(it);            boolean skip = false;            if (firstPass) {                if (values.getHeaderName().byteAt(0) != ':') {                    skip = true;                }            } else {                if (values.getHeaderName().byteAt(0) == ':') {                    skip = true;                }            }            if(SKIP.contains(values.getHeaderName())) {                skip = true;            }            if (!skip) {                for (int i = 0; i < values.size(); ++i) {                    HttpString headerName = values.getHeaderName();                    int required = 11 + headerName.length();                     String val = values.get(i);                    for(int v = 0; v < val.length(); ++v) {                        char c = val.charAt(v);                        if(c == '\\r' || c == '\\n') {                            val = val.replace('\\r', ' ').replace('\\n', ' ');                            break;                        }                    }                    TableEntry tableEntry = findInTable(headerName, val);                    required += (1 + val.length());                    boolean overflowing = false;                    ByteBuffer current = target;                    if (current.remaining() < required) {                        overflowing = true;                        current = ByteBuffer.wrap(overflowData = new byte[required]);                        overflowPos = 0;                    }                    boolean canIndex = hpackHeaderFunction.shouldUseIndexing(headerName, val) && (headerName.length() + val.length() + 32) < maxTableSize;                     if (tableEntry == null && canIndex) {                        current.put((byte) (1 << 6));                        writeHuffmanEncodableName(current, headerName);                        writeHuffmanEncodableValue(current, headerName, val);                        addToDynamicTable(headerName, val);                    } else if (tableEntry == null) {                        current.put((byte) (1 << 4));                        writeHuffmanEncodableName(current, headerName);                        writeHuffmanEncodableValue(current, headerName, val);                    } else {                        if (val.equals(tableEntry.value)) {                            current.put((byte) (1 << 7));                            encodeInteger(current, tableEntry.getPosition(), 7);                        } else {                            if (canIndex) {                                current.put((byte) (1 << 6));                                encodeInteger(current, tableEntry.getPosition(), 6);                                writeHuffmanEncodableValue(current, headerName, val);                                addToDynamicTable(headerName, val);                            } else {                                current.put((byte) (1 << 4));                                encodeInteger(current, tableEntry.getPosition(), 4);                                writeHuffmanEncodableValue(current, headerName, val);                            }                        }                    }                    if(overflowing) {                        it = headers.fiNext(it);                        this.headersIterator = it;                        this.overflowLength = current.position();                        return State.OVERFLOW;                    }                }            }            it = headers.fiNext(it);            if (it == -1 && firstPass) {                firstPass = false;                it = headers.fastIterate();            }        }        headersIterator = -1;        firstPass = true;        return State.COMPLETE;    }    private void writeHuffmanEncodableName(ByteBuffer target, HttpString headerName) {        if (hpackHeaderFunction.shouldUseHuffman(headerName)) {            if(HPackHuffman.encode(target, headerName.toString(), true)) {                return;            }        }        target.put((byte) 0);         encodeInteger(target, headerName.length(), 7);        for (int j = 0; j < headerName.length(); ++j) {            target.put(Hpack.toLower(headerName.byteAt(j)));        }    }    private void writeHuffmanEncodableValue(ByteBuffer target, HttpString headerName, String val) {        if (hpackHeaderFunction.shouldUseHuffman(headerName, val)) {            if (!HPackHuffman.encode(target, val, false)) {                writeValueString(target, val);            }        } else {            writeValueString(target, val);        }    }    private void writeValueString(ByteBuffer target, String val) {        target.put((byte) 0);         encodeInteger(target, val.length(), 7);        for (int j = 0; j < val.length(); ++j) {            target.put((byte) val.charAt(j));        }    }    private void addToDynamicTable(HttpString headerName, String val) {        int pos = entryPositionCounter++;        DynamicTableEntry d = new DynamicTableEntry(headerName, val, -pos);        List<TableEntry> existing = dynamicTable.get(headerName);        if (existing == null) {            dynamicTable.put(headerName, existing = new ArrayList<>(1));        }        existing.add(d);        evictionQueue.add(d);        currentTableSize += d.size;        runEvictionIfRequired();        if (entryPositionCounter == Integer.MAX_VALUE) {            preventPositionRollover();        }    }    private void preventPositionRollover() {        for (Map.Entry<HttpString, List<TableEntry>> entry : dynamicTable.entrySet()) {            for (TableEntry t : entry.getValue()) {                t.position = t.getPosition();            }        }        entryPositionCounter = 0;    }    private void runEvictionIfRequired() {        while (currentTableSize > maxTableSize) {            TableEntry next = evictionQueue.poll();            if (next == null) {                return;            }            currentTableSize -= next.size;            List<TableEntry> list = dynamicTable.get(next.name);            list.remove(next);            if (list.isEmpty()) {                dynamicTable.remove(next.name);            }        }    }    private TableEntry findInTable(HttpString headerName, String value) {        TableEntry[] staticTable = ENCODING_STATIC_TABLE.get(headerName);        if (staticTable != null) {            for (TableEntry st : staticTable) {                if (st.value != null && st.value.equals(value)) {                     return st;                }            }        }        List<TableEntry> dynamic = dynamicTable.get(headerName);        if (dynamic != null) {            for (int i = 0; i < dynamic.size(); ++i) {                TableEntry st = dynamic.get(i);                if (st.value.equals(value)) {                     return st;                }            }        }        if (staticTable != null) {            return staticTable[0];        }        return null;    }    public void setMaxTableSize(int newSize) {        this.newMaxHeaderSize = newSize;        if (minNewMaxHeaderSize == -1) {            minNewMaxHeaderSize = newSize;        } else {            minNewMaxHeaderSize = Math.min(newSize, minNewMaxHeaderSize);        }    }    private void handleTableSizeChange(ByteBuffer target) {        if (newMaxHeaderSize == -1) {            return;        }        if (minNewMaxHeaderSize != newMaxHeaderSize) {            target.put((byte) (1 << 5));            encodeInteger(target, minNewMaxHeaderSize, 5);        }        target.put((byte) (1 << 5));        encodeInteger(target, newMaxHeaderSize, 5);        maxTableSize = newMaxHeaderSize;        runEvictionIfRequired();        newMaxHeaderSize = -1;        minNewMaxHeaderSize = -1;    }    public enum State {        COMPLETE,        OVERFLOW,    }    static class TableEntry {        final HttpString name;        final String value;        final int size;        int position;        TableEntry(HttpString name, String value, int position) {            this.name = name;            this.value = value;            this.position = position;            if (value != null) {                this.size = 32 + name.length() + value.length();            } else {                this.size = -1;            }        }        public int getPosition() {            return position;        }    }    class DynamicTableEntry extends TableEntry {        DynamicTableEntry(HttpString name, String value, int position) {            super(name, value, position);        }        @Override        public int getPosition() {            return super.getPosition() + entryPositionCounter + STATIC_TABLE_LENGTH;        }    }    public interface HpackHeaderFunction {        boolean shouldUseIndexing(HttpString header, String value);        boolean shouldUseHuffman(HttpString header, String value);        boolean shouldUseHuffman(HttpString header);    }}"}
{"code": "import io.undertow.UndertowLogger;import io.undertow.UndertowMessages;import io.undertow.UndertowOptions;import io.undertow.connector.ByteBufferPool;import io.undertow.connector.PooledByteBuffer;import io.undertow.server.protocol.ParseTimeoutUpdater;import io.undertow.server.protocol.framed.AbstractFramedChannel;import io.undertow.server.protocol.framed.AbstractFramedStreamSourceChannel;import io.undertow.server.protocol.framed.FrameHeaderData;import io.undertow.server.protocol.http2.Http2OpenListener;import io.undertow.util.Attachable;import io.undertow.util.AttachmentKey;import io.undertow.util.AttachmentList;import io.undertow.util.HeaderMap;import io.undertow.util.HttpString;import org.xnio.Bits;import org.xnio.ChannelExceptionHandler;import org.xnio.ChannelListener;import org.xnio.ChannelListeners;import org.xnio.IoUtils;import org.xnio.OptionMap;import org.xnio.StreamConnection;import org.xnio.channels.StreamSinkChannel;import org.xnio.ssl.SslConnection;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.Channel;import java.nio.channels.ClosedChannelException;import java.security.SecureRandom;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Random;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;import javax.net.ssl.SSLSession;public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHttp2StreamSourceChannel, AbstractHttp2StreamSinkChannel> implements Attachable {    public static final String CLEARTEXT_UPGRADE_STRING = \"h2c\";    public static final HttpString METHOD = new HttpString(\":method\");    public static final HttpString PATH = new HttpString(\":path\");    public static final HttpString SCHEME = new HttpString(\":scheme\");    public static final HttpString AUTHORITY = new HttpString(\":authority\");    public static final HttpString STATUS = new HttpString(\":status\");    static final int FRAME_TYPE_DATA = 0x00;    static final int FRAME_TYPE_HEADERS = 0x01;    static final int FRAME_TYPE_PRIORITY = 0x02;    static final int FRAME_TYPE_RST_STREAM = 0x03;    static final int FRAME_TYPE_SETTINGS = 0x04;    static final int FRAME_TYPE_PUSH_PROMISE = 0x05;    static final int FRAME_TYPE_PING = 0x06;    static final int FRAME_TYPE_GOAWAY = 0x07;    static final int FRAME_TYPE_WINDOW_UPDATE = 0x08;    static final int FRAME_TYPE_CONTINUATION = 0x09;    public static final int ERROR_NO_ERROR = 0x00;    public static final int ERROR_PROTOCOL_ERROR = 0x01;    public static final int ERROR_INTERNAL_ERROR = 0x02;    public static final int ERROR_FLOW_CONTROL_ERROR = 0x03;    public static final int ERROR_SETTINGS_TIMEOUT = 0x04;    public static final int ERROR_STREAM_CLOSED = 0x05;    public static final int ERROR_FRAME_SIZE_ERROR = 0x06;    public static final int ERROR_REFUSED_STREAM = 0x07;    public static final int ERROR_CANCEL = 0x08;    public static final int ERROR_COMPRESSION_ERROR = 0x09;    public static final int ERROR_CONNECT_ERROR = 0x0a;    public static final int ERROR_ENHANCE_YOUR_CALM = 0x0b;    public static final int ERROR_INADEQUATE_SECURITY = 0x0c;    static final int DATA_FLAG_END_STREAM = 0x1;    static final int DATA_FLAG_END_SEGMENT = 0x2;    static final int DATA_FLAG_PADDED = 0x8;    static final int PING_FRAME_LENGTH = 8;    static final int PING_FLAG_ACK = 0x1;    static final int HEADERS_FLAG_END_STREAM = 0x1;    static final int HEADERS_FLAG_END_SEGMENT = 0x2;    static final int HEADERS_FLAG_END_HEADERS = 0x4;    static final int HEADERS_FLAG_PADDED = 0x8;    static final int HEADERS_FLAG_PRIORITY = 0x20;    static final int SETTINGS_FLAG_ACK = 0x1;    static final int CONTINUATION_FLAG_END_HEADERS = 0x4;    public static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;    static final byte[] PREFACE_BYTES = {            0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,            0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,            0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a};    public static final int DEFAULT_MAX_FRAME_SIZE = 16384;    public static final int MAX_FRAME_SIZE = 16777215;    public static final int FLOW_CONTROL_MIN_WINDOW = 2;    private Http2FrameHeaderParser frameParser;    private final Map<Integer, StreamHolder> currentStreams = new ConcurrentHashMap<>();    private final String protocol;    private final int encoderHeaderTableSize;    private volatile boolean pushEnabled;    private volatile int sendMaxConcurrentStreams = -1;    private final int receiveMaxConcurrentStreams;    private volatile int sendConcurrentStreams = 0;    private volatile int receiveConcurrentStreams = 0;    private final int initialReceiveWindowSize;    private volatile int sendMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;    private final int receiveMaxFrameSize;    private int unackedReceiveMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;     private final int maxHeaders;    private final int maxHeaderListSize;    private static final AtomicIntegerFieldUpdater<Http2Channel> sendConcurrentStreamsAtomicUpdater = AtomicIntegerFieldUpdater.newUpdater(            Http2Channel.class, \"sendConcurrentStreams\");    private static final AtomicIntegerFieldUpdater<Http2Channel> receiveConcurrentStreamsAtomicUpdater = AtomicIntegerFieldUpdater.newUpdater(            Http2Channel.class, \"receiveConcurrentStreams\");    private boolean thisGoneAway = false;    private boolean peerGoneAway = false;    private boolean lastDataRead = false;    private int streamIdCounter;    private int lastGoodStreamId;    private int lastAssignedStreamOtherSide;    private final HpackDecoder decoder;    private final HpackEncoder encoder;    private final int maxPadding;    private final Random paddingRandom;    private int prefaceCount;    private boolean initialSettingsReceived;     private Http2HeadersParser continuationParser = null;     private boolean initialSettingsSent = false;    private final Map<AttachmentKey<?>, Object> attachments = Collections.synchronizedMap(new HashMap<AttachmentKey<?>, Object>());    private final ParseTimeoutUpdater parseTimeoutUpdater;    private final Object flowControlLock = new Object();    private volatile int initialSendWindowSize = DEFAULT_INITIAL_WINDOW_SIZE;    private volatile long sendWindowSize = initialSendWindowSize;    private volatile int receiveWindowSize;    public Http2Channel(StreamConnection connectedStreamChannel, String protocol, ByteBufferPool bufferPool, PooledByteBuffer data, boolean clientSide, boolean fromUpgrade, OptionMap settings) {        this(connectedStreamChannel, protocol, bufferPool, data, clientSide, fromUpgrade, true, null, settings);    }    public Http2Channel(StreamConnection connectedStreamChannel, String protocol, ByteBufferPool bufferPool, PooledByteBuffer data, boolean clientSide, boolean fromUpgrade, boolean prefaceRequired, OptionMap settings) {        this(connectedStreamChannel, protocol, bufferPool, data, clientSide, fromUpgrade, prefaceRequired, null, settings);    }    public Http2Channel(StreamConnection connectedStreamChannel, String protocol, ByteBufferPool bufferPool, PooledByteBuffer data, boolean clientSide, boolean fromUpgrade, boolean prefaceRequired, ByteBuffer initialOtherSideSettings, OptionMap settings) {        super(connectedStreamChannel, bufferPool, new Http2FramePriority(clientSide ? (fromUpgrade ? 3 : 1) : 2), data, settings);        streamIdCounter = clientSide ? (fromUpgrade ? 3 : 1) : 2;        pushEnabled = settings.get(UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, true);        this.initialReceiveWindowSize = settings.get(UndertowOptions.HTTP2_SETTINGS_INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);        this.receiveWindowSize = initialReceiveWindowSize;        this.receiveMaxConcurrentStreams = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, -1);        this.protocol = protocol == null ? Http2OpenListener.HTTP2 : protocol;        this.maxHeaders = settings.get(UndertowOptions.MAX_HEADERS, clientSide ? -1 : UndertowOptions.DEFAULT_MAX_HEADERS);        encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);        receiveMaxFrameSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_FRAME_SIZE, DEFAULT_MAX_FRAME_SIZE);        maxPadding = settings.get(UndertowOptions.HTTP2_PADDING_SIZE, 0);        maxHeaderListSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE, settings.get(UndertowOptions.MAX_HEADER_SIZE, -1));        if(maxPadding > 0) {            paddingRandom = new SecureRandom();        } else {            paddingRandom = null;        }        this.decoder = new HpackDecoder(encoderHeaderTableSize);        this.encoder = new HpackEncoder(encoderHeaderTableSize);        if(!prefaceRequired) {            prefaceCount = PREFACE_BYTES.length;        }        if (clientSide) {            sendPreface();            prefaceCount = PREFACE_BYTES.length;            sendSettings();            initialSettingsSent = true;            if(fromUpgrade) {                StreamHolder streamHolder = new StreamHolder((Http2StreamSinkChannel) null);                streamHolder.sinkClosed = true;                sendConcurrentStreamsAtomicUpdater.getAndIncrement(this);                currentStreams.put(1, streamHolder);            }        } else if(fromUpgrade) {            sendSettings();            initialSettingsSent = true;        }        if (initialOtherSideSettings != null) {            Http2SettingsParser parser = new Http2SettingsParser(initialOtherSideSettings.remaining());            try {                final Http2FrameHeaderParser headerParser = new Http2FrameHeaderParser(this, null);                headerParser.length = initialOtherSideSettings.remaining();                parser.parse(initialOtherSideSettings, headerParser);                updateSettings(parser.getSettings());            } catch (Throwable e) {                IoUtils.safeClose(connectedStreamChannel);                throw new RuntimeException(e);            }        }        int requestParseTimeout = settings.get(UndertowOptions.REQUEST_PARSE_TIMEOUT, -1);        int requestIdleTimeout = settings.get(UndertowOptions.NO_REQUEST_TIMEOUT, -1);        if(requestIdleTimeout < 0 && requestParseTimeout < 0) {            this.parseTimeoutUpdater = null;        } else {            this.parseTimeoutUpdater = new ParseTimeoutUpdater(this, requestParseTimeout, requestIdleTimeout, new Runnable() {                @Override                public void run() {                    sendGoAway(ERROR_NO_ERROR);                    getIoThread().executeAfter(new Runnable() {                        @Override                        public void run() {                            IoUtils.safeClose(Http2Channel.this);                        }                    }, 2, TimeUnit.SECONDS);                }            });            this.addCloseTask(new ChannelListener<Http2Channel>() {                @Override                public void handleEvent(Http2Channel channel) {                    parseTimeoutUpdater.close();                }            });        }    }    private void sendSettings() {        List<Http2Setting> settings = new ArrayList<>();        settings.add(new Http2Setting(Http2Setting.SETTINGS_HEADER_TABLE_SIZE, encoderHeaderTableSize));        if(isClient()) {            settings.add(new Http2Setting(Http2Setting.SETTINGS_ENABLE_PUSH, pushEnabled ? 1 : 0));        }        settings.add(new Http2Setting(Http2Setting.SETTINGS_MAX_FRAME_SIZE, receiveMaxFrameSize));        settings.add(new Http2Setting(Http2Setting.SETTINGS_INITIAL_WINDOW_SIZE, initialReceiveWindowSize));        if(maxHeaderListSize > 0) {            settings.add(new Http2Setting(Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, maxHeaderListSize));        }        if(receiveMaxConcurrentStreams > 0) {            settings.add(new Http2Setting(Http2Setting.SETTINGS_MAX_CONCURRENT_STREAMS, receiveMaxConcurrentStreams));        }        Http2SettingsStreamSinkChannel stream = new Http2SettingsStreamSinkChannel(this, settings);        flushChannelIgnoreFailure(stream);    }    private void sendSettingsAck() {        if(!initialSettingsSent) {            sendSettings();            initialSettingsSent = true;        }        Http2SettingsStreamSinkChannel stream = new Http2SettingsStreamSinkChannel(this);        flushChannelIgnoreFailure(stream);    }    private void flushChannelIgnoreFailure(StreamSinkChannel stream) {        try {            flushChannel(stream);        } catch (IOException e) {            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);        } catch (Throwable t) {            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);        }    }    private void flushChannel(StreamSinkChannel stream) throws IOException {        stream.shutdownWrites();        if (!stream.flush()) {            stream.getWriteSetter().set(ChannelListeners.flushingChannelListener(null, writeExceptionHandler()));            stream.resumeWrites();        }    }    private void sendPreface() {        Http2PrefaceStreamSinkChannel preface = new Http2PrefaceStreamSinkChannel(this);        flushChannelIgnoreFailure(preface);    }    @Override    protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHeaderData, PooledByteBuffer frameData) throws IOException {        AbstractHttp2StreamSourceChannel channel = createChannelImpl(frameHeaderData, frameData);        if(channel instanceof Http2StreamSourceChannel) {            if (parseTimeoutUpdater != null) {                if (channel != null) {                    parseTimeoutUpdater.requestStarted();                } else if (currentStreams.isEmpty()) {                    parseTimeoutUpdater.failedParse();                }            }        }        return channel;    }    protected AbstractHttp2StreamSourceChannel createChannelImpl(FrameHeaderData frameHeaderData, PooledByteBuffer frameData) throws IOException {        Http2FrameHeaderParser frameParser = (Http2FrameHeaderParser) frameHeaderData;        AbstractHttp2StreamSourceChannel channel;        if (frameParser.type == FRAME_TYPE_DATA) {            sendGoAway(ERROR_PROTOCOL_ERROR);            UndertowLogger.REQUEST_LOGGER.tracef(\"Dropping Frame of length %s for stream %s\", frameParser.getFrameLength(), frameParser.streamId);            return null;        }        switch (frameParser.type) {            case FRAME_TYPE_CONTINUATION:            case FRAME_TYPE_PUSH_PROMISE: {                if(frameParser.parser instanceof Http2PushPromiseParser) {                    if(!isClient()) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        throw UndertowMessages.MESSAGES.serverReceivedPushPromise();                    }                    Http2PushPromiseParser pushPromiseParser = (Http2PushPromiseParser) frameParser.parser;                    channel = new Http2PushPromiseStreamSourceChannel(this, frameData, frameParser.getFrameLength(), pushPromiseParser.getHeaderMap(), pushPromiseParser.getPromisedStreamId(), frameParser.streamId);                    break;                }            }            case FRAME_TYPE_HEADERS: {                if(!isIdle(frameParser.streamId)) {                    StreamHolder existing = currentStreams.get(frameParser.streamId);                    if(existing == null || existing.sourceClosed) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        frameData.close();                        return null;                    } else if (existing.sourceChannel != null ){                        if(!Bits.allAreSet(frameParser.flags, HEADERS_FLAG_END_STREAM)) {                            sendGoAway(ERROR_PROTOCOL_ERROR);                            frameData.close();                            return null;                        }                    }                } else {                    if(frameParser.streamId < getLastAssignedStreamOtherSide()) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        frameData.close();                        return null;                    }                    if(frameParser.streamId % 2 == (isClient() ? 1 : 0)) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        frameData.close();                        return null;                    }                }                Http2HeadersParser parser = (Http2HeadersParser) frameParser.parser;                channel = new Http2StreamSourceChannel(this, frameData, frameHeaderData.getFrameLength(), parser.getHeaderMap(), frameParser.streamId);                updateStreamIdsCountersInHeaders(frameParser.streamId);                StreamHolder holder = currentStreams.get(frameParser.streamId);                if(holder == null) {                    receiveConcurrentStreamsAtomicUpdater.getAndIncrement(this);                    currentStreams.put(frameParser.streamId, holder = new StreamHolder((Http2StreamSourceChannel) channel));                } else {                    holder.sourceChannel = (Http2StreamSourceChannel) channel;                }                if (parser.isHeadersEndStream() && Bits.allAreSet(frameParser.flags, HEADERS_FLAG_END_HEADERS)) {                    channel.lastFrame();                    holder.sourceChannel = null;                    if(!isClient() || !\"100\".equals(parser.getHeaderMap().getFirst(STATUS))) {                        holder.sourceClosed = true;                        if(holder.sinkClosed) {                            receiveConcurrentStreamsAtomicUpdater.getAndDecrement(this);                            currentStreams.remove(frameParser.streamId);                        }                    }                }                if(parser.isInvalid()) {                    channel.rstStream(ERROR_PROTOCOL_ERROR);                    sendRstStream(frameParser.streamId, Http2Channel.ERROR_PROTOCOL_ERROR);                    channel = null;                }                if(parser.getDependentStreamId() == frameParser.streamId) {                    sendRstStream(frameParser.streamId, ERROR_PROTOCOL_ERROR);                    frameData.close();                    return null;                }                break;            }            case FRAME_TYPE_RST_STREAM: {                Http2RstStreamParser parser = (Http2RstStreamParser) frameParser.parser;                if (frameParser.streamId == 0) {                    if(frameData != null) {                        frameData.close();                    }                    throw new ConnectionErrorException(Http2Channel.ERROR_PROTOCOL_ERROR, UndertowMessages.MESSAGES.streamIdMustNotBeZeroForFrameType(FRAME_TYPE_RST_STREAM));                }                channel = new Http2RstStreamStreamSourceChannel(this, frameData, parser.getErrorCode(), frameParser.streamId);                handleRstStream(frameParser.streamId);                if(isIdle(frameParser.streamId)) {                    sendGoAway(ERROR_PROTOCOL_ERROR);                }                break;            }            case FRAME_TYPE_SETTINGS: {                if (!Bits.anyAreSet(frameParser.flags, SETTINGS_FLAG_ACK)) {                    if(updateSettings(((Http2SettingsParser) frameParser.parser).getSettings())) {                        sendSettingsAck();                    }                } else if (frameHeaderData.getFrameLength() != 0) {                    sendGoAway(ERROR_FRAME_SIZE_ERROR);                    frameData.close();                    return null;                }                channel = new Http2SettingsStreamSourceChannel(this, frameData, frameParser.getFrameLength(), ((Http2SettingsParser) frameParser.parser).getSettings());                unackedReceiveMaxFrameSize = receiveMaxFrameSize;                break;            }            case FRAME_TYPE_PING: {                Http2PingParser pingParser = (Http2PingParser) frameParser.parser;                frameData.close();                boolean ack = Bits.anyAreSet(frameParser.flags, PING_FLAG_ACK);                channel = new Http2PingStreamSourceChannel(this, pingParser.getData(), ack);                if(!ack) {                     sendPing(pingParser.getData(),  new Http2ControlMessageExceptionHandler(), true);                }                break;            }            case FRAME_TYPE_GOAWAY: {                Http2GoAwayParser http2GoAwayParser = (Http2GoAwayParser) frameParser.parser;                channel = new Http2GoAwayStreamSourceChannel(this, frameData, frameParser.getFrameLength(), http2GoAwayParser.getStatusCode(), http2GoAwayParser.getLastGoodStreamId());                peerGoneAway = true;                for(StreamHolder holder : currentStreams.values()) {                    if(holder.sourceChannel != null) {                        holder.sourceChannel.rstStream();                    }                    if(holder.sinkChannel != null) {                        holder.sinkChannel.rstStream();                    }                }                frameData.close();                sendGoAway(ERROR_NO_ERROR);                break;            }            case FRAME_TYPE_WINDOW_UPDATE: {                Http2WindowUpdateParser parser = (Http2WindowUpdateParser) frameParser.parser;                handleWindowUpdate(frameParser.streamId, parser.getDeltaWindowSize());                frameData.close();                return null;            }            case FRAME_TYPE_PRIORITY: {                Http2PriorityParser parser = (Http2PriorityParser) frameParser.parser;                if(parser.getStreamDependency() == frameParser.streamId) {                    sendRstStream(frameParser.streamId, ERROR_PROTOCOL_ERROR);                    return null;                }                frameData.close();                return null;            }            default: {                UndertowLogger.REQUEST_LOGGER.tracef(\"Dropping frame of length %s and type %s for stream %s as we do not understand this type of frame\", frameParser.getFrameLength(), frameParser.type, frameParser.streamId);                frameData.close();                return null;            }        }        return channel;    }    @Override    protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {        Http2FrameHeaderParser frameParser;        do {            frameParser = parseFrameNoContinuation(data);        } while(frameParser != null && frameParser.getContinuationParser() != null && data.hasRemaining());        return frameParser;    }    private Http2FrameHeaderParser parseFrameNoContinuation(ByteBuffer data) throws IOException {        if (prefaceCount < PREFACE_BYTES.length) {            while (data.hasRemaining() && prefaceCount < PREFACE_BYTES.length) {                if (data.get() != PREFACE_BYTES[prefaceCount]) {                    IoUtils.safeClose(getUnderlyingConnection());                    throw UndertowMessages.MESSAGES.incorrectHttp2Preface();                }                prefaceCount++;            }        }        Http2FrameHeaderParser frameParser = this.frameParser;        if (frameParser == null) {            this.frameParser = frameParser = new Http2FrameHeaderParser(this, continuationParser);            this.continuationParser = null;        }        if (!frameParser.handle(data)) {            return null;        }        if (!initialSettingsReceived) {            if (frameParser.type != FRAME_TYPE_SETTINGS) {                UndertowLogger.REQUEST_IO_LOGGER.remoteEndpointFailedToSendInitialSettings(frameParser.type);                markReadsBroken(new IOException());            } else {                initialSettingsReceived = true;            }        }        this.frameParser = null;        if (frameParser.getActualLength() > receiveMaxFrameSize && frameParser.getActualLength() > unackedReceiveMaxFrameSize) {            sendGoAway(ERROR_FRAME_SIZE_ERROR);            throw UndertowMessages.MESSAGES.http2FrameTooLarge();        }        if (frameParser.getContinuationParser() != null) {            this.continuationParser = frameParser.getContinuationParser();        }        return frameParser;    }    protected void lastDataRead() {        lastDataRead = true;        if(!peerGoneAway) {            IoUtils.safeClose(this);        } else {            peerGoneAway = true;            if(!thisGoneAway) {                sendGoAway(ERROR_CONNECT_ERROR);            }        }    }    @Override    protected boolean isLastFrameReceived() {        return lastDataRead;    }    @Override    protected boolean isLastFrameSent() {        return thisGoneAway;    }    @Override    protected void handleBrokenSourceChannel(Throwable e) {        UndertowLogger.REQUEST_LOGGER.debugf(e, \"Closing HTTP2 channel to %s due to broken read side\", getPeerAddress());        if (e instanceof ConnectionErrorException) {            sendGoAway(((ConnectionErrorException) e).getCode(), new Http2ControlMessageExceptionHandler());        } else {            sendGoAway(e instanceof ClosedChannelException ? Http2Channel.ERROR_CONNECT_ERROR : Http2Channel.ERROR_PROTOCOL_ERROR, new Http2ControlMessageExceptionHandler());        }    }    @Override    protected void handleBrokenSinkChannel(Throwable e) {        UndertowLogger.REQUEST_LOGGER.debugf(e, \"Closing HTTP2 channel to %s due to broken write side\", getPeerAddress());        IoUtils.safeClose(this);    }    @Override    protected void closeSubChannels() {        for (Map.Entry<Integer, StreamHolder> e : currentStreams.entrySet()) {            StreamHolder holder = e.getValue();            AbstractHttp2StreamSourceChannel receiver = holder.sourceChannel;            if(receiver != null) {                receiver.markStreamBroken();            }            Http2StreamSinkChannel sink = holder.sinkChannel;            if(sink != null) {                if (sink.isWritesShutdown()) {                    ChannelListeners.invokeChannelListener(sink.getIoThread(), sink, ((ChannelListener.SimpleSetter) sink.getWriteSetter()).get());                }                IoUtils.safeClose(sink);            }        }    }    @Override    protected Collection<AbstractFramedStreamSourceChannel<Http2Channel, AbstractHttp2StreamSourceChannel, AbstractHttp2StreamSinkChannel>> getReceivers() {        List<AbstractFramedStreamSourceChannel<Http2Channel, AbstractHttp2StreamSourceChannel, AbstractHttp2StreamSinkChannel>> channels = new ArrayList<>(currentStreams.size());        for(Map.Entry<Integer, StreamHolder> entry : currentStreams.entrySet()) {            if(!entry.getValue().sourceClosed) {                channels.add(entry.getValue().sourceChannel);            }        }        return channels;    }    boolean updateSettings(List<Http2Setting> settings) {        for (Http2Setting setting : settings) {            if (setting.getId() == Http2Setting.SETTINGS_INITIAL_WINDOW_SIZE) {                synchronized (flowControlLock) {                    if (setting.getValue() > Integer.MAX_VALUE) {                        sendGoAway(ERROR_FLOW_CONTROL_ERROR);                        return false;                    }                    initialSendWindowSize = (int) setting.getValue();                }            } else if (setting.getId() == Http2Setting.SETTINGS_MAX_FRAME_SIZE) {                if(setting.getValue() > MAX_FRAME_SIZE || setting.getValue() < DEFAULT_MAX_FRAME_SIZE) {                    UndertowLogger.REQUEST_IO_LOGGER.debug(\"Invalid value received for SETTINGS_MAX_FRAME_SIZE \" + setting.getValue());                    sendGoAway(ERROR_PROTOCOL_ERROR);                    return false;                }                sendMaxFrameSize = (int) setting.getValue();            } else if (setting.getId() == Http2Setting.SETTINGS_HEADER_TABLE_SIZE) {                synchronized (this) {                    encoder.setMaxTableSize((int) setting.getValue());                }            } else if (setting.getId() == Http2Setting.SETTINGS_ENABLE_PUSH) {                int result = (int) setting.getValue();                if(result == 0) {                    pushEnabled = false;                } else if(re", "nl": "import io.undertow.UndertowLogger;import io.undertow.UndertowMessages;import io.undertow.UndertowOptions;import io.undertow.connector.ByteBufferPool;import io.undertow.connector.PooledByteBuffer;import io.undertow.server.protocol.ParseTimeoutUpdater;import io.undertow.server.protocol.framed.AbstractFramedChannel;import io.undertow.server.protocol.framed.AbstractFramedStreamSourceChannel;import io.undertow.server.protocol.framed.FrameHeaderData;import io.undertow.server.protocol.http2.Http2OpenListener;import io.undertow.util.Attachable;import io.undertow.util.AttachmentKey;import io.undertow.util.AttachmentList;import io.undertow.util.HeaderMap;import io.undertow.util.HttpString;import org.xnio.Bits;import org.xnio.ChannelExceptionHandler;import org.xnio.ChannelListener;import org.xnio.ChannelListeners;import org.xnio.IoUtils;import org.xnio.OptionMap;import org.xnio.StreamConnection;import org.xnio.channels.StreamSinkChannel;import org.xnio.ssl.SslConnection;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.Channel;import java.nio.channels.ClosedChannelException;import java.security.SecureRandom;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Random;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;import javax.net.ssl.SSLSession;public class Http2Channel extends AbstractFramedChannel<Http2Channel, AbstractHttp2StreamSourceChannel, AbstractHttp2StreamSinkChannel> implements Attachable {    public static final String CLEARTEXT_UPGRADE_STRING = \"h2c\";    public static final HttpString METHOD = new HttpString(\":method\");    public static final HttpString PATH = new HttpString(\":path\");    public static final HttpString SCHEME = new HttpString(\":scheme\");    public static final HttpString AUTHORITY = new HttpString(\":authority\");    public static final HttpString STATUS = new HttpString(\":status\");    static final int FRAME_TYPE_DATA = 0x00;    static final int FRAME_TYPE_HEADERS = 0x01;    static final int FRAME_TYPE_PRIORITY = 0x02;    static final int FRAME_TYPE_RST_STREAM = 0x03;    static final int FRAME_TYPE_SETTINGS = 0x04;    static final int FRAME_TYPE_PUSH_PROMISE = 0x05;    static final int FRAME_TYPE_PING = 0x06;    static final int FRAME_TYPE_GOAWAY = 0x07;    static final int FRAME_TYPE_WINDOW_UPDATE = 0x08;    static final int FRAME_TYPE_CONTINUATION = 0x09;    public static final int ERROR_NO_ERROR = 0x00;    public static final int ERROR_PROTOCOL_ERROR = 0x01;    public static final int ERROR_INTERNAL_ERROR = 0x02;    public static final int ERROR_FLOW_CONTROL_ERROR = 0x03;    public static final int ERROR_SETTINGS_TIMEOUT = 0x04;    public static final int ERROR_STREAM_CLOSED = 0x05;    public static final int ERROR_FRAME_SIZE_ERROR = 0x06;    public static final int ERROR_REFUSED_STREAM = 0x07;    public static final int ERROR_CANCEL = 0x08;    public static final int ERROR_COMPRESSION_ERROR = 0x09;    public static final int ERROR_CONNECT_ERROR = 0x0a;    public static final int ERROR_ENHANCE_YOUR_CALM = 0x0b;    public static final int ERROR_INADEQUATE_SECURITY = 0x0c;    static final int DATA_FLAG_END_STREAM = 0x1;    static final int DATA_FLAG_END_SEGMENT = 0x2;    static final int DATA_FLAG_PADDED = 0x8;    static final int PING_FRAME_LENGTH = 8;    static final int PING_FLAG_ACK = 0x1;    static final int HEADERS_FLAG_END_STREAM = 0x1;    static final int HEADERS_FLAG_END_SEGMENT = 0x2;    static final int HEADERS_FLAG_END_HEADERS = 0x4;    static final int HEADERS_FLAG_PADDED = 0x8;    static final int HEADERS_FLAG_PRIORITY = 0x20;    static final int SETTINGS_FLAG_ACK = 0x1;    static final int CONTINUATION_FLAG_END_HEADERS = 0x4;    public static final int DEFAULT_INITIAL_WINDOW_SIZE = 65535;    static final byte[] PREFACE_BYTES = {            0x50, 0x52, 0x49, 0x20, 0x2a, 0x20, 0x48, 0x54,            0x54, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,            0x0d, 0x0a, 0x53, 0x4d, 0x0d, 0x0a, 0x0d, 0x0a};    public static final int DEFAULT_MAX_FRAME_SIZE = 16384;    public static final int MAX_FRAME_SIZE = 16777215;    public static final int FLOW_CONTROL_MIN_WINDOW = 2;    private Http2FrameHeaderParser frameParser;    private final Map<Integer, StreamHolder> currentStreams = new ConcurrentHashMap<>();    private final String protocol;    private final int encoderHeaderTableSize;    private volatile boolean pushEnabled;    private volatile int sendMaxConcurrentStreams = -1;    private final int receiveMaxConcurrentStreams;    private volatile int sendConcurrentStreams = 0;    private volatile int receiveConcurrentStreams = 0;    private final int initialReceiveWindowSize;    private volatile int sendMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;    private final int receiveMaxFrameSize;    private int unackedReceiveMaxFrameSize = DEFAULT_MAX_FRAME_SIZE;     private final int maxHeaders;    private final int maxHeaderListSize;    private static final AtomicIntegerFieldUpdater<Http2Channel> sendConcurrentStreamsAtomicUpdater = AtomicIntegerFieldUpdater.newUpdater(            Http2Channel.class, \"sendConcurrentStreams\");    private static final AtomicIntegerFieldUpdater<Http2Channel> receiveConcurrentStreamsAtomicUpdater = AtomicIntegerFieldUpdater.newUpdater(            Http2Channel.class, \"receiveConcurrentStreams\");    private boolean thisGoneAway = false;    private boolean peerGoneAway = false;    private boolean lastDataRead = false;    private int streamIdCounter;    private int lastGoodStreamId;    private int lastAssignedStreamOtherSide;    private final HpackDecoder decoder;    private final HpackEncoder encoder;    private final int maxPadding;    private final Random paddingRandom;    private int prefaceCount;    private boolean initialSettingsReceived;     private Http2HeadersParser continuationParser = null;     private boolean initialSettingsSent = false;    private final Map<AttachmentKey<?>, Object> attachments = Collections.synchronizedMap(new HashMap<AttachmentKey<?>, Object>());    private final ParseTimeoutUpdater parseTimeoutUpdater;    private final Object flowControlLock = new Object();    private volatile int initialSendWindowSize = DEFAULT_INITIAL_WINDOW_SIZE;    private volatile long sendWindowSize = initialSendWindowSize;    private volatile int receiveWindowSize;    public Http2Channel(StreamConnection connectedStreamChannel, String protocol, ByteBufferPool bufferPool, PooledByteBuffer data, boolean clientSide, boolean fromUpgrade, OptionMap settings) {        this(connectedStreamChannel, protocol, bufferPool, data, clientSide, fromUpgrade, true, null, settings);    }    public Http2Channel(StreamConnection connectedStreamChannel, String protocol, ByteBufferPool bufferPool, PooledByteBuffer data, boolean clientSide, boolean fromUpgrade, boolean prefaceRequired, OptionMap settings) {        this(connectedStreamChannel, protocol, bufferPool, data, clientSide, fromUpgrade, prefaceRequired, null, settings);    }    public Http2Channel(StreamConnection connectedStreamChannel, String protocol, ByteBufferPool bufferPool, PooledByteBuffer data, boolean clientSide, boolean fromUpgrade, boolean prefaceRequired, ByteBuffer initialOtherSideSettings, OptionMap settings) {        super(connectedStreamChannel, bufferPool, new Http2FramePriority(clientSide ? (fromUpgrade ? 3 : 1) : 2), data, settings);        streamIdCounter = clientSide ? (fromUpgrade ? 3 : 1) : 2;        pushEnabled = settings.get(UndertowOptions.HTTP2_SETTINGS_ENABLE_PUSH, true);        this.initialReceiveWindowSize = settings.get(UndertowOptions.HTTP2_SETTINGS_INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);        this.receiveWindowSize = initialReceiveWindowSize;        this.receiveMaxConcurrentStreams = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, -1);        this.protocol = protocol == null ? Http2OpenListener.HTTP2 : protocol;        this.maxHeaders = settings.get(UndertowOptions.MAX_HEADERS, clientSide ? -1 : UndertowOptions.DEFAULT_MAX_HEADERS);        encoderHeaderTableSize = settings.get(UndertowOptions.HTTP2_SETTINGS_HEADER_TABLE_SIZE, Hpack.DEFAULT_TABLE_SIZE);        receiveMaxFrameSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_FRAME_SIZE, DEFAULT_MAX_FRAME_SIZE);        maxPadding = settings.get(UndertowOptions.HTTP2_PADDING_SIZE, 0);        maxHeaderListSize = settings.get(UndertowOptions.HTTP2_SETTINGS_MAX_HEADER_LIST_SIZE, settings.get(UndertowOptions.MAX_HEADER_SIZE, -1));        if(maxPadding > 0) {            paddingRandom = new SecureRandom();        } else {            paddingRandom = null;        }        this.decoder = new HpackDecoder(encoderHeaderTableSize);        this.encoder = new HpackEncoder(encoderHeaderTableSize);        if(!prefaceRequired) {            prefaceCount = PREFACE_BYTES.length;        }        if (clientSide) {            sendPreface();            prefaceCount = PREFACE_BYTES.length;            sendSettings();            initialSettingsSent = true;            if(fromUpgrade) {                StreamHolder streamHolder = new StreamHolder((Http2StreamSinkChannel) null);                streamHolder.sinkClosed = true;                sendConcurrentStreamsAtomicUpdater.getAndIncrement(this);                currentStreams.put(1, streamHolder);            }        } else if(fromUpgrade) {            sendSettings();            initialSettingsSent = true;        }        if (initialOtherSideSettings != null) {            Http2SettingsParser parser = new Http2SettingsParser(initialOtherSideSettings.remaining());            try {                final Http2FrameHeaderParser headerParser = new Http2FrameHeaderParser(this, null);                headerParser.length = initialOtherSideSettings.remaining();                parser.parse(initialOtherSideSettings, headerParser);                updateSettings(parser.getSettings());            } catch (Throwable e) {                IoUtils.safeClose(connectedStreamChannel);                throw new RuntimeException(e);            }        }        int requestParseTimeout = settings.get(UndertowOptions.REQUEST_PARSE_TIMEOUT, -1);        int requestIdleTimeout = settings.get(UndertowOptions.NO_REQUEST_TIMEOUT, -1);        if(requestIdleTimeout < 0 && requestParseTimeout < 0) {            this.parseTimeoutUpdater = null;        } else {            this.parseTimeoutUpdater = new ParseTimeoutUpdater(this, requestParseTimeout, requestIdleTimeout, new Runnable() {                @Override                public void run() {                    sendGoAway(ERROR_NO_ERROR);                    getIoThread().executeAfter(new Runnable() {                        @Override                        public void run() {                            IoUtils.safeClose(Http2Channel.this);                        }                    }, 2, TimeUnit.SECONDS);                }            });            this.addCloseTask(new ChannelListener<Http2Channel>() {                @Override                public void handleEvent(Http2Channel channel) {                    parseTimeoutUpdater.close();                }            });        }    }    private void sendSettings() {        List<Http2Setting> settings = new ArrayList<>();        settings.add(new Http2Setting(Http2Setting.SETTINGS_HEADER_TABLE_SIZE, encoderHeaderTableSize));        if(isClient()) {            settings.add(new Http2Setting(Http2Setting.SETTINGS_ENABLE_PUSH, pushEnabled ? 1 : 0));        }        settings.add(new Http2Setting(Http2Setting.SETTINGS_MAX_FRAME_SIZE, receiveMaxFrameSize));        settings.add(new Http2Setting(Http2Setting.SETTINGS_INITIAL_WINDOW_SIZE, initialReceiveWindowSize));        if(maxHeaderListSize > 0) {            settings.add(new Http2Setting(Http2Setting.SETTINGS_MAX_HEADER_LIST_SIZE, maxHeaderListSize));        }        if(receiveMaxConcurrentStreams > 0) {            settings.add(new Http2Setting(Http2Setting.SETTINGS_MAX_CONCURRENT_STREAMS, receiveMaxConcurrentStreams));        }        Http2SettingsStreamSinkChannel stream = new Http2SettingsStreamSinkChannel(this, settings);        flushChannelIgnoreFailure(stream);    }    private void sendSettingsAck() {        if(!initialSettingsSent) {            sendSettings();            initialSettingsSent = true;        }        Http2SettingsStreamSinkChannel stream = new Http2SettingsStreamSinkChannel(this);        flushChannelIgnoreFailure(stream);    }    private void flushChannelIgnoreFailure(StreamSinkChannel stream) {        try {            flushChannel(stream);        } catch (IOException e) {            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);        } catch (Throwable t) {            UndertowLogger.REQUEST_IO_LOGGER.handleUnexpectedFailure(t);        }    }    private void flushChannel(StreamSinkChannel stream) throws IOException {        stream.shutdownWrites();        if (!stream.flush()) {            stream.getWriteSetter().set(ChannelListeners.flushingChannelListener(null, writeExceptionHandler()));            stream.resumeWrites();        }    }    private void sendPreface() {        Http2PrefaceStreamSinkChannel preface = new Http2PrefaceStreamSinkChannel(this);        flushChannelIgnoreFailure(preface);    }    @Override    protected AbstractHttp2StreamSourceChannel createChannel(FrameHeaderData frameHeaderData, PooledByteBuffer frameData) throws IOException {        AbstractHttp2StreamSourceChannel channel = createChannelImpl(frameHeaderData, frameData);        if(channel instanceof Http2StreamSourceChannel) {            if (parseTimeoutUpdater != null) {                if (channel != null) {                    parseTimeoutUpdater.requestStarted();                } else if (currentStreams.isEmpty()) {                    parseTimeoutUpdater.failedParse();                }            }        }        return channel;    }    protected AbstractHttp2StreamSourceChannel createChannelImpl(FrameHeaderData frameHeaderData, PooledByteBuffer frameData) throws IOException {        Http2FrameHeaderParser frameParser = (Http2FrameHeaderParser) frameHeaderData;        AbstractHttp2StreamSourceChannel channel;        if (frameParser.type == FRAME_TYPE_DATA) {            sendGoAway(ERROR_PROTOCOL_ERROR);            UndertowLogger.REQUEST_LOGGER.tracef(\"Dropping Frame of length %s for stream %s\", frameParser.getFrameLength(), frameParser.streamId);            return null;        }        switch (frameParser.type) {            case FRAME_TYPE_CONTINUATION:            case FRAME_TYPE_PUSH_PROMISE: {                if(frameParser.parser instanceof Http2PushPromiseParser) {                    if(!isClient()) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        throw UndertowMessages.MESSAGES.serverReceivedPushPromise();                    }                    Http2PushPromiseParser pushPromiseParser = (Http2PushPromiseParser) frameParser.parser;                    channel = new Http2PushPromiseStreamSourceChannel(this, frameData, frameParser.getFrameLength(), pushPromiseParser.getHeaderMap(), pushPromiseParser.getPromisedStreamId(), frameParser.streamId);                    break;                }            }            case FRAME_TYPE_HEADERS: {                if(!isIdle(frameParser.streamId)) {                    StreamHolder existing = currentStreams.get(frameParser.streamId);                    if(existing == null || existing.sourceClosed) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        frameData.close();                        return null;                    } else if (existing.sourceChannel != null ){                        if(!Bits.allAreSet(frameParser.flags, HEADERS_FLAG_END_STREAM)) {                            sendGoAway(ERROR_PROTOCOL_ERROR);                            frameData.close();                            return null;                        }                    }                } else {                    if(frameParser.streamId < getLastAssignedStreamOtherSide()) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        frameData.close();                        return null;                    }                    if(frameParser.streamId % 2 == (isClient() ? 1 : 0)) {                        sendGoAway(ERROR_PROTOCOL_ERROR);                        frameData.close();                        return null;                    }                }                Http2HeadersParser parser = (Http2HeadersParser) frameParser.parser;                channel = new Http2StreamSourceChannel(this, frameData, frameHeaderData.getFrameLength(), parser.getHeaderMap(), frameParser.streamId);                updateStreamIdsCountersInHeaders(frameParser.streamId);                StreamHolder holder = currentStreams.get(frameParser.streamId);                if(holder == null) {                    receiveConcurrentStreamsAtomicUpdater.getAndIncrement(this);                    currentStreams.put(frameParser.streamId, holder = new StreamHolder((Http2StreamSourceChannel) channel));                } else {                    holder.sourceChannel = (Http2StreamSourceChannel) channel;                }                if (parser.isHeadersEndStream() && Bits.allAreSet(frameParser.flags, HEADERS_FLAG_END_HEADERS)) {                    channel.lastFrame();                    holder.sourceChannel = null;                    if(!isClient() || !\"100\".equals(parser.getHeaderMap().getFirst(STATUS))) {                        holder.sourceClosed = true;                        if(holder.sinkClosed) {                            receiveConcurrentStreamsAtomicUpdater.getAndDecrement(this);                            currentStreams.remove(frameParser.streamId);                        }                    }                }                if(parser.isInvalid()) {                    channel.rstStream(ERROR_PROTOCOL_ERROR);                    sendRstStream(frameParser.streamId, Http2Channel.ERROR_PROTOCOL_ERROR);                    channel = null;                }                if(parser.getDependentStreamId() == frameParser.streamId) {                    sendRstStream(frameParser.streamId, ERROR_PROTOCOL_ERROR);                    frameData.close();                    return null;                }                break;            }            case FRAME_TYPE_RST_STREAM: {                Http2RstStreamParser parser = (Http2RstStreamParser) frameParser.parser;                if (frameParser.streamId == 0) {                    if(frameData != null) {                        frameData.close();                    }                    throw new ConnectionErrorException(Http2Channel.ERROR_PROTOCOL_ERROR, UndertowMessages.MESSAGES.streamIdMustNotBeZeroForFrameType(FRAME_TYPE_RST_STREAM));                }                channel = new Http2RstStreamStreamSourceChannel(this, frameData, parser.getErrorCode(), frameParser.streamId);                handleRstStream(frameParser.streamId);                if(isIdle(frameParser.streamId)) {                    sendGoAway(ERROR_PROTOCOL_ERROR);                }                break;            }            case FRAME_TYPE_SETTINGS: {                if (!Bits.anyAreSet(frameParser.flags, SETTINGS_FLAG_ACK)) {                    if(updateSettings(((Http2SettingsParser) frameParser.parser).getSettings())) {                        sendSettingsAck();                    }                } else if (frameHeaderData.getFrameLength() != 0) {                    sendGoAway(ERROR_FRAME_SIZE_ERROR);                    frameData.close();                    return null;                }                channel = new Http2SettingsStreamSourceChannel(this, frameData, frameParser.getFrameLength(), ((Http2SettingsParser) frameParser.parser).getSettings());                unackedReceiveMaxFrameSize = receiveMaxFrameSize;                break;            }            case FRAME_TYPE_PING: {                Http2PingParser pingParser = (Http2PingParser) frameParser.parser;                frameData.close();                boolean ack = Bits.anyAreSet(frameParser.flags, PING_FLAG_ACK);                channel = new Http2PingStreamSourceChannel(this, pingParser.getData(), ack);                if(!ack) {                     sendPing(pingParser.getData(),  new Http2ControlMessageExceptionHandler(), true);                }                break;            }            case FRAME_TYPE_GOAWAY: {                Http2GoAwayParser http2GoAwayParser = (Http2GoAwayParser) frameParser.parser;                channel = new Http2GoAwayStreamSourceChannel(this, frameData, frameParser.getFrameLength(), http2GoAwayParser.getStatusCode(), http2GoAwayParser.getLastGoodStreamId());                peerGoneAway = true;                for(StreamHolder holder : currentStreams.values()) {                    if(holder.sourceChannel != null) {                        holder.sourceChannel.rstStream();                    }                    if(holder.sinkChannel != null) {                        holder.sinkChannel.rstStream();                    }                }                frameData.close();                sendGoAway(ERROR_NO_ERROR);                break;            }            case FRAME_TYPE_WINDOW_UPDATE: {                Http2WindowUpdateParser parser = (Http2WindowUpdateParser) frameParser.parser;                handleWindowUpdate(frameParser.streamId, parser.getDeltaWindowSize());                frameData.close();                return null;            }            case FRAME_TYPE_PRIORITY: {                Http2PriorityParser parser = (Http2PriorityParser) frameParser.parser;                if(parser.getStreamDependency() == frameParser.streamId) {                    sendRstStream(frameParser.streamId, ERROR_PROTOCOL_ERROR);                    return null;                }                frameData.close();                return null;            }            default: {                UndertowLogger.REQUEST_LOGGER.tracef(\"Dropping frame of length %s and type %s for stream %s as we do not understand this type of frame\", frameParser.getFrameLength(), frameParser.type, frameParser.streamId);                frameData.close();                return null;            }        }        return channel;    }    @Override    protected FrameHeaderData parseFrame(ByteBuffer data) throws IOException {        if (prefaceCount < PREFACE_BYTES.length) {            while (data.hasRemaining() && prefaceCount < PREFACE_BYTES.length) {                if (data.get() != PREFACE_BYTES[prefaceCount]) {                    IoUtils.safeClose(getUnderlyingConnection());                    throw UndertowMessages.MESSAGES.incorrectHttp2Preface();                }                prefaceCount++;            }        }        Http2FrameHeaderParser frameParser = this.frameParser;        if (frameParser == null) {            this.frameParser = frameParser = new Http2FrameHeaderParser(this, continuationParser);            this.continuationParser = null;        }        if (!frameParser.handle(data)) {            return null;        }        if (!initialSettingsReceived) {            if (frameParser.type != FRAME_TYPE_SETTINGS) {                UndertowLogger.REQUEST_IO_LOGGER.remoteEndpointFailedToSendInitialSettings(frameParser.type);                markReadsBroken(new IOException());            } else {                initialSettingsReceived = true;            }        }        this.frameParser = null;        if (frameParser.getActualLength() > receiveMaxFrameSize && frameParser.getActualLength() > unackedReceiveMaxFrameSize) {            sendGoAway(ERROR_FRAME_SIZE_ERROR);            throw UndertowMessages.MESSAGES.http2FrameTooLarge();        }        if (frameParser.getContinuationParser() != null) {            this.continuationParser = frameParser.getContinuationParser();            return null;        }        return frameParser;    }    protected void lastDataRead() {        lastDataRead = true;        if(!peerGoneAway) {            IoUtils.safeClose(this);        } else {            peerGoneAway = true;            if(!thisGoneAway) {                sendGoAway(ERROR_CONNECT_ERROR);            }        }    }    @Override    protected boolean isLastFrameReceived() {        return lastDataRead;    }    @Override    protected boolean isLastFrameSent() {        return thisGoneAway;    }    @Override    protected void handleBrokenSourceChannel(Throwable e) {        UndertowLogger.REQUEST_LOGGER.debugf(e, \"Closing HTTP2 channel to %s due to broken read side\", getPeerAddress());        if (e instanceof ConnectionErrorException) {            sendGoAway(((ConnectionErrorException) e).getCode(), new Http2ControlMessageExceptionHandler());        } else {            sendGoAway(e instanceof ClosedChannelException ? Http2Channel.ERROR_CONNECT_ERROR : Http2Channel.ERROR_PROTOCOL_ERROR, new Http2ControlMessageExceptionHandler());        }    }    @Override    protected void handleBrokenSinkChannel(Throwable e) {        UndertowLogger.REQUEST_LOGGER.debugf(e, \"Closing HTTP2 channel to %s due to broken write side\", getPeerAddress());        IoUtils.safeClose(this);    }    @Override    protected void closeSubChannels() {        for (Map.Entry<Integer, StreamHolder> e : currentStreams.entrySet()) {            StreamHolder holder = e.getValue();            AbstractHttp2StreamSourceChannel receiver = holder.sourceChannel;            if(receiver != null) {                receiver.markStreamBroken();            }            Http2StreamSinkChannel sink = holder.sinkChannel;            if(sink != null) {                if (sink.isWritesShutdown()) {                    ChannelListeners.invokeChannelListener(sink.getIoThread(), sink, ((ChannelListener.SimpleSetter) sink.getWriteSetter()).get());                }                IoUtils.safeClose(sink);            }        }    }    @Override    protected Collection<AbstractFramedStreamSourceChannel<Http2Channel, AbstractHttp2StreamSourceChannel, AbstractHttp2StreamSinkChannel>> getReceivers() {        List<AbstractFramedStreamSourceChannel<Http2Channel, AbstractHttp2StreamSourceChannel, AbstractHttp2StreamSinkChannel>> channels = new ArrayList<>(currentStreams.size());        for(Map.Entry<Integer, StreamHolder> entry : currentStreams.entrySet()) {            if(!entry.getValue().sourceClosed) {                channels.add(entry.getValue().sourceChannel);            }        }        return channels;    }    boolean updateSettings(List<Http2Setting> settings) {        for (Http2Setting setting : settings) {            if (setting.getId() == Http2Setting.SETTINGS_INITIAL_WINDOW_SIZE) {                synchronized (flowControlLock) {                    if (setting.getValue() > Integer.MAX_VALUE) {                        sendGoAway(ERROR_FLOW_CONTROL_ERROR);                        return false;                    }                    initialSendWindowSize = (int) setting.getValue();                }            } else if (setting.getId() == Http2Setting.SETTINGS_MAX_FRAME_SIZE) {                if(setting.getValue() > MAX_FRAME_SIZE || setting.getValue() < DEFAULT_MAX_FRAME_SIZE) {                    UndertowLogger.REQUEST_IO_LOGGER.debug(\"Invalid value received for SETTINGS_MAX_FRAME_SIZE \" + setting.getValue());                    sendGoAway(ERROR_PROTOCOL_ERROR);                    return false;                }                sendMaxFrameSize = (int) setting.getValue();            } else if (setting.getId() == Http2Setting.SETTINGS_HEADER_TABLE_SIZE) {                synchronized (this) {                    encoder.setMaxTableSize((int) setting.getValue());                }            } else if (setting.getId() == Http2Setting.SETTINGS_ENABLE_PUSH) {                int result = (int) setting.getValue();                if(result == 0) {                    pushEnabled = false;                } else if(result != 1) {                    UndertowLogger.REQUEST_IO_LOGGER.debug(\"Invalid value received for SETTINGS_ENABLE_PUSH \" + result);                    sendGoAway(ERROR_PROTOCOL_ERROR);                    return false;                }            } else if (setting.getId() == Http2Setting.SETTINGS_MAX_CONCURRENT_STREAMS) {                sendMaxConcurrentStreams = (int) setting.getValue();            }        }        return"}
{"code": "import io.undertow.Undertow;import io.undertow.UndertowOptions;import io.undertow.client.ClientCallback;import io.undertow.client.ClientConnection;import io.undertow.client.ClientExchange;import io.undertow.client.ClientRequest;import io.undertow.client.ClientResponse;import io.undertow.client.UndertowClient;import io.undertow.connector.ByteBufferPool;import io.undertow.io.Receiver;import io.undertow.io.Sender;import io.undertow.protocols.ssl.UndertowXnioSsl;import io.undertow.server.DefaultByteBufferPool;import io.undertow.server.HttpHandler;import io.undertow.server.HttpServerExchange;import io.undertow.server.handlers.PathHandler;import io.undertow.server.protocol.http2.Http2UpgradeHandler;import io.undertow.testutils.DebuggingSlicePool;import io.undertow.testutils.DefaultServer;import io.undertow.testutils.HttpOneOnly;import io.undertow.util.AttachmentKey;import io.undertow.util.HeaderValues;import io.undertow.util.Headers;import io.undertow.util.HttpString;import io.undertow.util.Methods;import io.undertow.util.StatusCodes;import io.undertow.util.StringReadChannelListener;import io.undertow.util.StringWriteChannelListener;import java.io.IOException;import java.net.URI;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.AfterClass;import org.junit.Assert;import org.junit.BeforeClass;import org.junit.Test;import org.junit.runner.RunWith;import org.xnio.ChannelListeners;import org.xnio.IoUtils;import org.xnio.OptionMap;import org.xnio.Options;import org.xnio.Xnio;import org.xnio.XnioWorker;import org.xnio.channels.StreamSinkChannel;@RunWith(DefaultServer.class)@HttpOneOnlypublic class H2CUpgradeContinuationTestCase {    private static final String HEADER_PREFFIX = \"custom-header-\";    private static final String ECHO_PATH = \"/echo\";    private static final AttachmentKey<String> RESPONSE_BODY = AttachmentKey.create(String.class);    private static ByteBufferPool smallPool;    private static XnioWorker worker;    private static Undertow server;    private static void sendEchoResponse(final HttpServerExchange exchange) {        exchange.setStatusCode(StatusCodes.OK);        for (HeaderValues header : exchange.getRequestHeaders()) {            if (header.getFirst().startsWith(HEADER_PREFFIX)) {                exchange.getResponseHeaders().putAll(header.getHeaderName(), header.subList(0, header.size()));            }        }        if (exchange.getRequestContentLength() > 0) {            exchange.getRequestReceiver().receiveFullString(new Receiver.FullStringCallback() {                @Override                public void handle(HttpServerExchange exchange, String message) {                    exchange.getResponseSender().send(message);                }            });        } else {            final Sender sender = exchange.getResponseSender();            sender.send(\"\");        }    }    @BeforeClass    public static void beforeClass() throws IOException {        smallPool = new DebuggingSlicePool(new DefaultByteBufferPool(true, 1024, 1000, 10, 100));        final PathHandler path = new PathHandler()                .addExactPath(ECHO_PATH, new HttpHandler() {                    @Override                    public void handleRequest(HttpServerExchange exchange) throws Exception {                        sendEchoResponse(exchange);                    }                });        server = Undertow.builder()                .setByteBufferPool(smallPool)                .addHttpListener(DefaultServer.getHostPort(\"default\") + 1, DefaultServer.getHostAddress(\"default\"), new Http2UpgradeHandler(path))                .setSocketOption(Options.REUSE_ADDRESSES, true)                .build();        server.start();        final Xnio xnio = Xnio.getInstance();        final XnioWorker xnioWorker = xnio.createWorker(null, OptionMap.builder()                .set(Options.WORKER_IO_THREADS, 8)                .set(Options.TCP_NODELAY, true)                .set(Options.KEEP_ALIVE, true)                .getMap());        worker = xnioWorker;    }    @AfterClass    public static void afterClass() {        if (server != null) {            server.stop();        }        if (worker != null) {            worker.shutdown();        }        if (smallPool != null) {            smallPool.close();            smallPool = null;        }    }    private void sendRequest(ClientConnection connection, int requestCount, int headersCount, int contentLength) throws Exception {        final CountDownLatch latch = new CountDownLatch(requestCount);        final List<ClientResponse> responses = new CopyOnWriteArrayList<>();        StringBuilder sb = new StringBuilder();        for (int i = 0; i < contentLength; i++) {            sb.append(i % 10);        }        final String content = sb.length() > 0? sb.toString() : null;        connection.getIoThread().execute(new Runnable() {            @Override            public void run() {                for (int i = 0; i < requestCount; i++) {                    final ClientRequest request = new ClientRequest()                            .setMethod(contentLength > 0 ? Methods.POST : Methods.GET)                            .setPath(ECHO_PATH);                    request.getRequestHeaders().put(Headers.HOST, DefaultServer.getHostAddress());                    if (contentLength > 0) {                        request.getRequestHeaders().put(Headers.CONTENT_LENGTH, contentLength);                    }                    for (int j = 0; j < headersCount; j++) {                        request.getRequestHeaders().put(new HttpString(HEADER_PREFFIX + j), HEADER_PREFFIX + j);                    }                    connection.sendRequest(request, createClientCallback(responses, latch, content));                }            }        });        latch.await(10, TimeUnit.SECONDS);        Assert.assertEquals(\"No responses received from server in 10s\", requestCount, responses.size());        for (int i = 0; i < requestCount; i++) {            Assert.assertEquals(\"Response \" + i + \" code was not OK\", StatusCodes.OK, responses.get(i).getResponseCode());            Assert.assertEquals(\"Incorrect data received for response \" + i, contentLength > 0 ? content : \"\", responses.get(i).getAttachment(RESPONSE_BODY));            int headersReturned = 0;            for (HeaderValues header : responses.get(i).getResponseHeaders()) {                if (header.getFirst().startsWith(HEADER_PREFFIX)) {                    headersReturned += header.size();                }            }            Assert.assertEquals(\"Incorrect number of headers returned for response \" + i, headersCount, headersReturned);        }    }    @Test    public void testDifferentSizes() throws Exception {        final UndertowClient client = UndertowClient.getInstance();        final ClientConnection connection = client.connect(                new URI(\"http:                worker, new UndertowXnioSsl(worker.getXnio(), OptionMap.EMPTY, DefaultServer.getClientSSLContext()),                smallPool, OptionMap.create(UndertowOptions.ENABLE_HTTP2, true)).get();        try {            sendRequest(connection, 1, 0, 0);            sendRequest(connection, 10, 10, 0);            sendRequest(connection, 10, 100, 0);            sendRequest(connection, 10, 150, 0);            sendRequest(connection, 10, 1, 10);            sendRequest(connection, 10, 0, 2000);            sendRequest(connection, 10, 150, 2000);        } finally {            IoUtils.safeClose(connection);        }    }    private static ClientCallback<ClientExchange> createClientCallback(final List<ClientResponse> responses, final CountDownLatch latch, String message) {        return new ClientCallback<ClientExchange>() {            @Override            public void completed(ClientExchange result) {                if (message != null) {                    new StringWriteChannelListener(message).setup(result.getRequestChannel());                }                result.setResponseListener(new ClientCallback<ClientExchange>() {                    @Override                    public void completed(final ClientExchange result) {                        responses.add(result.getResponse());                        new StringReadChannelListener(result.getConnection().getBufferPool()) {                            @Override                            protected void stringDone(String string) {                                result.getResponse().putAttachment(RESPONSE_BODY, string);                                latch.countDown();                            }                            @Override                            protected void error(IOException e) {                                e.printStackTrace();                                latch.countDown();                            }                        }.setup(result.getResponseChannel());                    }                    @Override                    public void failed(IOException e) {                        e.printStackTrace();                        latch.countDown();                    }                });                try {                    result.getRequestChannel().shutdownWrites();                    if (!result.getRequestChannel().flush()) {                        result.getRequestChannel().getWriteSetter().set(ChannelListeners.<StreamSinkChannel>flushingChannelListener(null, null));                        result.getRequestChannel().resumeWrites();                    }                } catch (IOException e) {                    e.printStackTrace();                    latch.countDown();                }            }            @Override            public void failed(IOException e) {                e.printStackTrace();                latch.countDown();            }        };    }}", "nl": ""}
{"code": "public interface Arm64Const {   public static final int UC_CPU_ARM64_A57 = 0;   public static final int UC_CPU_ARM64_A53 = 1;   public static final int UC_CPU_ARM64_A72 = 2;   public static final int UC_CPU_ARM64_MAX = 3;   public static final int UC_CPU_ARM64_ENDING = 4;   public static final int UC_ARM64_REG_INVALID = 0;   public static final int UC_ARM64_REG_X29 = 1;   public static final int UC_ARM64_REG_X30 = 2;   public static final int UC_ARM64_REG_NZCV = 3;   public static final int UC_ARM64_REG_SP = 4;   public static final int UC_ARM64_REG_WSP = 5;   public static final int UC_ARM64_REG_WZR = 6;   public static final int UC_ARM64_REG_XZR = 7;   public static final int UC_ARM64_REG_B0 = 8;   public static final int UC_ARM64_REG_B1 = 9;   public static final int UC_ARM64_REG_B2 = 10;   public static final int UC_ARM64_REG_B3 = 11;   public static final int UC_ARM64_REG_B4 = 12;   public static final int UC_ARM64_REG_B5 = 13;   public static final int UC_ARM64_REG_B6 = 14;   public static final int UC_ARM64_REG_B7 = 15;   public static final int UC_ARM64_REG_B8 = 16;   public static final int UC_ARM64_REG_B9 = 17;   public static final int UC_ARM64_REG_B10 = 18;   public static final int UC_ARM64_REG_B11 = 19;   public static final int UC_ARM64_REG_B12 = 20;   public static final int UC_ARM64_REG_B13 = 21;   public static final int UC_ARM64_REG_B14 = 22;   public static final int UC_ARM64_REG_B15 = 23;   public static final int UC_ARM64_REG_B16 = 24;   public static final int UC_ARM64_REG_B17 = 25;   public static final int UC_ARM64_REG_B18 = 26;   public static final int UC_ARM64_REG_B19 = 27;   public static final int UC_ARM64_REG_B20 = 28;   public static final int UC_ARM64_REG_B21 = 29;   public static final int UC_ARM64_REG_B22 = 30;   public static final int UC_ARM64_REG_B23 = 31;   public static final int UC_ARM64_REG_B24 = 32;   public static final int UC_ARM64_REG_B25 = 33;   public static final int UC_ARM64_REG_B26 = 34;   public static final int UC_ARM64_REG_B27 = 35;   public static final int UC_ARM64_REG_B28 = 36;   public static final int UC_ARM64_REG_B29 = 37;   public static final int UC_ARM64_REG_B30 = 38;   public static final int UC_ARM64_REG_B31 = 39;   public static final int UC_ARM64_REG_D0 = 40;   public static final int UC_ARM64_REG_D1 = 41;   public static final int UC_ARM64_REG_D2 = 42;   public static final int UC_ARM64_REG_D3 = 43;   public static final int UC_ARM64_REG_D4 = 44;   public static final int UC_ARM64_REG_D5 = 45;   public static final int UC_ARM64_REG_D6 = 46;   public static final int UC_ARM64_REG_D7 = 47;   public static final int UC_ARM64_REG_D8 = 48;   public static final int UC_ARM64_REG_D9 = 49;   public static final int UC_ARM64_REG_D10 = 50;   public static final int UC_ARM64_REG_D11 = 51;   public static final int UC_ARM64_REG_D12 = 52;   public static final int UC_ARM64_REG_D13 = 53;   public static final int UC_ARM64_REG_D14 = 54;   public static final int UC_ARM64_REG_D15 = 55;   public static final int UC_ARM64_REG_D16 = 56;   public static final int UC_ARM64_REG_D17 = 57;   public static final int UC_ARM64_REG_D18 = 58;   public static final int UC_ARM64_REG_D19 = 59;   public static final int UC_ARM64_REG_D20 = 60;   public static final int UC_ARM64_REG_D21 = 61;   public static final int UC_ARM64_REG_D22 = 62;   public static final int UC_ARM64_REG_D23 = 63;   public static final int UC_ARM64_REG_D24 = 64;   public static final int UC_ARM64_REG_D25 = 65;   public static final int UC_ARM64_REG_D26 = 66;   public static final int UC_ARM64_REG_D27 = 67;   public static final int UC_ARM64_REG_D28 = 68;   public static final int UC_ARM64_REG_D29 = 69;   public static final int UC_ARM64_REG_D30 = 70;   public static final int UC_ARM64_REG_D31 = 71;   public static final int UC_ARM64_REG_H0 = 72;   public static final int UC_ARM64_REG_H1 = 73;   public static final int UC_ARM64_REG_H2 = 74;   public static final int UC_ARM64_REG_H3 = 75;   public static final int UC_ARM64_REG_H4 = 76;   public static final int UC_ARM64_REG_H5 = 77;   public static final int UC_ARM64_REG_H6 = 78;   public static final int UC_ARM64_REG_H7 = 79;   public static final int UC_ARM64_REG_H8 = 80;   public static final int UC_ARM64_REG_H9 = 81;   public static final int UC_ARM64_REG_H10 = 82;   public static final int UC_ARM64_REG_H11 = 83;   public static final int UC_ARM64_REG_H12 = 84;   public static final int UC_ARM64_REG_H13 = 85;   public static final int UC_ARM64_REG_H14 = 86;   public static final int UC_ARM64_REG_H15 = 87;   public static final int UC_ARM64_REG_H16 = 88;   public static final int UC_ARM64_REG_H17 = 89;   public static final int UC_ARM64_REG_H18 = 90;   public static final int UC_ARM64_REG_H19 = 91;   public static final int UC_ARM64_REG_H20 = 92;   public static final int UC_ARM64_REG_H21 = 93;   public static final int UC_ARM64_REG_H22 = 94;   public static final int UC_ARM64_REG_H23 = 95;   public static final int UC_ARM64_REG_H24 = 96;   public static final int UC_ARM64_REG_H25 = 97;   public static final int UC_ARM64_REG_H26 = 98;   public static final int UC_ARM64_REG_H27 = 99;   public static final int UC_ARM64_REG_H28 = 100;   public static final int UC_ARM64_REG_H29 = 101;   public static final int UC_ARM64_REG_H30 = 102;   public static final int UC_ARM64_REG_H31 = 103;   public static final int UC_ARM64_REG_Q0 = 104;   public static final int UC_ARM64_REG_Q1 = 105;   public static final int UC_ARM64_REG_Q2 = 106;   public static final int UC_ARM64_REG_Q3 = 107;   public static final int UC_ARM64_REG_Q4 = 108;   public static final int UC_ARM64_REG_Q5 = 109;   public static final int UC_ARM64_REG_Q6 = 110;   public static final int UC_ARM64_REG_Q7 = 111;   public static final int UC_ARM64_REG_Q8 = 112;   public static final int UC_ARM64_REG_Q9 = 113;   public static final int UC_ARM64_REG_Q10 = 114;   public static final int UC_ARM64_REG_Q11 = 115;   public static final int UC_ARM64_REG_Q12 = 116;   public static final int UC_ARM64_REG_Q13 = 117;   public static final int UC_ARM64_REG_Q14 = 118;   public static final int UC_ARM64_REG_Q15 = 119;   public static final int UC_ARM64_REG_Q16 = 120;   public static final int UC_ARM64_REG_Q17 = 121;   public static final int UC_ARM64_REG_Q18 = 122;   public static final int UC_ARM64_REG_Q19 = 123;   public static final int UC_ARM64_REG_Q20 = 124;   public static final int UC_ARM64_REG_Q21 = 125;   public static final int UC_ARM64_REG_Q22 = 126;   public static final int UC_ARM64_REG_Q23 = 127;   public static final int UC_ARM64_REG_Q24 = 128;   public static final int UC_ARM64_REG_Q25 = 129;   public static final int UC_ARM64_REG_Q26 = 130;   public static final int UC_ARM64_REG_Q27 = 131;   public static final int UC_ARM64_REG_Q28 = 132;   public static final int UC_ARM64_REG_Q29 = 133;   public static final int UC_ARM64_REG_Q30 = 134;   public static final int UC_ARM64_REG_Q31 = 135;   public static final int UC_ARM64_REG_S0 = 136;   public static final int UC_ARM64_REG_S1 = 137;   public static final int UC_ARM64_REG_S2 = 138;   public static final int UC_ARM64_REG_S3 = 139;   public static final int UC_ARM64_REG_S4 = 140;   public static final int UC_ARM64_REG_S5 = 141;   public static final int UC_ARM64_REG_S6 = 142;   public static final int UC_ARM64_REG_S7 = 143;   public static final int UC_ARM64_REG_S8 = 144;   public static final int UC_ARM64_REG_S9 = 145;   public static final int UC_ARM64_REG_S10 = 146;   public static final int UC_ARM64_REG_S11 = 147;   public static final int UC_ARM64_REG_S12 = 148;   public static final int UC_ARM64_REG_S13 = 149;   public static final int UC_ARM64_REG_S14 = 150;   public static final int UC_ARM64_REG_S15 = 151;   public static final int UC_ARM64_REG_S16 = 152;   public static final int UC_ARM64_REG_S17 = 153;   public static final int UC_ARM64_REG_S18 = 154;   public static final int UC_ARM64_REG_S19 = 155;   public static final int UC_ARM64_REG_S20 = 156;   public static final int UC_ARM64_REG_S21 = 157;   public static final int UC_ARM64_REG_S22 = 158;   public static final int UC_ARM64_REG_S23 = 159;   public static final int UC_ARM64_REG_S24 = 160;   public static final int UC_ARM64_REG_S25 = 161;   public static final int UC_ARM64_REG_S26 = 162;   public static final int UC_ARM64_REG_S27 = 163;   public static final int UC_ARM64_REG_S28 = 164;   public static final int UC_ARM64_REG_S29 = 165;   public static final int UC_ARM64_REG_S30 = 166;   public static final int UC_ARM64_REG_S31 = 167;   public static final int UC_ARM64_REG_W0 = 168;   public static final int UC_ARM64_REG_W1 = 169;   public static final int UC_ARM64_REG_W2 = 170;   public static final int UC_ARM64_REG_W3 = 171;   public static final int UC_ARM64_REG_W4 = 172;   public static final int UC_ARM64_REG_W5 = 173;   public static final int UC_ARM64_REG_W6 = 174;   public static final int UC_ARM64_REG_W7 = 175;   public static final int UC_ARM64_REG_W8 = 176;   public static final int UC_ARM64_REG_W9 = 177;   public static final int UC_ARM64_REG_W10 = 178;   public static final int UC_ARM64_REG_W11 = 179;   public static final int UC_ARM64_REG_W12 = 180;   public static final int UC_ARM64_REG_W13 = 181;   public static final int UC_ARM64_REG_W14 = 182;   public static final int UC_ARM64_REG_W15 = 183;   public static final int UC_ARM64_REG_W16 = 184;   public static final int UC_ARM64_REG_W17 = 185;   public static final int UC_ARM64_REG_W18 = 186;   public static final int UC_ARM64_REG_W19 = 187;   public static final int UC_ARM64_REG_W20 = 188;   public static final int UC_ARM64_REG_W21 = 189;   public static final int UC_ARM64_REG_W22 = 190;   public static final int UC_ARM64_REG_W23 = 191;   public static final int UC_ARM64_REG_W24 = 192;   public static final int UC_ARM64_REG_W25 = 193;   public static final int UC_ARM64_REG_W26 = 194;   public static final int UC_ARM64_REG_W27 = 195;   public static final int UC_ARM64_REG_W28 = 196;   public static final int UC_ARM64_REG_W29 = 197;   public static final int UC_ARM64_REG_W30 = 198;   public static final int UC_ARM64_REG_X0 = 199;   public static final int UC_ARM64_REG_X1 = 200;   public static final int UC_ARM64_REG_X2 = 201;   public static final int UC_ARM64_REG_X3 = 202;   public static final int UC_ARM64_REG_X4 = 203;   public static final int UC_ARM64_REG_X5 = 204;   public static final int UC_ARM64_REG_X6 = 205;   public static final int UC_ARM64_REG_X7 = 206;   public static final int UC_ARM64_REG_X8 = 207;   public static final int UC_ARM64_REG_X9 = 208;   public static final int UC_ARM64_REG_X10 = 209;   public static final int UC_ARM64_REG_X11 = 210;   public static final int UC_ARM64_REG_X12 = 211;   public static final int UC_ARM64_REG_X13 = 212;   public static final int UC_ARM64_REG_X14 = 213;   public static final int UC_ARM64_REG_X15 = 214;   public static final int UC_ARM64_REG_X16 = 215;   public static final int UC_ARM64_REG_X17 = 216;   public static final int UC_ARM64_REG_X18 = 217;   public static final int UC_ARM64_REG_X19 = 218;   public static final int UC_ARM64_REG_X20 = 219;   public static final int UC_ARM64_REG_X21 = 220;   public static final int UC_ARM64_REG_X22 = 221;   public static final int UC_ARM64_REG_X23 = 222;   public static final int UC_ARM64_REG_X24 = 223;   public static final int UC_ARM64_REG_X25 = 224;   public static final int UC_ARM64_REG_X26 = 225;   public static final int UC_ARM64_REG_X27 = 226;   public static final int UC_ARM64_REG_X28 = 227;   public static final int UC_ARM64_REG_V0 = 228;   public static final int UC_ARM64_REG_V1 = 229;   public static final int UC_ARM64_REG_V2 = 230;   public static final int UC_ARM64_REG_V3 = 231;   public static final int UC_ARM64_REG_V4 = 232;   public static final int UC_ARM64_REG_V5 = 233;   public static final int UC_ARM64_REG_V6 = 234;   public static final int UC_ARM64_REG_V7 = 235;   public static final int UC_ARM64_REG_V8 = 236;   public static final int UC_ARM64_REG_V9 = 237;   public static final int UC_ARM64_REG_V10 = 238;   public static final int UC_ARM64_REG_V11 = 239;   public static final int UC_ARM64_REG_V12 = 240;   public static final int UC_ARM64_REG_V13 = 241;   public static final int UC_ARM64_REG_V14 = 242;   public static final int UC_ARM64_REG_V15 = 243;   public static final int UC_ARM64_REG_V16 = 244;   public static final int UC_ARM64_REG_V17 = 245;   public static final int UC_ARM64_REG_V18 = 246;   public static final int UC_ARM64_REG_V19 = 247;   public static final int UC_ARM64_REG_V20 = 248;   public static final int UC_ARM64_REG_V21 = 249;   public static final int UC_ARM64_REG_V22 = 250;   public static final int UC_ARM64_REG_V23 = 251;   public static final int UC_ARM64_REG_V24 = 252;   public static final int UC_ARM64_REG_V25 = 253;   public static final int UC_ARM64_REG_V26 = 254;   public static final int UC_ARM64_REG_V27 = 255;   public static final int UC_ARM64_REG_V28 = 256;   public static final int UC_ARM64_REG_V29 = 257;   public static final int UC_ARM64_REG_V30 = 258;   public static final int UC_ARM64_REG_V31 = 259;   public static final int UC_ARM64_REG_PC = 260;   public static final int UC_ARM64_REG_CPACR_EL1 = 261;   public static final int UC_ARM64_REG_TPIDR_EL0 = 262;   public static final int UC_ARM64_REG_TPIDRRO_EL0 = 263;   public static final int UC_ARM64_REG_TPIDR_EL1 = 264;   public static final int UC_ARM64_REG_PSTATE = 265;   public static final int UC_ARM64_REG_ELR_EL0 = 266;   public static final int UC_ARM64_REG_ELR_EL1 = 267;   public static final int UC_ARM64_REG_ELR_EL2 = 268;   public static final int UC_ARM64_REG_ELR_EL3 = 269;   public static final int UC_ARM64_REG_SP_EL0 = 270;   public static final int UC_ARM64_REG_SP_EL1 = 271;   public static final int UC_ARM64_REG_SP_EL2 = 272;   public static final int UC_ARM64_REG_SP_EL3 = 273;   public static final int UC_ARM64_REG_TTBR0_EL1 = 274;   public static final int UC_ARM64_REG_TTBR1_EL1 = 275;   public static final int UC_ARM64_REG_ESR_EL0 = 276;   public static final int UC_ARM64_REG_ESR_EL1 = 277;   public static final int UC_ARM64_REG_ESR_EL2 = 278;   public static final int UC_ARM64_REG_ESR_EL3 = 279;   public static final int UC_ARM64_REG_FAR_EL0 = 280;   public static final int UC_ARM64_REG_FAR_EL1 = 281;   public static final int UC_ARM64_REG_FAR_EL2 = 282;   public static final int UC_ARM64_REG_FAR_EL3 = 283;   public static final int UC_ARM64_REG_PAR_EL1 = 284;   public static final int UC_ARM64_REG_MAIR_EL1 = 285;   public static final int UC_ARM64_REG_VBAR_EL0 = 286;   public static final int UC_ARM64_REG_VBAR_EL1 = 287;   public static final int UC_ARM64_REG_VBAR_EL2 = 288;   public static final int UC_ARM64_REG_VBAR_EL3 = 289;   public static final int UC_ARM64_REG_CP_REG = 290;   public static final int UC_ARM64_REG_ENDING = 291;   public static final int UC_ARM64_REG_IP0 = 215;   public static final int UC_ARM64_REG_IP1 = 216;   public static final int UC_ARM64_REG_FP = 1;   public static final int UC_ARM64_REG_LR = 2;   public static final int UC_ARM64_INS_INVALID = 0;   public static final int UC_ARM64_INS_MRS = 1;   public static final int UC_ARM64_INS_MSR = 2;   public static final int UC_ARM64_INS_SYS = 3;   public static final int UC_ARM64_INS_SYSL = 4;   public static final int UC_ARM64_INS_ENDING = 5;}", "nl": "public interface Arm64Const {   public static final int UC_CPU_AARCH64_A57 = 0;   public static final int UC_CPU_AARCH64_A53 = 1;   public static final int UC_CPU_AARCH64_A72 = 2;   public static final int UC_CPU_AARCH64_MAX = 3;   public static final int UC_ARM64_REG_INVALID = 0;   public static final int UC_ARM64_REG_X29 = 1;   public static final int UC_ARM64_REG_X30 = 2;   public static final int UC_ARM64_REG_NZCV = 3;   public static final int UC_ARM64_REG_SP = 4;   public static final int UC_ARM64_REG_WSP = 5;   public static final int UC_ARM64_REG_WZR = 6;   public static final int UC_ARM64_REG_XZR = 7;   public static final int UC_ARM64_REG_B0 = 8;   public static final int UC_ARM64_REG_B1 = 9;   public static final int UC_ARM64_REG_B2 = 10;   public static final int UC_ARM64_REG_B3 = 11;   public static final int UC_ARM64_REG_B4 = 12;   public static final int UC_ARM64_REG_B5 = 13;   public static final int UC_ARM64_REG_B6 = 14;   public static final int UC_ARM64_REG_B7 = 15;   public static final int UC_ARM64_REG_B8 = 16;   public static final int UC_ARM64_REG_B9 = 17;   public static final int UC_ARM64_REG_B10 = 18;   public static final int UC_ARM64_REG_B11 = 19;   public static final int UC_ARM64_REG_B12 = 20;   public static final int UC_ARM64_REG_B13 = 21;   public static final int UC_ARM64_REG_B14 = 22;   public static final int UC_ARM64_REG_B15 = 23;   public static final int UC_ARM64_REG_B16 = 24;   public static final int UC_ARM64_REG_B17 = 25;   public static final int UC_ARM64_REG_B18 = 26;   public static final int UC_ARM64_REG_B19 = 27;   public static final int UC_ARM64_REG_B20 = 28;   public static final int UC_ARM64_REG_B21 = 29;   public static final int UC_ARM64_REG_B22 = 30;   public static final int UC_ARM64_REG_B23 = 31;   public static final int UC_ARM64_REG_B24 = 32;   public static final int UC_ARM64_REG_B25 = 33;   public static final int UC_ARM64_REG_B26 = 34;   public static final int UC_ARM64_REG_B27 = 35;   public static final int UC_ARM64_REG_B28 = 36;   public static final int UC_ARM64_REG_B29 = 37;   public static final int UC_ARM64_REG_B30 = 38;   public static final int UC_ARM64_REG_B31 = 39;   public static final int UC_ARM64_REG_D0 = 40;   public static final int UC_ARM64_REG_D1 = 41;   public static final int UC_ARM64_REG_D2 = 42;   public static final int UC_ARM64_REG_D3 = 43;   public static final int UC_ARM64_REG_D4 = 44;   public static final int UC_ARM64_REG_D5 = 45;   public static final int UC_ARM64_REG_D6 = 46;   public static final int UC_ARM64_REG_D7 = 47;   public static final int UC_ARM64_REG_D8 = 48;   public static final int UC_ARM64_REG_D9 = 49;   public static final int UC_ARM64_REG_D10 = 50;   public static final int UC_ARM64_REG_D11 = 51;   public static final int UC_ARM64_REG_D12 = 52;   public static final int UC_ARM64_REG_D13 = 53;   public static final int UC_ARM64_REG_D14 = 54;   public static final int UC_ARM64_REG_D15 = 55;   public static final int UC_ARM64_REG_D16 = 56;   public static final int UC_ARM64_REG_D17 = 57;   public static final int UC_ARM64_REG_D18 = 58;   public static final int UC_ARM64_REG_D19 = 59;   public static final int UC_ARM64_REG_D20 = 60;   public static final int UC_ARM64_REG_D21 = 61;   public static final int UC_ARM64_REG_D22 = 62;   public static final int UC_ARM64_REG_D23 = 63;   public static final int UC_ARM64_REG_D24 = 64;   public static final int UC_ARM64_REG_D25 = 65;   public static final int UC_ARM64_REG_D26 = 66;   public static final int UC_ARM64_REG_D27 = 67;   public static final int UC_ARM64_REG_D28 = 68;   public static final int UC_ARM64_REG_D29 = 69;   public static final int UC_ARM64_REG_D30 = 70;   public static final int UC_ARM64_REG_D31 = 71;   public static final int UC_ARM64_REG_H0 = 72;   public static final int UC_ARM64_REG_H1 = 73;   public static final int UC_ARM64_REG_H2 = 74;   public static final int UC_ARM64_REG_H3 = 75;   public static final int UC_ARM64_REG_H4 = 76;   public static final int UC_ARM64_REG_H5 = 77;   public static final int UC_ARM64_REG_H6 = 78;   public static final int UC_ARM64_REG_H7 = 79;   public static final int UC_ARM64_REG_H8 = 80;   public static final int UC_ARM64_REG_H9 = 81;   public static final int UC_ARM64_REG_H10 = 82;   public static final int UC_ARM64_REG_H11 = 83;   public static final int UC_ARM64_REG_H12 = 84;   public static final int UC_ARM64_REG_H13 = 85;   public static final int UC_ARM64_REG_H14 = 86;   public static final int UC_ARM64_REG_H15 = 87;   public static final int UC_ARM64_REG_H16 = 88;   public static final int UC_ARM64_REG_H17 = 89;   public static final int UC_ARM64_REG_H18 = 90;   public static final int UC_ARM64_REG_H19 = 91;   public static final int UC_ARM64_REG_H20 = 92;   public static final int UC_ARM64_REG_H21 = 93;   public static final int UC_ARM64_REG_H22 = 94;   public static final int UC_ARM64_REG_H23 = 95;   public static final int UC_ARM64_REG_H24 = 96;   public static final int UC_ARM64_REG_H25 = 97;   public static final int UC_ARM64_REG_H26 = 98;   public static final int UC_ARM64_REG_H27 = 99;   public static final int UC_ARM64_REG_H28 = 100;   public static final int UC_ARM64_REG_H29 = 101;   public static final int UC_ARM64_REG_H30 = 102;   public static final int UC_ARM64_REG_H31 = 103;   public static final int UC_ARM64_REG_Q0 = 104;   public static final int UC_ARM64_REG_Q1 = 105;   public static final int UC_ARM64_REG_Q2 = 106;   public static final int UC_ARM64_REG_Q3 = 107;   public static final int UC_ARM64_REG_Q4 = 108;   public static final int UC_ARM64_REG_Q5 = 109;   public static final int UC_ARM64_REG_Q6 = 110;   public static final int UC_ARM64_REG_Q7 = 111;   public static final int UC_ARM64_REG_Q8 = 112;   public static final int UC_ARM64_REG_Q9 = 113;   public static final int UC_ARM64_REG_Q10 = 114;   public static final int UC_ARM64_REG_Q11 = 115;   public static final int UC_ARM64_REG_Q12 = 116;   public static final int UC_ARM64_REG_Q13 = 117;   public static final int UC_ARM64_REG_Q14 = 118;   public static final int UC_ARM64_REG_Q15 = 119;   public static final int UC_ARM64_REG_Q16 = 120;   public static final int UC_ARM64_REG_Q17 = 121;   public static final int UC_ARM64_REG_Q18 = 122;   public static final int UC_ARM64_REG_Q19 = 123;   public static final int UC_ARM64_REG_Q20 = 124;   public static final int UC_ARM64_REG_Q21 = 125;   public static final int UC_ARM64_REG_Q22 = 126;   public static final int UC_ARM64_REG_Q23 = 127;   public static final int UC_ARM64_REG_Q24 = 128;   public static final int UC_ARM64_REG_Q25 = 129;   public static final int UC_ARM64_REG_Q26 = 130;   public static final int UC_ARM64_REG_Q27 = 131;   public static final int UC_ARM64_REG_Q28 = 132;   public static final int UC_ARM64_REG_Q29 = 133;   public static final int UC_ARM64_REG_Q30 = 134;   public static final int UC_ARM64_REG_Q31 = 135;   public static final int UC_ARM64_REG_S0 = 136;   public static final int UC_ARM64_REG_S1 = 137;   public static final int UC_ARM64_REG_S2 = 138;   public static final int UC_ARM64_REG_S3 = 139;   public static final int UC_ARM64_REG_S4 = 140;   public static final int UC_ARM64_REG_S5 = 141;   public static final int UC_ARM64_REG_S6 = 142;   public static final int UC_ARM64_REG_S7 = 143;   public static final int UC_ARM64_REG_S8 = 144;   public static final int UC_ARM64_REG_S9 = 145;   public static final int UC_ARM64_REG_S10 = 146;   public static final int UC_ARM64_REG_S11 = 147;   public static final int UC_ARM64_REG_S12 = 148;   public static final int UC_ARM64_REG_S13 = 149;   public static final int UC_ARM64_REG_S14 = 150;   public static final int UC_ARM64_REG_S15 = 151;   public static final int UC_ARM64_REG_S16 = 152;   public static final int UC_ARM64_REG_S17 = 153;   public static final int UC_ARM64_REG_S18 = 154;   public static final int UC_ARM64_REG_S19 = 155;   public static final int UC_ARM64_REG_S20 = 156;   public static final int UC_ARM64_REG_S21 = 157;   public static final int UC_ARM64_REG_S22 = 158;   public static final int UC_ARM64_REG_S23 = 159;   public static final int UC_ARM64_REG_S24 = 160;   public static final int UC_ARM64_REG_S25 = 161;   public static final int UC_ARM64_REG_S26 = 162;   public static final int UC_ARM64_REG_S27 = 163;   public static final int UC_ARM64_REG_S28 = 164;   public static final int UC_ARM64_REG_S29 = 165;   public static final int UC_ARM64_REG_S30 = 166;   public static final int UC_ARM64_REG_S31 = 167;   public static final int UC_ARM64_REG_W0 = 168;   public static final int UC_ARM64_REG_W1 = 169;   public static final int UC_ARM64_REG_W2 = 170;   public static final int UC_ARM64_REG_W3 = 171;   public static final int UC_ARM64_REG_W4 = 172;   public static final int UC_ARM64_REG_W5 = 173;   public static final int UC_ARM64_REG_W6 = 174;   public static final int UC_ARM64_REG_W7 = 175;   public static final int UC_ARM64_REG_W8 = 176;   public static final int UC_ARM64_REG_W9 = 177;   public static final int UC_ARM64_REG_W10 = 178;   public static final int UC_ARM64_REG_W11 = 179;   public static final int UC_ARM64_REG_W12 = 180;   public static final int UC_ARM64_REG_W13 = 181;   public static final int UC_ARM64_REG_W14 = 182;   public static final int UC_ARM64_REG_W15 = 183;   public static final int UC_ARM64_REG_W16 = 184;   public static final int UC_ARM64_REG_W17 = 185;   public static final int UC_ARM64_REG_W18 = 186;   public static final int UC_ARM64_REG_W19 = 187;   public static final int UC_ARM64_REG_W20 = 188;   public static final int UC_ARM64_REG_W21 = 189;   public static final int UC_ARM64_REG_W22 = 190;   public static final int UC_ARM64_REG_W23 = 191;   public static final int UC_ARM64_REG_W24 = 192;   public static final int UC_ARM64_REG_W25 = 193;   public static final int UC_ARM64_REG_W26 = 194;   public static final int UC_ARM64_REG_W27 = 195;   public static final int UC_ARM64_REG_W28 = 196;   public static final int UC_ARM64_REG_W29 = 197;   public static final int UC_ARM64_REG_W30 = 198;   public static final int UC_ARM64_REG_X0 = 199;   public static final int UC_ARM64_REG_X1 = 200;   public static final int UC_ARM64_REG_X2 = 201;   public static final int UC_ARM64_REG_X3 = 202;   public static final int UC_ARM64_REG_X4 = 203;   public static final int UC_ARM64_REG_X5 = 204;   public static final int UC_ARM64_REG_X6 = 205;   public static final int UC_ARM64_REG_X7 = 206;   public static final int UC_ARM64_REG_X8 = 207;   public static final int UC_ARM64_REG_X9 = 208;   public static final int UC_ARM64_REG_X10 = 209;   public static final int UC_ARM64_REG_X11 = 210;   public static final int UC_ARM64_REG_X12 = 211;   public static final int UC_ARM64_REG_X13 = 212;   public static final int UC_ARM64_REG_X14 = 213;   public static final int UC_ARM64_REG_X15 = 214;   public static final int UC_ARM64_REG_X16 = 215;   public static final int UC_ARM64_REG_X17 = 216;   public static final int UC_ARM64_REG_X18 = 217;   public static final int UC_ARM64_REG_X19 = 218;   public static final int UC_ARM64_REG_X20 = 219;   public static final int UC_ARM64_REG_X21 = 220;   public static final int UC_ARM64_REG_X22 = 221;   public static final int UC_ARM64_REG_X23 = 222;   public static final int UC_ARM64_REG_X24 = 223;   public static final int UC_ARM64_REG_X25 = 224;   public static final int UC_ARM64_REG_X26 = 225;   public static final int UC_ARM64_REG_X27 = 226;   public static final int UC_ARM64_REG_X28 = 227;   public static final int UC_ARM64_REG_V0 = 228;   public static final int UC_ARM64_REG_V1 = 229;   public static final int UC_ARM64_REG_V2 = 230;   public static final int UC_ARM64_REG_V3 = 231;   public static final int UC_ARM64_REG_V4 = 232;   public static final int UC_ARM64_REG_V5 = 233;   public static final int UC_ARM64_REG_V6 = 234;   public static final int UC_ARM64_REG_V7 = 235;   public static final int UC_ARM64_REG_V8 = 236;   public static final int UC_ARM64_REG_V9 = 237;   public static final int UC_ARM64_REG_V10 = 238;   public static final int UC_ARM64_REG_V11 = 239;   public static final int UC_ARM64_REG_V12 = 240;   public static final int UC_ARM64_REG_V13 = 241;   public static final int UC_ARM64_REG_V14 = 242;   public static final int UC_ARM64_REG_V15 = 243;   public static final int UC_ARM64_REG_V16 = 244;   public static final int UC_ARM64_REG_V17 = 245;   public static final int UC_ARM64_REG_V18 = 246;   public static final int UC_ARM64_REG_V19 = 247;   public static final int UC_ARM64_REG_V20 = 248;   public static final int UC_ARM64_REG_V21 = 249;   public static final int UC_ARM64_REG_V22 = 250;   public static final int UC_ARM64_REG_V23 = 251;   public static final int UC_ARM64_REG_V24 = 252;   public static final int UC_ARM64_REG_V25 = 253;   public static final int UC_ARM64_REG_V26 = 254;   public static final int UC_ARM64_REG_V27 = 255;   public static final int UC_ARM64_REG_V28 = 256;   public static final int UC_ARM64_REG_V29 = 257;   public static final int UC_ARM64_REG_V30 = 258;   public static final int UC_ARM64_REG_V31 = 259;   public static final int UC_ARM64_REG_PC = 260;   public static final int UC_ARM64_REG_CPACR_EL1 = 261;   public static final int UC_ARM64_REG_TPIDR_EL0 = 262;   public static final int UC_ARM64_REG_TPIDRRO_EL0 = 263;   public static final int UC_ARM64_REG_TPIDR_EL1 = 264;   public static final int UC_ARM64_REG_PSTATE = 265;   public static final int UC_ARM64_REG_ELR_EL0 = 266;   public static final int UC_ARM64_REG_ELR_EL1 = 267;   public static final int UC_ARM64_REG_ELR_EL2 = 268;   public static final int UC_ARM64_REG_ELR_EL3 = 269;   public static final int UC_ARM64_REG_SP_EL0 = 270;   public static final int UC_ARM64_REG_SP_EL1 = 271;   public static final int UC_ARM64_REG_SP_EL2 = 272;   public static final int UC_ARM64_REG_SP_EL3 = 273;   public static final int UC_ARM64_REG_TTBR0_EL1 = 274;   public static final int UC_ARM64_REG_TTBR1_EL1 = 275;   public static final int UC_ARM64_REG_ESR_EL0 = 276;   public static final int UC_ARM64_REG_ESR_EL1 = 277;   public static final int UC_ARM64_REG_ESR_EL2 = 278;   public static final int UC_ARM64_REG_ESR_EL3 = 279;   public static final int UC_ARM64_REG_FAR_EL0 = 280;   public static final int UC_ARM64_REG_FAR_EL1 = 281;   public static final int UC_ARM64_REG_FAR_EL2 = 282;   public static final int UC_ARM64_REG_FAR_EL3 = 283;   public static final int UC_ARM64_REG_PAR_EL1 = 284;   public static final int UC_ARM64_REG_MAIR_EL1 = 285;   public static final int UC_ARM64_REG_VBAR_EL0 = 286;   public static final int UC_ARM64_REG_VBAR_EL1 = 287;   public static final int UC_ARM64_REG_VBAR_EL2 = 288;   public static final int UC_ARM64_REG_VBAR_EL3 = 289;   public static final int UC_ARM64_REG_CP_REG = 290;   public static final int UC_ARM64_REG_ENDING = 291;   public static final int UC_ARM64_REG_IP0 = 215;   public static final int UC_ARM64_REG_IP1 = 216;   public static final int UC_ARM64_REG_FP = 1;   public static final int UC_ARM64_REG_LR = 2;   public static final int UC_ARM64_INS_INVALID = 0;   public static final int UC_ARM64_INS_MRS = 1;   public static final int UC_ARM64_INS_MSR = 2;   public static final int UC_ARM64_INS_SYS = 3;   public static final int UC_ARM64_INS_SYSL = 4;   public static final int UC_ARM64_INS_ENDING = 5;}"}
{"code": "public interface ArmConst {   public static final int UC_CPU_ARM_926 = 0;   public static final int UC_CPU_ARM_946 = 1;   public static final int UC_CPU_ARM_1026 = 2;   public static final int UC_CPU_ARM_1136_R2 = 3;   public static final int UC_CPU_ARM_1136 = 4;   public static final int UC_CPU_ARM_1176 = 5;   public static final int UC_CPU_ARM_11MPCORE = 6;   public static final int UC_CPU_ARM_CORTEX_M0 = 7;   public static final int UC_CPU_ARM_CORTEX_M3 = 8;   public static final int UC_CPU_ARM_CORTEX_M4 = 9;   public static final int UC_CPU_ARM_CORTEX_M7 = 10;   public static final int UC_CPU_ARM_CORTEX_M33 = 11;   public static final int UC_CPU_ARM_CORTEX_R5 = 12;   public static final int UC_CPU_ARM_CORTEX_R5F = 13;   public static final int UC_CPU_ARM_CORTEX_A7 = 14;   public static final int UC_CPU_ARM_CORTEX_A8 = 15;   public static final int UC_CPU_ARM_CORTEX_A9 = 16;   public static final int UC_CPU_ARM_CORTEX_A15 = 17;   public static final int UC_CPU_ARM_TI925T = 18;   public static final int UC_CPU_ARM_SA1100 = 19;   public static final int UC_CPU_ARM_SA1110 = 20;   public static final int UC_CPU_ARM_PXA250 = 21;   public static final int UC_CPU_ARM_PXA255 = 22;   public static final int UC_CPU_ARM_PXA260 = 23;   public static final int UC_CPU_ARM_PXA261 = 24;   public static final int UC_CPU_ARM_PXA262 = 25;   public static final int UC_CPU_ARM_PXA270 = 26;   public static final int UC_CPU_ARM_PXA270A0 = 27;   public static final int UC_CPU_ARM_PXA270A1 = 28;   public static final int UC_CPU_ARM_PXA270B0 = 29;   public static final int UC_CPU_ARM_PXA270B1 = 30;   public static final int UC_CPU_ARM_PXA270C0 = 31;   public static final int UC_CPU_ARM_PXA270C5 = 32;   public static final int UC_CPU_ARM_MAX = 33;   public static final int UC_CPU_ARM_ENDING = 34;   public static final int UC_ARM_REG_INVALID = 0;   public static final int UC_ARM_REG_APSR = 1;   public static final int UC_ARM_REG_APSR_NZCV = 2;   public static final int UC_ARM_REG_CPSR = 3;   public static final int UC_ARM_REG_FPEXC = 4;   public static final int UC_ARM_REG_FPINST = 5;   public static final int UC_ARM_REG_FPSCR = 6;   public static final int UC_ARM_REG_FPSCR_NZCV = 7;   public static final int UC_ARM_REG_FPSID = 8;   public static final int UC_ARM_REG_ITSTATE = 9;   public static final int UC_ARM_REG_LR = 10;   public static final int UC_ARM_REG_PC = 11;   public static final int UC_ARM_REG_SP = 12;   public static final int UC_ARM_REG_SPSR = 13;   public static final int UC_ARM_REG_D0 = 14;   public static final int UC_ARM_REG_D1 = 15;   public static final int UC_ARM_REG_D2 = 16;   public static final int UC_ARM_REG_D3 = 17;   public static final int UC_ARM_REG_D4 = 18;   public static final int UC_ARM_REG_D5 = 19;   public static final int UC_ARM_REG_D6 = 20;   public static final int UC_ARM_REG_D7 = 21;   public static final int UC_ARM_REG_D8 = 22;   public static final int UC_ARM_REG_D9 = 23;   public static final int UC_ARM_REG_D10 = 24;   public static final int UC_ARM_REG_D11 = 25;   public static final int UC_ARM_REG_D12 = 26;   public static final int UC_ARM_REG_D13 = 27;   public static final int UC_ARM_REG_D14 = 28;   public static final int UC_ARM_REG_D15 = 29;   public static final int UC_ARM_REG_D16 = 30;   public static final int UC_ARM_REG_D17 = 31;   public static final int UC_ARM_REG_D18 = 32;   public static final int UC_ARM_REG_D19 = 33;   public static final int UC_ARM_REG_D20 = 34;   public static final int UC_ARM_REG_D21 = 35;   public static final int UC_ARM_REG_D22 = 36;   public static final int UC_ARM_REG_D23 = 37;   public static final int UC_ARM_REG_D24 = 38;   public static final int UC_ARM_REG_D25 = 39;   public static final int UC_ARM_REG_D26 = 40;   public static final int UC_ARM_REG_D27 = 41;   public static final int UC_ARM_REG_D28 = 42;   public static final int UC_ARM_REG_D29 = 43;   public static final int UC_ARM_REG_D30 = 44;   public static final int UC_ARM_REG_D31 = 45;   public static final int UC_ARM_REG_FPINST2 = 46;   public static final int UC_ARM_REG_MVFR0 = 47;   public static final int UC_ARM_REG_MVFR1 = 48;   public static final int UC_ARM_REG_MVFR2 = 49;   public static final int UC_ARM_REG_Q0 = 50;   public static final int UC_ARM_REG_Q1 = 51;   public static final int UC_ARM_REG_Q2 = 52;   public static final int UC_ARM_REG_Q3 = 53;   public static final int UC_ARM_REG_Q4 = 54;   public static final int UC_ARM_REG_Q5 = 55;   public static final int UC_ARM_REG_Q6 = 56;   public static final int UC_ARM_REG_Q7 = 57;   public static final int UC_ARM_REG_Q8 = 58;   public static final int UC_ARM_REG_Q9 = 59;   public static final int UC_ARM_REG_Q10 = 60;   public static final int UC_ARM_REG_Q11 = 61;   public static final int UC_ARM_REG_Q12 = 62;   public static final int UC_ARM_REG_Q13 = 63;   public static final int UC_ARM_REG_Q14 = 64;   public static final int UC_ARM_REG_Q15 = 65;   public static final int UC_ARM_REG_R0 = 66;   public static final int UC_ARM_REG_R1 = 67;   public static final int UC_ARM_REG_R2 = 68;   public static final int UC_ARM_REG_R3 = 69;   public static final int UC_ARM_REG_R4 = 70;   public static final int UC_ARM_REG_R5 = 71;   public static final int UC_ARM_REG_R6 = 72;   public static final int UC_ARM_REG_R7 = 73;   public static final int UC_ARM_REG_R8 = 74;   public static final int UC_ARM_REG_R9 = 75;   public static final int UC_ARM_REG_R10 = 76;   public static final int UC_ARM_REG_R11 = 77;   public static final int UC_ARM_REG_R12 = 78;   public static final int UC_ARM_REG_S0 = 79;   public static final int UC_ARM_REG_S1 = 80;   public static final int UC_ARM_REG_S2 = 81;   public static final int UC_ARM_REG_S3 = 82;   public static final int UC_ARM_REG_S4 = 83;   public static final int UC_ARM_REG_S5 = 84;   public static final int UC_ARM_REG_S6 = 85;   public static final int UC_ARM_REG_S7 = 86;   public static final int UC_ARM_REG_S8 = 87;   public static final int UC_ARM_REG_S9 = 88;   public static final int UC_ARM_REG_S10 = 89;   public static final int UC_ARM_REG_S11 = 90;   public static final int UC_ARM_REG_S12 = 91;   public static final int UC_ARM_REG_S13 = 92;   public static final int UC_ARM_REG_S14 = 93;   public static final int UC_ARM_REG_S15 = 94;   public static final int UC_ARM_REG_S16 = 95;   public static final int UC_ARM_REG_S17 = 96;   public static final int UC_ARM_REG_S18 = 97;   public static final int UC_ARM_REG_S19 = 98;   public static final int UC_ARM_REG_S20 = 99;   public static final int UC_ARM_REG_S21 = 100;   public static final int UC_ARM_REG_S22 = 101;   public static final int UC_ARM_REG_S23 = 102;   public static final int UC_ARM_REG_S24 = 103;   public static final int UC_ARM_REG_S25 = 104;   public static final int UC_ARM_REG_S26 = 105;   public static final int UC_ARM_REG_S27 = 106;   public static final int UC_ARM_REG_S28 = 107;   public static final int UC_ARM_REG_S29 = 108;   public static final int UC_ARM_REG_S30 = 109;   public static final int UC_ARM_REG_S31 = 110;   public static final int UC_ARM_REG_C1_C0_2 = 111;   public static final int UC_ARM_REG_C13_C0_2 = 112;   public static final int UC_ARM_REG_C13_C0_3 = 113;   public static final int UC_ARM_REG_IPSR = 114;   public static final int UC_ARM_REG_MSP = 115;   public static final int UC_ARM_REG_PSP = 116;   public static final int UC_ARM_REG_CONTROL = 117;   public static final int UC_ARM_REG_IAPSR = 118;   public static final int UC_ARM_REG_EAPSR = 119;   public static final int UC_ARM_REG_XPSR = 120;   public static final int UC_ARM_REG_EPSR = 121;   public static final int UC_ARM_REG_IEPSR = 122;   public static final int UC_ARM_REG_PRIMASK = 123;   public static final int UC_ARM_REG_BASEPRI = 124;   public static final int UC_ARM_REG_BASEPRI_MAX = 125;   public static final int UC_ARM_REG_FAULTMASK = 126;   public static final int UC_ARM_REG_APSR_NZCVQ = 127;   public static final int UC_ARM_REG_APSR_G = 128;   public static final int UC_ARM_REG_APSR_NZCVQG = 129;   public static final int UC_ARM_REG_IAPSR_NZCVQ = 130;   public static final int UC_ARM_REG_IAPSR_G = 131;   public static final int UC_ARM_REG_IAPSR_NZCVQG = 132;   public static final int UC_ARM_REG_EAPSR_NZCVQ = 133;   public static final int UC_ARM_REG_EAPSR_G = 134;   public static final int UC_ARM_REG_EAPSR_NZCVQG = 135;   public static final int UC_ARM_REG_XPSR_NZCVQ = 136;   public static final int UC_ARM_REG_XPSR_G = 137;   public static final int UC_ARM_REG_XPSR_NZCVQG = 138;   public static final int UC_ARM_REG_CP_REG = 139;   public static final int UC_ARM_REG_ENDING = 140;   public static final int UC_ARM_REG_R13 = 12;   public static final int UC_ARM_REG_R14 = 10;   public static final int UC_ARM_REG_R15 = 11;   public static final int UC_ARM_REG_SB = 75;   public static final int UC_ARM_REG_SL = 76;   public static final int UC_ARM_REG_FP = 77;   public static final int UC_ARM_REG_IP = 78;}", "nl": "public interface ArmConst {   public static final int UC_CPU_ARM_926 = 0;   public static final int UC_CPU_ARM_946 = 1;   public static final int UC_CPU_ARM_1026 = 2;   public static final int UC_CPU_ARM_1136_R2 = 3;   public static final int UC_CPU_ARM_1136 = 4;   public static final int UC_CPU_ARM_1176 = 5;   public static final int UC_CPU_ARM_11MPCORE = 6;   public static final int UC_CPU_ARM_CORTEX_M0 = 7;   public static final int UC_CPU_ARM_CORTEX_M3 = 8;   public static final int UC_CPU_ARM_CORTEX_M4 = 9;   public static final int UC_CPU_ARM_CORTEX_M7 = 10;   public static final int UC_CPU_ARM_CORTEX_M33 = 11;   public static final int UC_CPU_ARM_CORTEX_R5 = 12;   public static final int UC_CPU_ARM_CORTEX_R5F = 13;   public static final int UC_CPU_ARM_CORTEX_A7 = 14;   public static final int UC_CPU_ARM_CORTEX_A8 = 15;   public static final int UC_CPU_ARM_CORTEX_A9 = 16;   public static final int UC_CPU_ARM_CORTEX_A15 = 17;   public static final int UC_CPU_ARM_TI925T = 18;   public static final int UC_CPU_ARM_SA1100 = 19;   public static final int UC_CPU_ARM_SA1110 = 20;   public static final int UC_CPU_ARM_PXA250 = 21;   public static final int UC_CPU_ARM_PXA255 = 22;   public static final int UC_CPU_ARM_PXA260 = 23;   public static final int UC_CPU_ARM_PXA261 = 24;   public static final int UC_CPU_ARM_PXA262 = 25;   public static final int UC_CPU_ARM_PXA270 = 26;   public static final int UC_CPU_ARM_PXA270A0 = 27;   public static final int UC_CPU_ARM_PXA270A1 = 28;   public static final int UC_CPU_ARM_PXA270B0 = 29;   public static final int UC_CPU_ARM_PXA270B1 = 30;   public static final int UC_CPU_ARM_PXA270C0 = 31;   public static final int UC_CPU_ARM_PXA270C5 = 32;   public static final int UC_CPU_ARM_MAX = 33;   public static final int UC_ARM_REG_INVALID = 0;   public static final int UC_ARM_REG_APSR = 1;   public static final int UC_ARM_REG_APSR_NZCV = 2;   public static final int UC_ARM_REG_CPSR = 3;   public static final int UC_ARM_REG_FPEXC = 4;   public static final int UC_ARM_REG_FPINST = 5;   public static final int UC_ARM_REG_FPSCR = 6;   public static final int UC_ARM_REG_FPSCR_NZCV = 7;   public static final int UC_ARM_REG_FPSID = 8;   public static final int UC_ARM_REG_ITSTATE = 9;   public static final int UC_ARM_REG_LR = 10;   public static final int UC_ARM_REG_PC = 11;   public static final int UC_ARM_REG_SP = 12;   public static final int UC_ARM_REG_SPSR = 13;   public static final int UC_ARM_REG_D0 = 14;   public static final int UC_ARM_REG_D1 = 15;   public static final int UC_ARM_REG_D2 = 16;   public static final int UC_ARM_REG_D3 = 17;   public static final int UC_ARM_REG_D4 = 18;   public static final int UC_ARM_REG_D5 = 19;   public static final int UC_ARM_REG_D6 = 20;   public static final int UC_ARM_REG_D7 = 21;   public static final int UC_ARM_REG_D8 = 22;   public static final int UC_ARM_REG_D9 = 23;   public static final int UC_ARM_REG_D10 = 24;   public static final int UC_ARM_REG_D11 = 25;   public static final int UC_ARM_REG_D12 = 26;   public static final int UC_ARM_REG_D13 = 27;   public static final int UC_ARM_REG_D14 = 28;   public static final int UC_ARM_REG_D15 = 29;   public static final int UC_ARM_REG_D16 = 30;   public static final int UC_ARM_REG_D17 = 31;   public static final int UC_ARM_REG_D18 = 32;   public static final int UC_ARM_REG_D19 = 33;   public static final int UC_ARM_REG_D20 = 34;   public static final int UC_ARM_REG_D21 = 35;   public static final int UC_ARM_REG_D22 = 36;   public static final int UC_ARM_REG_D23 = 37;   public static final int UC_ARM_REG_D24 = 38;   public static final int UC_ARM_REG_D25 = 39;   public static final int UC_ARM_REG_D26 = 40;   public static final int UC_ARM_REG_D27 = 41;   public static final int UC_ARM_REG_D28 = 42;   public static final int UC_ARM_REG_D29 = 43;   public static final int UC_ARM_REG_D30 = 44;   public static final int UC_ARM_REG_D31 = 45;   public static final int UC_ARM_REG_FPINST2 = 46;   public static final int UC_ARM_REG_MVFR0 = 47;   public static final int UC_ARM_REG_MVFR1 = 48;   public static final int UC_ARM_REG_MVFR2 = 49;   public static final int UC_ARM_REG_Q0 = 50;   public static final int UC_ARM_REG_Q1 = 51;   public static final int UC_ARM_REG_Q2 = 52;   public static final int UC_ARM_REG_Q3 = 53;   public static final int UC_ARM_REG_Q4 = 54;   public static final int UC_ARM_REG_Q5 = 55;   public static final int UC_ARM_REG_Q6 = 56;   public static final int UC_ARM_REG_Q7 = 57;   public static final int UC_ARM_REG_Q8 = 58;   public static final int UC_ARM_REG_Q9 = 59;   public static final int UC_ARM_REG_Q10 = 60;   public static final int UC_ARM_REG_Q11 = 61;   public static final int UC_ARM_REG_Q12 = 62;   public static final int UC_ARM_REG_Q13 = 63;   public static final int UC_ARM_REG_Q14 = 64;   public static final int UC_ARM_REG_Q15 = 65;   public static final int UC_ARM_REG_R0 = 66;   public static final int UC_ARM_REG_R1 = 67;   public static final int UC_ARM_REG_R2 = 68;   public static final int UC_ARM_REG_R3 = 69;   public static final int UC_ARM_REG_R4 = 70;   public static final int UC_ARM_REG_R5 = 71;   public static final int UC_ARM_REG_R6 = 72;   public static final int UC_ARM_REG_R7 = 73;   public static final int UC_ARM_REG_R8 = 74;   public static final int UC_ARM_REG_R9 = 75;   public static final int UC_ARM_REG_R10 = 76;   public static final int UC_ARM_REG_R11 = 77;   public static final int UC_ARM_REG_R12 = 78;   public static final int UC_ARM_REG_S0 = 79;   public static final int UC_ARM_REG_S1 = 80;   public static final int UC_ARM_REG_S2 = 81;   public static final int UC_ARM_REG_S3 = 82;   public static final int UC_ARM_REG_S4 = 83;   public static final int UC_ARM_REG_S5 = 84;   public static final int UC_ARM_REG_S6 = 85;   public static final int UC_ARM_REG_S7 = 86;   public static final int UC_ARM_REG_S8 = 87;   public static final int UC_ARM_REG_S9 = 88;   public static final int UC_ARM_REG_S10 = 89;   public static final int UC_ARM_REG_S11 = 90;   public static final int UC_ARM_REG_S12 = 91;   public static final int UC_ARM_REG_S13 = 92;   public static final int UC_ARM_REG_S14 = 93;   public static final int UC_ARM_REG_S15 = 94;   public static final int UC_ARM_REG_S16 = 95;   public static final int UC_ARM_REG_S17 = 96;   public static final int UC_ARM_REG_S18 = 97;   public static final int UC_ARM_REG_S19 = 98;   public static final int UC_ARM_REG_S20 = 99;   public static final int UC_ARM_REG_S21 = 100;   public static final int UC_ARM_REG_S22 = 101;   public static final int UC_ARM_REG_S23 = 102;   public static final int UC_ARM_REG_S24 = 103;   public static final int UC_ARM_REG_S25 = 104;   public static final int UC_ARM_REG_S26 = 105;   public static final int UC_ARM_REG_S27 = 106;   public static final int UC_ARM_REG_S28 = 107;   public static final int UC_ARM_REG_S29 = 108;   public static final int UC_ARM_REG_S30 = 109;   public static final int UC_ARM_REG_S31 = 110;   public static final int UC_ARM_REG_C1_C0_2 = 111;   public static final int UC_ARM_REG_C13_C0_2 = 112;   public static final int UC_ARM_REG_C13_C0_3 = 113;   public static final int UC_ARM_REG_IPSR = 114;   public static final int UC_ARM_REG_MSP = 115;   public static final int UC_ARM_REG_PSP = 116;   public static final int UC_ARM_REG_CONTROL = 117;   public static final int UC_ARM_REG_IAPSR = 118;   public static final int UC_ARM_REG_EAPSR = 119;   public static final int UC_ARM_REG_XPSR = 120;   public static final int UC_ARM_REG_EPSR = 121;   public static final int UC_ARM_REG_IEPSR = 122;   public static final int UC_ARM_REG_PRIMASK = 123;   public static final int UC_ARM_REG_BASEPRI = 124;   public static final int UC_ARM_REG_BASEPRI_MAX = 125;   public static final int UC_ARM_REG_FAULTMASK = 126;   public static final int UC_ARM_REG_APSR_NZCVQ = 127;   public static final int UC_ARM_REG_APSR_G = 128;   public static final int UC_ARM_REG_APSR_NZCVQG = 129;   public static final int UC_ARM_REG_IAPSR_NZCVQ = 130;   public static final int UC_ARM_REG_IAPSR_G = 131;   public static final int UC_ARM_REG_IAPSR_NZCVQG = 132;   public static final int UC_ARM_REG_EAPSR_NZCVQ = 133;   public static final int UC_ARM_REG_EAPSR_G = 134;   public static final int UC_ARM_REG_EAPSR_NZCVQG = 135;   public static final int UC_ARM_REG_XPSR_NZCVQ = 136;   public static final int UC_ARM_REG_XPSR_G = 137;   public static final int UC_ARM_REG_XPSR_NZCVQG = 138;   public static final int UC_ARM_REG_CP_REG = 139;   public static final int UC_ARM_REG_ENDING = 140;   public static final int UC_ARM_REG_R13 = 12;   public static final int UC_ARM_REG_R14 = 10;   public static final int UC_ARM_REG_R15 = 11;   public static final int UC_ARM_REG_SB = 75;   public static final int UC_ARM_REG_SL = 76;   public static final int UC_ARM_REG_FP = 77;   public static final int UC_ARM_REG_IP = 78;}"}
{"code": "public interface M68kConst {   public static final int UC_CPU_M68K_M5206 = 0;   public static final int UC_CPU_M68K_M68000 = 1;   public static final int UC_CPU_M68K_M68020 = 2;   public static final int UC_CPU_M68K_M68030 = 3;   public static final int UC_CPU_M68K_M68040 = 4;   public static final int UC_CPU_M68K_M68060 = 5;   public static final int UC_CPU_M68K_M5208 = 6;   public static final int UC_CPU_M68K_CFV4E = 7;   public static final int UC_CPU_M68K_ANY = 8;   public static final int UC_CPU_M68K_ENDING = 9;   public static final int UC_M68K_REG_INVALID = 0;   public static final int UC_M68K_REG_A0 = 1;   public static final int UC_M68K_REG_A1 = 2;   public static final int UC_M68K_REG_A2 = 3;   public static final int UC_M68K_REG_A3 = 4;   public static final int UC_M68K_REG_A4 = 5;   public static final int UC_M68K_REG_A5 = 6;   public static final int UC_M68K_REG_A6 = 7;   public static final int UC_M68K_REG_A7 = 8;   public static final int UC_M68K_REG_D0 = 9;   public static final int UC_M68K_REG_D1 = 10;   public static final int UC_M68K_REG_D2 = 11;   public static final int UC_M68K_REG_D3 = 12;   public static final int UC_M68K_REG_D4 = 13;   public static final int UC_M68K_REG_D5 = 14;   public static final int UC_M68K_REG_D6 = 15;   public static final int UC_M68K_REG_D7 = 16;   public static final int UC_M68K_REG_SR = 17;   public static final int UC_M68K_REG_PC = 18;   public static final int UC_M68K_REG_ENDING = 19;}", "nl": "public interface M68kConst {   public static final int UC_CPU_M68K_M5206 = 0;   public static final int UC_CPU_M68K_M68000 = 1;   public static final int UC_CPU_M68K_M68020 = 2;   public static final int UC_CPU_M68K_M68030 = 3;   public static final int UC_CPU_M68K_M68040 = 4;   public static final int UC_CPU_M68K_M68060 = 5;   public static final int UC_CPU_M68K_M5208 = 6;   public static final int UC_CPU_M68K_CFV4E = 7;   public static final int UC_CPU_M68K_ANY = 8;   public static final int UC_M68K_REG_INVALID = 0;   public static final int UC_M68K_REG_A0 = 1;   public static final int UC_M68K_REG_A1 = 2;   public static final int UC_M68K_REG_A2 = 3;   public static final int UC_M68K_REG_A3 = 4;   public static final int UC_M68K_REG_A4 = 5;   public static final int UC_M68K_REG_A5 = 6;   public static final int UC_M68K_REG_A6 = 7;   public static final int UC_M68K_REG_A7 = 8;   public static final int UC_M68K_REG_D0 = 9;   public static final int UC_M68K_REG_D1 = 10;   public static final int UC_M68K_REG_D2 = 11;   public static final int UC_M68K_REG_D3 = 12;   public static final int UC_M68K_REG_D4 = 13;   public static final int UC_M68K_REG_D5 = 14;   public static final int UC_M68K_REG_D6 = 15;   public static final int UC_M68K_REG_D7 = 16;   public static final int UC_M68K_REG_SR = 17;   public static final int UC_M68K_REG_PC = 18;   public static final int UC_M68K_REG_ENDING = 19;}"}
{"code": "public interface MipsConst {   public static final int UC_CPU_MIPS32_4KC = 0;   public static final int UC_CPU_MIPS32_4KM = 1;   public static final int UC_CPU_MIPS32_4KECR1 = 2;   public static final int UC_CPU_MIPS32_4KEMR1 = 3;   public static final int UC_CPU_MIPS32_4KEC = 4;   public static final int UC_CPU_MIPS32_4KEM = 5;   public static final int UC_CPU_MIPS32_24KC = 6;   public static final int UC_CPU_MIPS32_24KEC = 7;   public static final int UC_CPU_MIPS32_24KF = 8;   public static final int UC_CPU_MIPS32_34KF = 9;   public static final int UC_CPU_MIPS32_74KF = 10;   public static final int UC_CPU_MIPS32_M14K = 11;   public static final int UC_CPU_MIPS32_M14KC = 12;   public static final int UC_CPU_MIPS32_P5600 = 13;   public static final int UC_CPU_MIPS32_MIPS32R6_GENERIC = 14;   public static final int UC_CPU_MIPS32_I7200 = 15;   public static final int UC_CPU_MIPS32_ENDING = 16;   public static final int UC_CPU_MIPS64_R4000 = 0;   public static final int UC_CPU_MIPS64_VR5432 = 1;   public static final int UC_CPU_MIPS64_5KC = 2;   public static final int UC_CPU_MIPS64_5KF = 3;   public static final int UC_CPU_MIPS64_20KC = 4;   public static final int UC_CPU_MIPS64_MIPS64R2_GENERIC = 5;   public static final int UC_CPU_MIPS64_5KEC = 6;   public static final int UC_CPU_MIPS64_5KEF = 7;   public static final int UC_CPU_MIPS64_I6400 = 8;   public static final int UC_CPU_MIPS64_I6500 = 9;   public static final int UC_CPU_MIPS64_LOONGSON_2E = 10;   public static final int UC_CPU_MIPS64_LOONGSON_2F = 11;   public static final int UC_CPU_MIPS64_MIPS64DSPR2 = 12;   public static final int UC_CPU_MIPS64_ENDING = 13;   public static final int UC_MIPS_REG_INVALID = 0;   public static final int UC_MIPS_REG_PC = 1;   public static final int UC_MIPS_REG_0 = 2;   public static final int UC_MIPS_REG_1 = 3;   public static final int UC_MIPS_REG_2 = 4;   public static final int UC_MIPS_REG_3 = 5;   public static final int UC_MIPS_REG_4 = 6;   public static final int UC_MIPS_REG_5 = 7;   public static final int UC_MIPS_REG_6 = 8;   public static final int UC_MIPS_REG_7 = 9;   public static final int UC_MIPS_REG_8 = 10;   public static final int UC_MIPS_REG_9 = 11;   public static final int UC_MIPS_REG_10 = 12;   public static final int UC_MIPS_REG_11 = 13;   public static final int UC_MIPS_REG_12 = 14;   public static final int UC_MIPS_REG_13 = 15;   public static final int UC_MIPS_REG_14 = 16;   public static final int UC_MIPS_REG_15 = 17;   public static final int UC_MIPS_REG_16 = 18;   public static final int UC_MIPS_REG_17 = 19;   public static final int UC_MIPS_REG_18 = 20;   public static final int UC_MIPS_REG_19 = 21;   public static final int UC_MIPS_REG_20 = 22;   public static final int UC_MIPS_REG_21 = 23;   public static final int UC_MIPS_REG_22 = 24;   public static final int UC_MIPS_REG_23 = 25;   public static final int UC_MIPS_REG_24 = 26;   public static final int UC_MIPS_REG_25 = 27;   public static final int UC_MIPS_REG_26 = 28;   public static final int UC_MIPS_REG_27 = 29;   public static final int UC_MIPS_REG_28 = 30;   public static final int UC_MIPS_REG_29 = 31;   public static final int UC_MIPS_REG_30 = 32;   public static final int UC_MIPS_REG_31 = 33;   public static final int UC_MIPS_REG_DSPCCOND = 34;   public static final int UC_MIPS_REG_DSPCARRY = 35;   public static final int UC_MIPS_REG_DSPEFI = 36;   public static final int UC_MIPS_REG_DSPOUTFLAG = 37;   public static final int UC_MIPS_REG_DSPOUTFLAG16_19 = 38;   public static final int UC_MIPS_REG_DSPOUTFLAG20 = 39;   public static final int UC_MIPS_REG_DSPOUTFLAG21 = 40;   public static final int UC_MIPS_REG_DSPOUTFLAG22 = 41;   public static final int UC_MIPS_REG_DSPOUTFLAG23 = 42;   public static final int UC_MIPS_REG_DSPPOS = 43;   public static final int UC_MIPS_REG_DSPSCOUNT = 44;   public static final int UC_MIPS_REG_AC0 = 45;   public static final int UC_MIPS_REG_AC1 = 46;   public static final int UC_MIPS_REG_AC2 = 47;   public static final int UC_MIPS_REG_AC3 = 48;   public static final int UC_MIPS_REG_CC0 = 49;   public static final int UC_MIPS_REG_CC1 = 50;   public static final int UC_MIPS_REG_CC2 = 51;   public static final int UC_MIPS_REG_CC3 = 52;   public static final int UC_MIPS_REG_CC4 = 53;   public static final int UC_MIPS_REG_CC5 = 54;   public static final int UC_MIPS_REG_CC6 = 55;   public static final int UC_MIPS_REG_CC7 = 56;   public static final int UC_MIPS_REG_F0 = 57;   public static final int UC_MIPS_REG_F1 = 58;   public static final int UC_MIPS_REG_F2 = 59;   public static final int UC_MIPS_REG_F3 = 60;   public static final int UC_MIPS_REG_F4 = 61;   public static final int UC_MIPS_REG_F5 = 62;   public static final int UC_MIPS_REG_F6 = 63;   public static final int UC_MIPS_REG_F7 = 64;   public static final int UC_MIPS_REG_F8 = 65;   public static final int UC_MIPS_REG_F9 = 66;   public static final int UC_MIPS_REG_F10 = 67;   public static final int UC_MIPS_REG_F11 = 68;   public static final int UC_MIPS_REG_F12 = 69;   public static final int UC_MIPS_REG_F13 = 70;   public static final int UC_MIPS_REG_F14 = 71;   public static final int UC_MIPS_REG_F15 = 72;   public static final int UC_MIPS_REG_F16 = 73;   public static final int UC_MIPS_REG_F17 = 74;   public static final int UC_MIPS_REG_F18 = 75;   public static final int UC_MIPS_REG_F19 = 76;   public static final int UC_MIPS_REG_F20 = 77;   public static final int UC_MIPS_REG_F21 = 78;   public static final int UC_MIPS_REG_F22 = 79;   public static final int UC_MIPS_REG_F23 = 80;   public static final int UC_MIPS_REG_F24 = 81;   public static final int UC_MIPS_REG_F25 = 82;   public static final int UC_MIPS_REG_F26 = 83;   public static final int UC_MIPS_REG_F27 = 84;   public static final int UC_MIPS_REG_F28 = 85;   public static final int UC_MIPS_REG_F29 = 86;   public static final int UC_MIPS_REG_F30 = 87;   public static final int UC_MIPS_REG_F31 = 88;   public static final int UC_MIPS_REG_FCC0 = 89;   public static final int UC_MIPS_REG_FCC1 = 90;   public static final int UC_MIPS_REG_FCC2 = 91;   public static final int UC_MIPS_REG_FCC3 = 92;   public static final int UC_MIPS_REG_FCC4 = 93;   public static final int UC_MIPS_REG_FCC5 = 94;   public static final int UC_MIPS_REG_FCC6 = 95;   public static final int UC_MIPS_REG_FCC7 = 96;   public static final int UC_MIPS_REG_W0 = 97;   public static final int UC_MIPS_REG_W1 = 98;   public static final int UC_MIPS_REG_W2 = 99;   public static final int UC_MIPS_REG_W3 = 100;   public static final int UC_MIPS_REG_W4 = 101;   public static final int UC_MIPS_REG_W5 = 102;   public static final int UC_MIPS_REG_W6 = 103;   public static final int UC_MIPS_REG_W7 = 104;   public static final int UC_MIPS_REG_W8 = 105;   public static final int UC_MIPS_REG_W9 = 106;   public static final int UC_MIPS_REG_W10 = 107;   public static final int UC_MIPS_REG_W11 = 108;   public static final int UC_MIPS_REG_W12 = 109;   public static final int UC_MIPS_REG_W13 = 110;   public static final int UC_MIPS_REG_W14 = 111;   public static final int UC_MIPS_REG_W15 = 112;   public static final int UC_MIPS_REG_W16 = 113;   public static final int UC_MIPS_REG_W17 = 114;   public static final int UC_MIPS_REG_W18 = 115;   public static final int UC_MIPS_REG_W19 = 116;   public static final int UC_MIPS_REG_W20 = 117;   public static final int UC_MIPS_REG_W21 = 118;   public static final int UC_MIPS_REG_W22 = 119;   public static final int UC_MIPS_REG_W23 = 120;   public static final int UC_MIPS_REG_W24 = 121;   public static final int UC_MIPS_REG_W25 = 122;   public static final int UC_MIPS_REG_W26 = 123;   public static final int UC_MIPS_REG_W27 = 124;   public static final int UC_MIPS_REG_W28 = 125;   public static final int UC_MIPS_REG_W29 = 126;   public static final int UC_MIPS_REG_W30 = 127;   public static final int UC_MIPS_REG_W31 = 128;   public static final int UC_MIPS_REG_HI = 129;   public static final int UC_MIPS_REG_LO = 130;   public static final int UC_MIPS_REG_P0 = 131;   public static final int UC_MIPS_REG_P1 = 132;   public static final int UC_MIPS_REG_P2 = 133;   public static final int UC_MIPS_REG_MPL0 = 134;   public static final int UC_MIPS_REG_MPL1 = 135;   public static final int UC_MIPS_REG_MPL2 = 136;   public static final int UC_MIPS_REG_CP0_CONFIG3 = 137;   public static final int UC_MIPS_REG_CP0_USERLOCAL = 138;   public static final int UC_MIPS_REG_CP0_STATUS = 139;   public static final int UC_MIPS_REG_ENDING = 140;   public static final int UC_MIPS_REG_ZERO = 2;   public static final int UC_MIPS_REG_AT = 3;   public static final int UC_MIPS_REG_V0 = 4;   public static final int UC_MIPS_REG_V1 = 5;   public static final int UC_MIPS_REG_A0 = 6;   public static final int UC_MIPS_REG_A1 = 7;   public static final int UC_MIPS_REG_A2 = 8;   public static final int UC_MIPS_REG_A3 = 9;   public static final int UC_MIPS_REG_T0 = 10;   public static final int UC_MIPS_REG_T1 = 11;   public static final int UC_MIPS_REG_T2 = 12;   public static final int UC_MIPS_REG_T3 = 13;   public static final int UC_MIPS_REG_T4 = 14;   public static final int UC_MIPS_REG_T5 = 15;   public static final int UC_MIPS_REG_T6 = 16;   public static final int UC_MIPS_REG_T7 = 17;   public static final int UC_MIPS_REG_S0 = 18;   public static final int UC_MIPS_REG_S1 = 19;   public static final int UC_MIPS_REG_S2 = 20;   public static final int UC_MIPS_REG_S3 = 21;   public static final int UC_MIPS_REG_S4 = 22;   public static final int UC_MIPS_REG_S5 = 23;   public static final int UC_MIPS_REG_S6 = 24;   public static final int UC_MIPS_REG_S7 = 25;   public static final int UC_MIPS_REG_T8 = 26;   public static final int UC_MIPS_REG_T9 = 27;   public static final int UC_MIPS_REG_K0 = 28;   public static final int UC_MIPS_REG_K1 = 29;   public static final int UC_MIPS_REG_GP = 30;   public static final int UC_MIPS_REG_SP = 31;   public static final int UC_MIPS_REG_FP = 32;   public static final int UC_MIPS_REG_S8 = 32;   public static final int UC_MIPS_REG_RA = 33;   public static final int UC_MIPS_REG_HI0 = 45;   public static final int UC_MIPS_REG_HI1 = 46;   public static final int UC_MIPS_REG_HI2 = 47;   public static final int UC_MIPS_REG_HI3 = 48;   public static final int UC_MIPS_REG_LO0 = 45;   public static final int UC_MIPS_REG_LO1 = 46;   public static final int UC_MIPS_REG_LO2 = 47;   public static final int UC_MIPS_REG_LO3 = 48;}", "nl": "public interface MipsConst {   public static final int UC_CPU_MIPS32_4KC = 0;   public static final int UC_CPU_MIPS32_4KM = 1;   public static final int UC_CPU_MIPS32_4KECR1 = 2;   public static final int UC_CPU_MIPS32_4KEMR1 = 3;   public static final int UC_CPU_MIPS32_4KEC = 4;   public static final int UC_CPU_MIPS32_4KEM = 5;   public static final int UC_CPU_MIPS32_24KC = 6;   public static final int UC_CPU_MIPS32_24KEC = 7;   public static final int UC_CPU_MIPS32_24KF = 8;   public static final int UC_CPU_MIPS32_34KF = 9;   public static final int UC_CPU_MIPS32_74KF = 10;   public static final int UC_CPU_MIPS32_M14K = 11;   public static final int UC_CPU_MIPS32_M14KC = 12;   public static final int UC_CPU_MIPS32_P5600 = 13;   public static final int UC_CPU_MIPS32_MIPS32R6_GENERIC = 14;   public static final int UC_CPU_MIPS32_I7200 = 15;   public static final int UC_CPU_MIPS64_R4000 = 0;   public static final int UC_CPU_MIPS64_VR5432 = 1;   public static final int UC_CPU_MIPS64_5KC = 2;   public static final int UC_CPU_MIPS64_5KF = 3;   public static final int UC_CPU_MIPS64_20KC = 4;   public static final int UC_CPU_MIPS64_MIPS64R2_GENERIC = 5;   public static final int UC_CPU_MIPS64_5KEC = 6;   public static final int UC_CPU_MIPS64_5KEF = 7;   public static final int UC_CPU_MIPS64_I6400 = 8;   public static final int UC_CPU_MIPS64_I6500 = 9;   public static final int UC_CPU_MIPS64_LOONGSON_2E = 10;   public static final int UC_CPU_MIPS64_LOONGSON_2F = 11;   public static final int UC_CPU_MIPS64_MIPS64DSPR2 = 12;   public static final int UC_MIPS_REG_INVALID = 0;   public static final int UC_MIPS_REG_PC = 1;   public static final int UC_MIPS_REG_0 = 2;   public static final int UC_MIPS_REG_1 = 3;   public static final int UC_MIPS_REG_2 = 4;   public static final int UC_MIPS_REG_3 = 5;   public static final int UC_MIPS_REG_4 = 6;   public static final int UC_MIPS_REG_5 = 7;   public static final int UC_MIPS_REG_6 = 8;   public static final int UC_MIPS_REG_7 = 9;   public static final int UC_MIPS_REG_8 = 10;   public static final int UC_MIPS_REG_9 = 11;   public static final int UC_MIPS_REG_10 = 12;   public static final int UC_MIPS_REG_11 = 13;   public static final int UC_MIPS_REG_12 = 14;   public static final int UC_MIPS_REG_13 = 15;   public static final int UC_MIPS_REG_14 = 16;   public static final int UC_MIPS_REG_15 = 17;   public static final int UC_MIPS_REG_16 = 18;   public static final int UC_MIPS_REG_17 = 19;   public static final int UC_MIPS_REG_18 = 20;   public static final int UC_MIPS_REG_19 = 21;   public static final int UC_MIPS_REG_20 = 22;   public static final int UC_MIPS_REG_21 = 23;   public static final int UC_MIPS_REG_22 = 24;   public static final int UC_MIPS_REG_23 = 25;   public static final int UC_MIPS_REG_24 = 26;   public static final int UC_MIPS_REG_25 = 27;   public static final int UC_MIPS_REG_26 = 28;   public static final int UC_MIPS_REG_27 = 29;   public static final int UC_MIPS_REG_28 = 30;   public static final int UC_MIPS_REG_29 = 31;   public static final int UC_MIPS_REG_30 = 32;   public static final int UC_MIPS_REG_31 = 33;   public static final int UC_MIPS_REG_DSPCCOND = 34;   public static final int UC_MIPS_REG_DSPCARRY = 35;   public static final int UC_MIPS_REG_DSPEFI = 36;   public static final int UC_MIPS_REG_DSPOUTFLAG = 37;   public static final int UC_MIPS_REG_DSPOUTFLAG16_19 = 38;   public static final int UC_MIPS_REG_DSPOUTFLAG20 = 39;   public static final int UC_MIPS_REG_DSPOUTFLAG21 = 40;   public static final int UC_MIPS_REG_DSPOUTFLAG22 = 41;   public static final int UC_MIPS_REG_DSPOUTFLAG23 = 42;   public static final int UC_MIPS_REG_DSPPOS = 43;   public static final int UC_MIPS_REG_DSPSCOUNT = 44;   public static final int UC_MIPS_REG_AC0 = 45;   public static final int UC_MIPS_REG_AC1 = 46;   public static final int UC_MIPS_REG_AC2 = 47;   public static final int UC_MIPS_REG_AC3 = 48;   public static final int UC_MIPS_REG_CC0 = 49;   public static final int UC_MIPS_REG_CC1 = 50;   public static final int UC_MIPS_REG_CC2 = 51;   public static final int UC_MIPS_REG_CC3 = 52;   public static final int UC_MIPS_REG_CC4 = 53;   public static final int UC_MIPS_REG_CC5 = 54;   public static final int UC_MIPS_REG_CC6 = 55;   public static final int UC_MIPS_REG_CC7 = 56;   public static final int UC_MIPS_REG_F0 = 57;   public static final int UC_MIPS_REG_F1 = 58;   public static final int UC_MIPS_REG_F2 = 59;   public static final int UC_MIPS_REG_F3 = 60;   public static final int UC_MIPS_REG_F4 = 61;   public static final int UC_MIPS_REG_F5 = 62;   public static final int UC_MIPS_REG_F6 = 63;   public static final int UC_MIPS_REG_F7 = 64;   public static final int UC_MIPS_REG_F8 = 65;   public static final int UC_MIPS_REG_F9 = 66;   public static final int UC_MIPS_REG_F10 = 67;   public static final int UC_MIPS_REG_F11 = 68;   public static final int UC_MIPS_REG_F12 = 69;   public static final int UC_MIPS_REG_F13 = 70;   public static final int UC_MIPS_REG_F14 = 71;   public static final int UC_MIPS_REG_F15 = 72;   public static final int UC_MIPS_REG_F16 = 73;   public static final int UC_MIPS_REG_F17 = 74;   public static final int UC_MIPS_REG_F18 = 75;   public static final int UC_MIPS_REG_F19 = 76;   public static final int UC_MIPS_REG_F20 = 77;   public static final int UC_MIPS_REG_F21 = 78;   public static final int UC_MIPS_REG_F22 = 79;   public static final int UC_MIPS_REG_F23 = 80;   public static final int UC_MIPS_REG_F24 = 81;   public static final int UC_MIPS_REG_F25 = 82;   public static final int UC_MIPS_REG_F26 = 83;   public static final int UC_MIPS_REG_F27 = 84;   public static final int UC_MIPS_REG_F28 = 85;   public static final int UC_MIPS_REG_F29 = 86;   public static final int UC_MIPS_REG_F30 = 87;   public static final int UC_MIPS_REG_F31 = 88;   public static final int UC_MIPS_REG_FCC0 = 89;   public static final int UC_MIPS_REG_FCC1 = 90;   public static final int UC_MIPS_REG_FCC2 = 91;   public static final int UC_MIPS_REG_FCC3 = 92;   public static final int UC_MIPS_REG_FCC4 = 93;   public static final int UC_MIPS_REG_FCC5 = 94;   public static final int UC_MIPS_REG_FCC6 = 95;   public static final int UC_MIPS_REG_FCC7 = 96;   public static final int UC_MIPS_REG_W0 = 97;   public static final int UC_MIPS_REG_W1 = 98;   public static final int UC_MIPS_REG_W2 = 99;   public static final int UC_MIPS_REG_W3 = 100;   public static final int UC_MIPS_REG_W4 = 101;   public static final int UC_MIPS_REG_W5 = 102;   public static final int UC_MIPS_REG_W6 = 103;   public static final int UC_MIPS_REG_W7 = 104;   public static final int UC_MIPS_REG_W8 = 105;   public static final int UC_MIPS_REG_W9 = 106;   public static final int UC_MIPS_REG_W10 = 107;   public static final int UC_MIPS_REG_W11 = 108;   public static final int UC_MIPS_REG_W12 = 109;   public static final int UC_MIPS_REG_W13 = 110;   public static final int UC_MIPS_REG_W14 = 111;   public static final int UC_MIPS_REG_W15 = 112;   public static final int UC_MIPS_REG_W16 = 113;   public static final int UC_MIPS_REG_W17 = 114;   public static final int UC_MIPS_REG_W18 = 115;   public static final int UC_MIPS_REG_W19 = 116;   public static final int UC_MIPS_REG_W20 = 117;   public static final int UC_MIPS_REG_W21 = 118;   public static final int UC_MIPS_REG_W22 = 119;   public static final int UC_MIPS_REG_W23 = 120;   public static final int UC_MIPS_REG_W24 = 121;   public static final int UC_MIPS_REG_W25 = 122;   public static final int UC_MIPS_REG_W26 = 123;   public static final int UC_MIPS_REG_W27 = 124;   public static final int UC_MIPS_REG_W28 = 125;   public static final int UC_MIPS_REG_W29 = 126;   public static final int UC_MIPS_REG_W30 = 127;   public static final int UC_MIPS_REG_W31 = 128;   public static final int UC_MIPS_REG_HI = 129;   public static final int UC_MIPS_REG_LO = 130;   public static final int UC_MIPS_REG_P0 = 131;   public static final int UC_MIPS_REG_P1 = 132;   public static final int UC_MIPS_REG_P2 = 133;   public static final int UC_MIPS_REG_MPL0 = 134;   public static final int UC_MIPS_REG_MPL1 = 135;   public static final int UC_MIPS_REG_MPL2 = 136;   public static final int UC_MIPS_REG_CP0_CONFIG3 = 137;   public static final int UC_MIPS_REG_CP0_USERLOCAL = 138;   public static final int UC_MIPS_REG_CP0_STATUS = 139;   public static final int UC_MIPS_REG_ENDING = 140;   public static final int UC_MIPS_REG_ZERO = 2;   public static final int UC_MIPS_REG_AT = 3;   public static final int UC_MIPS_REG_V0 = 4;   public static final int UC_MIPS_REG_V1 = 5;   public static final int UC_MIPS_REG_A0 = 6;   public static final int UC_MIPS_REG_A1 = 7;   public static final int UC_MIPS_REG_A2 = 8;   public static final int UC_MIPS_REG_A3 = 9;   public static final int UC_MIPS_REG_T0 = 10;   public static final int UC_MIPS_REG_T1 = 11;   public static final int UC_MIPS_REG_T2 = 12;   public static final int UC_MIPS_REG_T3 = 13;   public static final int UC_MIPS_REG_T4 = 14;   public static final int UC_MIPS_REG_T5 = 15;   public static final int UC_MIPS_REG_T6 = 16;   public static final int UC_MIPS_REG_T7 = 17;   public static final int UC_MIPS_REG_S0 = 18;   public static final int UC_MIPS_REG_S1 = 19;   public static final int UC_MIPS_REG_S2 = 20;   public static final int UC_MIPS_REG_S3 = 21;   public static final int UC_MIPS_REG_S4 = 22;   public static final int UC_MIPS_REG_S5 = 23;   public static final int UC_MIPS_REG_S6 = 24;   public static final int UC_MIPS_REG_S7 = 25;   public static final int UC_MIPS_REG_T8 = 26;   public static final int UC_MIPS_REG_T9 = 27;   public static final int UC_MIPS_REG_K0 = 28;   public static final int UC_MIPS_REG_K1 = 29;   public static final int UC_MIPS_REG_GP = 30;   public static final int UC_MIPS_REG_SP = 31;   public static final int UC_MIPS_REG_FP = 32;   public static final int UC_MIPS_REG_S8 = 32;   public static final int UC_MIPS_REG_RA = 33;   public static final int UC_MIPS_REG_HI0 = 45;   public static final int UC_MIPS_REG_HI1 = 46;   public static final int UC_MIPS_REG_HI2 = 47;   public static final int UC_MIPS_REG_HI3 = 48;   public static final int UC_MIPS_REG_LO0 = 45;   public static final int UC_MIPS_REG_LO1 = 46;   public static final int UC_MIPS_REG_LO2 = 47;   public static final int UC_MIPS_REG_LO3 = 48;}"}
{"code": "public interface PpcConst {   public static final int UC_CPU_PPC32_401 = 0;   public static final int UC_CPU_PPC32_401A1 = 1;   public static final int UC_CPU_PPC32_401B2 = 2;   public static final int UC_CPU_PPC32_401C2 = 3;   public static final int UC_CPU_PPC32_401D2 = 4;   public static final int UC_CPU_PPC32_401E2 = 5;   public static final int UC_CPU_PPC32_401F2 = 6;   public static final int UC_CPU_PPC32_401G2 = 7;   public static final int UC_CPU_PPC32_IOP480 = 8;   public static final int UC_CPU_PPC32_COBRA = 9;   public static final int UC_CPU_PPC32_403GA = 10;   public static final int UC_CPU_PPC32_403GB = 11;   public static final int UC_CPU_PPC32_403GC = 12;   public static final int UC_CPU_PPC32_403GCX = 13;   public static final int UC_CPU_PPC32_405D2 = 14;   public static final int UC_CPU_PPC32_405D4 = 15;   public static final int UC_CPU_PPC32_405CRA = 16;   public static final int UC_CPU_PPC32_405CRB = 17;   public static final int UC_CPU_PPC32_405CRC = 18;   public static final int UC_CPU_PPC32_405EP = 19;   public static final int UC_CPU_PPC32_405EZ = 20;   public static final int UC_CPU_PPC32_405GPA = 21;   public static final int UC_CPU_PPC32_405GPB = 22;   public static final int UC_CPU_PPC32_405GPC = 23;   public static final int UC_CPU_PPC32_405GPD = 24;   public static final int UC_CPU_PPC32_405GPR = 25;   public static final int UC_CPU_PPC32_405LP = 26;   public static final int UC_CPU_PPC32_NPE405H = 27;   public static final int UC_CPU_PPC32_NPE405H2 = 28;   public static final int UC_CPU_PPC32_NPE405L = 29;   public static final int UC_CPU_PPC32_NPE4GS3 = 30;   public static final int UC_CPU_PPC32_STB03 = 31;   public static final int UC_CPU_PPC32_STB04 = 32;   public static final int UC_CPU_PPC32_STB25 = 33;   public static final int UC_CPU_PPC32_X2VP4 = 34;   public static final int UC_CPU_PPC32_X2VP20 = 35;   public static final int UC_CPU_PPC32_440_XILINX = 36;   public static final int UC_CPU_PPC32_440_XILINX_W_DFPU = 37;   public static final int UC_CPU_PPC32_440EPA = 38;   public static final int UC_CPU_PPC32_440EPB = 39;   public static final int UC_CPU_PPC32_440EPX = 40;   public static final int UC_CPU_PPC32_460EXB = 41;   public static final int UC_CPU_PPC32_G2 = 42;   public static final int UC_CPU_PPC32_G2H4 = 43;   public static final int UC_CPU_PPC32_G2GP = 44;   public static final int UC_CPU_PPC32_G2LS = 45;   public static final int UC_CPU_PPC32_G2HIP3 = 46;   public static final int UC_CPU_PPC32_G2HIP4 = 47;   public static final int UC_CPU_PPC32_MPC603 = 48;   public static final int UC_CPU_PPC32_G2LE = 49;   public static final int UC_CPU_PPC32_G2LEGP = 50;   public static final int UC_CPU_PPC32_G2LELS = 51;   public static final int UC_CPU_PPC32_G2LEGP1 = 52;   public static final int UC_CPU_PPC32_G2LEGP3 = 53;   public static final int UC_CPU_PPC32_MPC5200_V10 = 54;   public static final int UC_CPU_PPC32_MPC5200_V11 = 55;   public static final int UC_CPU_PPC32_MPC5200_V12 = 56;   public static final int UC_CPU_PPC32_MPC5200B_V20 = 57;   public static final int UC_CPU_PPC32_MPC5200B_V21 = 58;   public static final int UC_CPU_PPC32_E200Z5 = 59;   public static final int UC_CPU_PPC32_E200Z6 = 60;   public static final int UC_CPU_PPC32_E300C1 = 61;   public static final int UC_CPU_PPC32_E300C2 = 62;   public static final int UC_CPU_PPC32_E300C3 = 63;   public static final int UC_CPU_PPC32_E300C4 = 64;   public static final int UC_CPU_PPC32_MPC8343 = 65;   public static final int UC_CPU_PPC32_MPC8343A = 66;   public static final int UC_CPU_PPC32_MPC8343E = 67;   public static final int UC_CPU_PPC32_MPC8343EA = 68;   public static final int UC_CPU_PPC32_MPC8347T = 69;   public static final int UC_CPU_PPC32_MPC8347P = 70;   public static final int UC_CPU_PPC32_MPC8347AT = 71;   public static final int UC_CPU_PPC32_MPC8347AP = 72;   public static final int UC_CPU_PPC32_MPC8347ET = 73;   public static final int UC_CPU_PPC32_MPC8347EP = 74;   public static final int UC_CPU_PPC32_MPC8347EAT = 75;   public static final int UC_CPU_PPC32_MPC8347EAP = 76;   public static final int UC_CPU_PPC32_MPC8349 = 77;   public static final int UC_CPU_PPC32_MPC8349A = 78;   public static final int UC_CPU_PPC32_MPC8349E = 79;   public static final int UC_CPU_PPC32_MPC8349EA = 80;   public static final int UC_CPU_PPC32_MPC8377 = 81;   public static final int UC_CPU_PPC32_MPC8377E = 82;   public static final int UC_CPU_PPC32_MPC8378 = 83;   public static final int UC_CPU_PPC32_MPC8378E = 84;   public static final int UC_CPU_PPC32_MPC8379 = 85;   public static final int UC_CPU_PPC32_MPC8379E = 86;   public static final int UC_CPU_PPC32_E500_V10 = 87;   public static final int UC_CPU_PPC32_E500_V20 = 88;   public static final int UC_CPU_PPC32_E500V2_V10 = 89;   public static final int UC_CPU_PPC32_E500V2_V20 = 90;   public static final int UC_CPU_PPC32_E500V2_V21 = 91;   public static final int UC_CPU_PPC32_E500V2_V22 = 92;   public static final int UC_CPU_PPC32_E500V2_V30 = 93;   public static final int UC_CPU_PPC32_E500MC = 94;   public static final int UC_CPU_PPC32_MPC8533_V10 = 95;   public static final int UC_CPU_PPC32_MPC8533_V11 = 96;   public static final int UC_CPU_PPC32_MPC8533E_V10 = 97;   public static final int UC_CPU_PPC32_MPC8533E_V11 = 98;   public static final int UC_CPU_PPC32_MPC8540_V10 = 99;   public static final int UC_CPU_PPC32_MPC8540_V20 = 100;   public static final int UC_CPU_PPC32_MPC8540_V21 = 101;   public static final int UC_CPU_PPC32_MPC8541_V10 = 102;   public static final int UC_CPU_PPC32_MPC8541_V11 = 103;   public static final int UC_CPU_PPC32_MPC8541E_V10 = 104;   public static final int UC_CPU_PPC32_MPC8541E_V11 = 105;   public static final int UC_CPU_PPC32_MPC8543_V10 = 106;   public static final int UC_CPU_PPC32_MPC8543_V11 = 107;   public static final int UC_CPU_PPC32_MPC8543_V20 = 108;   public static final int UC_CPU_PPC32_MPC8543_V21 = 109;   public static final int UC_CPU_PPC32_MPC8543E_V10 = 110;   public static final int UC_CPU_PPC32_MPC8543E_V11 = 111;   public static final int UC_CPU_PPC32_MPC8543E_V20 = 112;   public static final int UC_CPU_PPC32_MPC8543E_V21 = 113;   public static final int UC_CPU_PPC32_MPC8544_V10 = 114;   public static final int UC_CPU_PPC32_MPC8544_V11 = 115;   public static final int UC_CPU_PPC32_MPC8544E_V10 = 116;   public static final int UC_CPU_PPC32_MPC8544E_V11 = 117;   public static final int UC_CPU_PPC32_MPC8545_V20 = 118;   public static final int UC_CPU_PPC32_MPC8545_V21 = 119;   public static final int UC_CPU_PPC32_MPC8545E_V20 = 120;   public static final int UC_CPU_PPC32_MPC8545E_V21 = 121;   public static final int UC_CPU_PPC32_MPC8547E_V20 = 122;   public static final int UC_CPU_PPC32_MPC8547E_V21 = 123;   public static final int UC_CPU_PPC32_MPC8548_V10 = 124;   public static final int UC_CPU_PPC32_MPC8548_V11 = 125;   public static final int UC_CPU_PPC32_MPC8548_V20 = 126;   public static final int UC_CPU_PPC32_MPC8548_V21 = 127;   public static final int UC_CPU_PPC32_MPC8548E_V10 = 128;   public static final int UC_CPU_PPC32_MPC8548E_V11 = 129;   public static final int UC_CPU_PPC32_MPC8548E_V20 = 130;   public static final int UC_CPU_PPC32_MPC8548E_V21 = 131;   public static final int UC_CPU_PPC32_MPC8555_V10 = 132;   public static final int UC_CPU_PPC32_MPC8555_V11 = 133;   public static final int UC_CPU_PPC32_MPC8555E_V10 = 134;   public static final int UC_CPU_PPC32_MPC8555E_V11 = 135;   public static final int UC_CPU_PPC32_MPC8560_V10 = 136;   public static final int UC_CPU_PPC32_MPC8560_V20 = 137;   public static final int UC_CPU_PPC32_MPC8560_V21 = 138;   public static final int UC_CPU_PPC32_MPC8567 = 139;   public static final int UC_CPU_PPC32_MPC8567E = 140;   public static final int UC_CPU_PPC32_MPC8568 = 141;   public static final int UC_CPU_PPC32_MPC8568E = 142;   public static final int UC_CPU_PPC32_MPC8572 = 143;   public static final int UC_CPU_PPC32_MPC8572E = 144;   public static final int UC_CPU_PPC32_E600 = 145;   public static final int UC_CPU_PPC32_MPC8610 = 146;   public static final int UC_CPU_PPC32_MPC8641 = 147;   public static final int UC_CPU_PPC32_MPC8641D = 148;   public static final int UC_CPU_PPC32_601_V0 = 149;   public static final int UC_CPU_PPC32_601_V1 = 150;   public static final int UC_CPU_PPC32_601_V2 = 151;   public static final int UC_CPU_PPC32_602 = 152;   public static final int UC_CPU_PPC32_603 = 153;   public static final int UC_CPU_PPC32_603E_V1_1 = 154;   public static final int UC_CPU_PPC32_603E_V1_2 = 155;   public static final int UC_CPU_PPC32_603E_V1_3 = 156;   public static final int UC_CPU_PPC32_603E_V1_4 = 157;   public static final int UC_CPU_PPC32_603E_V2_2 = 158;   public static final int UC_CPU_PPC32_603E_V3 = 159;   public static final int UC_CPU_PPC32_603E_V4 = 160;   public static final int UC_CPU_PPC32_603E_V4_1 = 161;   public static final int UC_CPU_PPC32_603E7 = 162;   public static final int UC_CPU_PPC32_603E7T = 163;   public static final int UC_CPU_PPC32_603E7V = 164;   public static final int UC_CPU_PPC32_603E7V1 = 165;   public static final int UC_CPU_PPC32_603E7V2 = 166;   public static final int UC_CPU_PPC32_603P = 167;   public static final int UC_CPU_PPC32_604 = 168;   public static final int UC_CPU_PPC32_604E_V1_0 = 169;   public static final int UC_CPU_PPC32_604E_V2_2 = 170;   public static final int UC_CPU_PPC32_604E_V2_4 = 171;   public static final int UC_CPU_PPC32_604R = 172;   public static final int UC_CPU_PPC32_740_V1_0 = 173;   public static final int UC_CPU_PPC32_750_V1_0 = 174;   public static final int UC_CPU_PPC32_740_V2_0 = 175;   public static final int UC_CPU_PPC32_750_V2_0 = 176;   public static final int UC_CPU_PPC32_740_V2_1 = 177;   public static final int UC_CPU_PPC32_750_V2_1 = 178;   public static final int UC_CPU_PPC32_740_V2_2 = 179;   public static final int UC_CPU_PPC32_750_V2_2 = 180;   public static final int UC_CPU_PPC32_740_V3_0 = 181;   public static final int UC_CPU_PPC32_750_V3_0 = 182;   public static final int UC_CPU_PPC32_740_V3_1 = 183;   public static final int UC_CPU_PPC32_750_V3_1 = 184;   public static final int UC_CPU_PPC32_740E = 185;   public static final int UC_CPU_PPC32_750E = 186;   public static final int UC_CPU_PPC32_740P = 187;   public static final int UC_CPU_PPC32_750P = 188;   public static final int UC_CPU_PPC32_750CL_V1_0 = 189;   public static final int UC_CPU_PPC32_750CL_V2_0 = 190;   public static final int UC_CPU_PPC32_750CX_V1_0 = 191;   public static final int UC_CPU_PPC32_750CX_V2_0 = 192;   public static final int UC_CPU_PPC32_750CX_V2_1 = 193;   public static final int UC_CPU_PPC32_750CX_V2_2 = 194;   public static final int UC_CPU_PPC32_750CXE_V2_1 = 195;   public static final int UC_CPU_PPC32_750CXE_V2_2 = 196;   public static final int UC_CPU_PPC32_750CXE_V2_3 = 197;   public static final int UC_CPU_PPC32_750CXE_V2_4 = 198;   public static final int UC_CPU_PPC32_750CXE_V2_4B = 199;   public static final int UC_CPU_PPC32_750CXE_V3_0 = 200;   public static final int UC_CPU_PPC32_750CXE_V3_1 = 201;   public static final int UC_CPU_PPC32_750CXE_V3_1B = 202;   public static final int UC_CPU_PPC32_750CXR = 203;   public static final int UC_CPU_PPC32_750FL = 204;   public static final int UC_CPU_PPC32_750FX_V1_0 = 205;   public static final int UC_CPU_PPC32_750FX_V2_0 = 206;   public static final int UC_CPU_PPC32_750FX_V2_1 = 207;   public static final int UC_CPU_PPC32_750FX_V2_2 = 208;   public static final int UC_CPU_PPC32_750FX_V2_3 = 209;   public static final int UC_CPU_PPC32_750GL = 210;   public static final int UC_CPU_PPC32_750GX_V1_0 = 211;   public static final int UC_CPU_PPC32_750GX_V1_1 = 212;   public static final int UC_CPU_PPC32_750GX_V1_2 = 213;   public static final int UC_CPU_PPC32_750L_V2_0 = 214;   public static final int UC_CPU_PPC32_750L_V2_1 = 215;   public static final int UC_CPU_PPC32_750L_V2_2 = 216;   public static final int UC_CPU_PPC32_750L_V3_0 = 217;   public static final int UC_CPU_PPC32_750L_V3_2 = 218;   public static final int UC_CPU_PPC32_745_V1_0 = 219;   public static final int UC_CPU_PPC32_755_V1_0 = 220;   public static final int UC_CPU_PPC32_745_V1_1 = 221;   public static final int UC_CPU_PPC32_755_V1_1 = 222;   public static final int UC_CPU_PPC32_745_V2_0 = 223;   public static final int UC_CPU_PPC32_755_V2_0 = 224;   public static final int UC_CPU_PPC32_745_V2_1 = 225;   public static final int UC_CPU_PPC32_755_V2_1 = 226;   public static final int UC_CPU_PPC32_745_V2_2 = 227;   public static final int UC_CPU_PPC32_755_V2_2 = 228;   public static final int UC_CPU_PPC32_745_V2_3 = 229;   public static final int UC_CPU_PPC32_755_V2_3 = 230;   public static final int UC_CPU_PPC32_745_V2_4 = 231;   public static final int UC_CPU_PPC32_755_V2_4 = 232;   public static final int UC_CPU_PPC32_745_V2_5 = 233;   public static final int UC_CPU_PPC32_755_V2_5 = 234;   public static final int UC_CPU_PPC32_745_V2_6 = 235;   public static final int UC_CPU_PPC32_755_V2_6 = 236;   public static final int UC_CPU_PPC32_745_V2_7 = 237;   public static final int UC_CPU_PPC32_755_V2_7 = 238;   public static final int UC_CPU_PPC32_745_V2_8 = 239;   public static final int UC_CPU_PPC32_755_V2_8 = 240;   public static final int UC_CPU_PPC32_7400_V1_0 = 241;   public static final int UC_CPU_PPC32_7400_V1_1 = 242;   public static final int UC_CPU_PPC32_7400_V2_0 = 243;   public static final int UC_CPU_PPC32_7400_V2_1 = 244;   public static final int UC_CPU_PPC32_7400_V2_2 = 245;   public static final int UC_CPU_PPC32_7400_V2_6 = 246;   public static final int UC_CPU_PPC32_7400_V2_7 = 247;   public static final int UC_CPU_PPC32_7400_V2_8 = 248;   public static final int UC_CPU_PPC32_7400_V2_9 = 249;   public static final int UC_CPU_PPC32_7410_V1_0 = 250;   public static final int UC_CPU_PPC32_7410_V1_1 = 251;   public static final int UC_CPU_PPC32_7410_V1_2 = 252;   public static final int UC_CPU_PPC32_7410_V1_3 = 253;   public static final int UC_CPU_PPC32_7410_V1_4 = 254;   public static final int UC_CPU_PPC32_7448_V1_0 = 255;   public static final int UC_CPU_PPC32_7448_V1_1 = 256;   public static final int UC_CPU_PPC32_7448_V2_0 = 257;   public static final int UC_CPU_PPC32_7448_V2_1 = 258;   public static final int UC_CPU_PPC32_7450_V1_0 = 259;   public static final int UC_CPU_PPC32_7450_V1_1 = 260;   public static final int UC_CPU_PPC32_7450_V1_2 = 261;   public static final int UC_CPU_PPC32_7450_V2_0 = 262;   public static final int UC_CPU_PPC32_7450_V2_1 = 263;   public static final int UC_CPU_PPC32_7441_V2_1 = 264;   public static final int UC_CPU_PPC32_7441_V2_3 = 265;   public static final int UC_CPU_PPC32_7451_V2_3 = 266;   public static final int UC_CPU_PPC32_7441_V2_10 = 267;   public static final int UC_CPU_PPC32_7451_V2_10 = 268;   public static final int UC_CPU_PPC32_7445_V1_0 = 269;   public static final int UC_CPU_PPC32_7455_V1_0 = 270;   public static final int UC_CPU_PPC32_7445_V2_1 = 271;   public static final int UC_CPU_PPC32_7455_V2_1 = 272;   public static final int UC_CPU_PPC32_7445_V3_2 = 273;   public static final int UC_CPU_PPC32_7455_V3_2 = 274;   public static final int UC_CPU_PPC32_7445_V3_3 = 275;   public static final int UC_CPU_PPC32_7455_V3_3 = 276;   public static final int UC_CPU_PPC32_7445_V3_4 = 277;   public static final int UC_CPU_PPC32_7455_V3_4 = 278;   public static final int UC_CPU_PPC32_7447_V1_0 = 279;   public static final int UC_CPU_PPC32_7457_V1_0 = 280;   public static final int UC_CPU_PPC32_7447_V1_1 = 281;   public static final int UC_CPU_PPC32_7457_V1_1 = 282;   public static final int UC_CPU_PPC32_7457_V1_2 = 283;   public static final int UC_CPU_PPC32_7447A_V1_0 = 284;   public static final int UC_CPU_PPC32_7457A_V1_0 = 285;   public static final int UC_CPU_PPC32_7447A_V1_1 = 286;   public static final int UC_CPU_PPC32_7457A_V1_1 = 287;   public static final int UC_CPU_PPC32_7447A_V1_2 = 288;   public static final int UC_CPU_PPC32_7457A_V1_2 = 289;   public static final int UC_CPU_PPC32_ENDING = 290;   public static final int UC_CPU_PPC64_E5500 = 0;   public static final int UC_CPU_PPC64_E6500 = 1;   public static final int UC_CPU_PPC64_970_V2_2 = 2;   public static final int UC_CPU_PPC64_970FX_V1_0 = 3;   public static final int UC_CPU_PPC64_970FX_V2_0 = 4;   public static final int UC_CPU_PPC64_970FX_V2_1 = 5;   public static final int UC_CPU_PPC64_970FX_V3_0 = 6;   public static final int UC_CPU_PPC64_970FX_V3_1 = 7;   public static final int UC_CPU_PPC64_970MP_V1_0 = 8;   public static final int UC_CPU_PPC64_970MP_V1_1 = 9;   public static final int UC_CPU_PPC64_POWER5_V2_1 = 10;   public static final int UC_CPU_PPC64_POWER7_V2_3 = 11;   public static final int UC_CPU_PPC64_POWER7_V2_1 = 12;   public static final int UC_CPU_PPC64_POWER8E_V2_1 = 13;   public static final int UC_CPU_PPC64_POWER8_V2_0 = 14;   public static final int UC_CPU_PPC64_POWER8NVL_V1_0 = 15;   public static final int UC_CPU_PPC64_POWER9_V1_0 = 16;   public static final int UC_CPU_PPC64_POWER9_V2_0 = 17;   public static final int UC_CPU_PPC64_POWER10_V1_0 = 18;   public static final int UC_CPU_PPC64_ENDING = 19;   public static final int UC_PPC_REG_INVALID = 0;   public static final int UC_PPC_REG_PC = 1;   public static final int UC_PPC_REG_0 = 2;   public static final int UC_PPC_REG_1 = 3;   public static final int UC_PPC_REG_2 = 4;   public static final int UC_PPC_REG_3 = 5;   public static final int UC_PPC_REG_4 = 6;   public static final int UC_PPC_REG_5 = 7;   public static final int UC_PPC_REG_6 = 8;   public static final int UC_PPC_REG_7 = 9;   public static final int UC_PPC_REG_8 = 10;   public static final int UC_PPC_REG_9 = 11;   public static final int UC_PPC_REG_10 = 12;   public static final int UC_PPC_REG_11 = 13;   public static final int UC_PPC_REG_12 = 14;   public static final int UC_PPC_REG_13 = 15;   public static final int UC_PPC_REG_14 = 16;   public static final int UC_PPC_REG_15 = 17;   public static final int UC_PPC_REG_16 = 18;   public static final int UC_PPC_REG_17 = 19;   public static final int UC_PPC_REG_18 = 20;   public static final int UC_PPC_REG_19 = 21;   public static final int UC_PPC_REG_20 = 22;   public static final int UC_PPC_REG_21 = 23;   public static final int UC_PPC_REG_22 = 24;   public static final int UC_PPC_REG_23 = 25;   public static final int UC_PPC_REG_24 = 26;   public static final int UC_PPC_REG_25 = 27;   public static final int UC_PPC_REG_26 = 28;   public static final int UC_PPC_REG_27 = 29;   public static final int UC_PPC_REG_28 = 30;   public static final int UC_PPC_REG_29 = 31;   public static final int UC_PPC_REG_30 = 32;   public static final int UC_PPC_REG_31 = 33;   public static final int UC_PPC_REG_CR0 = 34;   public static final int UC_PPC_REG_CR1 = 35;   public static final int UC_PPC_REG_CR2 = 36;   public static final int UC_PPC_REG_CR3 = 37;   public static final int UC_PPC_REG_CR4 = 38;   public static final int UC_PPC_REG_CR5 = 39;   public static final int UC_PPC_REG_CR6 = 40;   public static final int UC_PPC_REG_CR7 = 41;   public static final int UC_PPC_REG_FPR0 = 42;   public static final int UC_PPC_REG_FPR1 = 43;   public static final int UC_PPC_REG_FPR2 = 44;   public static final int UC_PPC_REG_FPR3 = 45;   public static final int UC_PPC_REG_FPR4 = 46;   public static final int UC_PPC_REG_FPR5 = 47;   public static final int UC_PPC_REG_FPR6 = 48;   public static final int UC_PPC_REG_FPR7 = 49;   public static final int UC_PPC_REG_FPR8 = 50;   public static final int UC_PPC_REG_FPR9 = 51;   public static final int UC_PPC_REG_FPR10 = 52;   public static final int UC_PPC_REG_FPR11 = 53;   public static final int UC_PPC_REG_FPR12 = 54;   public static final int UC_PPC_REG_FPR13 = 55;   public static final int UC_PPC_REG_FPR14 = 56;   public static final int UC_PPC_REG_FPR15 = 57;   public static final int UC_PPC_REG_FPR16 = 58;   public static final int UC_PPC_REG_FPR17 = 59;   public static final int UC_PPC_REG_FPR18 = 60;   public static final int UC_PPC_REG_FPR19 = 61;   public static final int UC_PPC_REG_FPR20 = 62;   public static final int UC_PPC_REG_FPR21 = 63;   public static final int UC_PPC_REG_FPR22 = 64;   public static final int UC_PPC_REG_FPR23 = 65;   public static final int UC_PPC_REG_FPR24 = 66;   public static final int UC_PPC_REG_FPR25 = 67;   public static final int UC_PPC_REG_FPR26 = 68;   public static final int UC_PPC_REG_FPR27 = 69;   public static final int UC_PPC_REG_FPR28 = 70;   public static final int UC_PPC_REG_FPR29 = 71;   public static final int UC_PPC_REG_FPR30 = 72;   public static final int UC_PPC_REG_FPR31 = 73;   public static final int UC_PPC_REG_LR = 74;   public static final int UC_PPC_REG_XER = 75;   public static final int UC_PPC_REG_CTR = 76;   public static final int UC_PPC_REG_MSR = 77;   public static final int UC_PPC_REG_FPSCR = 78;   public static final int UC_PPC_REG_CR = 79;   public static final int UC_PPC_REG_ENDING = 80;}", "nl": "public interface PpcConst {   public static final int UC_CPU_PPC_401 = 0;   public static final int UC_CPU_PPC_401A1 = 1;   public static final int UC_CPU_PPC_401B2 = 2;   public static final int UC_CPU_PPC_401C2 = 3;   public static final int UC_CPU_PPC_401D2 = 4;   public static final int UC_CPU_PPC_401E2 = 5;   public static final int UC_CPU_PPC_401F2 = 6;   public static final int UC_CPU_PPC_401G2 = 7;   public static final int UC_CPU_PPC_IOP480 = 8;   public static final int UC_CPU_PPC_COBRA = 9;   public static final int UC_CPU_PPC_403GA = 10;   public static final int UC_CPU_PPC_403GB = 11;   public static final int UC_CPU_PPC_403GC = 12;   public static final int UC_CPU_PPC_403GCX = 13;   public static final int UC_CPU_PPC_405D2 = 14;   public static final int UC_CPU_PPC_405D4 = 15;   public static final int UC_CPU_PPC_405CRA = 16;   public static final int UC_CPU_PPC_405CRB = 17;   public static final int UC_CPU_PPC_405CRC = 18;   public static final int UC_CPU_PPC_405EP = 19;   public static final int UC_CPU_PPC_405EZ = 20;   public static final int UC_CPU_PPC_405GPA = 21;   public static final int UC_CPU_PPC_405GPB = 22;   public static final int UC_CPU_PPC_405GPC = 23;   public static final int UC_CPU_PPC_405GPD = 24;   public static final int UC_CPU_PPC_405GPR = 25;   public static final int UC_CPU_PPC_405LP = 26;   public static final int UC_CPU_PPC_NPE405H = 27;   public static final int UC_CPU_PPC_NPE405H2 = 28;   public static final int UC_CPU_PPC_NPE405L = 29;   public static final int UC_CPU_PPC_NPE4GS3 = 30;   public static final int UC_CPU_PPC_STB03 = 31;   public static final int UC_CPU_PPC_STB04 = 32;   public static final int UC_CPU_PPC_STB25 = 33;   public static final int UC_CPU_PPC_X2VP4 = 34;   public static final int UC_CPU_PPC_X2VP20 = 35;   public static final int UC_CPU_PPC_440_XILINX = 36;   public static final int UC_CPU_PPC_440_XILINX_W_DFPU = 37;   public static final int UC_CPU_PPC_440EPA = 38;   public static final int UC_CPU_PPC_440EPB = 39;   public static final int UC_CPU_PPC_440EPX = 40;   public static final int UC_CPU_PPC_460EXB = 41;   public static final int UC_CPU_PPC_G2 = 42;   public static final int UC_CPU_PPC_G2H4 = 43;   public static final int UC_CPU_PPC_G2GP = 44;   public static final int UC_CPU_PPC_G2LS = 45;   public static final int UC_CPU_PPC_G2HIP3 = 46;   public static final int UC_CPU_PPC_G2HIP4 = 47;   public static final int UC_CPU_PPC_MPC603 = 48;   public static final int UC_CPU_PPC_G2LE = 49;   public static final int UC_CPU_PPC_G2LEGP = 50;   public static final int UC_CPU_PPC_G2LELS = 51;   public static final int UC_CPU_PPC_G2LEGP1 = 52;   public static final int UC_CPU_PPC_G2LEGP3 = 53;   public static final int UC_CPU_PPC_MPC5200_V10 = 54;   public static final int UC_CPU_PPC_MPC5200_V11 = 55;   public static final int UC_CPU_PPC_MPC5200_V12 = 56;   public static final int UC_CPU_PPC_MPC5200B_V20 = 57;   public static final int UC_CPU_PPC_MPC5200B_V21 = 58;   public static final int UC_CPU_PPC_E200Z5 = 59;   public static final int UC_CPU_PPC_E200Z6 = 60;   public static final int UC_CPU_PPC_E300C1 = 61;   public static final int UC_CPU_PPC_E300C2 = 62;   public static final int UC_CPU_PPC_E300C3 = 63;   public static final int UC_CPU_PPC_E300C4 = 64;   public static final int UC_CPU_PPC_MPC8343 = 65;   public static final int UC_CPU_PPC_MPC8343A = 66;   public static final int UC_CPU_PPC_MPC8343E = 67;   public static final int UC_CPU_PPC_MPC8343EA = 68;   public static final int UC_CPU_PPC_MPC8347T = 69;   public static final int UC_CPU_PPC_MPC8347P = 70;   public static final int UC_CPU_PPC_MPC8347AT = 71;   public static final int UC_CPU_PPC_MPC8347AP = 72;   public static final int UC_CPU_PPC_MPC8347ET = 73;   public static final int UC_CPU_PPC_MPC8347EP = 74;   public static final int UC_CPU_PPC_MPC8347EAT = 75;   public static final int UC_CPU_PPC_MPC8347EAP = 76;   public static final int UC_CPU_PPC_MPC8349 = 77;   public static final int UC_CPU_PPC_MPC8349A = 78;   public static final int UC_CPU_PPC_MPC8349E = 79;   public static final int UC_CPU_PPC_MPC8349EA = 80;   public static final int UC_CPU_PPC_MPC8377 = 81;   public static final int UC_CPU_PPC_MPC8377E = 82;   public static final int UC_CPU_PPC_MPC8378 = 83;   public static final int UC_CPU_PPC_MPC8378E = 84;   public static final int UC_CPU_PPC_MPC8379 = 85;   public static final int UC_CPU_PPC_MPC8379E = 86;   public static final int UC_CPU_PPC_E500_V10 = 87;   public static final int UC_CPU_PPC_E500_V20 = 88;   public static final int UC_CPU_PPC_E500V2_V10 = 89;   public static final int UC_CPU_PPC_E500V2_V20 = 90;   public static final int UC_CPU_PPC_E500V2_V21 = 91;   public static final int UC_CPU_PPC_E500V2_V22 = 92;   public static final int UC_CPU_PPC_E500V2_V30 = 93;   public static final int UC_CPU_PPC_E500MC = 94;   public static final int UC_CPU_PPC_MPC8533_V10 = 95;   public static final int UC_CPU_PPC_MPC8533_V11 = 96;   public static final int UC_CPU_PPC_MPC8533E_V10 = 97;   public static final int UC_CPU_PPC_MPC8533E_V11 = 98;   public static final int UC_CPU_PPC_MPC8540_V10 = 99;   public static final int UC_CPU_PPC_MPC8540_V20 = 100;   public static final int UC_CPU_PPC_MPC8540_V21 = 101;   public static final int UC_CPU_PPC_MPC8541_V10 = 102;   public static final int UC_CPU_PPC_MPC8541_V11 = 103;   public static final int UC_CPU_PPC_MPC8541E_V10 = 104;   public static final int UC_CPU_PPC_MPC8541E_V11 = 105;   public static final int UC_CPU_PPC_MPC8543_V10 = 106;   public static final int UC_CPU_PPC_MPC8543_V11 = 107;   public static final int UC_CPU_PPC_MPC8543_V20 = 108;   public static final int UC_CPU_PPC_MPC8543_V21 = 109;   public static final int UC_CPU_PPC_MPC8543E_V10 = 110;   public static final int UC_CPU_PPC_MPC8543E_V11 = 111;   public static final int UC_CPU_PPC_MPC8543E_V20 = 112;   public static final int UC_CPU_PPC_MPC8543E_V21 = 113;   public static final int UC_CPU_PPC_MPC8544_V10 = 114;   public static final int UC_CPU_PPC_MPC8544_V11 = 115;   public static final int UC_CPU_PPC_MPC8544E_V10 = 116;   public static final int UC_CPU_PPC_MPC8544E_V11 = 117;   public static final int UC_CPU_PPC_MPC8545_V20 = 118;   public static final int UC_CPU_PPC_MPC8545_V21 = 119;   public static final int UC_CPU_PPC_MPC8545E_V20 = 120;   public static final int UC_CPU_PPC_MPC8545E_V21 = 121;   public static final int UC_CPU_PPC_MPC8547E_V20 = 122;   public static final int UC_CPU_PPC_MPC8547E_V21 = 123;   public static final int UC_CPU_PPC_MPC8548_V10 = 124;   public static final int UC_CPU_PPC_MPC8548_V11 = 125;   public static final int UC_CPU_PPC_MPC8548_V20 = 126;   public static final int UC_CPU_PPC_MPC8548_V21 = 127;   public static final int UC_CPU_PPC_MPC8548E_V10 = 128;   public static final int UC_CPU_PPC_MPC8548E_V11 = 129;   public static final int UC_CPU_PPC_MPC8548E_V20 = 130;   public static final int UC_CPU_PPC_MPC8548E_V21 = 131;   public static final int UC_CPU_PPC_MPC8555_V10 = 132;   public static final int UC_CPU_PPC_MPC8555_V11 = 133;   public static final int UC_CPU_PPC_MPC8555E_V10 = 134;   public static final int UC_CPU_PPC_MPC8555E_V11 = 135;   public static final int UC_CPU_PPC_MPC8560_V10 = 136;   public static final int UC_CPU_PPC_MPC8560_V20 = 137;   public static final int UC_CPU_PPC_MPC8560_V21 = 138;   public static final int UC_CPU_PPC_MPC8567 = 139;   public static final int UC_CPU_PPC_MPC8567E = 140;   public static final int UC_CPU_PPC_MPC8568 = 141;   public static final int UC_CPU_PPC_MPC8568E = 142;   public static final int UC_CPU_PPC_MPC8572 = 143;   public static final int UC_CPU_PPC_MPC8572E = 144;   public static final int UC_CPU_PPC_E600 = 145;   public static final int UC_CPU_PPC_MPC8610 = 146;   public static final int UC_CPU_PPC_MPC8641 = 147;   public static final int UC_CPU_PPC_MPC8641D = 148;   public static final int UC_CPU_PPC_601_V0 = 149;   public static final int UC_CPU_PPC_601_V1 = 150;   public static final int UC_CPU_PPC_601_V2 = 151;   public static final int UC_CPU_PPC_602 = 152;   public static final int UC_CPU_PPC_603 = 153;   public static final int UC_CPU_PPC_603E_V1_1 = 154;   public static final int UC_CPU_PPC_603E_V1_2 = 155;   public static final int UC_CPU_PPC_603E_V1_3 = 156;   public static final int UC_CPU_PPC_603E_V1_4 = 157;   public static final int UC_CPU_PPC_603E_V2_2 = 158;   public static final int UC_CPU_PPC_603E_V3 = 159;   public static final int UC_CPU_PPC_603E_V4 = 160;   public static final int UC_CPU_PPC_603E_V4_1 = 161;   public static final int UC_CPU_PPC_603E7 = 162;   public static final int UC_CPU_PPC_603E7T = 163;   public static final int UC_CPU_PPC_603E7V = 164;   public static final int UC_CPU_PPC_603E7V1 = 165;   public static final int UC_CPU_PPC_603E7V2 = 166;   public static final int UC_CPU_PPC_603P = 167;   public static final int UC_CPU_PPC_604 = 168;   public static final int UC_CPU_PPC_604E_V1_0 = 169;   public static final int UC_CPU_PPC_604E_V2_2 = 170;   public static final int UC_CPU_PPC_604E_V2_4 = 171;   public static final int UC_CPU_PPC_604R = 172;   public static final int UC_CPU_PPC_740_V1_0 = 173;   public static final int UC_CPU_PPC_750_V1_0 = 174;   public static final int UC_CPU_PPC_740_V2_0 = 175;   public static final int UC_CPU_PPC_750_V2_0 = 176;   public static final int UC_CPU_PPC_740_V2_1 = 177;   public static final int UC_CPU_PPC_750_V2_1 = 178;   public static final int UC_CPU_PPC_740_V2_2 = 179;   public static final int UC_CPU_PPC_750_V2_2 = 180;   public static final int UC_CPU_PPC_740_V3_0 = 181;   public static final int UC_CPU_PPC_750_V3_0 = 182;   public static final int UC_CPU_PPC_740_V3_1 = 183;   public static final int UC_CPU_PPC_750_V3_1 = 184;   public static final int UC_CPU_PPC_740E = 185;   public static final int UC_CPU_PPC_750E = 186;   public static final int UC_CPU_PPC_740P = 187;   public static final int UC_CPU_PPC_750P = 188;   public static final int UC_CPU_PPC_750CL_V1_0 = 189;   public static final int UC_CPU_PPC_750CL_V2_0 = 190;   public static final int UC_CPU_PPC_750CX_V1_0 = 191;   public static final int UC_CPU_PPC_750CX_V2_0 = 192;   public static final int UC_CPU_PPC_750CX_V2_1 = 193;   public static final int UC_CPU_PPC_750CX_V2_2 = 194;   public static final int UC_CPU_PPC_750CXE_V2_1 = 195;   public static final int UC_CPU_PPC_750CXE_V2_2 = 196;   public static final int UC_CPU_PPC_750CXE_V2_3 = 197;   public static final int UC_CPU_PPC_750CXE_V2_4 = 198;   public static final int UC_CPU_PPC_750CXE_V2_4B = 199;   public static final int UC_CPU_PPC_750CXE_V3_0 = 200;   public static final int UC_CPU_PPC_750CXE_V3_1 = 201;   public static final int UC_CPU_PPC_750CXE_V3_1B = 202;   public static final int UC_CPU_PPC_750CXR = 203;   public static final int UC_CPU_PPC_750FL = 204;   public static final int UC_CPU_PPC_750FX_V1_0 = 205;   public static final int UC_CPU_PPC_750FX_V2_0 = 206;   public static final int UC_CPU_PPC_750FX_V2_1 = 207;   public static final int UC_CPU_PPC_750FX_V2_2 = 208;   public static final int UC_CPU_PPC_750FX_V2_3 = 209;   public static final int UC_CPU_PPC_750GL = 210;   public static final int UC_CPU_PPC_750GX_V1_0 = 211;   public static final int UC_CPU_PPC_750GX_V1_1 = 212;   public static final int UC_CPU_PPC_750GX_V1_2 = 213;   public static final int UC_CPU_PPC_750L_V2_0 = 214;   public static final int UC_CPU_PPC_750L_V2_1 = 215;   public static final int UC_CPU_PPC_750L_V2_2 = 216;   public static final int UC_CPU_PPC_750L_V3_0 = 217;   public static final int UC_CPU_PPC_750L_V3_2 = 218;   public static final int UC_CPU_PPC_745_V1_0 = 219;   public static final int UC_CPU_PPC_755_V1_0 = 220;   public static final int UC_CPU_PPC_745_V1_1 = 221;   public static final int UC_CPU_PPC_755_V1_1 = 222;   public static final int UC_CPU_PPC_745_V2_0 = 223;   public static final int UC_CPU_PPC_755_V2_0 = 224;   public static final int UC_CPU_PPC_745_V2_1 = 225;   public static final int UC_CPU_PPC_755_V2_1 = 226;   public static final int UC_CPU_PPC_745_V2_2 = 227;   public static final int UC_CPU_PPC_755_V2_2 = 228;   public static final int UC_CPU_PPC_745_V2_3 = 229;   public static final int UC_CPU_PPC_755_V2_3 = 230;   public static final int UC_CPU_PPC_745_V2_4 = 231;   public static final int UC_CPU_PPC_755_V2_4 = 232;   public static final int UC_CPU_PPC_745_V2_5 = 233;   public static final int UC_CPU_PPC_755_V2_5 = 234;   public static final int UC_CPU_PPC_745_V2_6 = 235;   public static final int UC_CPU_PPC_755_V2_6 = 236;   public static final int UC_CPU_PPC_745_V2_7 = 237;   public static final int UC_CPU_PPC_755_V2_7 = 238;   public static final int UC_CPU_PPC_745_V2_8 = 239;   public static final int UC_CPU_PPC_755_V2_8 = 240;   public static final int UC_CPU_PPC_7400_V1_0 = 241;   public static final int UC_CPU_PPC_7400_V1_1 = 242;   public static final int UC_CPU_PPC_7400_V2_0 = 243;   public static final int UC_CPU_PPC_7400_V2_1 = 244;   public static final int UC_CPU_PPC_7400_V2_2 = 245;   public static final int UC_CPU_PPC_7400_V2_6 = 246;   public static final int UC_CPU_PPC_7400_V2_7 = 247;   public static final int UC_CPU_PPC_7400_V2_8 = 248;   public static final int UC_CPU_PPC_7400_V2_9 = 249;   public static final int UC_CPU_PPC_7410_V1_0 = 250;   public static final int UC_CPU_PPC_7410_V1_1 = 251;   public static final int UC_CPU_PPC_7410_V1_2 = 252;   public static final int UC_CPU_PPC_7410_V1_3 = 253;   public static final int UC_CPU_PPC_7410_V1_4 = 254;   public static final int UC_CPU_PPC_7448_V1_0 = 255;   public static final int UC_CPU_PPC_7448_V1_1 = 256;   public static final int UC_CPU_PPC_7448_V2_0 = 257;   public static final int UC_CPU_PPC_7448_V2_1 = 258;   public static final int UC_CPU_PPC_7450_V1_0 = 259;   public static final int UC_CPU_PPC_7450_V1_1 = 260;   public static final int UC_CPU_PPC_7450_V1_2 = 261;   public static final int UC_CPU_PPC_7450_V2_0 = 262;   public static final int UC_CPU_PPC_7450_V2_1 = 263;   public static final int UC_CPU_PPC_7441_V2_1 = 264;   public static final int UC_CPU_PPC_7441_V2_3 = 265;   public static final int UC_CPU_PPC_7451_V2_3 = 266;   public static final int UC_CPU_PPC_7441_V2_10 = 267;   public static final int UC_CPU_PPC_7451_V2_10 = 268;   public static final int UC_CPU_PPC_7445_V1_0 = 269;   public static final int UC_CPU_PPC_7455_V1_0 = 270;   public static final int UC_CPU_PPC_7445_V2_1 = 271;   public static final int UC_CPU_PPC_7455_V2_1 = 272;   public static final int UC_CPU_PPC_7445_V3_2 = 273;   public static final int UC_CPU_PPC_7455_V3_2 = 274;   public static final int UC_CPU_PPC_7445_V3_3 = 275;   public static final int UC_CPU_PPC_7455_V3_3 = 276;   public static final int UC_CPU_PPC_7445_V3_4 = 277;   public static final int UC_CPU_PPC_7455_V3_4 = 278;   public static final int UC_CPU_PPC_7447_V1_0 = 279;   public static final int UC_CPU_PPC_7457_V1_0 = 280;   public static final int UC_CPU_PPC_7447_V1_1 = 281;   public static final int UC_CPU_PPC_7457_V1_1 = 282;   public static final int UC_CPU_PPC_7457_V1_2 = 283;   public static final int UC_CPU_PPC_7447A_V1_0 = 284;   public static final int UC_CPU_PPC_7457A_V1_0 = 285;   public static final int UC_CPU_PPC_7447A_V1_1 = 286;   public static final int UC_CPU_PPC_7457A_V1_1 = 287;   public static final int UC_CPU_PPC_7447A_V1_2 = 288;   public static final int UC_CPU_PPC_7457A_V1_2 = 289;   public static final int UC_CPU_PPC_E5500 = 0;   public static final int UC_CPU_PPC_E6500 = 1;   public static final int UC_CPU_PPC_970_V2_2 = 2;   public static final int UC_CPU_PPC_970FX_V1_0 = 3;   public static final int UC_CPU_PPC_970FX_V2_0 = 4;   public static final int UC_CPU_PPC_970FX_V2_1 = 5;   public static final int UC_CPU_PPC_970FX_V3_0 = 6;   public static final int UC_CPU_PPC_970FX_V3_1 = 7;   public static final int UC_CPU_PPC_970MP_V1_0 = 8;   public static final int UC_CPU_PPC_970MP_V1_1 = 9;   public static final int UC_CPU_PPC_POWER5_V2_1 = 10;   public static final int UC_CPU_PPC_POWER7_V2_3 = 11;   public static final int UC_CPU_PPC_POWER7_V2_1 = 12;   public static final int UC_CPU_PPC_POWER8E_V2_1 = 13;   public static final int UC_CPU_PPC_POWER8_V2_0 = 14;   public static final int UC_CPU_PPC_POWER8NVL_V1_0 = 15;   public static final int UC_CPU_PPC_POWER9_V1_0 = 16;   public static final int UC_CPU_PPC_POWER9_V2_0 = 17;   public static final int UC_CPU_PPC_POWER10_V1_0 = 18;   public static final int UC_PPC_REG_INVALID = 0;   public static final int UC_PPC_REG_PC = 1;   public static final int UC_PPC_REG_0 = 2;   public static final int UC_PPC_REG_1 = 3;   public static final int UC_PPC_REG_2 = 4;   public static final int UC_PPC_REG_3 = 5;   public static final int UC_PPC_REG_4 = 6;   public static final int UC_PPC_REG_5 = 7;   public static final int UC_PPC_REG_6 = 8;   public static final int UC_PPC_REG_7 = 9;   public static final int UC_PPC_REG_8 = 10;   public static final int UC_PPC_REG_9 = 11;   public static final int UC_PPC_REG_10 = 12;   public static final int UC_PPC_REG_11 = 13;   public static final int UC_PPC_REG_12 = 14;   public static final int UC_PPC_REG_13 = 15;   public static final int UC_PPC_REG_14 = 16;   public static final int UC_PPC_REG_15 = 17;   public static final int UC_PPC_REG_16 = 18;   public static final int UC_PPC_REG_17 = 19;   public static final int UC_PPC_REG_18 = 20;   public static final int UC_PPC_REG_19 = 21;   public static final int UC_PPC_REG_20 = 22;   public static final int UC_PPC_REG_21 = 23;   public static final int UC_PPC_REG_22 = 24;   public static final int UC_PPC_REG_23 = 25;   public static final int UC_PPC_REG_24 = 26;   public static final int UC_PPC_REG_25 = 27;   public static final int UC_PPC_REG_26 = 28;   public static final int UC_PPC_REG_27 = 29;   public static final int UC_PPC_REG_28 = 30;   public static final int UC_PPC_REG_29 = 31;   public static final int UC_PPC_REG_30 = 32;   public static final int UC_PPC_REG_31 = 33;   public static final int UC_PPC_REG_CR0 = 34;   public static final int UC_PPC_REG_CR1 = 35;   public static final int UC_PPC_REG_CR2 = 36;   public static final int UC_PPC_REG_CR3 = 37;   public static final int UC_PPC_REG_CR4 = 38;   public static final int UC_PPC_REG_CR5 = 39;   public static final int UC_PPC_REG_CR6 = 40;   public static final int UC_PPC_REG_CR7 = 41;   public static final int UC_PPC_REG_FPR0 = 42;   public static final int UC_PPC_REG_FPR1 = 43;   public static final int UC_PPC_REG_FPR2 = 44;   public static final int UC_PPC_REG_FPR3 = 45;   public static final int UC_PPC_REG_FPR4 = 46;   public static final int UC_PPC_REG_FPR5 = 47;   public static final int UC_PPC_REG_FPR6 = 48;   public static final int UC_PPC_REG_FPR7 = 49;   public static final int UC_PPC_REG_FPR8 = 50;   public static final int UC_PPC_REG_FPR9 = 51;   public static final int UC_PPC_REG_FPR10 = 52;   public static final int UC_PPC_REG_FPR11 = 53;   public static final int UC_PPC_REG_FPR12 = 54;   public static final int UC_PPC_REG_FPR13 = 55;   public static final int UC_PPC_REG_FPR14 = 56;   public static final int UC_PPC_REG_FPR15 = 57;   public static final int UC_PPC_REG_FPR16 = 58;   public static final int UC_PPC_REG_FPR17 = 59;   public static final int UC_PPC_REG_FPR18 = 60;   public static final int UC_PPC_REG_FPR19 = 61;   public static final int UC_PPC_REG_FPR20 = 62;   public static final int UC_PPC_REG_FPR21 = 63;   public static final int UC_PPC_REG_FPR22 = 64;   public static final int UC_PPC_REG_FPR23 = 65;   public static final int UC_PPC_REG_FPR24 = 66;   public static final int UC_PPC_REG_FPR25 = 67;   public static final int UC_PPC_REG_FPR26 = 68;   public static final int UC_PPC_REG_FPR27 = 69;   public static final int UC_PPC_REG_FPR28 = 70;   public static final int UC_PPC_REG_FPR29 = 71;   public static final int UC_PPC_REG_FPR30 = 72;   public static final int UC_PPC_REG_FPR31 = 73;   public static final int UC_PPC_REG_LR = 74;   public static final int UC_PPC_REG_XER = 75;   public static final int UC_PPC_REG_CTR = 76;   public static final int UC_PPC_REG_MSR = 77;   public static final int UC_PPC_REG_FPSCR = 78;   public static final int UC_PPC_REG_CR = 79;   public static final int UC_PPC_REG_ENDING = 80;}"}
{"code": "public interface RiscvConst {   public static final int UC_CPU_RISCV32_ANY = 0;   public static final int UC_CPU_RISCV32_BASE32 = 1;   public static final int UC_CPU_RISCV32_SIFIVE_E31 = 2;   public static final int UC_CPU_RISCV32_SIFIVE_U34 = 3;   public static final int UC_CPU_RISCV32_ENDING = 4;   public static final int UC_CPU_RISCV64_ANY = 0;   public static final int UC_CPU_RISCV64_BASE64 = 1;   public static final int UC_CPU_RISCV64_SIFIVE_E51 = 2;   public static final int UC_CPU_RISCV64_SIFIVE_U54 = 3;   public static final int UC_CPU_RISCV64_ENDING = 4;   public static final int UC_RISCV_REG_INVALID = 0;   public static final int UC_RISCV_REG_X0 = 1;   public static final int UC_RISCV_REG_X1 = 2;   public static final int UC_RISCV_REG_X2 = 3;   public static final int UC_RISCV_REG_X3 = 4;   public static final int UC_RISCV_REG_X4 = 5;   public static final int UC_RISCV_REG_X5 = 6;   public static final int UC_RISCV_REG_X6 = 7;   public static final int UC_RISCV_REG_X7 = 8;   public static final int UC_RISCV_REG_X8 = 9;   public static final int UC_RISCV_REG_X9 = 10;   public static final int UC_RISCV_REG_X10 = 11;   public static final int UC_RISCV_REG_X11 = 12;   public static final int UC_RISCV_REG_X12 = 13;   public static final int UC_RISCV_REG_X13 = 14;   public static final int UC_RISCV_REG_X14 = 15;   public static final int UC_RISCV_REG_X15 = 16;   public static final int UC_RISCV_REG_X16 = 17;   public static final int UC_RISCV_REG_X17 = 18;   public static final int UC_RISCV_REG_X18 = 19;   public static final int UC_RISCV_REG_X19 = 20;   public static final int UC_RISCV_REG_X20 = 21;   public static final int UC_RISCV_REG_X21 = 22;   public static final int UC_RISCV_REG_X22 = 23;   public static final int UC_RISCV_REG_X23 = 24;   public static final int UC_RISCV_REG_X24 = 25;   public static final int UC_RISCV_REG_X25 = 26;   public static final int UC_RISCV_REG_X26 = 27;   public static final int UC_RISCV_REG_X27 = 28;   public static final int UC_RISCV_REG_X28 = 29;   public static final int UC_RISCV_REG_X29 = 30;   public static final int UC_RISCV_REG_X30 = 31;   public static final int UC_RISCV_REG_X31 = 32;   public static final int UC_RISCV_REG_USTATUS = 33;   public static final int UC_RISCV_REG_UIE = 34;   public static final int UC_RISCV_REG_UTVEC = 35;   public static final int UC_RISCV_REG_USCRATCH = 36;   public static final int UC_RISCV_REG_UEPC = 37;   public static final int UC_RISCV_REG_UCAUSE = 38;   public static final int UC_RISCV_REG_UTVAL = 39;   public static final int UC_RISCV_REG_UIP = 40;   public static final int UC_RISCV_REG_FFLAGS = 41;   public static final int UC_RISCV_REG_FRM = 42;   public static final int UC_RISCV_REG_FCSR = 43;   public static final int UC_RISCV_REG_CYCLE = 44;   public static final int UC_RISCV_REG_TIME = 45;   public static final int UC_RISCV_REG_INSTRET = 46;   public static final int UC_RISCV_REG_HPMCOUNTER3 = 47;   public static final int UC_RISCV_REG_HPMCOUNTER4 = 48;   public static final int UC_RISCV_REG_HPMCOUNTER5 = 49;   public static final int UC_RISCV_REG_HPMCOUNTER6 = 50;   public static final int UC_RISCV_REG_HPMCOUNTER7 = 51;   public static final int UC_RISCV_REG_HPMCOUNTER8 = 52;   public static final int UC_RISCV_REG_HPMCOUNTER9 = 53;   public static final int UC_RISCV_REG_HPMCOUNTER10 = 54;   public static final int UC_RISCV_REG_HPMCOUNTER11 = 55;   public static final int UC_RISCV_REG_HPMCOUNTER12 = 56;   public static final int UC_RISCV_REG_HPMCOUNTER13 = 57;   public static final int UC_RISCV_REG_HPMCOUNTER14 = 58;   public static final int UC_RISCV_REG_HPMCOUNTER15 = 59;   public static final int UC_RISCV_REG_HPMCOUNTER16 = 60;   public static final int UC_RISCV_REG_HPMCOUNTER17 = 61;   public static final int UC_RISCV_REG_HPMCOUNTER18 = 62;   public static final int UC_RISCV_REG_HPMCOUNTER19 = 63;   public static final int UC_RISCV_REG_HPMCOUNTER20 = 64;   public static final int UC_RISCV_REG_HPMCOUNTER21 = 65;   public static final int UC_RISCV_REG_HPMCOUNTER22 = 66;   public static final int UC_RISCV_REG_HPMCOUNTER23 = 67;   public static final int UC_RISCV_REG_HPMCOUNTER24 = 68;   public static final int UC_RISCV_REG_HPMCOUNTER25 = 69;   public static final int UC_RISCV_REG_HPMCOUNTER26 = 70;   public static final int UC_RISCV_REG_HPMCOUNTER27 = 71;   public static final int UC_RISCV_REG_HPMCOUNTER28 = 72;   public static final int UC_RISCV_REG_HPMCOUNTER29 = 73;   public static final int UC_RISCV_REG_HPMCOUNTER30 = 74;   public static final int UC_RISCV_REG_HPMCOUNTER31 = 75;   public static final int UC_RISCV_REG_CYCLEH = 76;   public static final int UC_RISCV_REG_TIMEH = 77;   public static final int UC_RISCV_REG_INSTRETH = 78;   public static final int UC_RISCV_REG_HPMCOUNTER3H = 79;   public static final int UC_RISCV_REG_HPMCOUNTER4H = 80;   public static final int UC_RISCV_REG_HPMCOUNTER5H = 81;   public static final int UC_RISCV_REG_HPMCOUNTER6H = 82;   public static final int UC_RISCV_REG_HPMCOUNTER7H = 83;   public static final int UC_RISCV_REG_HPMCOUNTER8H = 84;   public static final int UC_RISCV_REG_HPMCOUNTER9H = 85;   public static final int UC_RISCV_REG_HPMCOUNTER10H = 86;   public static final int UC_RISCV_REG_HPMCOUNTER11H = 87;   public static final int UC_RISCV_REG_HPMCOUNTER12H = 88;   public static final int UC_RISCV_REG_HPMCOUNTER13H = 89;   public static final int UC_RISCV_REG_HPMCOUNTER14H = 90;   public static final int UC_RISCV_REG_HPMCOUNTER15H = 91;   public static final int UC_RISCV_REG_HPMCOUNTER16H = 92;   public static final int UC_RISCV_REG_HPMCOUNTER17H = 93;   public static final int UC_RISCV_REG_HPMCOUNTER18H = 94;   public static final int UC_RISCV_REG_HPMCOUNTER19H = 95;   public static final int UC_RISCV_REG_HPMCOUNTER20H = 96;   public static final int UC_RISCV_REG_HPMCOUNTER21H = 97;   public static final int UC_RISCV_REG_HPMCOUNTER22H = 98;   public static final int UC_RISCV_REG_HPMCOUNTER23H = 99;   public static final int UC_RISCV_REG_HPMCOUNTER24H = 100;   public static final int UC_RISCV_REG_HPMCOUNTER25H = 101;   public static final int UC_RISCV_REG_HPMCOUNTER26H = 102;   public static final int UC_RISCV_REG_HPMCOUNTER27H = 103;   public static final int UC_RISCV_REG_HPMCOUNTER28H = 104;   public static final int UC_RISCV_REG_HPMCOUNTER29H = 105;   public static final int UC_RISCV_REG_HPMCOUNTER30H = 106;   public static final int UC_RISCV_REG_HPMCOUNTER31H = 107;   public static final int UC_RISCV_REG_MCYCLE = 108;   public static final int UC_RISCV_REG_MINSTRET = 109;   public static final int UC_RISCV_REG_MCYCLEH = 110;   public static final int UC_RISCV_REG_MINSTRETH = 111;   public static final int UC_RISCV_REG_MVENDORID = 112;   public static final int UC_RISCV_REG_MARCHID = 113;   public static final int UC_RISCV_REG_MIMPID = 114;   public static final int UC_RISCV_REG_MHARTID = 115;   public static final int UC_RISCV_REG_MSTATUS = 116;   public static final int UC_RISCV_REG_MISA = 117;   public static final int UC_RISCV_REG_MEDELEG = 118;   public static final int UC_RISCV_REG_MIDELEG = 119;   public static final int UC_RISCV_REG_MIE = 120;   public static final int UC_RISCV_REG_MTVEC = 121;   public static final int UC_RISCV_REG_MCOUNTEREN = 122;   public static final int UC_RISCV_REG_MSTATUSH = 123;   public static final int UC_RISCV_REG_MUCOUNTEREN = 124;   public static final int UC_RISCV_REG_MSCOUNTEREN = 125;   public static final int UC_RISCV_REG_MHCOUNTEREN = 126;   public static final int UC_RISCV_REG_MSCRATCH = 127;   public static final int UC_RISCV_REG_MEPC = 128;   public static final int UC_RISCV_REG_MCAUSE = 129;   public static final int UC_RISCV_REG_MTVAL = 130;   public static final int UC_RISCV_REG_MIP = 131;   public static final int UC_RISCV_REG_MBADADDR = 132;   public static final int UC_RISCV_REG_SSTATUS = 133;   public static final int UC_RISCV_REG_SEDELEG = 134;   public static final int UC_RISCV_REG_SIDELEG = 135;   public static final int UC_RISCV_REG_SIE = 136;   public static final int UC_RISCV_REG_STVEC = 137;   public static final int UC_RISCV_REG_SCOUNTEREN = 138;   public static final int UC_RISCV_REG_SSCRATCH = 139;   public static final int UC_RISCV_REG_SEPC = 140;   public static final int UC_RISCV_REG_SCAUSE = 141;   public static final int UC_RISCV_REG_STVAL = 142;   public static final int UC_RISCV_REG_SIP = 143;   public static final int UC_RISCV_REG_SBADADDR = 144;   public static final int UC_RISCV_REG_SPTBR = 145;   public static final int UC_RISCV_REG_SATP = 146;   public static final int UC_RISCV_REG_HSTATUS = 147;   public static final int UC_RISCV_REG_HEDELEG = 148;   public static final int UC_RISCV_REG_HIDELEG = 149;   public static final int UC_RISCV_REG_HIE = 150;   public static final int UC_RISCV_REG_HCOUNTEREN = 151;   public static final int UC_RISCV_REG_HTVAL = 152;   public static final int UC_RISCV_REG_HIP = 153;   public static final int UC_RISCV_REG_HTINST = 154;   public static final int UC_RISCV_REG_HGATP = 155;   public static final int UC_RISCV_REG_HTIMEDELTA = 156;   public static final int UC_RISCV_REG_HTIMEDELTAH = 157;   public static final int UC_RISCV_REG_F0 = 158;   public static final int UC_RISCV_REG_F1 = 159;   public static final int UC_RISCV_REG_F2 = 160;   public static final int UC_RISCV_REG_F3 = 161;   public static final int UC_RISCV_REG_F4 = 162;   public static final int UC_RISCV_REG_F5 = 163;   public static final int UC_RISCV_REG_F6 = 164;   public static final int UC_RISCV_REG_F7 = 165;   public static final int UC_RISCV_REG_F8 = 166;   public static final int UC_RISCV_REG_F9 = 167;   public static final int UC_RISCV_REG_F10 = 168;   public static final int UC_RISCV_REG_F11 = 169;   public static final int UC_RISCV_REG_F12 = 170;   public static final int UC_RISCV_REG_F13 = 171;   public static final int UC_RISCV_REG_F14 = 172;   public static final int UC_RISCV_REG_F15 = 173;   public static final int UC_RISCV_REG_F16 = 174;   public static final int UC_RISCV_REG_F17 = 175;   public static final int UC_RISCV_REG_F18 = 176;   public static final int UC_RISCV_REG_F19 = 177;   public static final int UC_RISCV_REG_F20 = 178;   public static final int UC_RISCV_REG_F21 = 179;   public static final int UC_RISCV_REG_F22 = 180;   public static final int UC_RISCV_REG_F23 = 181;   public static final int UC_RISCV_REG_F24 = 182;   public static final int UC_RISCV_REG_F25 = 183;   public static final int UC_RISCV_REG_F26 = 184;   public static final int UC_RISCV_REG_F27 = 185;   public static final int UC_RISCV_REG_F28 = 186;   public static final int UC_RISCV_REG_F29 = 187;   public static final int UC_RISCV_REG_F30 = 188;   public static final int UC_RISCV_REG_F31 = 189;   public static final int UC_RISCV_REG_PC = 190;   public static final int UC_RISCV_REG_ENDING = 191;   public static final int UC_RISCV_REG_ZERO = 1;   public static final int UC_RISCV_REG_RA = 2;   public static final int UC_RISCV_REG_SP = 3;   public static final int UC_RISCV_REG_GP = 4;   public static final int UC_RISCV_REG_TP = 5;   public static final int UC_RISCV_REG_T0 = 6;   public static final int UC_RISCV_REG_T1 = 7;   public static final int UC_RISCV_REG_T2 = 8;   public static final int UC_RISCV_REG_S0 = 9;   public static final int UC_RISCV_REG_FP = 9;   public static final int UC_RISCV_REG_S1 = 10;   public static final int UC_RISCV_REG_A0 = 11;   public static final int UC_RISCV_REG_A1 = 12;   public static final int UC_RISCV_REG_A2 = 13;   public static final int UC_RISCV_REG_A3 = 14;   public static final int UC_RISCV_REG_A4 = 15;   public static final int UC_RISCV_REG_A5 = 16;   public static final int UC_RISCV_REG_A6 = 17;   public static final int UC_RISCV_REG_A7 = 18;   public static final int UC_RISCV_REG_S2 = 19;   public static final int UC_RISCV_REG_S3 = 20;   public static final int UC_RISCV_REG_S4 = 21;   public static final int UC_RISCV_REG_S5 = 22;   public static final int UC_RISCV_REG_S6 = 23;   public static final int UC_RISCV_REG_S7 = 24;   public static final int UC_RISCV_REG_S8 = 25;   public static final int UC_RISCV_REG_S9 = 26;   public static final int UC_RISCV_REG_S10 = 27;   public static final int UC_RISCV_REG_S11 = 28;   public static final int UC_RISCV_REG_T3 = 29;   public static final int UC_RISCV_REG_T4 = 30;   public static final int UC_RISCV_REG_T5 = 31;   public static final int UC_RISCV_REG_T6 = 32;   public static final int UC_RISCV_REG_FT0 = 158;   public static final int UC_RISCV_REG_FT1 = 159;   public static final int UC_RISCV_REG_FT2 = 160;   public static final int UC_RISCV_REG_FT3 = 161;   public static final int UC_RISCV_REG_FT4 = 162;   public static final int UC_RISCV_REG_FT5 = 163;   public static final int UC_RISCV_REG_FT6 = 164;   public static final int UC_RISCV_REG_FT7 = 165;   public static final int UC_RISCV_REG_FS0 = 166;   public static final int UC_RISCV_REG_FS1 = 167;   public static final int UC_RISCV_REG_FA0 = 168;   public static final int UC_RISCV_REG_FA1 = 169;   public static final int UC_RISCV_REG_FA2 = 170;   public static final int UC_RISCV_REG_FA3 = 171;   public static final int UC_RISCV_REG_FA4 = 172;   public static final int UC_RISCV_REG_FA5 = 173;   public static final int UC_RISCV_REG_FA6 = 174;   public static final int UC_RISCV_REG_FA7 = 175;   public static final int UC_RISCV_REG_FS2 = 176;   public static final int UC_RISCV_REG_FS3 = 177;   public static final int UC_RISCV_REG_FS4 = 178;   public static final int UC_RISCV_REG_FS5 = 179;   public static final int UC_RISCV_REG_FS6 = 180;   public static final int UC_RISCV_REG_FS7 = 181;   public static final int UC_RISCV_REG_FS8 = 182;   public static final int UC_RISCV_REG_FS9 = 183;   public static final int UC_RISCV_REG_FS10 = 184;   public static final int UC_RISCV_REG_FS11 = 185;   public static final int UC_RISCV_REG_FT8 = 186;   public static final int UC_RISCV_REG_FT9 = 187;   public static final int UC_RISCV_REG_FT10 = 188;   public static final int UC_RISCV_REG_FT11 = 189;}", "nl": "public interface RiscvConst {   public static final int UC_CPU_RISCV32_ANY = 0;   public static final int UC_CPU_RISCV32_BASE32 = 1;   public static final int UC_CPU_RISCV32_SIFIVE_E31 = 2;   public static final int UC_CPU_RISCV32_SIFIVE_U34 = 3;   public static final int UC_CPU_RISCV64_ANY = 0;   public static final int UC_CPU_RISCV64_BASE64 = 1;   public static final int UC_CPU_RISCV64_SIFIVE_E51 = 2;   public static final int UC_CPU_RISCV64_SIFIVE_U54 = 3;   public static final int UC_RISCV_REG_INVALID = 0;   public static final int UC_RISCV_REG_X0 = 1;   public static final int UC_RISCV_REG_X1 = 2;   public static final int UC_RISCV_REG_X2 = 3;   public static final int UC_RISCV_REG_X3 = 4;   public static final int UC_RISCV_REG_X4 = 5;   public static final int UC_RISCV_REG_X5 = 6;   public static final int UC_RISCV_REG_X6 = 7;   public static final int UC_RISCV_REG_X7 = 8;   public static final int UC_RISCV_REG_X8 = 9;   public static final int UC_RISCV_REG_X9 = 10;   public static final int UC_RISCV_REG_X10 = 11;   public static final int UC_RISCV_REG_X11 = 12;   public static final int UC_RISCV_REG_X12 = 13;   public static final int UC_RISCV_REG_X13 = 14;   public static final int UC_RISCV_REG_X14 = 15;   public static final int UC_RISCV_REG_X15 = 16;   public static final int UC_RISCV_REG_X16 = 17;   public static final int UC_RISCV_REG_X17 = 18;   public static final int UC_RISCV_REG_X18 = 19;   public static final int UC_RISCV_REG_X19 = 20;   public static final int UC_RISCV_REG_X20 = 21;   public static final int UC_RISCV_REG_X21 = 22;   public static final int UC_RISCV_REG_X22 = 23;   public static final int UC_RISCV_REG_X23 = 24;   public static final int UC_RISCV_REG_X24 = 25;   public static final int UC_RISCV_REG_X25 = 26;   public static final int UC_RISCV_REG_X26 = 27;   public static final int UC_RISCV_REG_X27 = 28;   public static final int UC_RISCV_REG_X28 = 29;   public static final int UC_RISCV_REG_X29 = 30;   public static final int UC_RISCV_REG_X30 = 31;   public static final int UC_RISCV_REG_X31 = 32;   public static final int UC_RISCV_REG_USTATUS = 33;   public static final int UC_RISCV_REG_UIE = 34;   public static final int UC_RISCV_REG_UTVEC = 35;   public static final int UC_RISCV_REG_USCRATCH = 36;   public static final int UC_RISCV_REG_UEPC = 37;   public static final int UC_RISCV_REG_UCAUSE = 38;   public static final int UC_RISCV_REG_UTVAL = 39;   public static final int UC_RISCV_REG_UIP = 40;   public static final int UC_RISCV_REG_FFLAGS = 41;   public static final int UC_RISCV_REG_FRM = 42;   public static final int UC_RISCV_REG_FCSR = 43;   public static final int UC_RISCV_REG_CYCLE = 44;   public static final int UC_RISCV_REG_TIME = 45;   public static final int UC_RISCV_REG_INSTRET = 46;   public static final int UC_RISCV_REG_HPMCOUNTER3 = 47;   public static final int UC_RISCV_REG_HPMCOUNTER4 = 48;   public static final int UC_RISCV_REG_HPMCOUNTER5 = 49;   public static final int UC_RISCV_REG_HPMCOUNTER6 = 50;   public static final int UC_RISCV_REG_HPMCOUNTER7 = 51;   public static final int UC_RISCV_REG_HPMCOUNTER8 = 52;   public static final int UC_RISCV_REG_HPMCOUNTER9 = 53;   public static final int UC_RISCV_REG_HPMCOUNTER10 = 54;   public static final int UC_RISCV_REG_HPMCOUNTER11 = 55;   public static final int UC_RISCV_REG_HPMCOUNTER12 = 56;   public static final int UC_RISCV_REG_HPMCOUNTER13 = 57;   public static final int UC_RISCV_REG_HPMCOUNTER14 = 58;   public static final int UC_RISCV_REG_HPMCOUNTER15 = 59;   public static final int UC_RISCV_REG_HPMCOUNTER16 = 60;   public static final int UC_RISCV_REG_HPMCOUNTER17 = 61;   public static final int UC_RISCV_REG_HPMCOUNTER18 = 62;   public static final int UC_RISCV_REG_HPMCOUNTER19 = 63;   public static final int UC_RISCV_REG_HPMCOUNTER20 = 64;   public static final int UC_RISCV_REG_HPMCOUNTER21 = 65;   public static final int UC_RISCV_REG_HPMCOUNTER22 = 66;   public static final int UC_RISCV_REG_HPMCOUNTER23 = 67;   public static final int UC_RISCV_REG_HPMCOUNTER24 = 68;   public static final int UC_RISCV_REG_HPMCOUNTER25 = 69;   public static final int UC_RISCV_REG_HPMCOUNTER26 = 70;   public static final int UC_RISCV_REG_HPMCOUNTER27 = 71;   public static final int UC_RISCV_REG_HPMCOUNTER28 = 72;   public static final int UC_RISCV_REG_HPMCOUNTER29 = 73;   public static final int UC_RISCV_REG_HPMCOUNTER30 = 74;   public static final int UC_RISCV_REG_HPMCOUNTER31 = 75;   public static final int UC_RISCV_REG_CYCLEH = 76;   public static final int UC_RISCV_REG_TIMEH = 77;   public static final int UC_RISCV_REG_INSTRETH = 78;   public static final int UC_RISCV_REG_HPMCOUNTER3H = 79;   public static final int UC_RISCV_REG_HPMCOUNTER4H = 80;   public static final int UC_RISCV_REG_HPMCOUNTER5H = 81;   public static final int UC_RISCV_REG_HPMCOUNTER6H = 82;   public static final int UC_RISCV_REG_HPMCOUNTER7H = 83;   public static final int UC_RISCV_REG_HPMCOUNTER8H = 84;   public static final int UC_RISCV_REG_HPMCOUNTER9H = 85;   public static final int UC_RISCV_REG_HPMCOUNTER10H = 86;   public static final int UC_RISCV_REG_HPMCOUNTER11H = 87;   public static final int UC_RISCV_REG_HPMCOUNTER12H = 88;   public static final int UC_RISCV_REG_HPMCOUNTER13H = 89;   public static final int UC_RISCV_REG_HPMCOUNTER14H = 90;   public static final int UC_RISCV_REG_HPMCOUNTER15H = 91;   public static final int UC_RISCV_REG_HPMCOUNTER16H = 92;   public static final int UC_RISCV_REG_HPMCOUNTER17H = 93;   public static final int UC_RISCV_REG_HPMCOUNTER18H = 94;   public static final int UC_RISCV_REG_HPMCOUNTER19H = 95;   public static final int UC_RISCV_REG_HPMCOUNTER20H = 96;   public static final int UC_RISCV_REG_HPMCOUNTER21H = 97;   public static final int UC_RISCV_REG_HPMCOUNTER22H = 98;   public static final int UC_RISCV_REG_HPMCOUNTER23H = 99;   public static final int UC_RISCV_REG_HPMCOUNTER24H = 100;   public static final int UC_RISCV_REG_HPMCOUNTER25H = 101;   public static final int UC_RISCV_REG_HPMCOUNTER26H = 102;   public static final int UC_RISCV_REG_HPMCOUNTER27H = 103;   public static final int UC_RISCV_REG_HPMCOUNTER28H = 104;   public static final int UC_RISCV_REG_HPMCOUNTER29H = 105;   public static final int UC_RISCV_REG_HPMCOUNTER30H = 106;   public static final int UC_RISCV_REG_HPMCOUNTER31H = 107;   public static final int UC_RISCV_REG_MCYCLE = 108;   public static final int UC_RISCV_REG_MINSTRET = 109;   public static final int UC_RISCV_REG_MCYCLEH = 110;   public static final int UC_RISCV_REG_MINSTRETH = 111;   public static final int UC_RISCV_REG_MVENDORID = 112;   public static final int UC_RISCV_REG_MARCHID = 113;   public static final int UC_RISCV_REG_MIMPID = 114;   public static final int UC_RISCV_REG_MHARTID = 115;   public static final int UC_RISCV_REG_MSTATUS = 116;   public static final int UC_RISCV_REG_MISA = 117;   public static final int UC_RISCV_REG_MEDELEG = 118;   public static final int UC_RISCV_REG_MIDELEG = 119;   public static final int UC_RISCV_REG_MIE = 120;   public static final int UC_RISCV_REG_MTVEC = 121;   public static final int UC_RISCV_REG_MCOUNTEREN = 122;   public static final int UC_RISCV_REG_MSTATUSH = 123;   public static final int UC_RISCV_REG_MUCOUNTEREN = 124;   public static final int UC_RISCV_REG_MSCOUNTEREN = 125;   public static final int UC_RISCV_REG_MHCOUNTEREN = 126;   public static final int UC_RISCV_REG_MSCRATCH = 127;   public static final int UC_RISCV_REG_MEPC = 128;   public static final int UC_RISCV_REG_MCAUSE = 129;   public static final int UC_RISCV_REG_MTVAL = 130;   public static final int UC_RISCV_REG_MIP = 131;   public static final int UC_RISCV_REG_MBADADDR = 132;   public static final int UC_RISCV_REG_SSTATUS = 133;   public static final int UC_RISCV_REG_SEDELEG = 134;   public static final int UC_RISCV_REG_SIDELEG = 135;   public static final int UC_RISCV_REG_SIE = 136;   public static final int UC_RISCV_REG_STVEC = 137;   public static final int UC_RISCV_REG_SCOUNTEREN = 138;   public static final int UC_RISCV_REG_SSCRATCH = 139;   public static final int UC_RISCV_REG_SEPC = 140;   public static final int UC_RISCV_REG_SCAUSE = 141;   public static final int UC_RISCV_REG_STVAL = 142;   public static final int UC_RISCV_REG_SIP = 143;   public static final int UC_RISCV_REG_SBADADDR = 144;   public static final int UC_RISCV_REG_SPTBR = 145;   public static final int UC_RISCV_REG_SATP = 146;   public static final int UC_RISCV_REG_HSTATUS = 147;   public static final int UC_RISCV_REG_HEDELEG = 148;   public static final int UC_RISCV_REG_HIDELEG = 149;   public static final int UC_RISCV_REG_HIE = 150;   public static final int UC_RISCV_REG_HCOUNTEREN = 151;   public static final int UC_RISCV_REG_HTVAL = 152;   public static final int UC_RISCV_REG_HIP = 153;   public static final int UC_RISCV_REG_HTINST = 154;   public static final int UC_RISCV_REG_HGATP = 155;   public static final int UC_RISCV_REG_HTIMEDELTA = 156;   public static final int UC_RISCV_REG_HTIMEDELTAH = 157;   public static final int UC_RISCV_REG_F0 = 158;   public static final int UC_RISCV_REG_F1 = 159;   public static final int UC_RISCV_REG_F2 = 160;   public static final int UC_RISCV_REG_F3 = 161;   public static final int UC_RISCV_REG_F4 = 162;   public static final int UC_RISCV_REG_F5 = 163;   public static final int UC_RISCV_REG_F6 = 164;   public static final int UC_RISCV_REG_F7 = 165;   public static final int UC_RISCV_REG_F8 = 166;   public static final int UC_RISCV_REG_F9 = 167;   public static final int UC_RISCV_REG_F10 = 168;   public static final int UC_RISCV_REG_F11 = 169;   public static final int UC_RISCV_REG_F12 = 170;   public static final int UC_RISCV_REG_F13 = 171;   public static final int UC_RISCV_REG_F14 = 172;   public static final int UC_RISCV_REG_F15 = 173;   public static final int UC_RISCV_REG_F16 = 174;   public static final int UC_RISCV_REG_F17 = 175;   public static final int UC_RISCV_REG_F18 = 176;   public static final int UC_RISCV_REG_F19 = 177;   public static final int UC_RISCV_REG_F20 = 178;   public static final int UC_RISCV_REG_F21 = 179;   public static final int UC_RISCV_REG_F22 = 180;   public static final int UC_RISCV_REG_F23 = 181;   public static final int UC_RISCV_REG_F24 = 182;   public static final int UC_RISCV_REG_F25 = 183;   public static final int UC_RISCV_REG_F26 = 184;   public static final int UC_RISCV_REG_F27 = 185;   public static final int UC_RISCV_REG_F28 = 186;   public static final int UC_RISCV_REG_F29 = 187;   public static final int UC_RISCV_REG_F30 = 188;   public static final int UC_RISCV_REG_F31 = 189;   public static final int UC_RISCV_REG_PC = 190;   public static final int UC_RISCV_REG_ENDING = 191;   public static final int UC_RISCV_REG_ZERO = 1;   public static final int UC_RISCV_REG_RA = 2;   public static final int UC_RISCV_REG_SP = 3;   public static final int UC_RISCV_REG_GP = 4;   public static final int UC_RISCV_REG_TP = 5;   public static final int UC_RISCV_REG_T0 = 6;   public static final int UC_RISCV_REG_T1 = 7;   public static final int UC_RISCV_REG_T2 = 8;   public static final int UC_RISCV_REG_S0 = 9;   public static final int UC_RISCV_REG_FP = 9;   public static final int UC_RISCV_REG_S1 = 10;   public static final int UC_RISCV_REG_A0 = 11;   public static final int UC_RISCV_REG_A1 = 12;   public static final int UC_RISCV_REG_A2 = 13;   public static final int UC_RISCV_REG_A3 = 14;   public static final int UC_RISCV_REG_A4 = 15;   public static final int UC_RISCV_REG_A5 = 16;   public static final int UC_RISCV_REG_A6 = 17;   public static final int UC_RISCV_REG_A7 = 18;   public static final int UC_RISCV_REG_S2 = 19;   public static final int UC_RISCV_REG_S3 = 20;   public static final int UC_RISCV_REG_S4 = 21;   public static final int UC_RISCV_REG_S5 = 22;   public static final int UC_RISCV_REG_S6 = 23;   public static final int UC_RISCV_REG_S7 = 24;   public static final int UC_RISCV_REG_S8 = 25;   public static final int UC_RISCV_REG_S9 = 26;   public static final int UC_RISCV_REG_S10 = 27;   public static final int UC_RISCV_REG_S11 = 28;   public static final int UC_RISCV_REG_T3 = 29;   public static final int UC_RISCV_REG_T4 = 30;   public static final int UC_RISCV_REG_T5 = 31;   public static final int UC_RISCV_REG_T6 = 32;   public static final int UC_RISCV_REG_FT0 = 158;   public static final int UC_RISCV_REG_FT1 = 159;   public static final int UC_RISCV_REG_FT2 = 160;   public static final int UC_RISCV_REG_FT3 = 161;   public static final int UC_RISCV_REG_FT4 = 162;   public static final int UC_RISCV_REG_FT5 = 163;   public static final int UC_RISCV_REG_FT6 = 164;   public static final int UC_RISCV_REG_FT7 = 165;   public static final int UC_RISCV_REG_FS0 = 166;   public static final int UC_RISCV_REG_FS1 = 167;   public static final int UC_RISCV_REG_FA0 = 168;   public static final int UC_RISCV_REG_FA1 = 169;   public static final int UC_RISCV_REG_FA2 = 170;   public static final int UC_RISCV_REG_FA3 = 171;   public static final int UC_RISCV_REG_FA4 = 172;   public static final int UC_RISCV_REG_FA5 = 173;   public static final int UC_RISCV_REG_FA6 = 174;   public static final int UC_RISCV_REG_FA7 = 175;   public static final int UC_RISCV_REG_FS2 = 176;   public static final int UC_RISCV_REG_FS3 = 177;   public static final int UC_RISCV_REG_FS4 = 178;   public static final int UC_RISCV_REG_FS5 = 179;   public static final int UC_RISCV_REG_FS6 = 180;   public static final int UC_RISCV_REG_FS7 = 181;   public static final int UC_RISCV_REG_FS8 = 182;   public static final int UC_RISCV_REG_FS9 = 183;   public static final int UC_RISCV_REG_FS10 = 184;   public static final int UC_RISCV_REG_FS11 = 185;   public static final int UC_RISCV_REG_FT8 = 186;   public static final int UC_RISCV_REG_FT9 = 187;   public static final int UC_RISCV_REG_FT10 = 188;   public static final int UC_RISCV_REG_FT11 = 189;}"}
{"code": "public interface S390xConst {   public static final int UC_CPU_S390X_Z900 = 0;   public static final int UC_CPU_S390X_Z900_2 = 1;   public static final int UC_CPU_S390X_Z900_3 = 2;   public static final int UC_CPU_S390X_Z800 = 3;   public static final int UC_CPU_S390X_Z990 = 4;   public static final int UC_CPU_S390X_Z990_2 = 5;   public static final int UC_CPU_S390X_Z990_3 = 6;   public static final int UC_CPU_S390X_Z890 = 7;   public static final int UC_CPU_S390X_Z990_4 = 8;   public static final int UC_CPU_S390X_Z890_2 = 9;   public static final int UC_CPU_S390X_Z990_5 = 10;   public static final int UC_CPU_S390X_Z890_3 = 11;   public static final int UC_CPU_S390X_Z9EC = 12;   public static final int UC_CPU_S390X_Z9EC_2 = 13;   public static final int UC_CPU_S390X_Z9BC = 14;   public static final int UC_CPU_S390X_Z9EC_3 = 15;   public static final int UC_CPU_S390X_Z9BC_2 = 16;   public static final int UC_CPU_S390X_Z10EC = 17;   public static final int UC_CPU_S390X_Z10EC_2 = 18;   public static final int UC_CPU_S390X_Z10BC = 19;   public static final int UC_CPU_S390X_Z10EC_3 = 20;   public static final int UC_CPU_S390X_Z10BC_2 = 21;   public static final int UC_CPU_S390X_Z196 = 22;   public static final int UC_CPU_S390X_Z196_2 = 23;   public static final int UC_CPU_S390X_Z114 = 24;   public static final int UC_CPU_S390X_ZEC12 = 25;   public static final int UC_CPU_S390X_ZEC12_2 = 26;   public static final int UC_CPU_S390X_ZBC12 = 27;   public static final int UC_CPU_S390X_Z13 = 28;   public static final int UC_CPU_S390X_Z13_2 = 29;   public static final int UC_CPU_S390X_Z13S = 30;   public static final int UC_CPU_S390X_Z14 = 31;   public static final int UC_CPU_S390X_Z14_2 = 32;   public static final int UC_CPU_S390X_Z14ZR1 = 33;   public static final int UC_CPU_S390X_GEN15A = 34;   public static final int UC_CPU_S390X_GEN15B = 35;   public static final int UC_CPU_S390X_QEMU = 36;   public static final int UC_CPU_S390X_MAX = 37;   public static final int UC_CPU_S390X_ENDING = 38;   public static final int UC_S390X_REG_INVALID = 0;   public static final int UC_S390X_REG_R0 = 1;   public static final int UC_S390X_REG_R1 = 2;   public static final int UC_S390X_REG_R2 = 3;   public static final int UC_S390X_REG_R3 = 4;   public static final int UC_S390X_REG_R4 = 5;   public static final int UC_S390X_REG_R5 = 6;   public static final int UC_S390X_REG_R6 = 7;   public static final int UC_S390X_REG_R7 = 8;   public static final int UC_S390X_REG_R8 = 9;   public static final int UC_S390X_REG_R9 = 10;   public static final int UC_S390X_REG_R10 = 11;   public static final int UC_S390X_REG_R11 = 12;   public static final int UC_S390X_REG_R12 = 13;   public static final int UC_S390X_REG_R13 = 14;   public static final int UC_S390X_REG_R14 = 15;   public static final int UC_S390X_REG_R15 = 16;   public static final int UC_S390X_REG_F0 = 17;   public static final int UC_S390X_REG_F1 = 18;   public static final int UC_S390X_REG_F2 = 19;   public static final int UC_S390X_REG_F3 = 20;   public static final int UC_S390X_REG_F4 = 21;   public static final int UC_S390X_REG_F5 = 22;   public static final int UC_S390X_REG_F6 = 23;   public static final int UC_S390X_REG_F7 = 24;   public static final int UC_S390X_REG_F8 = 25;   public static final int UC_S390X_REG_F9 = 26;   public static final int UC_S390X_REG_F10 = 27;   public static final int UC_S390X_REG_F11 = 28;   public static final int UC_S390X_REG_F12 = 29;   public static final int UC_S390X_REG_F13 = 30;   public static final int UC_S390X_REG_F14 = 31;   public static final int UC_S390X_REG_F15 = 32;   public static final int UC_S390X_REG_F16 = 33;   public static final int UC_S390X_REG_F17 = 34;   public static final int UC_S390X_REG_F18 = 35;   public static final int UC_S390X_REG_F19 = 36;   public static final int UC_S390X_REG_F20 = 37;   public static final int UC_S390X_REG_F21 = 38;   public static final int UC_S390X_REG_F22 = 39;   public static final int UC_S390X_REG_F23 = 40;   public static final int UC_S390X_REG_F24 = 41;   public static final int UC_S390X_REG_F25 = 42;   public static final int UC_S390X_REG_F26 = 43;   public static final int UC_S390X_REG_F27 = 44;   public static final int UC_S390X_REG_F28 = 45;   public static final int UC_S390X_REG_F29 = 46;   public static final int UC_S390X_REG_F30 = 47;   public static final int UC_S390X_REG_F31 = 48;   public static final int UC_S390X_REG_A0 = 49;   public static final int UC_S390X_REG_A1 = 50;   public static final int UC_S390X_REG_A2 = 51;   public static final int UC_S390X_REG_A3 = 52;   public static final int UC_S390X_REG_A4 = 53;   public static final int UC_S390X_REG_A5 = 54;   public static final int UC_S390X_REG_A6 = 55;   public static final int UC_S390X_REG_A7 = 56;   public static final int UC_S390X_REG_A8 = 57;   public static final int UC_S390X_REG_A9 = 58;   public static final int UC_S390X_REG_A10 = 59;   public static final int UC_S390X_REG_A11 = 60;   public static final int UC_S390X_REG_A12 = 61;   public static final int UC_S390X_REG_A13 = 62;   public static final int UC_S390X_REG_A14 = 63;   public static final int UC_S390X_REG_A15 = 64;   public static final int UC_S390X_REG_PC = 65;   public static final int UC_S390X_REG_PSWM = 66;   public static final int UC_S390X_REG_ENDING = 67;}", "nl": "public interface S390xConst {   public static final int UC_CPU_S390X_Z900 = 0;   public static final int UC_CPU_S390X_Z900_2 = 1;   public static final int UC_CPU_S390X_Z900_3 = 2;   public static final int UC_CPU_S390X_Z800 = 3;   public static final int UC_CPU_S390X_Z990 = 4;   public static final int UC_CPU_S390X_Z990_2 = 5;   public static final int UC_CPU_S390X_Z990_3 = 6;   public static final int UC_CPU_S390X_Z890 = 7;   public static final int UC_CPU_S390X_Z990_4 = 8;   public static final int UC_CPU_S390X_Z890_2 = 9;   public static final int UC_CPU_S390X_Z990_5 = 10;   public static final int UC_CPU_S390X_Z890_3 = 11;   public static final int UC_CPU_S390X_Z9EC = 12;   public static final int UC_CPU_S390X_Z9EC_2 = 13;   public static final int UC_CPU_S390X_Z9BC = 14;   public static final int UC_CPU_S390X_Z9EC_3 = 15;   public static final int UC_CPU_S390X_Z9BC_2 = 16;   public static final int UC_CPU_S390X_Z10EC = 17;   public static final int UC_CPU_S390X_Z10EC_2 = 18;   public static final int UC_CPU_S390X_Z10BC = 19;   public static final int UC_CPU_S390X_Z10EC_3 = 20;   public static final int UC_CPU_S390X_Z10BC_2 = 21;   public static final int UC_CPU_S390X_Z196 = 22;   public static final int UC_CPU_S390X_Z196_2 = 23;   public static final int UC_CPU_S390X_Z114 = 24;   public static final int UC_CPU_S390X_ZEC12 = 25;   public static final int UC_CPU_S390X_ZEC12_2 = 26;   public static final int UC_CPU_S390X_ZBC12 = 27;   public static final int UC_CPU_S390X_Z13 = 28;   public static final int UC_CPU_S390X_Z13_2 = 29;   public static final int UC_CPU_S390X_Z13S = 30;   public static final int UC_CPU_S390X_Z14 = 31;   public static final int UC_CPU_S390X_Z14_2 = 32;   public static final int UC_CPU_S390X_Z14ZR1 = 33;   public static final int UC_CPU_S390X_GEN15A = 34;   public static final int UC_CPU_S390X_GEN15B = 35;   public static final int UC_CPU_S390X_QEMU = 36;   public static final int UC_CPU_S390X_MAX = 37;   public static final int UC_S390X_REG_INVALID = 0;   public static final int UC_S390X_REG_R0 = 1;   public static final int UC_S390X_REG_R1 = 2;   public static final int UC_S390X_REG_R2 = 3;   public static final int UC_S390X_REG_R3 = 4;   public static final int UC_S390X_REG_R4 = 5;   public static final int UC_S390X_REG_R5 = 6;   public static final int UC_S390X_REG_R6 = 7;   public static final int UC_S390X_REG_R7 = 8;   public static final int UC_S390X_REG_R8 = 9;   public static final int UC_S390X_REG_R9 = 10;   public static final int UC_S390X_REG_R10 = 11;   public static final int UC_S390X_REG_R11 = 12;   public static final int UC_S390X_REG_R12 = 13;   public static final int UC_S390X_REG_R13 = 14;   public static final int UC_S390X_REG_R14 = 15;   public static final int UC_S390X_REG_R15 = 16;   public static final int UC_S390X_REG_F0 = 17;   public static final int UC_S390X_REG_F1 = 18;   public static final int UC_S390X_REG_F2 = 19;   public static final int UC_S390X_REG_F3 = 20;   public static final int UC_S390X_REG_F4 = 21;   public static final int UC_S390X_REG_F5 = 22;   public static final int UC_S390X_REG_F6 = 23;   public static final int UC_S390X_REG_F7 = 24;   public static final int UC_S390X_REG_F8 = 25;   public static final int UC_S390X_REG_F9 = 26;   public static final int UC_S390X_REG_F10 = 27;   public static final int UC_S390X_REG_F11 = 28;   public static final int UC_S390X_REG_F12 = 29;   public static final int UC_S390X_REG_F13 = 30;   public static final int UC_S390X_REG_F14 = 31;   public static final int UC_S390X_REG_F15 = 32;   public static final int UC_S390X_REG_F16 = 33;   public static final int UC_S390X_REG_F17 = 34;   public static final int UC_S390X_REG_F18 = 35;   public static final int UC_S390X_REG_F19 = 36;   public static final int UC_S390X_REG_F20 = 37;   public static final int UC_S390X_REG_F21 = 38;   public static final int UC_S390X_REG_F22 = 39;   public static final int UC_S390X_REG_F23 = 40;   public static final int UC_S390X_REG_F24 = 41;   public static final int UC_S390X_REG_F25 = 42;   public static final int UC_S390X_REG_F26 = 43;   public static final int UC_S390X_REG_F27 = 44;   public static final int UC_S390X_REG_F28 = 45;   public static final int UC_S390X_REG_F29 = 46;   public static final int UC_S390X_REG_F30 = 47;   public static final int UC_S390X_REG_F31 = 48;   public static final int UC_S390X_REG_A0 = 49;   public static final int UC_S390X_REG_A1 = 50;   public static final int UC_S390X_REG_A2 = 51;   public static final int UC_S390X_REG_A3 = 52;   public static final int UC_S390X_REG_A4 = 53;   public static final int UC_S390X_REG_A5 = 54;   public static final int UC_S390X_REG_A6 = 55;   public static final int UC_S390X_REG_A7 = 56;   public static final int UC_S390X_REG_A8 = 57;   public static final int UC_S390X_REG_A9 = 58;   public static final int UC_S390X_REG_A10 = 59;   public static final int UC_S390X_REG_A11 = 60;   public static final int UC_S390X_REG_A12 = 61;   public static final int UC_S390X_REG_A13 = 62;   public static final int UC_S390X_REG_A14 = 63;   public static final int UC_S390X_REG_A15 = 64;   public static final int UC_S390X_REG_PC = 65;   public static final int UC_S390X_REG_PSWM = 66;   public static final int UC_S390X_REG_ENDING = 67;}"}
{"code": "public interface SparcConst {   public static final int UC_CPU_SPARC32_FUJITSU_MB86904 = 0;   public static final int UC_CPU_SPARC32_FUJITSU_MB86907 = 1;   public static final int UC_CPU_SPARC32_TI_MICROSPARC_I = 2;   public static final int UC_CPU_SPARC32_TI_MICROSPARC_II = 3;   public static final int UC_CPU_SPARC32_TI_MICROSPARC_IIEP = 4;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_40 = 5;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_50 = 6;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_51 = 7;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_60 = 8;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_61 = 9;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_II = 10;   public static final int UC_CPU_SPARC32_LEON2 = 11;   public static final int UC_CPU_SPARC32_LEON3 = 12;   public static final int UC_CPU_SPARC32_ENDING = 13;   public static final int UC_CPU_SPARC64_FUJITSU = 0;   public static final int UC_CPU_SPARC64_FUJITSU_III = 1;   public static final int UC_CPU_SPARC64_FUJITSU_IV = 2;   public static final int UC_CPU_SPARC64_FUJITSU_V = 3;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_I = 4;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_II = 5;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_III = 6;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_IIE = 7;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_III = 8;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_III_CU = 9;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IIII = 10;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IV = 11;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IV_PLUS = 12;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IIII_PLUS = 13;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_T1 = 14;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_T2 = 15;   public static final int UC_CPU_SPARC64_NEC_ULTRASPARC_I = 16;   public static final int UC_CPU_SPARC64_ENDING = 17;   public static final int UC_SPARC_REG_INVALID = 0;   public static final int UC_SPARC_REG_F0 = 1;   public static final int UC_SPARC_REG_F1 = 2;   public static final int UC_SPARC_REG_F2 = 3;   public static final int UC_SPARC_REG_F3 = 4;   public static final int UC_SPARC_REG_F4 = 5;   public static final int UC_SPARC_REG_F5 = 6;   public static final int UC_SPARC_REG_F6 = 7;   public static final int UC_SPARC_REG_F7 = 8;   public static final int UC_SPARC_REG_F8 = 9;   public static final int UC_SPARC_REG_F9 = 10;   public static final int UC_SPARC_REG_F10 = 11;   public static final int UC_SPARC_REG_F11 = 12;   public static final int UC_SPARC_REG_F12 = 13;   public static final int UC_SPARC_REG_F13 = 14;   public static final int UC_SPARC_REG_F14 = 15;   public static final int UC_SPARC_REG_F15 = 16;   public static final int UC_SPARC_REG_F16 = 17;   public static final int UC_SPARC_REG_F17 = 18;   public static final int UC_SPARC_REG_F18 = 19;   public static final int UC_SPARC_REG_F19 = 20;   public static final int UC_SPARC_REG_F20 = 21;   public static final int UC_SPARC_REG_F21 = 22;   public static final int UC_SPARC_REG_F22 = 23;   public static final int UC_SPARC_REG_F23 = 24;   public static final int UC_SPARC_REG_F24 = 25;   public static final int UC_SPARC_REG_F25 = 26;   public static final int UC_SPARC_REG_F26 = 27;   public static final int UC_SPARC_REG_F27 = 28;   public static final int UC_SPARC_REG_F28 = 29;   public static final int UC_SPARC_REG_F29 = 30;   public static final int UC_SPARC_REG_F30 = 31;   public static final int UC_SPARC_REG_F31 = 32;   public static final int UC_SPARC_REG_F32 = 33;   public static final int UC_SPARC_REG_F34 = 34;   public static final int UC_SPARC_REG_F36 = 35;   public static final int UC_SPARC_REG_F38 = 36;   public static final int UC_SPARC_REG_F40 = 37;   public static final int UC_SPARC_REG_F42 = 38;   public static final int UC_SPARC_REG_F44 = 39;   public static final int UC_SPARC_REG_F46 = 40;   public static final int UC_SPARC_REG_F48 = 41;   public static final int UC_SPARC_REG_F50 = 42;   public static final int UC_SPARC_REG_F52 = 43;   public static final int UC_SPARC_REG_F54 = 44;   public static final int UC_SPARC_REG_F56 = 45;   public static final int UC_SPARC_REG_F58 = 46;   public static final int UC_SPARC_REG_F60 = 47;   public static final int UC_SPARC_REG_F62 = 48;   public static final int UC_SPARC_REG_FCC0 = 49;   public static final int UC_SPARC_REG_FCC1 = 50;   public static final int UC_SPARC_REG_FCC2 = 51;   public static final int UC_SPARC_REG_FCC3 = 52;   public static final int UC_SPARC_REG_G0 = 53;   public static final int UC_SPARC_REG_G1 = 54;   public static final int UC_SPARC_REG_G2 = 55;   public static final int UC_SPARC_REG_G3 = 56;   public static final int UC_SPARC_REG_G4 = 57;   public static final int UC_SPARC_REG_G5 = 58;   public static final int UC_SPARC_REG_G6 = 59;   public static final int UC_SPARC_REG_G7 = 60;   public static final int UC_SPARC_REG_I0 = 61;   public static final int UC_SPARC_REG_I1 = 62;   public static final int UC_SPARC_REG_I2 = 63;   public static final int UC_SPARC_REG_I3 = 64;   public static final int UC_SPARC_REG_I4 = 65;   public static final int UC_SPARC_REG_I5 = 66;   public static final int UC_SPARC_REG_FP = 67;   public static final int UC_SPARC_REG_I7 = 68;   public static final int UC_SPARC_REG_ICC = 69;   public static final int UC_SPARC_REG_L0 = 70;   public static final int UC_SPARC_REG_L1 = 71;   public static final int UC_SPARC_REG_L2 = 72;   public static final int UC_SPARC_REG_L3 = 73;   public static final int UC_SPARC_REG_L4 = 74;   public static final int UC_SPARC_REG_L5 = 75;   public static final int UC_SPARC_REG_L6 = 76;   public static final int UC_SPARC_REG_L7 = 77;   public static final int UC_SPARC_REG_O0 = 78;   public static final int UC_SPARC_REG_O1 = 79;   public static final int UC_SPARC_REG_O2 = 80;   public static final int UC_SPARC_REG_O3 = 81;   public static final int UC_SPARC_REG_O4 = 82;   public static final int UC_SPARC_REG_O5 = 83;   public static final int UC_SPARC_REG_SP = 84;   public static final int UC_SPARC_REG_O7 = 85;   public static final int UC_SPARC_REG_Y = 86;   public static final int UC_SPARC_REG_XCC = 87;   public static final int UC_SPARC_REG_PC = 88;   public static final int UC_SPARC_REG_ENDING = 89;   public static final int UC_SPARC_REG_O6 = 84;   public static final int UC_SPARC_REG_I6 = 67;}", "nl": "public interface SparcConst {   public static final int UC_CPU_SPARC32_FUJITSU_MB86904 = 0;   public static final int UC_CPU_SPARC32_FUJITSU_MB86907 = 1;   public static final int UC_CPU_SPARC32_TI_MICROSPARC_I = 2;   public static final int UC_CPU_SPARC32_TI_MICROSPARC_II = 3;   public static final int UC_CPU_SPARC32_TI_MICROSPARC_IIEP = 4;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_40 = 5;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_50 = 6;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_51 = 7;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_60 = 8;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_61 = 9;   public static final int UC_CPU_SPARC32_TI_SUPERSPARC_II = 10;   public static final int UC_CPU_SPARC32_LEON2 = 11;   public static final int UC_CPU_SPARC32_LEON3 = 12;   public static final int UC_CPU_SPARC64_FUJITSU = 0;   public static final int UC_CPU_SPARC64_FUJITSU_III = 1;   public static final int UC_CPU_SPARC64_FUJITSU_IV = 2;   public static final int UC_CPU_SPARC64_FUJITSU_V = 3;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_I = 4;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_II = 5;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_III = 6;   public static final int UC_CPU_SPARC64_TI_ULTRASPARC_IIE = 7;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_III = 8;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_III_CU = 9;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IIII = 10;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IV = 11;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IV_PLUS = 12;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_IIII_PLUS = 13;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_T1 = 14;   public static final int UC_CPU_SPARC64_SUN_ULTRASPARC_T2 = 15;   public static final int UC_CPU_SPARC64_NEC_ULTRASPARC_I = 16;   public static final int UC_SPARC_REG_INVALID = 0;   public static final int UC_SPARC_REG_F0 = 1;   public static final int UC_SPARC_REG_F1 = 2;   public static final int UC_SPARC_REG_F2 = 3;   public static final int UC_SPARC_REG_F3 = 4;   public static final int UC_SPARC_REG_F4 = 5;   public static final int UC_SPARC_REG_F5 = 6;   public static final int UC_SPARC_REG_F6 = 7;   public static final int UC_SPARC_REG_F7 = 8;   public static final int UC_SPARC_REG_F8 = 9;   public static final int UC_SPARC_REG_F9 = 10;   public static final int UC_SPARC_REG_F10 = 11;   public static final int UC_SPARC_REG_F11 = 12;   public static final int UC_SPARC_REG_F12 = 13;   public static final int UC_SPARC_REG_F13 = 14;   public static final int UC_SPARC_REG_F14 = 15;   public static final int UC_SPARC_REG_F15 = 16;   public static final int UC_SPARC_REG_F16 = 17;   public static final int UC_SPARC_REG_F17 = 18;   public static final int UC_SPARC_REG_F18 = 19;   public static final int UC_SPARC_REG_F19 = 20;   public static final int UC_SPARC_REG_F20 = 21;   public static final int UC_SPARC_REG_F21 = 22;   public static final int UC_SPARC_REG_F22 = 23;   public static final int UC_SPARC_REG_F23 = 24;   public static final int UC_SPARC_REG_F24 = 25;   public static final int UC_SPARC_REG_F25 = 26;   public static final int UC_SPARC_REG_F26 = 27;   public static final int UC_SPARC_REG_F27 = 28;   public static final int UC_SPARC_REG_F28 = 29;   public static final int UC_SPARC_REG_F29 = 30;   public static final int UC_SPARC_REG_F30 = 31;   public static final int UC_SPARC_REG_F31 = 32;   public static final int UC_SPARC_REG_F32 = 33;   public static final int UC_SPARC_REG_F34 = 34;   public static final int UC_SPARC_REG_F36 = 35;   public static final int UC_SPARC_REG_F38 = 36;   public static final int UC_SPARC_REG_F40 = 37;   public static final int UC_SPARC_REG_F42 = 38;   public static final int UC_SPARC_REG_F44 = 39;   public static final int UC_SPARC_REG_F46 = 40;   public static final int UC_SPARC_REG_F48 = 41;   public static final int UC_SPARC_REG_F50 = 42;   public static final int UC_SPARC_REG_F52 = 43;   public static final int UC_SPARC_REG_F54 = 44;   public static final int UC_SPARC_REG_F56 = 45;   public static final int UC_SPARC_REG_F58 = 46;   public static final int UC_SPARC_REG_F60 = 47;   public static final int UC_SPARC_REG_F62 = 48;   public static final int UC_SPARC_REG_FCC0 = 49;   public static final int UC_SPARC_REG_FCC1 = 50;   public static final int UC_SPARC_REG_FCC2 = 51;   public static final int UC_SPARC_REG_FCC3 = 52;   public static final int UC_SPARC_REG_G0 = 53;   public static final int UC_SPARC_REG_G1 = 54;   public static final int UC_SPARC_REG_G2 = 55;   public static final int UC_SPARC_REG_G3 = 56;   public static final int UC_SPARC_REG_G4 = 57;   public static final int UC_SPARC_REG_G5 = 58;   public static final int UC_SPARC_REG_G6 = 59;   public static final int UC_SPARC_REG_G7 = 60;   public static final int UC_SPARC_REG_I0 = 61;   public static final int UC_SPARC_REG_I1 = 62;   public static final int UC_SPARC_REG_I2 = 63;   public static final int UC_SPARC_REG_I3 = 64;   public static final int UC_SPARC_REG_I4 = 65;   public static final int UC_SPARC_REG_I5 = 66;   public static final int UC_SPARC_REG_FP = 67;   public static final int UC_SPARC_REG_I7 = 68;   public static final int UC_SPARC_REG_ICC = 69;   public static final int UC_SPARC_REG_L0 = 70;   public static final int UC_SPARC_REG_L1 = 71;   public static final int UC_SPARC_REG_L2 = 72;   public static final int UC_SPARC_REG_L3 = 73;   public static final int UC_SPARC_REG_L4 = 74;   public static final int UC_SPARC_REG_L5 = 75;   public static final int UC_SPARC_REG_L6 = 76;   public static final int UC_SPARC_REG_L7 = 77;   public static final int UC_SPARC_REG_O0 = 78;   public static final int UC_SPARC_REG_O1 = 79;   public static final int UC_SPARC_REG_O2 = 80;   public static final int UC_SPARC_REG_O3 = 81;   public static final int UC_SPARC_REG_O4 = 82;   public static final int UC_SPARC_REG_O5 = 83;   public static final int UC_SPARC_REG_SP = 84;   public static final int UC_SPARC_REG_O7 = 85;   public static final int UC_SPARC_REG_Y = 86;   public static final int UC_SPARC_REG_XCC = 87;   public static final int UC_SPARC_REG_PC = 88;   public static final int UC_SPARC_REG_ENDING = 89;   public static final int UC_SPARC_REG_O6 = 84;   public static final int UC_SPARC_REG_I6 = 67;}"}
{"code": "public interface X86Const {   public static final int UC_CPU_X86_QEMU64 = 0;   public static final int UC_CPU_X86_PHENOM = 1;   public static final int UC_CPU_X86_CORE2DUO = 2;   public static final int UC_CPU_X86_KVM64 = 3;   public static final int UC_CPU_X86_QEMU32 = 4;   public static final int UC_CPU_X86_KVM32 = 5;   public static final int UC_CPU_X86_COREDUO = 6;   public static final int UC_CPU_X86_486 = 7;   public static final int UC_CPU_X86_PENTIUM = 8;   public static final int UC_CPU_X86_PENTIUM2 = 9;   public static final int UC_CPU_X86_PENTIUM3 = 10;   public static final int UC_CPU_X86_ATHLON = 11;   public static final int UC_CPU_X86_N270 = 12;   public static final int UC_CPU_X86_CONROE = 13;   public static final int UC_CPU_X86_PENRYN = 14;   public static final int UC_CPU_X86_NEHALEM = 15;   public static final int UC_CPU_X86_WESTMERE = 16;   public static final int UC_CPU_X86_SANDYBRIDGE = 17;   public static final int UC_CPU_X86_IVYBRIDGE = 18;   public static final int UC_CPU_X86_HASWELL = 19;   public static final int UC_CPU_X86_BROADWELL = 20;   public static final int UC_CPU_X86_SKYLAKE_CLIENT = 21;   public static final int UC_CPU_X86_SKYLAKE_SERVER = 22;   public static final int UC_CPU_X86_CASCADELAKE_SERVER = 23;   public static final int UC_CPU_X86_COOPERLAKE = 24;   public static final int UC_CPU_X86_ICELAKE_CLIENT = 25;   public static final int UC_CPU_X86_ICELAKE_SERVER = 26;   public static final int UC_CPU_X86_DENVERTON = 27;   public static final int UC_CPU_X86_SNOWRIDGE = 28;   public static final int UC_CPU_X86_KNIGHTSMILL = 29;   public static final int UC_CPU_X86_OPTERON_G1 = 30;   public static final int UC_CPU_X86_OPTERON_G2 = 31;   public static final int UC_CPU_X86_OPTERON_G3 = 32;   public static final int UC_CPU_X86_OPTERON_G4 = 33;   public static final int UC_CPU_X86_OPTERON_G5 = 34;   public static final int UC_CPU_X86_EPYC = 35;   public static final int UC_CPU_X86_DHYANA = 36;   public static final int UC_CPU_X86_EPYC_ROME = 37;   public static final int UC_CPU_X86_ENDING = 38;   public static final int UC_X86_REG_INVALID = 0;   public static final int UC_X86_REG_AH = 1;   public static final int UC_X86_REG_AL = 2;   public static final int UC_X86_REG_AX = 3;   public static final int UC_X86_REG_BH = 4;   public static final int UC_X86_REG_BL = 5;   public static final int UC_X86_REG_BP = 6;   public static final int UC_X86_REG_BPL = 7;   public static final int UC_X86_REG_BX = 8;   public static final int UC_X86_REG_CH = 9;   public static final int UC_X86_REG_CL = 10;   public static final int UC_X86_REG_CS = 11;   public static final int UC_X86_REG_CX = 12;   public static final int UC_X86_REG_DH = 13;   public static final int UC_X86_REG_DI = 14;   public static final int UC_X86_REG_DIL = 15;   public static final int UC_X86_REG_DL = 16;   public static final int UC_X86_REG_DS = 17;   public static final int UC_X86_REG_DX = 18;   public static final int UC_X86_REG_EAX = 19;   public static final int UC_X86_REG_EBP = 20;   public static final int UC_X86_REG_EBX = 21;   public static final int UC_X86_REG_ECX = 22;   public static final int UC_X86_REG_EDI = 23;   public static final int UC_X86_REG_EDX = 24;   public static final int UC_X86_REG_EFLAGS = 25;   public static final int UC_X86_REG_EIP = 26;   public static final int UC_X86_REG_ES = 28;   public static final int UC_X86_REG_ESI = 29;   public static final int UC_X86_REG_ESP = 30;   public static final int UC_X86_REG_FPSW = 31;   public static final int UC_X86_REG_FS = 32;   public static final int UC_X86_REG_GS = 33;   public static final int UC_X86_REG_IP = 34;   public static final int UC_X86_REG_RAX = 35;   public static final int UC_X86_REG_RBP = 36;   public static final int UC_X86_REG_RBX = 37;   public static final int UC_X86_REG_RCX = 38;   public static final int UC_X86_REG_RDI = 39;   public static final int UC_X86_REG_RDX = 40;   public static final int UC_X86_REG_RIP = 41;   public static final int UC_X86_REG_RSI = 43;   public static final int UC_X86_REG_RSP = 44;   public static final int UC_X86_REG_SI = 45;   public static final int UC_X86_REG_SIL = 46;   public static final int UC_X86_REG_SP = 47;   public static final int UC_X86_REG_SPL = 48;   public static final int UC_X86_REG_SS = 49;   public static final int UC_X86_REG_CR0 = 50;   public static final int UC_X86_REG_CR1 = 51;   public static final int UC_X86_REG_CR2 = 52;   public static final int UC_X86_REG_CR3 = 53;   public static final int UC_X86_REG_CR4 = 54;   public static final int UC_X86_REG_CR8 = 58;   public static final int UC_X86_REG_DR0 = 66;   public static final int UC_X86_REG_DR1 = 67;   public static final int UC_X86_REG_DR2 = 68;   public static final int UC_X86_REG_DR3 = 69;   public static final int UC_X86_REG_DR4 = 70;   public static final int UC_X86_REG_DR5 = 71;   public static final int UC_X86_REG_DR6 = 72;   public static final int UC_X86_REG_DR7 = 73;   public static final int UC_X86_REG_FP0 = 82;   public static final int UC_X86_REG_FP1 = 83;   public static final int UC_X86_REG_FP2 = 84;   public static final int UC_X86_REG_FP3 = 85;   public static final int UC_X86_REG_FP4 = 86;   public static final int UC_X86_REG_FP5 = 87;   public static final int UC_X86_REG_FP6 = 88;   public static final int UC_X86_REG_FP7 = 89;   public static final int UC_X86_REG_K0 = 90;   public static final int UC_X86_REG_K1 = 91;   public static final int UC_X86_REG_K2 = 92;   public static final int UC_X86_REG_K3 = 93;   public static final int UC_X86_REG_K4 = 94;   public static final int UC_X86_REG_K5 = 95;   public static final int UC_X86_REG_K6 = 96;   public static final int UC_X86_REG_K7 = 97;   public static final int UC_X86_REG_MM0 = 98;   public static final int UC_X86_REG_MM1 = 99;   public static final int UC_X86_REG_MM2 = 100;   public static final int UC_X86_REG_MM3 = 101;   public static final int UC_X86_REG_MM4 = 102;   public static final int UC_X86_REG_MM5 = 103;   public static final int UC_X86_REG_MM6 = 104;   public static final int UC_X86_REG_MM7 = 105;   public static final int UC_X86_REG_R8 = 106;   public static final int UC_X86_REG_R9 = 107;   public static final int UC_X86_REG_R10 = 108;   public static final int UC_X86_REG_R11 = 109;   public static final int UC_X86_REG_R12 = 110;   public static final int UC_X86_REG_R13 = 111;   public static final int UC_X86_REG_R14 = 112;   public static final int UC_X86_REG_R15 = 113;   public static final int UC_X86_REG_ST0 = 114;   public static final int UC_X86_REG_ST1 = 115;   public static final int UC_X86_REG_ST2 = 116;   public static final int UC_X86_REG_ST3 = 117;   public static final int UC_X86_REG_ST4 = 118;   public static final int UC_X86_REG_ST5 = 119;   public static final int UC_X86_REG_ST6 = 120;   public static final int UC_X86_REG_ST7 = 121;   public static final int UC_X86_REG_XMM0 = 122;   public static final int UC_X86_REG_XMM1 = 123;   public static final int UC_X86_REG_XMM2 = 124;   public static final int UC_X86_REG_XMM3 = 125;   public static final int UC_X86_REG_XMM4 = 126;   public static final int UC_X86_REG_XMM5 = 127;   public static final int UC_X86_REG_XMM6 = 128;   public static final int UC_X86_REG_XMM7 = 129;   public static final int UC_X86_REG_XMM8 = 130;   public static final int UC_X86_REG_XMM9 = 131;   public static final int UC_X86_REG_XMM10 = 132;   public static final int UC_X86_REG_XMM11 = 133;   public static final int UC_X86_REG_XMM12 = 134;   public static final int UC_X86_REG_XMM13 = 135;   public static final int UC_X86_REG_XMM14 = 136;   public static final int UC_X86_REG_XMM15 = 137;   public static final int UC_X86_REG_XMM16 = 138;   public static final int UC_X86_REG_XMM17 = 139;   public static final int UC_X86_REG_XMM18 = 140;   public static final int UC_X86_REG_XMM19 = 141;   public static final int UC_X86_REG_XMM20 = 142;   public static final int UC_X86_REG_XMM21 = 143;   public static final int UC_X86_REG_XMM22 = 144;   public static final int UC_X86_REG_XMM23 = 145;   public static final int UC_X86_REG_XMM24 = 146;   public static final int UC_X86_REG_XMM25 = 147;   public static final int UC_X86_REG_XMM26 = 148;   public static final int UC_X86_REG_XMM27 = 149;   public static final int UC_X86_REG_XMM28 = 150;   public static final int UC_X86_REG_XMM29 = 151;   public static final int UC_X86_REG_XMM30 = 152;   public static final int UC_X86_REG_XMM31 = 153;   public static final int UC_X86_REG_YMM0 = 154;   public static final int UC_X86_REG_YMM1 = 155;   public static final int UC_X86_REG_YMM2 = 156;   public static final int UC_X86_REG_YMM3 = 157;   public static final int UC_X86_REG_YMM4 = 158;   public static final int UC_X86_REG_YMM5 = 159;   public static final int UC_X86_REG_YMM6 = 160;   public static final int UC_X86_REG_YMM7 = 161;   public static final int UC_X86_REG_YMM8 = 162;   public static final int UC_X86_REG_YMM9 = 163;   public static final int UC_X86_REG_YMM10 = 164;   public static final int UC_X86_REG_YMM11 = 165;   public static final int UC_X86_REG_YMM12 = 166;   public static final int UC_X86_REG_YMM13 = 167;   public static final int UC_X86_REG_YMM14 = 168;   public static final int UC_X86_REG_YMM15 = 169;   public static final int UC_X86_REG_YMM16 = 170;   public static final int UC_X86_REG_YMM17 = 171;   public static final int UC_X86_REG_YMM18 = 172;   public static final int UC_X86_REG_YMM19 = 173;   public static final int UC_X86_REG_YMM20 = 174;   public static final int UC_X86_REG_YMM21 = 175;   public static final int UC_X86_REG_YMM22 = 176;   public static final int UC_X86_REG_YMM23 = 177;   public static final int UC_X86_REG_YMM24 = 178;   public static final int UC_X86_REG_YMM25 = 179;   public static final int UC_X86_REG_YMM26 = 180;   public static final int UC_X86_REG_YMM27 = 181;   public static final int UC_X86_REG_YMM28 = 182;   public static final int UC_X86_REG_YMM29 = 183;   public static final int UC_X86_REG_YMM30 = 184;   public static final int UC_X86_REG_YMM31 = 185;   public static final int UC_X86_REG_ZMM0 = 186;   public static final int UC_X86_REG_ZMM1 = 187;   public static final int UC_X86_REG_ZMM2 = 188;   public static final int UC_X86_REG_ZMM3 = 189;   public static final int UC_X86_REG_ZMM4 = 190;   public static final int UC_X86_REG_ZMM5 = 191;   public static final int UC_X86_REG_ZMM6 = 192;   public static final int UC_X86_REG_ZMM7 = 193;   public static final int UC_X86_REG_ZMM8 = 194;   public static final int UC_X86_REG_ZMM9 = 195;   public static final int UC_X86_REG_ZMM10 = 196;   public static final int UC_X86_REG_ZMM11 = 197;   public static final int UC_X86_REG_ZMM12 = 198;   public static final int UC_X86_REG_ZMM13 = 199;   public static final int UC_X86_REG_ZMM14 = 200;   public static final int UC_X86_REG_ZMM15 = 201;   public static final int UC_X86_REG_ZMM16 = 202;   public static final int UC_X86_REG_ZMM17 = 203;   public static final int UC_X86_REG_ZMM18 = 204;   public static final int UC_X86_REG_ZMM19 = 205;   public static final int UC_X86_REG_ZMM20 = 206;   public static final int UC_X86_REG_ZMM21 = 207;   public static final int UC_X86_REG_ZMM22 = 208;   public static final int UC_X86_REG_ZMM23 = 209;   public static final int UC_X86_REG_ZMM24 = 210;   public static final int UC_X86_REG_ZMM25 = 211;   public static final int UC_X86_REG_ZMM26 = 212;   public static final int UC_X86_REG_ZMM27 = 213;   public static final int UC_X86_REG_ZMM28 = 214;   public static final int UC_X86_REG_ZMM29 = 215;   public static final int UC_X86_REG_ZMM30 = 216;   public static final int UC_X86_REG_ZMM31 = 217;   public static final int UC_X86_REG_R8B = 218;   public static final int UC_X86_REG_R9B = 219;   public static final int UC_X86_REG_R10B = 220;   public static final int UC_X86_REG_R11B = 221;   public static final int UC_X86_REG_R12B = 222;   public static final int UC_X86_REG_R13B = 223;   public static final int UC_X86_REG_R14B = 224;   public static final int UC_X86_REG_R15B = 225;   public static final int UC_X86_REG_R8D = 226;   public static final int UC_X86_REG_R9D = 227;   public static final int UC_X86_REG_R10D = 228;   public static final int UC_X86_REG_R11D = 229;   public static final int UC_X86_REG_R12D = 230;   public static final int UC_X86_REG_R13D = 231;   public static final int UC_X86_REG_R14D = 232;   public static final int UC_X86_REG_R15D = 233;   public static final int UC_X86_REG_R8W = 234;   public static final int UC_X86_REG_R9W = 235;   public static final int UC_X86_REG_R10W = 236;   public static final int UC_X86_REG_R11W = 237;   public static final int UC_X86_REG_R12W = 238;   public static final int UC_X86_REG_R13W = 239;   public static final int UC_X86_REG_R14W = 240;   public static final int UC_X86_REG_R15W = 241;   public static final int UC_X86_REG_IDTR = 242;   public static final int UC_X86_REG_GDTR = 243;   public static final int UC_X86_REG_LDTR = 244;   public static final int UC_X86_REG_TR = 245;   public static final int UC_X86_REG_FPCW = 246;   public static final int UC_X86_REG_FPTAG = 247;   public static final int UC_X86_REG_MSR = 248;   public static final int UC_X86_REG_MXCSR = 249;   public static final int UC_X86_REG_FS_BASE = 250;   public static final int UC_X86_REG_GS_BASE = 251;   public static final int UC_X86_REG_FLAGS = 252;   public static final int UC_X86_REG_RFLAGS = 253;   public static final int UC_X86_REG_FIP = 254;   public static final int UC_X86_REG_FCS = 255;   public static final int UC_X86_REG_FDP = 256;   public static final int UC_X86_REG_FDS = 257;   public static final int UC_X86_REG_FOP = 258;   public static final int UC_X86_REG_ENDING = 259;   public static final int UC_X86_INS_INVALID = 0;   public static final int UC_X86_INS_AAA = 1;   public static final int UC_X86_INS_AAD = 2;   public static final int UC_X86_INS_AAM = 3;   public static final int UC_X86_INS_AAS = 4;   public static final int UC_X86_INS_FABS = 5;   public static final int UC_X86_INS_ADC = 6;   public static final int UC_X86_INS_ADCX = 7;   public static final int UC_X86_INS_ADD = 8;   public static final int UC_X86_INS_ADDPD = 9;   public static final int UC_X86_INS_ADDPS = 10;   public static final int UC_X86_INS_ADDSD = 11;   public static final int UC_X86_INS_ADDSS = 12;   public static final int UC_X86_INS_ADDSUBPD = 13;   public static final int UC_X86_INS_ADDSUBPS = 14;   public static final int UC_X86_INS_FADD = 15;   public static final int UC_X86_INS_FIADD = 16;   public static final int UC_X86_INS_FADDP = 17;   public static final int UC_X86_INS_ADOX = 18;   public static final int UC_X86_INS_AESDECLAST = 19;   public static final int UC_X86_INS_AESDEC = 20;   public static final int UC_X86_INS_AESENCLAST = 21;   public static final int UC_X86_INS_AESENC = 22;   public static final int UC_X86_INS_AESIMC = 23;   public static final int UC_X86_INS_AESKEYGENASSIST = 24;   public static final int UC_X86_INS_AND = 25;   public static final int UC_X86_INS_ANDN = 26;   public static final int UC_X86_INS_ANDNPD = 27;   public static final int UC_X86_INS_ANDNPS = 28;   public static final int UC_X86_INS_ANDPD = 29;   public static final int UC_X86_INS_ANDPS = 30;   public static final int UC_X86_INS_ARPL = 31;   public static final int UC_X86_INS_BEXTR = 32;   public static final int UC_X86_INS_BLCFILL = 33;   public static final int UC_X86_INS_BLCI = 34;   public static final int UC_X86_INS_BLCIC = 35;   public static final int UC_X86_INS_BLCMSK = 36;   public static final int UC_X86_INS_BLCS = 37;   public static final int UC_X86_INS_BLENDPD = 38;   public static final int UC_X86_INS_BLENDPS = 39;   public static final int UC_X86_INS_BLENDVPD = 40;   public static final int UC_X86_INS_BLENDVPS = 41;   public static final int UC_X86_INS_BLSFILL = 42;   public static final int UC_X86_INS_BLSI = 43;   public static final int UC_X86_INS_BLSIC = 44;   public static final int UC_X86_INS_BLSMSK = 45;   public static final int UC_X86_INS_BLSR = 46;   public static final int UC_X86_INS_BOUND = 47;   public static final int UC_X86_INS_BSF = 48;   public static final int UC_X86_INS_BSR = 49;   public static final int UC_X86_INS_BSWAP = 50;   public static final int UC_X86_INS_BT = 51;   public static final int UC_X86_INS_BTC = 52;   public static final int UC_X86_INS_BTR = 53;   public static final int UC_X86_INS_BTS = 54;   public static final int UC_X86_INS_BZHI = 55;   public static final int UC_X86_INS_CALL = 56;   public static final int UC_X86_INS_CBW = 57;   public static final int UC_X86_INS_CDQ = 58;   public static final int UC_X86_INS_CDQE = 59;   public static final int UC_X86_INS_FCHS = 60;   public static final int UC_X86_INS_CLAC = 61;   public static final int UC_X86_INS_CLC = 62;   public static final int UC_X86_INS_CLD = 63;   public static final int UC_X86_INS_CLFLUSH = 64;   public static final int UC_X86_INS_CLFLUSHOPT = 65;   public static final int UC_X86_INS_CLGI = 66;   public static final int UC_X86_INS_CLI = 67;   public static final int UC_X86_INS_CLTS = 68;   public static final int UC_X86_INS_CLWB = 69;   public static final int UC_X86_INS_CMC = 70;   public static final int UC_X86_INS_CMOVA = 71;   public static final int UC_X86_INS_CMOVAE = 72;   public static final int UC_X86_INS_CMOVB = 73;   public static final int UC_X86_INS_CMOVBE = 74;   public static final int UC_X86_INS_FCMOVBE = 75;   public static final int UC_X86_INS_FCMOVB = 76;   public static final int UC_X86_INS_CMOVE = 77;   public static final int UC_X86_INS_FCMOVE = 78;   public static final int UC_X86_INS_CMOVG = 79;   public static final int UC_X86_INS_CMOVGE = 80;   public static final int UC_X86_INS_CMOVL = 81;   public static final int UC_X86_INS_CMOVLE = 82;   public static final int UC_X86_INS_FCMOVNBE = 83;   public static final int UC_X86_INS_FCMOVNB = 84;   public static final int UC_X86_INS_CMOVNE = 85;   public static final int UC_X86_INS_FCMOVNE = 86;   public static final int UC_X86_INS_CMOVNO = 87;   public static final int UC_X86_INS_CMOVNP = 88;   public static final int UC_X86_INS_FCMOVNU = 89;   public static final int UC_X86_INS_CMOVNS = 90;   public static final int UC_X86_INS_CMOVO = 91;   public static final int UC_X86_INS_CMOVP = 92;   public static final int UC_X86_INS_FCMOVU = 93;   public static final int UC_X86_INS_CMOVS = 94;   public static final int UC_X86_INS_CMP = 95;   public static final int UC_X86_INS_CMPPD = 96;   public static final int UC_X86_INS_CMPPS = 97;   public static final int UC_X86_INS_CMPSB = 98;   public static final int UC_X86_INS_CMPSD = 99;   public static final int UC_X86_INS_CMPSQ = 100;   public static final int UC_X86_INS_CMPSS = 101;   public static final int UC_X86_INS_CMPSW = 102;   public static final int UC_X86_INS_CMPXCHG16B = 103;   public static final int UC_X86_INS_CMPXCHG = 104;   public static final int UC_X86_INS_CMPXCHG8B = 105;   public static final int UC_X86_INS_COMISD = 106;   public static final int UC_X86_INS_COMISS = 107;   public static final int UC_X86_INS_FCOMP = 108;   public static final int UC_X86_INS_FCOMPI = 109;   public static final int UC_X86_INS_FCOMI = 110;   public static final int UC_X86_INS_FCOM = 111;   public static final int UC_X86_INS_FCOS = 112;   public static final int UC_X86_INS_CPUID = 113;   public static final int UC_X86_INS_CQO = 114;   public static final int UC_X86_INS_CRC32 = 115;   public static final int UC_X86_INS_CVTDQ2PD = 116;   public static final int UC_X86_INS_CVTDQ2PS = 117;   public static final int UC_X86_INS_CVTPD2DQ = 118;   public static final int UC_X86_INS_CVTPD2PS = 119;   public static final int UC_X86_INS_CVTPS2DQ = 120;   public static final int UC_X86_INS_CVTPS2PD = 121;   public static final int UC_X86_INS_CVTSD2SI = 122;   public static final int UC_X86_INS_CVTSD2SS = 123;   public static final int UC_X86_INS_CVTSI2SD = 124;   public static final int UC_X86_INS_CVTSI2SS = 125;   public static final int UC_X86_INS_CVTSS2SD = 126;   public static final int UC_X86_INS_CVTSS2SI = 127;   public static final int UC_X86_INS_CVTTPD2DQ = 128;   public static final int UC_X86_INS_CVTTPS2DQ = 129;   public static final int UC_X86_INS_CVTTSD2SI = 130;   public static final int UC_X86_INS_CVTTSS2SI = 131;   public static final int UC_X86_INS_CWD = 132;   public static final int UC_X86_INS_CWDE = 133;   public static final int UC_X86_INS_DAA = 134;   public static final int UC_X86_INS_DAS = 135;   public static final int UC_X86_INS_DATA16 = 136;   public static final int UC_X86_INS_DEC = 137;   public static final int UC_X86_INS_DIV = 138;   public static final int UC_X86_INS_DIVPD = 139;   public static final int UC_X86_INS_DIVPS = 140;   public static final int UC_X86_INS_FDIVR = 141;   public static final int UC_X86_INS_FIDIVR = 142;   public static final int UC_X86_INS_FDIVRP = 143;   public static final int UC_X86_INS_DIVSD = 144;   public static final int UC_X86_INS_DIVSS = 145;   public static final int UC_X86_INS_FDIV = 146;   public static final int UC_X86_INS_FIDIV = 147;   public static final int UC_X86_INS_FDIVP = 148;   public static final int UC_X86_INS_DPPD = 149;   public static final int UC_X86_INS_DPPS = 150;   public static final int UC_X86_INS_RET = 151;   public static final int UC_X86_INS_ENCLS = 152;   public static final int UC_X86_INS_ENCLU = 153;   public static final int UC_X86_INS_ENTER = 154;   public static final int UC_X86_INS_EXTRACTPS = 155;   public static final int UC_X86_INS_EXTRQ = 156;   public static final int UC_X86_INS_F2XM1 = 157;   public static final int UC_X86_INS_LCALL = 158;   public static final int UC_X86_INS_LJMP = 159;   public static final int UC_X86_INS_FBLD = 160;   public static final int UC_X86_INS_FBSTP = 161;   public static final int UC_X86_INS_FCOMPP = 162;   public static final int UC_X86_INS_FDECSTP = 163;   public static final int UC_X86_INS_FEMMS = 164;   public static final int UC_X86_INS_FFREE = 165;   public static final int UC_X86_INS_FICOM = 166;   public static final int UC_X86_INS_FICOMP = 167;   public static final int UC_X86_INS_FINCSTP = 168;   public static final int UC_X86_INS_FLDCW = 169;   public static final int UC_X86_INS_FLDENV = 170;   public static final int UC_X86_INS_FLDL2E = 171;   public static final int UC_X86_INS_FLDL2T = 172;   public static final int UC_X86_INS_FLDLG2 = 173;   public static final int UC_X86_INS_FLDLN2 = 174;   public static final int UC_X86_INS_FLDPI = 175;   public static final int UC_X86_INS_FNCLEX = 176;   public static final int UC_X86_INS_FNINIT = 177;   public static final int UC_X86_INS_FNOP = 178;   public static final int UC_X86_INS_FNSTCW = 179;   public static final int UC_X86_INS_FNSTSW = 180;   public static final int UC_X86_INS_FPATAN = 181;   public static final int UC_X86_INS_FPREM = 182;   public static final int UC_X86_INS_FPREM1 = 183;   public static final int UC_X86_INS_FPTAN = 184;   public static final int UC_X86_INS_FFREEP = 185;   public static final int UC_X86_INS_FRNDINT = 186;   public static final int UC_X86_INS_FRSTOR = 187;   public static final int UC_X86_INS_FNSAVE = 188;   public static final int UC_X86_INS_FSCALE = 189;   public static final int UC_X86_INS_FSETPM = 190;   public static final int UC_X86_INS_FSINCOS = 191;   public static final int UC_X86_INS_FNSTENV = 192;   public static final int UC_X86_INS_FXAM = 193;   public static final int UC_X86_INS_FXRSTOR = 194;   public static final int UC_X86_INS_FXRSTOR64 = 195;   public static final int UC_X86_INS_FXSAVE = 196;   public static final int UC_X86_INS_FXSAVE64 = 197;   public static final int UC_X86_INS_FXTRACT = 198;   public static final int UC_X86_INS_FYL2X = 199;   public static final int UC_X86_INS_FYL2XP1 = 200;   public static final int UC_X86_INS_MOVAPD = 201;   public static final int UC_X86_INS_MOVAPS = 202;   public static final int UC_X86_INS_ORPD = 203;   public static final int UC_X86_INS_ORPS = 204;   public static final int UC_X86_INS_VMOVAPD = 205;   public static final int UC_X86_INS_VMOVAPS = 206;   public static final int UC_X86_INS_XORPD = 207;   public static final int UC_X86_INS_XORPS = 208;   public static final int UC_X86_INS_GETSEC = 209;   public static final int UC_X86_INS_HADDPD = 210;   public static final int UC_X86_INS_HADDPS = 211;   public static final int UC_X86_INS_HLT = 212;   public static final int UC_X86_INS_HSUBPD = 213;   public static final int UC_X86_INS_HSUBPS = 214;   public static final int UC_X86_INS_IDIV = 215;   public static final int UC_X86_INS_FILD = 216;   public static final int UC_X86_INS_IMUL = 217;   public static final int UC_X86_INS_IN = 218;   public static final int UC_X86_INS_INC = 219;   public static final int UC_X86_INS_INSB = 220;   public static final int UC_X86_INS_INSERTPS = 221;   public static final int UC_X86_INS_INSERTQ = 222;   public static final int UC_X86_INS_INSD = 223;   public static final int UC_X86_INS_INSW = 224;   public static final int UC_X86_INS_INT = 225;   public static final int UC_X86_INS_INT1 = 226;   public static final int UC_X86_INS_INT3 = 227;   public static final int UC_X86_INS_INTO = 228;   public static final int UC_X86_INS_INVD = 229;   public static final int UC_X86_INS_INVEPT = 230;   public static final int UC_X86_INS_INVLPG = 231;   public static final int UC_X86_INS_INVLPGA = 232;   public static final int UC_X86_INS_INVPCID = 233;   public static final int UC_X86_INS_INVVPID = 234;   public static final int UC_X86_INS_IRET = 235;   public static final int UC_X86_INS_IRETD = 236;   public static final int UC_X86_INS_IRETQ = 237;   public static final int UC_X86_INS_FISTTP = 238;   public static final int UC_X86_INS_FIST = 239;   public static final int UC_X86_INS_FISTP = 240;   public static final int UC_X86_INS_UCOMISD = 241;   public static final int UC_X86_INS_UCOMISS = 242;   public static final int UC_X86_INS_VCOMISD = 243;   public static final int UC_X86_INS_VCOMISS = 244;   public static final int UC_X86_INS_VCVTSD2SS = 245;   public static final int UC_X86_INS_VCVTSI2SD = 246;   public static final int UC_X86_INS_VCVTSI2SS = 247;   public static final int UC_X86_INS_VCVTSS2SD = 248;   public static final int UC_X86_INS_VCVTTSD2SI = 249;   public static final int UC_X86_INS_VCVTTSD2USI = 250;   public static final int UC_X86_INS_VCVTTSS2SI = 251;   public static final int UC_X86_INS_VCVTTSS2USI = 252;   public static final int UC_X86_INS_VCVTUSI2SD = 253;   public static final int UC_X86_INS_VCVTUSI2SS = 254;   public static final int UC_X86_INS_VUCOMISD = 255;   public static final int UC_X86_INS_VUCOMISS = 256;   public static final int UC_X86_INS_JAE = 257;   public static final int UC_X86_INS_JA = 258;   public static final int UC_X86_INS_JBE = 259;   public static final int UC_X86_INS_JB = 260;   public static final int UC_X86_INS_JCXZ = 261;   public static final int UC_X86_INS_JECXZ = 262;   public static final int UC_X86_INS_JE = 263;   public static final int UC_X86_INS_JGE = 264;   public static final int UC_X86_INS_JG = 265;   public static final int UC_X86_INS_JLE = 266;   public static final int UC_X86_INS_JL = 267;   public static final int UC_X86_INS_JMP = 268;   public static final int UC_X86_INS_JNE = 269;   public static final int UC_X86_INS_JNO = 270;   public static final int UC_X86_INS_JNP = 271;   public static final int UC_X86_INS_JNS = 272;   public static final int UC_X86_INS_JO = 273;   public static final int UC_X86_INS_JP = 274;   public static final int UC_X86_INS_JRCXZ = 275;   public static final int UC_X86_INS_JS = 276;   public static final int UC_X86_INS_KANDB = 277;   public static final int UC_X86_INS_KANDD = 278;   public static final int UC_X86_INS_KANDNB = 279;   public static final int UC_X86_INS_KANDND = 280;   public static final int UC_X86_INS_KANDNQ = 281;   public static final int UC_X86_INS_KANDNW = 282;   public static final int UC_X86_INS_KANDQ = 283;   public static final int UC_X86_INS_KANDW = 284;   public static final int UC_X86_INS_KMOVB = 285;   public static final int UC_X86_INS_KMOVD = 286;   public static final int UC_X86_INS_KMOVQ = 287;   public static final int UC_X86_INS_KMOVW = 288;   public static final int UC_X86_INS_KNOTB = 289;   public static final int UC_X86_INS_KNOTD = 290;   public static final int UC_X86_INS_KNOTQ = 291;   public static final int UC_X86_INS_KNOTW = 292;   public static final int UC_X86_INS_KORB = 293;   public static final int UC_X86_INS_KORD = 294;   public static final int UC_X86_INS_KORQ = 295;   public static final int UC_X86_INS_KORTESTB = 296;   public static final int UC_X86_INS_KORTESTD = 297;   public static final int UC_X86_INS_KORTESTQ = 298;   public static final int UC_X86_INS_KORTESTW = 299;   public static final int UC_X86_INS_KORW = 300;   public static final int UC_X86_INS_KSHIFTLB = 301;   public static final int UC_X86_INS_KSHIFTLD = 302;   public static final int UC_X86_INS_KSHIFTLQ = 303;   public static final int UC_X86_INS_KSHIFTLW = 304;   public static final int UC_X86_INS_KSHIFTRB = 305;   public static final int UC_X86_INS_KSHIFTRD = 306;   public static final int UC_X86_INS_KSHIFTRQ = 307;   public static final int UC_X86_INS_KSHIFTRW = 308;   public static final int UC_X86_INS_KUNPCKBW = 309;   public static final int UC_X86_INS_KXNORB = 310;   public static final int UC_X86_INS_KXNORD = 311;   public static final int UC_X86_INS_KXNORQ = 312;   public static final int UC_X86_INS_KXNORW = 313;   public static final int UC_X86_INS_KXORB = 314;   public static final int UC_X86_INS_KXORD = 315;   public static final int UC_X86_INS_KXORQ = 316;   public static final int UC_X86_INS_KXORW = 317;   public static final int UC_X86_INS_LAHF = 318;   public static final int UC_X86_INS_LAR = 319;   public static final int UC_X86_INS_LDDQU = 320;   public static final int UC_X86_INS_LDMXCSR = 321;   public static final int UC_X86_INS_LDS = 322;   public static final int UC_X86_INS_FLDZ = 323;   public static final int UC_X86_INS_FLD1 = 324;   public static final int UC_X86_INS_FLD = 325;   public static final int UC_X86_INS_LEA = 326;   public static final int UC_X86_INS_LEAVE = 327;   public static final int UC_X86_INS_LES = 328;   public static final int UC_X86_INS_LFENCE = 329;   public static final int UC_X86_INS_LFS = 330;   public static final int UC_X86_INS_LGDT = 331;   public static final int UC_X86_INS_LGS = 332;   public static final int UC_X86_INS_LIDT = 333;   public static final int UC_X86_INS_LLDT = 334;   public static final int UC_X86_INS_LMSW = 335;   public static final int UC_X86_INS_OR = 336;   public static final int UC_X86_INS_SUB = 337;   public static final int UC_X86_INS_XOR = 338;   public static final int UC_X86_INS_LODSB = 339;   public static final int UC_X86_INS_LODSD = 340;   public static final int UC_X86_INS_LODSQ = 341;   public static final int UC_X86_INS_LODSW = 342;   public static final int UC_X86_INS_LOOP = 343;   public static final int UC_X86_INS_LOOPE = 344;   public static final int UC_X86_INS_LOOPNE = 345;   public static final int UC_X86_INS_RETF = 346;   public static final int UC_X86_INS_RETFQ = 347;   public static final int UC_X86_INS_LSL = 348;   public static final int UC_X86_INS_LSS = 349;   public static final int UC_X86_INS_LTR = 350;   public static final int UC_X86_INS_XADD = 351;   public static final int UC_X86_INS_LZCNT = 352;   public static final int UC_X86_INS_MASKMOVDQU = 353;   public static final int UC_X86_INS_MAXPD = 354;   public static final int UC_X86_INS_MAXPS = 355;   public static final int UC_X86_INS_MAXSD = 356;   public static final int UC_X86_INS_MAXSS = 357;   public static final int UC_X86_INS_MFENCE = 358;   public static final int UC_X86_INS_MINPD = 359;   public static final int UC_X86_INS_MINPS = 360;   public static final int UC_X86_INS_MINSD = 361;   public static final int UC_X86_INS_MINSS = 362;   public static final int UC_X86_INS_CVTPD2PI = 363;   public static final int UC_X86_INS_CVTPI2PD = 364;   public static final int", "nl": "public interface X86Const {   public static final int UC_CPU_X86_QEMU64 = 0;   public static final int UC_CPU_X86_PHENOM = 1;   public static final int UC_CPU_X86_CORE2DUO = 2;   public static final int UC_CPU_X86_KVM64 = 3;   public static final int UC_CPU_X86_QEMU32 = 4;   public static final int UC_CPU_X86_KVM32 = 5;   public static final int UC_CPU_X86_COREDUO = 6;   public static final int UC_CPU_X86_486 = 7;   public static final int UC_CPU_X86_PENTIUM = 8;   public static final int UC_CPU_X86_PENTIUM2 = 9;   public static final int UC_CPU_X86_PENTIUM3 = 10;   public static final int UC_CPU_X86_ATHLON = 11;   public static final int UC_CPU_X86_N270 = 12;   public static final int UC_CPU_X86_CONROE = 13;   public static final int UC_CPU_X86_PENRYN = 14;   public static final int UC_CPU_X86_NEHALEM = 15;   public static final int UC_CPU_X86_WESTMERE = 16;   public static final int UC_CPU_X86_SANDYBRIDGE = 17;   public static final int UC_CPU_X86_IVYBRIDGE = 18;   public static final int UC_CPU_X86_HASWELL = 19;   public static final int UC_CPU_X86_BROADWELL = 20;   public static final int UC_CPU_X86_SKYLAKE_CLIENT = 21;   public static final int UC_CPU_X86_SKYLAKE_SERVER = 22;   public static final int UC_CPU_X86_CASCADELAKE_SERVER = 23;   public static final int UC_CPU_X86_COOPERLAKE = 24;   public static final int UC_CPU_X86_ICELAKE_CLIENT = 25;   public static final int UC_CPU_X86_ICELAKE_SERVER = 26;   public static final int UC_CPU_X86_DENVERTON = 27;   public static final int UC_CPU_X86_SNOWRIDGE = 28;   public static final int UC_CPU_X86_KNIGHTSMILL = 29;   public static final int UC_CPU_X86_OPTERON_G1 = 30;   public static final int UC_CPU_X86_OPTERON_G2 = 31;   public static final int UC_CPU_X86_OPTERON_G3 = 32;   public static final int UC_CPU_X86_OPTERON_G4 = 33;   public static final int UC_CPU_X86_OPTERON_G5 = 34;   public static final int UC_CPU_X86_EPYC = 35;   public static final int UC_CPU_X86_DHYANA = 36;   public static final int UC_CPU_X86_EPYC_ROME = 37;   public static final int UC_X86_REG_INVALID = 0;   public static final int UC_X86_REG_AH = 1;   public static final int UC_X86_REG_AL = 2;   public static final int UC_X86_REG_AX = 3;   public static final int UC_X86_REG_BH = 4;   public static final int UC_X86_REG_BL = 5;   public static final int UC_X86_REG_BP = 6;   public static final int UC_X86_REG_BPL = 7;   public static final int UC_X86_REG_BX = 8;   public static final int UC_X86_REG_CH = 9;   public static final int UC_X86_REG_CL = 10;   public static final int UC_X86_REG_CS = 11;   public static final int UC_X86_REG_CX = 12;   public static final int UC_X86_REG_DH = 13;   public static final int UC_X86_REG_DI = 14;   public static final int UC_X86_REG_DIL = 15;   public static final int UC_X86_REG_DL = 16;   public static final int UC_X86_REG_DS = 17;   public static final int UC_X86_REG_DX = 18;   public static final int UC_X86_REG_EAX = 19;   public static final int UC_X86_REG_EBP = 20;   public static final int UC_X86_REG_EBX = 21;   public static final int UC_X86_REG_ECX = 22;   public static final int UC_X86_REG_EDI = 23;   public static final int UC_X86_REG_EDX = 24;   public static final int UC_X86_REG_EFLAGS = 25;   public static final int UC_X86_REG_EIP = 26;   public static final int UC_X86_REG_ES = 28;   public static final int UC_X86_REG_ESI = 29;   public static final int UC_X86_REG_ESP = 30;   public static final int UC_X86_REG_FPSW = 31;   public static final int UC_X86_REG_FS = 32;   public static final int UC_X86_REG_GS = 33;   public static final int UC_X86_REG_IP = 34;   public static final int UC_X86_REG_RAX = 35;   public static final int UC_X86_REG_RBP = 36;   public static final int UC_X86_REG_RBX = 37;   public static final int UC_X86_REG_RCX = 38;   public static final int UC_X86_REG_RDI = 39;   public static final int UC_X86_REG_RDX = 40;   public static final int UC_X86_REG_RIP = 41;   public static final int UC_X86_REG_RSI = 43;   public static final int UC_X86_REG_RSP = 44;   public static final int UC_X86_REG_SI = 45;   public static final int UC_X86_REG_SIL = 46;   public static final int UC_X86_REG_SP = 47;   public static final int UC_X86_REG_SPL = 48;   public static final int UC_X86_REG_SS = 49;   public static final int UC_X86_REG_CR0 = 50;   public static final int UC_X86_REG_CR1 = 51;   public static final int UC_X86_REG_CR2 = 52;   public static final int UC_X86_REG_CR3 = 53;   public static final int UC_X86_REG_CR4 = 54;   public static final int UC_X86_REG_CR8 = 58;   public static final int UC_X86_REG_DR0 = 66;   public static final int UC_X86_REG_DR1 = 67;   public static final int UC_X86_REG_DR2 = 68;   public static final int UC_X86_REG_DR3 = 69;   public static final int UC_X86_REG_DR4 = 70;   public static final int UC_X86_REG_DR5 = 71;   public static final int UC_X86_REG_DR6 = 72;   public static final int UC_X86_REG_DR7 = 73;   public static final int UC_X86_REG_FP0 = 82;   public static final int UC_X86_REG_FP1 = 83;   public static final int UC_X86_REG_FP2 = 84;   public static final int UC_X86_REG_FP3 = 85;   public static final int UC_X86_REG_FP4 = 86;   public static final int UC_X86_REG_FP5 = 87;   public static final int UC_X86_REG_FP6 = 88;   public static final int UC_X86_REG_FP7 = 89;   public static final int UC_X86_REG_K0 = 90;   public static final int UC_X86_REG_K1 = 91;   public static final int UC_X86_REG_K2 = 92;   public static final int UC_X86_REG_K3 = 93;   public static final int UC_X86_REG_K4 = 94;   public static final int UC_X86_REG_K5 = 95;   public static final int UC_X86_REG_K6 = 96;   public static final int UC_X86_REG_K7 = 97;   public static final int UC_X86_REG_MM0 = 98;   public static final int UC_X86_REG_MM1 = 99;   public static final int UC_X86_REG_MM2 = 100;   public static final int UC_X86_REG_MM3 = 101;   public static final int UC_X86_REG_MM4 = 102;   public static final int UC_X86_REG_MM5 = 103;   public static final int UC_X86_REG_MM6 = 104;   public static final int UC_X86_REG_MM7 = 105;   public static final int UC_X86_REG_R8 = 106;   public static final int UC_X86_REG_R9 = 107;   public static final int UC_X86_REG_R10 = 108;   public static final int UC_X86_REG_R11 = 109;   public static final int UC_X86_REG_R12 = 110;   public static final int UC_X86_REG_R13 = 111;   public static final int UC_X86_REG_R14 = 112;   public static final int UC_X86_REG_R15 = 113;   public static final int UC_X86_REG_ST0 = 114;   public static final int UC_X86_REG_ST1 = 115;   public static final int UC_X86_REG_ST2 = 116;   public static final int UC_X86_REG_ST3 = 117;   public static final int UC_X86_REG_ST4 = 118;   public static final int UC_X86_REG_ST5 = 119;   public static final int UC_X86_REG_ST6 = 120;   public static final int UC_X86_REG_ST7 = 121;   public static final int UC_X86_REG_XMM0 = 122;   public static final int UC_X86_REG_XMM1 = 123;   public static final int UC_X86_REG_XMM2 = 124;   public static final int UC_X86_REG_XMM3 = 125;   public static final int UC_X86_REG_XMM4 = 126;   public static final int UC_X86_REG_XMM5 = 127;   public static final int UC_X86_REG_XMM6 = 128;   public static final int UC_X86_REG_XMM7 = 129;   public static final int UC_X86_REG_XMM8 = 130;   public static final int UC_X86_REG_XMM9 = 131;   public static final int UC_X86_REG_XMM10 = 132;   public static final int UC_X86_REG_XMM11 = 133;   public static final int UC_X86_REG_XMM12 = 134;   public static final int UC_X86_REG_XMM13 = 135;   public static final int UC_X86_REG_XMM14 = 136;   public static final int UC_X86_REG_XMM15 = 137;   public static final int UC_X86_REG_XMM16 = 138;   public static final int UC_X86_REG_XMM17 = 139;   public static final int UC_X86_REG_XMM18 = 140;   public static final int UC_X86_REG_XMM19 = 141;   public static final int UC_X86_REG_XMM20 = 142;   public static final int UC_X86_REG_XMM21 = 143;   public static final int UC_X86_REG_XMM22 = 144;   public static final int UC_X86_REG_XMM23 = 145;   public static final int UC_X86_REG_XMM24 = 146;   public static final int UC_X86_REG_XMM25 = 147;   public static final int UC_X86_REG_XMM26 = 148;   public static final int UC_X86_REG_XMM27 = 149;   public static final int UC_X86_REG_XMM28 = 150;   public static final int UC_X86_REG_XMM29 = 151;   public static final int UC_X86_REG_XMM30 = 152;   public static final int UC_X86_REG_XMM31 = 153;   public static final int UC_X86_REG_YMM0 = 154;   public static final int UC_X86_REG_YMM1 = 155;   public static final int UC_X86_REG_YMM2 = 156;   public static final int UC_X86_REG_YMM3 = 157;   public static final int UC_X86_REG_YMM4 = 158;   public static final int UC_X86_REG_YMM5 = 159;   public static final int UC_X86_REG_YMM6 = 160;   public static final int UC_X86_REG_YMM7 = 161;   public static final int UC_X86_REG_YMM8 = 162;   public static final int UC_X86_REG_YMM9 = 163;   public static final int UC_X86_REG_YMM10 = 164;   public static final int UC_X86_REG_YMM11 = 165;   public static final int UC_X86_REG_YMM12 = 166;   public static final int UC_X86_REG_YMM13 = 167;   public static final int UC_X86_REG_YMM14 = 168;   public static final int UC_X86_REG_YMM15 = 169;   public static final int UC_X86_REG_YMM16 = 170;   public static final int UC_X86_REG_YMM17 = 171;   public static final int UC_X86_REG_YMM18 = 172;   public static final int UC_X86_REG_YMM19 = 173;   public static final int UC_X86_REG_YMM20 = 174;   public static final int UC_X86_REG_YMM21 = 175;   public static final int UC_X86_REG_YMM22 = 176;   public static final int UC_X86_REG_YMM23 = 177;   public static final int UC_X86_REG_YMM24 = 178;   public static final int UC_X86_REG_YMM25 = 179;   public static final int UC_X86_REG_YMM26 = 180;   public static final int UC_X86_REG_YMM27 = 181;   public static final int UC_X86_REG_YMM28 = 182;   public static final int UC_X86_REG_YMM29 = 183;   public static final int UC_X86_REG_YMM30 = 184;   public static final int UC_X86_REG_YMM31 = 185;   public static final int UC_X86_REG_ZMM0 = 186;   public static final int UC_X86_REG_ZMM1 = 187;   public static final int UC_X86_REG_ZMM2 = 188;   public static final int UC_X86_REG_ZMM3 = 189;   public static final int UC_X86_REG_ZMM4 = 190;   public static final int UC_X86_REG_ZMM5 = 191;   public static final int UC_X86_REG_ZMM6 = 192;   public static final int UC_X86_REG_ZMM7 = 193;   public static final int UC_X86_REG_ZMM8 = 194;   public static final int UC_X86_REG_ZMM9 = 195;   public static final int UC_X86_REG_ZMM10 = 196;   public static final int UC_X86_REG_ZMM11 = 197;   public static final int UC_X86_REG_ZMM12 = 198;   public static final int UC_X86_REG_ZMM13 = 199;   public static final int UC_X86_REG_ZMM14 = 200;   public static final int UC_X86_REG_ZMM15 = 201;   public static final int UC_X86_REG_ZMM16 = 202;   public static final int UC_X86_REG_ZMM17 = 203;   public static final int UC_X86_REG_ZMM18 = 204;   public static final int UC_X86_REG_ZMM19 = 205;   public static final int UC_X86_REG_ZMM20 = 206;   public static final int UC_X86_REG_ZMM21 = 207;   public static final int UC_X86_REG_ZMM22 = 208;   public static final int UC_X86_REG_ZMM23 = 209;   public static final int UC_X86_REG_ZMM24 = 210;   public static final int UC_X86_REG_ZMM25 = 211;   public static final int UC_X86_REG_ZMM26 = 212;   public static final int UC_X86_REG_ZMM27 = 213;   public static final int UC_X86_REG_ZMM28 = 214;   public static final int UC_X86_REG_ZMM29 = 215;   public static final int UC_X86_REG_ZMM30 = 216;   public static final int UC_X86_REG_ZMM31 = 217;   public static final int UC_X86_REG_R8B = 218;   public static final int UC_X86_REG_R9B = 219;   public static final int UC_X86_REG_R10B = 220;   public static final int UC_X86_REG_R11B = 221;   public static final int UC_X86_REG_R12B = 222;   public static final int UC_X86_REG_R13B = 223;   public static final int UC_X86_REG_R14B = 224;   public static final int UC_X86_REG_R15B = 225;   public static final int UC_X86_REG_R8D = 226;   public static final int UC_X86_REG_R9D = 227;   public static final int UC_X86_REG_R10D = 228;   public static final int UC_X86_REG_R11D = 229;   public static final int UC_X86_REG_R12D = 230;   public static final int UC_X86_REG_R13D = 231;   public static final int UC_X86_REG_R14D = 232;   public static final int UC_X86_REG_R15D = 233;   public static final int UC_X86_REG_R8W = 234;   public static final int UC_X86_REG_R9W = 235;   public static final int UC_X86_REG_R10W = 236;   public static final int UC_X86_REG_R11W = 237;   public static final int UC_X86_REG_R12W = 238;   public static final int UC_X86_REG_R13W = 239;   public static final int UC_X86_REG_R14W = 240;   public static final int UC_X86_REG_R15W = 241;   public static final int UC_X86_REG_IDTR = 242;   public static final int UC_X86_REG_GDTR = 243;   public static final int UC_X86_REG_LDTR = 244;   public static final int UC_X86_REG_TR = 245;   public static final int UC_X86_REG_FPCW = 246;   public static final int UC_X86_REG_FPTAG = 247;   public static final int UC_X86_REG_MSR = 248;   public static final int UC_X86_REG_MXCSR = 249;   public static final int UC_X86_REG_FS_BASE = 250;   public static final int UC_X86_REG_GS_BASE = 251;   public static final int UC_X86_REG_FLAGS = 252;   public static final int UC_X86_REG_RFLAGS = 253;   public static final int UC_X86_REG_FIP = 254;   public static final int UC_X86_REG_FCS = 255;   public static final int UC_X86_REG_FDP = 256;   public static final int UC_X86_REG_FDS = 257;   public static final int UC_X86_REG_FOP = 258;   public static final int UC_X86_REG_ENDING = 259;   public static final int UC_X86_INS_INVALID = 0;   public static final int UC_X86_INS_AAA = 1;   public static final int UC_X86_INS_AAD = 2;   public static final int UC_X86_INS_AAM = 3;   public static final int UC_X86_INS_AAS = 4;   public static final int UC_X86_INS_FABS = 5;   public static final int UC_X86_INS_ADC = 6;   public static final int UC_X86_INS_ADCX = 7;   public static final int UC_X86_INS_ADD = 8;   public static final int UC_X86_INS_ADDPD = 9;   public static final int UC_X86_INS_ADDPS = 10;   public static final int UC_X86_INS_ADDSD = 11;   public static final int UC_X86_INS_ADDSS = 12;   public static final int UC_X86_INS_ADDSUBPD = 13;   public static final int UC_X86_INS_ADDSUBPS = 14;   public static final int UC_X86_INS_FADD = 15;   public static final int UC_X86_INS_FIADD = 16;   public static final int UC_X86_INS_FADDP = 17;   public static final int UC_X86_INS_ADOX = 18;   public static final int UC_X86_INS_AESDECLAST = 19;   public static final int UC_X86_INS_AESDEC = 20;   public static final int UC_X86_INS_AESENCLAST = 21;   public static final int UC_X86_INS_AESENC = 22;   public static final int UC_X86_INS_AESIMC = 23;   public static final int UC_X86_INS_AESKEYGENASSIST = 24;   public static final int UC_X86_INS_AND = 25;   public static final int UC_X86_INS_ANDN = 26;   public static final int UC_X86_INS_ANDNPD = 27;   public static final int UC_X86_INS_ANDNPS = 28;   public static final int UC_X86_INS_ANDPD = 29;   public static final int UC_X86_INS_ANDPS = 30;   public static final int UC_X86_INS_ARPL = 31;   public static final int UC_X86_INS_BEXTR = 32;   public static final int UC_X86_INS_BLCFILL = 33;   public static final int UC_X86_INS_BLCI = 34;   public static final int UC_X86_INS_BLCIC = 35;   public static final int UC_X86_INS_BLCMSK = 36;   public static final int UC_X86_INS_BLCS = 37;   public static final int UC_X86_INS_BLENDPD = 38;   public static final int UC_X86_INS_BLENDPS = 39;   public static final int UC_X86_INS_BLENDVPD = 40;   public static final int UC_X86_INS_BLENDVPS = 41;   public static final int UC_X86_INS_BLSFILL = 42;   public static final int UC_X86_INS_BLSI = 43;   public static final int UC_X86_INS_BLSIC = 44;   public static final int UC_X86_INS_BLSMSK = 45;   public static final int UC_X86_INS_BLSR = 46;   public static final int UC_X86_INS_BOUND = 47;   public static final int UC_X86_INS_BSF = 48;   public static final int UC_X86_INS_BSR = 49;   public static final int UC_X86_INS_BSWAP = 50;   public static final int UC_X86_INS_BT = 51;   public static final int UC_X86_INS_BTC = 52;   public static final int UC_X86_INS_BTR = 53;   public static final int UC_X86_INS_BTS = 54;   public static final int UC_X86_INS_BZHI = 55;   public static final int UC_X86_INS_CALL = 56;   public static final int UC_X86_INS_CBW = 57;   public static final int UC_X86_INS_CDQ = 58;   public static final int UC_X86_INS_CDQE = 59;   public static final int UC_X86_INS_FCHS = 60;   public static final int UC_X86_INS_CLAC = 61;   public static final int UC_X86_INS_CLC = 62;   public static final int UC_X86_INS_CLD = 63;   public static final int UC_X86_INS_CLFLUSH = 64;   public static final int UC_X86_INS_CLFLUSHOPT = 65;   public static final int UC_X86_INS_CLGI = 66;   public static final int UC_X86_INS_CLI = 67;   public static final int UC_X86_INS_CLTS = 68;   public static final int UC_X86_INS_CLWB = 69;   public static final int UC_X86_INS_CMC = 70;   public static final int UC_X86_INS_CMOVA = 71;   public static final int UC_X86_INS_CMOVAE = 72;   public static final int UC_X86_INS_CMOVB = 73;   public static final int UC_X86_INS_CMOVBE = 74;   public static final int UC_X86_INS_FCMOVBE = 75;   public static final int UC_X86_INS_FCMOVB = 76;   public static final int UC_X86_INS_CMOVE = 77;   public static final int UC_X86_INS_FCMOVE = 78;   public static final int UC_X86_INS_CMOVG = 79;   public static final int UC_X86_INS_CMOVGE = 80;   public static final int UC_X86_INS_CMOVL = 81;   public static final int UC_X86_INS_CMOVLE = 82;   public static final int UC_X86_INS_FCMOVNBE = 83;   public static final int UC_X86_INS_FCMOVNB = 84;   public static final int UC_X86_INS_CMOVNE = 85;   public static final int UC_X86_INS_FCMOVNE = 86;   public static final int UC_X86_INS_CMOVNO = 87;   public static final int UC_X86_INS_CMOVNP = 88;   public static final int UC_X86_INS_FCMOVNU = 89;   public static final int UC_X86_INS_CMOVNS = 90;   public static final int UC_X86_INS_CMOVO = 91;   public static final int UC_X86_INS_CMOVP = 92;   public static final int UC_X86_INS_FCMOVU = 93;   public static final int UC_X86_INS_CMOVS = 94;   public static final int UC_X86_INS_CMP = 95;   public static final int UC_X86_INS_CMPPD = 96;   public static final int UC_X86_INS_CMPPS = 97;   public static final int UC_X86_INS_CMPSB = 98;   public static final int UC_X86_INS_CMPSD = 99;   public static final int UC_X86_INS_CMPSQ = 100;   public static final int UC_X86_INS_CMPSS = 101;   public static final int UC_X86_INS_CMPSW = 102;   public static final int UC_X86_INS_CMPXCHG16B = 103;   public static final int UC_X86_INS_CMPXCHG = 104;   public static final int UC_X86_INS_CMPXCHG8B = 105;   public static final int UC_X86_INS_COMISD = 106;   public static final int UC_X86_INS_COMISS = 107;   public static final int UC_X86_INS_FCOMP = 108;   public static final int UC_X86_INS_FCOMPI = 109;   public static final int UC_X86_INS_FCOMI = 110;   public static final int UC_X86_INS_FCOM = 111;   public static final int UC_X86_INS_FCOS = 112;   public static final int UC_X86_INS_CPUID = 113;   public static final int UC_X86_INS_CQO = 114;   public static final int UC_X86_INS_CRC32 = 115;   public static final int UC_X86_INS_CVTDQ2PD = 116;   public static final int UC_X86_INS_CVTDQ2PS = 117;   public static final int UC_X86_INS_CVTPD2DQ = 118;   public static final int UC_X86_INS_CVTPD2PS = 119;   public static final int UC_X86_INS_CVTPS2DQ = 120;   public static final int UC_X86_INS_CVTPS2PD = 121;   public static final int UC_X86_INS_CVTSD2SI = 122;   public static final int UC_X86_INS_CVTSD2SS = 123;   public static final int UC_X86_INS_CVTSI2SD = 124;   public static final int UC_X86_INS_CVTSI2SS = 125;   public static final int UC_X86_INS_CVTSS2SD = 126;   public static final int UC_X86_INS_CVTSS2SI = 127;   public static final int UC_X86_INS_CVTTPD2DQ = 128;   public static final int UC_X86_INS_CVTTPS2DQ = 129;   public static final int UC_X86_INS_CVTTSD2SI = 130;   public static final int UC_X86_INS_CVTTSS2SI = 131;   public static final int UC_X86_INS_CWD = 132;   public static final int UC_X86_INS_CWDE = 133;   public static final int UC_X86_INS_DAA = 134;   public static final int UC_X86_INS_DAS = 135;   public static final int UC_X86_INS_DATA16 = 136;   public static final int UC_X86_INS_DEC = 137;   public static final int UC_X86_INS_DIV = 138;   public static final int UC_X86_INS_DIVPD = 139;   public static final int UC_X86_INS_DIVPS = 140;   public static final int UC_X86_INS_FDIVR = 141;   public static final int UC_X86_INS_FIDIVR = 142;   public static final int UC_X86_INS_FDIVRP = 143;   public static final int UC_X86_INS_DIVSD = 144;   public static final int UC_X86_INS_DIVSS = 145;   public static final int UC_X86_INS_FDIV = 146;   public static final int UC_X86_INS_FIDIV = 147;   public static final int UC_X86_INS_FDIVP = 148;   public static final int UC_X86_INS_DPPD = 149;   public static final int UC_X86_INS_DPPS = 150;   public static final int UC_X86_INS_RET = 151;   public static final int UC_X86_INS_ENCLS = 152;   public static final int UC_X86_INS_ENCLU = 153;   public static final int UC_X86_INS_ENTER = 154;   public static final int UC_X86_INS_EXTRACTPS = 155;   public static final int UC_X86_INS_EXTRQ = 156;   public static final int UC_X86_INS_F2XM1 = 157;   public static final int UC_X86_INS_LCALL = 158;   public static final int UC_X86_INS_LJMP = 159;   public static final int UC_X86_INS_FBLD = 160;   public static final int UC_X86_INS_FBSTP = 161;   public static final int UC_X86_INS_FCOMPP = 162;   public static final int UC_X86_INS_FDECSTP = 163;   public static final int UC_X86_INS_FEMMS = 164;   public static final int UC_X86_INS_FFREE = 165;   public static final int UC_X86_INS_FICOM = 166;   public static final int UC_X86_INS_FICOMP = 167;   public static final int UC_X86_INS_FINCSTP = 168;   public static final int UC_X86_INS_FLDCW = 169;   public static final int UC_X86_INS_FLDENV = 170;   public static final int UC_X86_INS_FLDL2E = 171;   public static final int UC_X86_INS_FLDL2T = 172;   public static final int UC_X86_INS_FLDLG2 = 173;   public static final int UC_X86_INS_FLDLN2 = 174;   public static final int UC_X86_INS_FLDPI = 175;   public static final int UC_X86_INS_FNCLEX = 176;   public static final int UC_X86_INS_FNINIT = 177;   public static final int UC_X86_INS_FNOP = 178;   public static final int UC_X86_INS_FNSTCW = 179;   public static final int UC_X86_INS_FNSTSW = 180;   public static final int UC_X86_INS_FPATAN = 181;   public static final int UC_X86_INS_FPREM = 182;   public static final int UC_X86_INS_FPREM1 = 183;   public static final int UC_X86_INS_FPTAN = 184;   public static final int UC_X86_INS_FFREEP = 185;   public static final int UC_X86_INS_FRNDINT = 186;   public static final int UC_X86_INS_FRSTOR = 187;   public static final int UC_X86_INS_FNSAVE = 188;   public static final int UC_X86_INS_FSCALE = 189;   public static final int UC_X86_INS_FSETPM = 190;   public static final int UC_X86_INS_FSINCOS = 191;   public static final int UC_X86_INS_FNSTENV = 192;   public static final int UC_X86_INS_FXAM = 193;   public static final int UC_X86_INS_FXRSTOR = 194;   public static final int UC_X86_INS_FXRSTOR64 = 195;   public static final int UC_X86_INS_FXSAVE = 196;   public static final int UC_X86_INS_FXSAVE64 = 197;   public static final int UC_X86_INS_FXTRACT = 198;   public static final int UC_X86_INS_FYL2X = 199;   public static final int UC_X86_INS_FYL2XP1 = 200;   public static final int UC_X86_INS_MOVAPD = 201;   public static final int UC_X86_INS_MOVAPS = 202;   public static final int UC_X86_INS_ORPD = 203;   public static final int UC_X86_INS_ORPS = 204;   public static final int UC_X86_INS_VMOVAPD = 205;   public static final int UC_X86_INS_VMOVAPS = 206;   public static final int UC_X86_INS_XORPD = 207;   public static final int UC_X86_INS_XORPS = 208;   public static final int UC_X86_INS_GETSEC = 209;   public static final int UC_X86_INS_HADDPD = 210;   public static final int UC_X86_INS_HADDPS = 211;   public static final int UC_X86_INS_HLT = 212;   public static final int UC_X86_INS_HSUBPD = 213;   public static final int UC_X86_INS_HSUBPS = 214;   public static final int UC_X86_INS_IDIV = 215;   public static final int UC_X86_INS_FILD = 216;   public static final int UC_X86_INS_IMUL = 217;   public static final int UC_X86_INS_IN = 218;   public static final int UC_X86_INS_INC = 219;   public static final int UC_X86_INS_INSB = 220;   public static final int UC_X86_INS_INSERTPS = 221;   public static final int UC_X86_INS_INSERTQ = 222;   public static final int UC_X86_INS_INSD = 223;   public static final int UC_X86_INS_INSW = 224;   public static final int UC_X86_INS_INT = 225;   public static final int UC_X86_INS_INT1 = 226;   public static final int UC_X86_INS_INT3 = 227;   public static final int UC_X86_INS_INTO = 228;   public static final int UC_X86_INS_INVD = 229;   public static final int UC_X86_INS_INVEPT = 230;   public static final int UC_X86_INS_INVLPG = 231;   public static final int UC_X86_INS_INVLPGA = 232;   public static final int UC_X86_INS_INVPCID = 233;   public static final int UC_X86_INS_INVVPID = 234;   public static final int UC_X86_INS_IRET = 235;   public static final int UC_X86_INS_IRETD = 236;   public static final int UC_X86_INS_IRETQ = 237;   public static final int UC_X86_INS_FISTTP = 238;   public static final int UC_X86_INS_FIST = 239;   public static final int UC_X86_INS_FISTP = 240;   public static final int UC_X86_INS_UCOMISD = 241;   public static final int UC_X86_INS_UCOMISS = 242;   public static final int UC_X86_INS_VCOMISD = 243;   public static final int UC_X86_INS_VCOMISS = 244;   public static final int UC_X86_INS_VCVTSD2SS = 245;   public static final int UC_X86_INS_VCVTSI2SD = 246;   public static final int UC_X86_INS_VCVTSI2SS = 247;   public static final int UC_X86_INS_VCVTSS2SD = 248;   public static final int UC_X86_INS_VCVTTSD2SI = 249;   public static final int UC_X86_INS_VCVTTSD2USI = 250;   public static final int UC_X86_INS_VCVTTSS2SI = 251;   public static final int UC_X86_INS_VCVTTSS2USI = 252;   public static final int UC_X86_INS_VCVTUSI2SD = 253;   public static final int UC_X86_INS_VCVTUSI2SS = 254;   public static final int UC_X86_INS_VUCOMISD = 255;   public static final int UC_X86_INS_VUCOMISS = 256;   public static final int UC_X86_INS_JAE = 257;   public static final int UC_X86_INS_JA = 258;   public static final int UC_X86_INS_JBE = 259;   public static final int UC_X86_INS_JB = 260;   public static final int UC_X86_INS_JCXZ = 261;   public static final int UC_X86_INS_JECXZ = 262;   public static final int UC_X86_INS_JE = 263;   public static final int UC_X86_INS_JGE = 264;   public static final int UC_X86_INS_JG = 265;   public static final int UC_X86_INS_JLE = 266;   public static final int UC_X86_INS_JL = 267;   public static final int UC_X86_INS_JMP = 268;   public static final int UC_X86_INS_JNE = 269;   public static final int UC_X86_INS_JNO = 270;   public static final int UC_X86_INS_JNP = 271;   public static final int UC_X86_INS_JNS = 272;   public static final int UC_X86_INS_JO = 273;   public static final int UC_X86_INS_JP = 274;   public static final int UC_X86_INS_JRCXZ = 275;   public static final int UC_X86_INS_JS = 276;   public static final int UC_X86_INS_KANDB = 277;   public static final int UC_X86_INS_KANDD = 278;   public static final int UC_X86_INS_KANDNB = 279;   public static final int UC_X86_INS_KANDND = 280;   public static final int UC_X86_INS_KANDNQ = 281;   public static final int UC_X86_INS_KANDNW = 282;   public static final int UC_X86_INS_KANDQ = 283;   public static final int UC_X86_INS_KANDW = 284;   public static final int UC_X86_INS_KMOVB = 285;   public static final int UC_X86_INS_KMOVD = 286;   public static final int UC_X86_INS_KMOVQ = 287;   public static final int UC_X86_INS_KMOVW = 288;   public static final int UC_X86_INS_KNOTB = 289;   public static final int UC_X86_INS_KNOTD = 290;   public static final int UC_X86_INS_KNOTQ = 291;   public static final int UC_X86_INS_KNOTW = 292;   public static final int UC_X86_INS_KORB = 293;   public static final int UC_X86_INS_KORD = 294;   public static final int UC_X86_INS_KORQ = 295;   public static final int UC_X86_INS_KORTESTB = 296;   public static final int UC_X86_INS_KORTESTD = 297;   public static final int UC_X86_INS_KORTESTQ = 298;   public static final int UC_X86_INS_KORTESTW = 299;   public static final int UC_X86_INS_KORW = 300;   public static final int UC_X86_INS_KSHIFTLB = 301;   public static final int UC_X86_INS_KSHIFTLD = 302;   public static final int UC_X86_INS_KSHIFTLQ = 303;   public static final int UC_X86_INS_KSHIFTLW = 304;   public static final int UC_X86_INS_KSHIFTRB = 305;   public static final int UC_X86_INS_KSHIFTRD = 306;   public static final int UC_X86_INS_KSHIFTRQ = 307;   public static final int UC_X86_INS_KSHIFTRW = 308;   public static final int UC_X86_INS_KUNPCKBW = 309;   public static final int UC_X86_INS_KXNORB = 310;   public static final int UC_X86_INS_KXNORD = 311;   public static final int UC_X86_INS_KXNORQ = 312;   public static final int UC_X86_INS_KXNORW = 313;   public static final int UC_X86_INS_KXORB = 314;   public static final int UC_X86_INS_KXORD = 315;   public static final int UC_X86_INS_KXORQ = 316;   public static final int UC_X86_INS_KXORW = 317;   public static final int UC_X86_INS_LAHF = 318;   public static final int UC_X86_INS_LAR = 319;   public static final int UC_X86_INS_LDDQU = 320;   public static final int UC_X86_INS_LDMXCSR = 321;   public static final int UC_X86_INS_LDS = 322;   public static final int UC_X86_INS_FLDZ = 323;   public static final int UC_X86_INS_FLD1 = 324;   public static final int UC_X86_INS_FLD = 325;   public static final int UC_X86_INS_LEA = 326;   public static final int UC_X86_INS_LEAVE = 327;   public static final int UC_X86_INS_LES = 328;   public static final int UC_X86_INS_LFENCE = 329;   public static final int UC_X86_INS_LFS = 330;   public static final int UC_X86_INS_LGDT = 331;   public static final int UC_X86_INS_LGS = 332;   public static final int UC_X86_INS_LIDT = 333;   public static final int UC_X86_INS_LLDT = 334;   public static final int UC_X86_INS_LMSW = 335;   public static final int UC_X86_INS_OR = 336;   public static final int UC_X86_INS_SUB = 337;   public static final int UC_X86_INS_XOR = 338;   public static final int UC_X86_INS_LODSB = 339;   public static final int UC_X86_INS_LODSD = 340;   public static final int UC_X86_INS_LODSQ = 341;   public static final int UC_X86_INS_LODSW = 342;   public static final int UC_X86_INS_LOOP = 343;   public static final int UC_X86_INS_LOOPE = 344;   public static final int UC_X86_INS_LOOPNE = 345;   public static final int UC_X86_INS_RETF = 346;   public static final int UC_X86_INS_RETFQ = 347;   public static final int UC_X86_INS_LSL = 348;   public static final int UC_X86_INS_LSS = 349;   public static final int UC_X86_INS_LTR = 350;   public static final int UC_X86_INS_XADD = 351;   public static final int UC_X86_INS_LZCNT = 352;   public static final int UC_X86_INS_MASKMOVDQU = 353;   public static final int UC_X86_INS_MAXPD = 354;   public static final int UC_X86_INS_MAXPS = 355;   public static final int UC_X86_INS_MAXSD = 356;   public static final int UC_X86_INS_MAXSS = 357;   public static final int UC_X86_INS_MFENCE = 358;   public static final int UC_X86_INS_MINPD = 359;   public static final int UC_X86_INS_MINPS = 360;   public static final int UC_X86_INS_MINSD = 361;   public static final int UC_X86_INS_MINSS = 362;   public static final int UC_X86_INS_CVTPD2PI = 363;   public static final int UC_X86_INS_CVTPI2PD = 364;   public static final int UC_X86_INS_CVTPI2PS = 365;   public static final i"}
{"code": "import javax.xml.XMLConstants;import org.jkiss.code.NotNull;import org.jkiss.code.Nullable;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.xml.sax.InputSource;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Collection;import java.util.List;public class XMLUtils {    public static Document parseDocument(String fileName)        throws XMLException {        return parseDocument(new java.io.File(fileName));    }    public static Document parseDocument(java.io.File file) throws XMLException {        try (InputStream is = new FileInputStream(file)) {            return parseDocument(new InputSource(is));        } catch (IOException e) {            throw new XMLException(\"Error opening file '\" + file + \"'\", e);        }    }    public static Document parseDocument(java.io.InputStream is) throws XMLException {        return parseDocument(new InputSource(is));    }    public static Document parseDocument(java.io.Reader is) throws XMLException {        return parseDocument(new InputSource(is));    }    public static Document parseDocument(InputSource source) throws XMLException {        try {            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);            return xmlBuilder.parse(source);        } catch (Exception er) {            throw new XMLException(\"Error parsing XML document\", er);        }    }    public static Document createDocument()        throws XMLException {        try {            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();            return xmlBuilder.newDocument();        } catch (Exception er) {            throw new XMLException(\"Error creating XML document\", er);        }    }    public static Element getChildElement(Element element,                                          String childName) {        for (org.w3c.dom.Node node = element.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                ((Element) node).getTagName().equals(childName)) {                return (Element) node;            }        }        return null;    }    @Nullable    public static String getChildElementBody(Element element,                                             String childName) {        for (org.w3c.dom.Node node = element.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                ((Element) node).getTagName().equals(childName)) {                return getElementBody((Element) node);            }        }        return null;    }    @Nullable    public static String getElementBody(Element element) {        return element.getTextContent();    }    @NotNull    public static List<Element> getChildElementList(        Element parent,        String nodeName) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                nodeName.equals(node.getNodeName())) {                list.add((Element) node);            }        }        return list;    }    @NotNull    public static Collection<Element> getChildElementListNS(        Element parent,        String nsURI) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                node.getNamespaceURI().equals(nsURI)) {                list.add((Element) node);            }        }        return list;    }    public static Collection<Element> getChildElementListNS(        Element parent,        String nodeName,        String nsURI) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                node.getLocalName().equals(nodeName) &&                node.getNamespaceURI().equals(nsURI)) {                list.add((Element) node);            }        }        return list;    }    @NotNull    public static Collection<Element> getChildElementList(        Element parent,        String[] nodeNameList) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {                for (int i = 0; i < nodeNameList.length; i++) {                    if (node.getNodeName().equals(nodeNameList[i])) {                        list.add((Element) node);                    }                }            }        }        return list;    }    @Nullable    public static Element findChildElement(        Element parent) {        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {                return (Element) node;            }        }        return null;    }    public static Object escapeXml(Object obj) {        if (obj == null) {            return null;        } else if (obj instanceof CharSequence) {            return escapeXml((CharSequence) obj);        } else {            return obj;        }    }    public static String escapeXml(CharSequence str) {        if (str == null) {            return null;        }        StringBuilder res = null;        int strLength = str.length();        for (int i = 0; i < strLength; i++) {            char c = str.charAt(i);            String repl = encodeXMLChar(c);            if (repl == null) {                if (res != null) {                    res.append(c);                }            } else {                if (res == null) {                    res = new StringBuilder(str.length() + 5);                    for (int k = 0; k < i; k++) {                        res.append(str.charAt(k));                    }                }                res.append(repl);            }        }        return res == null ? str.toString() : res.toString();    }    public static boolean isValidXMLChar(char c) {        return (c >= 32 || c == '\\n' || c == '\\r' || c == '\\t');    }    public static String encodeXMLChar(char ch) {        switch (ch) {            case '&':                return \"&amp;\";            case '\\\"':                return \"&quot;\";            case '\\'':                return \"&#39;\";            case '<':                return \"&lt;\";            case '>':                return \"&gt;\";            default:                return null;        }    }    public static XMLException adaptSAXException(Exception toCatch) {        if (toCatch instanceof XMLException) {            return (XMLException) toCatch;        } else if (toCatch instanceof org.xml.sax.SAXException) {            String message = toCatch.getMessage();            Exception embedded = ((org.xml.sax.SAXException) toCatch).getException();            if (embedded != null && embedded.getMessage() != null && embedded.getMessage().equals(message)) {                return adaptSAXException(embedded);            } else {                return new XMLException(                    message,                    embedded != null ? adaptSAXException(embedded) : null);            }        } else {            return new XMLException(toCatch.getMessage(), toCatch);        }    }    public static Collection<Element> getChildElementList(Element element) {        List<Element> children = new ArrayList<>();        for (org.w3c.dom.Node node = element.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {                children.add((Element) node);            }        }        return children;    }}", "nl": "import org.jkiss.code.NotNull;import org.jkiss.code.Nullable;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.xml.sax.InputSource;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Collection;import java.util.List;public class XMLUtils {    public static Document parseDocument(String fileName)        throws XMLException {        return parseDocument(new java.io.File(fileName));    }    public static Document parseDocument(java.io.File file) throws XMLException {        try (InputStream is = new FileInputStream(file)) {            return parseDocument(new InputSource(is));        } catch (IOException e) {            throw new XMLException(\"Error opening file '\" + file + \"'\", e);        }    }    public static Document parseDocument(java.io.InputStream is) throws XMLException {        return parseDocument(new InputSource(is));    }    public static Document parseDocument(java.io.Reader is) throws XMLException {        return parseDocument(new InputSource(is));    }    public static Document parseDocument(InputSource source) throws XMLException {        try {            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();            return xmlBuilder.parse(source);        } catch (Exception er) {            throw new XMLException(\"Error parsing XML document\", er);        }    }    public static Document createDocument()        throws XMLException {        try {            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();            return xmlBuilder.newDocument();        } catch (Exception er) {            throw new XMLException(\"Error creating XML document\", er);        }    }    public static Element getChildElement(Element element,                                          String childName) {        for (org.w3c.dom.Node node = element.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                ((Element) node).getTagName().equals(childName)) {                return (Element) node;            }        }        return null;    }    @Nullable    public static String getChildElementBody(Element element,                                             String childName) {        for (org.w3c.dom.Node node = element.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                ((Element) node).getTagName().equals(childName)) {                return getElementBody((Element) node);            }        }        return null;    }    @Nullable    public static String getElementBody(Element element) {        return element.getTextContent();    }    @NotNull    public static List<Element> getChildElementList(        Element parent,        String nodeName) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                nodeName.equals(node.getNodeName())) {                list.add((Element) node);            }        }        return list;    }    @NotNull    public static Collection<Element> getChildElementListNS(        Element parent,        String nsURI) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                node.getNamespaceURI().equals(nsURI)) {                list.add((Element) node);            }        }        return list;    }    public static Collection<Element> getChildElementListNS(        Element parent,        String nodeName,        String nsURI) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE &&                node.getLocalName().equals(nodeName) &&                node.getNamespaceURI().equals(nsURI)) {                list.add((Element) node);            }        }        return list;    }    @NotNull    public static Collection<Element> getChildElementList(        Element parent,        String[] nodeNameList) {        List<Element> list = new ArrayList<>();        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {                for (int i = 0; i < nodeNameList.length; i++) {                    if (node.getNodeName().equals(nodeNameList[i])) {                        list.add((Element) node);                    }                }            }        }        return list;    }    @Nullable    public static Element findChildElement(        Element parent) {        for (org.w3c.dom.Node node = parent.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {                return (Element) node;            }        }        return null;    }    public static Object escapeXml(Object obj) {        if (obj == null) {            return null;        } else if (obj instanceof CharSequence) {            return escapeXml((CharSequence) obj);        } else {            return obj;        }    }    public static String escapeXml(CharSequence str) {        if (str == null) {            return null;        }        StringBuilder res = null;        int strLength = str.length();        for (int i = 0; i < strLength; i++) {            char c = str.charAt(i);            String repl = encodeXMLChar(c);            if (repl == null) {                if (res != null) {                    res.append(c);                }            } else {                if (res == null) {                    res = new StringBuilder(str.length() + 5);                    for (int k = 0; k < i; k++) {                        res.append(str.charAt(k));                    }                }                res.append(repl);            }        }        return res == null ? str.toString() : res.toString();    }    public static boolean isValidXMLChar(char c) {        return (c >= 32 || c == '\\n' || c == '\\r' || c == '\\t');    }    public static String encodeXMLChar(char ch) {        switch (ch) {            case '&':                return \"&amp;\";            case '\\\"':                return \"&quot;\";            case '\\'':                return \"&#39;\";            case '<':                return \"&lt;\";            case '>':                return \"&gt;\";            default:                return null;        }    }    public static XMLException adaptSAXException(Exception toCatch) {        if (toCatch instanceof XMLException) {            return (XMLException) toCatch;        } else if (toCatch instanceof org.xml.sax.SAXException) {            String message = toCatch.getMessage();            Exception embedded = ((org.xml.sax.SAXException) toCatch).getException();            if (embedded != null && embedded.getMessage() != null && embedded.getMessage().equals(message)) {                return adaptSAXException(embedded);            } else {                return new XMLException(                    message,                    embedded != null ? adaptSAXException(embedded) : null);            }        } else {            return new XMLException(toCatch.getMessage(), toCatch);        }    }    public static Collection<Element> getChildElementList(Element element) {        List<Element> children = new ArrayList<>();        for (org.w3c.dom.Node node = element.getFirstChild(); node != null; node = node.getNextSibling()) {            if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {                children.add((Element) node);            }        }        return children;    }}"}
{"code": "import com.nukkitx.protocol.bedrock.BedrockPacket;import com.nukkitx.protocol.bedrock.BedrockPacketCodec;import com.nukkitx.protocol.bedrock.data.ExperimentData;import com.nukkitx.protocol.bedrock.data.ResourcePackType;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.configuration.GeyserConfiguration;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslatorRegistry;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.utils.*;import java.io.FileInputStream;import java.io.InputStream;public class UpstreamPacketHandler extends LoggingPacketHandler {    public UpstreamPacketHandler(GeyserConnector connector, GeyserSession session) {        super(connector, session);    }    private boolean translateAndDefault(BedrockPacket packet) {        return PacketTranslatorRegistry.BEDROCK_TRANSLATOR.translate(packet.getClass(), packet, session);    }    @Override    boolean defaultHandler(BedrockPacket packet) {        return translateAndDefault(packet);    }    @Override    public boolean handle(LoginPacket loginPacket) {        BedrockPacketCodec packetCodec = BedrockProtocol.getBedrockCodec(loginPacket.getProtocolVersion());        if (packetCodec == null) {            String supportedVersions = BedrockProtocol.getAllSupportedVersions();            if (loginPacket.getProtocolVersion() > BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));                return true;            } else if (loginPacket.getProtocolVersion() < BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));                return true;            }        }        session.getUpstream().getSession().setPacketCodec(packetCodec);        session.setBlockMappings(BlockRegistries.BLOCKS.forVersion(loginPacket.getProtocolVersion()));        session.setItemMappings(Registries.ITEMS.forVersion(loginPacket.getProtocolVersion()));        LoginEncryptionUtils.encryptPlayerConnection(session, loginPacket);        PlayStatusPacket playStatus = new PlayStatusPacket();        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);        session.sendUpstreamPacket(playStatus);        ResourcePacksInfoPacket resourcePacksInfo = new ResourcePacksInfoPacket();        for(ResourcePack resourcePack : ResourcePack.PACKS.values()) {            ResourcePackManifest.Header header = resourcePack.getManifest().getHeader();            resourcePacksInfo.getResourcePackInfos().add(new ResourcePacksInfoPacket.Entry(                    header.getUuid().toString(), header.getVersionString(), resourcePack.getFile().length(),                            \"\", \"\", \"\", false, false));        }        resourcePacksInfo.setForcedToAccept(GeyserConnector.getInstance().getConfig().isForceResourcePacks());        session.sendUpstreamPacket(resourcePacksInfo);        return true;    }    @Override    public boolean handle(ResourcePackClientResponsePacket packet) {        switch (packet.getStatus()) {            case COMPLETED:                session.connect();                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.connect\", session.getAuthData().getName()));                break;            case SEND_PACKS:                for(String id : packet.getPackIds()) {                    ResourcePackDataInfoPacket data = new ResourcePackDataInfoPacket();                    String[] packID = id.split(\"_\");                    ResourcePack pack = ResourcePack.PACKS.get(packID[0]);                    ResourcePackManifest.Header header = pack.getManifest().getHeader();                    data.setPackId(header.getUuid());                    int chunkCount = (int) Math.ceil((int) pack.getFile().length() / (double) ResourcePack.CHUNK_SIZE);                    data.setChunkCount(chunkCount);                    data.setCompressedPackSize(pack.getFile().length());                    data.setMaxChunkSize(ResourcePack.CHUNK_SIZE);                    data.setHash(pack.getSha256());                    data.setPackVersion(packID[1]);                    data.setPremium(false);                    data.setType(ResourcePackType.RESOURCE);                    session.sendUpstreamPacket(data);                }                break;            case HAVE_ALL_PACKS:                ResourcePackStackPacket stackPacket = new ResourcePackStackPacket();                stackPacket.setExperimentsPreviouslyToggled(false);                stackPacket.setForcedToAccept(false);                 stackPacket.setGameVersion(session.getClientData().getGameVersion());                for (ResourcePack pack : ResourcePack.PACKS.values()) {                    ResourcePackManifest.Header header = pack.getManifest().getHeader();                    stackPacket.getResourcePacks().add(new ResourcePackStackPacket.Entry(header.getUuid().toString(), header.getVersionString(), \"\"));                }                if (session.getItemMappings().getFurnaceMinecartData() != null) {                    stackPacket.getExperiments().add(new ExperimentData(\"data_driven_items\", true));                }                if (session.getConnector().getConfig().isExtendedWorldHeight()) {                    stackPacket.getExperiments().add(new ExperimentData(\"caves_and_cliffs\", true));                }                session.sendUpstreamPacket(stackPacket);                break;            default:                session.disconnect(\"disconnectionScreen.resourcePack\");                break;        }        return true;    }    @Override    public boolean handle(ModalFormResponsePacket packet) {        session.executeInEventLoop(() -> session.getFormCache().handleResponse(packet));        return true;    }    private boolean couldLoginUserByName(String bedrockUsername) {        if (connector.getConfig().getUserAuths() != null) {            GeyserConfiguration.IUserAuthenticationInfo info = connector.getConfig().getUserAuths().get(bedrockUsername);            if (info != null) {                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.auth.stored_credentials\", session.getAuthData().getName()));                session.setMicrosoftAccount(info.isMicrosoftAccount());                session.authenticate(info.getEmail(), info.getPassword());                return true;            }        }        return false;    }    @Override    public boolean handle(SetLocalPlayerAsInitializedPacket packet) {        LanguageUtils.loadGeyserLocale(session.getLocale());        if (!session.isLoggedIn() && !session.isLoggingIn() && session.getRemoteAuthType() == AuthType.ONLINE) {            if (!couldLoginUserByName(session.getAuthData().getName())) {                LoginEncryptionUtils.buildAndShowLoginWindow(session);            }        }        return translateAndDefault(packet);    }    @Override    public boolean handle(MovePlayerPacket packet) {        if (session.isLoggingIn()) {            SetTitlePacket titlePacket = new SetTitlePacket();            titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);            titlePacket.setText(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.wait\", session.getLocale()));            titlePacket.setFadeInTime(0);            titlePacket.setFadeOutTime(1);            titlePacket.setStayTime(2);            titlePacket.setXuid(\"\");            titlePacket.setPlatformOnlineId(\"\");            session.sendUpstreamPacket(titlePacket);        }        return translateAndDefault(packet);    }    @Override    public boolean handle(ResourcePackChunkRequestPacket packet) {        ResourcePackChunkDataPacket data = new ResourcePackChunkDataPacket();        ResourcePack pack = ResourcePack.PACKS.get(packet.getPackId().toString());        data.setChunkIndex(packet.getChunkIndex());        data.setProgress(packet.getChunkIndex() * ResourcePack.CHUNK_SIZE);        data.setPackVersion(packet.getPackVersion());        data.setPackId(packet.getPackId());        int offset = packet.getChunkIndex() * ResourcePack.CHUNK_SIZE;        byte[] packData = new byte[(int) MathUtils.constrain(pack.getFile().length() - offset, 0, ResourcePack.CHUNK_SIZE)];        try (InputStream inputStream = new FileInputStream(pack.getFile())) {            inputStream.skip(offset);            inputStream.read(packData, 0, packData.length);        } catch (Exception e) {            e.printStackTrace();        }        data.setData(packData);        session.sendUpstreamPacket(data);        return true;    }}", "nl": "import com.nukkitx.protocol.bedrock.BedrockPacket;import com.nukkitx.protocol.bedrock.BedrockPacketCodec;import com.nukkitx.protocol.bedrock.data.ExperimentData;import com.nukkitx.protocol.bedrock.data.ResourcePackType;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.configuration.GeyserConfiguration;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslatorRegistry;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.utils.*;import java.io.FileInputStream;import java.io.InputStream;public class UpstreamPacketHandler extends LoggingPacketHandler {    public UpstreamPacketHandler(GeyserConnector connector, GeyserSession session) {        super(connector, session);    }    private boolean translateAndDefault(BedrockPacket packet) {        return PacketTranslatorRegistry.BEDROCK_TRANSLATOR.translate(packet.getClass(), packet, session);    }    @Override    boolean defaultHandler(BedrockPacket packet) {        return translateAndDefault(packet);    }    @Override    public boolean handle(LoginPacket loginPacket) {        BedrockPacketCodec packetCodec = BedrockProtocol.getBedrockCodec(loginPacket.getProtocolVersion());        if (packetCodec == null) {            String supportedVersions = BedrockProtocol.getAllSupportedVersions();            if (loginPacket.getProtocolVersion() > BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));                return true;            } else if (loginPacket.getProtocolVersion() < BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));                return true;            }        }        session.getUpstream().getSession().setPacketCodec(packetCodec);        session.setBlockMappings(BlockRegistries.BLOCKS.forVersion(loginPacket.getProtocolVersion()));        session.setItemMappings(Registries.ITEMS.forVersion(loginPacket.getProtocolVersion()));        LoginEncryptionUtils.encryptPlayerConnection(connector, session, loginPacket);        PlayStatusPacket playStatus = new PlayStatusPacket();        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);        session.sendUpstreamPacket(playStatus);        ResourcePacksInfoPacket resourcePacksInfo = new ResourcePacksInfoPacket();        for(ResourcePack resourcePack : ResourcePack.PACKS.values()) {            ResourcePackManifest.Header header = resourcePack.getManifest().getHeader();            resourcePacksInfo.getResourcePackInfos().add(new ResourcePacksInfoPacket.Entry(                    header.getUuid().toString(), header.getVersionString(), resourcePack.getFile().length(),                            \"\", \"\", \"\", false, false));        }        resourcePacksInfo.setForcedToAccept(GeyserConnector.getInstance().getConfig().isForceResourcePacks());        session.sendUpstreamPacket(resourcePacksInfo);        return true;    }    @Override    public boolean handle(ResourcePackClientResponsePacket packet) {        switch (packet.getStatus()) {            case COMPLETED:                session.connect();                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.connect\", session.getAuthData().getName()));                break;            case SEND_PACKS:                for(String id : packet.getPackIds()) {                    ResourcePackDataInfoPacket data = new ResourcePackDataInfoPacket();                    String[] packID = id.split(\"_\");                    ResourcePack pack = ResourcePack.PACKS.get(packID[0]);                    ResourcePackManifest.Header header = pack.getManifest().getHeader();                    data.setPackId(header.getUuid());                    int chunkCount = (int) Math.ceil((int) pack.getFile().length() / (double) ResourcePack.CHUNK_SIZE);                    data.setChunkCount(chunkCount);                    data.setCompressedPackSize(pack.getFile().length());                    data.setMaxChunkSize(ResourcePack.CHUNK_SIZE);                    data.setHash(pack.getSha256());                    data.setPackVersion(packID[1]);                    data.setPremium(false);                    data.setType(ResourcePackType.RESOURCE);                    session.sendUpstreamPacket(data);                }                break;            case HAVE_ALL_PACKS:                ResourcePackStackPacket stackPacket = new ResourcePackStackPacket();                stackPacket.setExperimentsPreviouslyToggled(false);                stackPacket.setForcedToAccept(false);                 stackPacket.setGameVersion(session.getClientData().getGameVersion());                for (ResourcePack pack : ResourcePack.PACKS.values()) {                    ResourcePackManifest.Header header = pack.getManifest().getHeader();                    stackPacket.getResourcePacks().add(new ResourcePackStackPacket.Entry(header.getUuid().toString(), header.getVersionString(), \"\"));                }                if (session.getItemMappings().getFurnaceMinecartData() != null) {                    stackPacket.getExperiments().add(new ExperimentData(\"data_driven_items\", true));                }                if (session.getConnector().getConfig().isExtendedWorldHeight()) {                    stackPacket.getExperiments().add(new ExperimentData(\"caves_and_cliffs\", true));                }                session.sendUpstreamPacket(stackPacket);                break;            default:                session.disconnect(\"disconnectionScreen.resourcePack\");                break;        }        return true;    }    @Override    public boolean handle(ModalFormResponsePacket packet) {        session.executeInEventLoop(() -> session.getFormCache().handleResponse(packet));        return true;    }    private boolean couldLoginUserByName(String bedrockUsername) {        if (connector.getConfig().getUserAuths() != null) {            GeyserConfiguration.IUserAuthenticationInfo info = connector.getConfig().getUserAuths().get(bedrockUsername);            if (info != null) {                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.auth.stored_credentials\", session.getAuthData().getName()));                session.setMicrosoftAccount(info.isMicrosoftAccount());                session.authenticate(info.getEmail(), info.getPassword());                return true;            }        }        return false;    }    @Override    public boolean handle(SetLocalPlayerAsInitializedPacket packet) {        LanguageUtils.loadGeyserLocale(session.getLocale());        if (!session.isLoggedIn() && !session.isLoggingIn() && session.getRemoteAuthType() == AuthType.ONLINE) {            if (!couldLoginUserByName(session.getAuthData().getName())) {                LoginEncryptionUtils.buildAndShowLoginWindow(session);            }        }        return translateAndDefault(packet);    }    @Override    public boolean handle(MovePlayerPacket packet) {        if (session.isLoggingIn()) {            SetTitlePacket titlePacket = new SetTitlePacket();            titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);            titlePacket.setText(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.wait\", session.getLocale()));            titlePacket.setFadeInTime(0);            titlePacket.setFadeOutTime(1);            titlePacket.setStayTime(2);            titlePacket.setXuid(\"\");            titlePacket.setPlatformOnlineId(\"\");            session.sendUpstreamPacket(titlePacket);        }        return translateAndDefault(packet);    }    @Override    public boolean handle(ResourcePackChunkRequestPacket packet) {        ResourcePackChunkDataPacket data = new ResourcePackChunkDataPacket();        ResourcePack pack = ResourcePack.PACKS.get(packet.getPackId().toString());        data.setChunkIndex(packet.getChunkIndex());        data.setProgress(packet.getChunkIndex() * ResourcePack.CHUNK_SIZE);        data.setPackVersion(packet.getPackVersion());        data.setPackId(packet.getPackId());        int offset = packet.getChunkIndex() * ResourcePack.CHUNK_SIZE;        byte[] packData = new byte[(int) MathUtils.constrain(pack.getFile().length() - offset, 0, ResourcePack.CHUNK_SIZE)];        try (InputStream inputStream = new FileInputStream(pack.getFile())) {            inputStream.skip(offset);            inputStream.read(packData, 0, packData.length);        } catch (Exception e) {            e.printStackTrace();        }        data.setData(packData);        session.sendUpstreamPacket(data);        return true;    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;public abstract class PacketTranslator<T> {    public abstract void translate(GeyserSession session, T packet);}", "nl": "import org.geysermc.connector.network.session.GeyserSession;public abstract class PacketTranslator<T> {    public abstract void translate(T packet, GeyserSession session);}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListDataPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateLightPacket;import com.github.steveice10.packetlib.packet.Packet;import com.nukkitx.protocol.bedrock.BedrockPacket;import io.netty.channel.EventLoop;import it.unimi.dsi.fastutil.objects.ObjectArrayList;import org.geysermc.common.PlatformType;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.utils.FileUtils;import org.geysermc.connector.utils.LanguageUtils;import java.util.IdentityHashMap;import java.util.Map;public class PacketTranslatorRegistry<T> {    private final Map<Class<? extends T>, PacketTranslator<? extends T>> translators = new IdentityHashMap<>();    public static final PacketTranslatorRegistry<Packet> JAVA_TRANSLATOR = new PacketTranslatorRegistry<>();    public static final PacketTranslatorRegistry<BedrockPacket> BEDROCK_TRANSLATOR = new PacketTranslatorRegistry<>();    private static final ObjectArrayList<Class<?>> IGNORED_PACKETS = new ObjectArrayList<>();    static {        for (Class<?> clazz : FileUtils.getGeneratedClassesForAnnotation(Translator.class)) {            Class<?> packet = clazz.getAnnotation(Translator.class).packet();            GeyserConnector.getInstance().getLogger().debug(\"Found annotated translator: \" + clazz.getCanonicalName() + \" : \" + packet.getSimpleName());            try {                if (Packet.class.isAssignableFrom(packet)) {                    Class<? extends Packet> targetPacket = (Class<? extends Packet>) packet;                    PacketTranslator<? extends Packet> translator = (PacketTranslator<? extends Packet>) clazz.newInstance();                    JAVA_TRANSLATOR.translators.put(targetPacket, translator);                } else if (BedrockPacket.class.isAssignableFrom(packet)) {                    Class<? extends BedrockPacket> targetPacket = (Class<? extends BedrockPacket>) packet;                    PacketTranslator<? extends BedrockPacket> translator = (PacketTranslator<? extends BedrockPacket>) clazz.newInstance();                    BEDROCK_TRANSLATOR.translators.put(targetPacket, translator);                } else {                    GeyserConnector.getInstance().getLogger().error(\"Class \" + clazz.getCanonicalName() + \" is annotated as a translator but has an invalid target packet.\");                }            } catch (InstantiationException | IllegalAccessException e) {                GeyserConnector.getInstance().getLogger().error(\"Could not instantiate annotated translator \" + clazz.getCanonicalName());            }        }        IGNORED_PACKETS.add(ServerUpdateLightPacket.class);         IGNORED_PACKETS.add(ServerPlayerListDataPacket.class);     }    private PacketTranslatorRegistry() {    }    public static void init() {    }    @SuppressWarnings(\"unchecked\")    public <P extends T> boolean translate(Class<? extends P> clazz, P packet, GeyserSession session) {        if (!session.getUpstream().isClosed() && !session.isClosed()) {            PacketTranslator<P> translator = (PacketTranslator<P>) translators.get(clazz);            if (translator != null) {                EventLoop eventLoop = session.getEventLoop();                if (eventLoop.inEventLoop()) {                    translate0(session, translator, packet);                } else {                    eventLoop.execute(() -> translate0(session, translator, packet));                }                return true;            } else {                if ((GeyserConnector.getInstance().getPlatformType() != PlatformType.STANDALONE || !(packet instanceof BedrockPacket)) && !IGNORED_PACKETS.contains(clazz)) {                    GeyserConnector.getInstance().getLogger().debug(\"Could not find packet for \" + (packet.toString().length() > 25 ? packet.getClass().getSimpleName() : packet));                }            }        }        return false;    }    private <P extends T> void translate0(GeyserSession session, PacketTranslator<P> translator, P packet) {        if (session.isClosed()) {            return;        }        try {            translator.translate(session, packet);        } catch (Throwable ex) {            GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.packet.failed\", packet.getClass().getSimpleName()), ex);            ex.printStackTrace();        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListDataPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateLightPacket;import com.github.steveice10.packetlib.packet.Packet;import com.nukkitx.protocol.bedrock.BedrockPacket;import io.netty.channel.EventLoop;import it.unimi.dsi.fastutil.objects.ObjectArrayList;import org.geysermc.common.PlatformType;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.utils.FileUtils;import org.geysermc.connector.utils.LanguageUtils;import java.util.IdentityHashMap;import java.util.Map;public class PacketTranslatorRegistry<T> {    private final Map<Class<? extends T>, PacketTranslator<? extends T>> translators = new IdentityHashMap<>();    public static final PacketTranslatorRegistry<Packet> JAVA_TRANSLATOR = new PacketTranslatorRegistry<>();    public static final PacketTranslatorRegistry<BedrockPacket> BEDROCK_TRANSLATOR = new PacketTranslatorRegistry<>();    private static final ObjectArrayList<Class<?>> IGNORED_PACKETS = new ObjectArrayList<>();    static {        for (Class<?> clazz : FileUtils.getGeneratedClassesForAnnotation(Translator.class)) {            Class<?> packet = clazz.getAnnotation(Translator.class).packet();            GeyserConnector.getInstance().getLogger().debug(\"Found annotated translator: \" + clazz.getCanonicalName() + \" : \" + packet.getSimpleName());            try {                if (Packet.class.isAssignableFrom(packet)) {                    Class<? extends Packet> targetPacket = (Class<? extends Packet>) packet;                    PacketTranslator<? extends Packet> translator = (PacketTranslator<? extends Packet>) clazz.newInstance();                    JAVA_TRANSLATOR.translators.put(targetPacket, translator);                } else if (BedrockPacket.class.isAssignableFrom(packet)) {                    Class<? extends BedrockPacket> targetPacket = (Class<? extends BedrockPacket>) packet;                    PacketTranslator<? extends BedrockPacket> translator = (PacketTranslator<? extends BedrockPacket>) clazz.newInstance();                    BEDROCK_TRANSLATOR.translators.put(targetPacket, translator);                } else {                    GeyserConnector.getInstance().getLogger().error(\"Class \" + clazz.getCanonicalName() + \" is annotated as a translator but has an invalid target packet.\");                }            } catch (InstantiationException | IllegalAccessException e) {                GeyserConnector.getInstance().getLogger().error(\"Could not instantiate annotated translator \" + clazz.getCanonicalName());            }        }        IGNORED_PACKETS.add(ServerUpdateLightPacket.class);         IGNORED_PACKETS.add(ServerPlayerListDataPacket.class);     }    private PacketTranslatorRegistry() {    }    public static void init() {    }    @SuppressWarnings(\"unchecked\")    public <P extends T> boolean translate(Class<? extends P> clazz, P packet, GeyserSession session) {        if (!session.getUpstream().isClosed() && !session.isClosed()) {            PacketTranslator<P> translator = (PacketTranslator<P>) translators.get(clazz);            if (translator != null) {                EventLoop eventLoop = session.getEventLoop();                if (eventLoop.inEventLoop()) {                    translate0(session, translator, packet);                } else {                    eventLoop.execute(() -> translate0(session, translator, packet));                }                return true;            } else {                if ((GeyserConnector.getInstance().getPlatformType() != PlatformType.STANDALONE || !(packet instanceof BedrockPacket)) && !IGNORED_PACKETS.contains(clazz)) {                    GeyserConnector.getInstance().getLogger().debug(\"Could not find packet for \" + (packet.toString().length() > 25 ? packet.getClass().getSimpleName() : packet));                }            }        }        return false;    }    private <P extends T> void translate0(GeyserSession session, PacketTranslator<P> translator, P packet) {        if (session.isClosed()) {            return;        }        try {            translator.translate(packet, session);        } catch (Throwable ex) {            GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.packet.failed\", packet.getClass().getSimpleName()), ex);            ex.printStackTrace();        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerAbilitiesPacket;import com.nukkitx.protocol.bedrock.data.AdventureSetting;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.AdventureSettingsPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = AdventureSettingsPacket.class)public class BedrockAdventureSettingsTranslator extends PacketTranslator<AdventureSettingsPacket> {    @Override    public void translate(GeyserSession session, AdventureSettingsPacket packet) {        boolean isFlying = packet.getSettings().contains(AdventureSetting.FLYING);        if (!isFlying && session.getGameMode() == GameMode.SPECTATOR) {            session.sendAdventureSettings();            return;        }        session.setFlying(isFlying);        ClientPlayerAbilitiesPacket abilitiesPacket = new ClientPlayerAbilitiesPacket(isFlying);        session.sendDownstreamPacket(abilitiesPacket);        if (isFlying && session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.SWIMMING)) {            session.setSwimming(false);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerAbilitiesPacket;import com.nukkitx.protocol.bedrock.data.AdventureSetting;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.AdventureSettingsPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = AdventureSettingsPacket.class)public class BedrockAdventureSettingsTranslator extends PacketTranslator<AdventureSettingsPacket> {    @Override    public void translate(AdventureSettingsPacket packet, GeyserSession session) {        boolean isFlying = packet.getSettings().contains(AdventureSetting.FLYING);        if (!isFlying && session.getGameMode() == GameMode.SPECTATOR) {            session.sendAdventureSettings();            return;        }        session.setFlying(isFlying);        ClientPlayerAbilitiesPacket abilitiesPacket = new ClientPlayerAbilitiesPacket(isFlying);        session.sendDownstreamPacket(abilitiesPacket);        if (isFlying && session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.SWIMMING)) {            session.setSwimming(false);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerSwingArmPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerBoatPacket;import com.nukkitx.protocol.bedrock.packet.AnimatePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.concurrent.TimeUnit;@Translator(packet = AnimatePacket.class)public class BedrockAnimateTranslator extends PacketTranslator<AnimatePacket> {    @Override    public void translate(GeyserSession session, AnimatePacket packet) {        if (!session.isSpawned()) {            return;        }        switch (packet.getAction()) {            case SWING_ARM:                session.scheduleInEventLoop(() ->                        session.sendDownstreamPacket(new ClientPlayerSwingArmPacket(Hand.MAIN_HAND)),                        25,                        TimeUnit.MILLISECONDS                );                break;            case ROW_LEFT:                session.setSteeringLeft(packet.getRowingTime() > 0.0);                ClientSteerBoatPacket steerLeftPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());                session.sendDownstreamPacket(steerLeftPacket);                break;            case ROW_RIGHT:                session.setSteeringRight(packet.getRowingTime() > 0.0);                ClientSteerBoatPacket steerRightPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());                session.sendDownstreamPacket(steerRightPacket);                break;        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerSwingArmPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerBoatPacket;import com.nukkitx.protocol.bedrock.packet.AnimatePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.concurrent.TimeUnit;@Translator(packet = AnimatePacket.class)public class BedrockAnimateTranslator extends PacketTranslator<AnimatePacket> {    @Override    public void translate(AnimatePacket packet, GeyserSession session) {        if (!session.isSpawned()) {            return;        }        switch (packet.getAction()) {            case SWING_ARM:                session.scheduleInEventLoop(() ->                        session.sendDownstreamPacket(new ClientPlayerSwingArmPacket(Hand.MAIN_HAND)),                        25,                        TimeUnit.MILLISECONDS                );                break;            case ROW_LEFT:                session.setSteeringLeft(packet.getRowingTime() > 0.0);                ClientSteerBoatPacket steerLeftPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());                session.sendDownstreamPacket(steerLeftPacket);                break;            case ROW_RIGHT:                session.setSteeringRight(packet.getRowingTime() > 0.0);                ClientSteerBoatPacket steerRightPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());                session.sendDownstreamPacket(steerRightPacket);                break;        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateJigsawBlockPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientUpdateSignPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.SignUtils;@Translator(packet = BlockEntityDataPacket.class)public class BedrockBlockEntityDataTranslator extends PacketTranslator<BlockEntityDataPacket> {    @Override    public void translate(GeyserSession session, BlockEntityDataPacket packet) {        NbtMap tag = packet.getData();        if (tag.getString(\"id\").equals(\"Sign\")) {            if (!tag.getString(\"Text\").equals(session.getLastSignMessage())) {                session.setLastSignMessage(tag.getString(\"Text\"));                return;            }            StringBuilder newMessage = new StringBuilder();            String[] lines = new String[] {\"\", \"\", \"\", \"\"};            int iterator = 0;            int widthCount = 0;            for (char character : tag.getString(\"Text\").toCharArray()) {                widthCount += SignUtils.getCharacterWidth(character);                if (character == '\\n' || widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX) {                    boolean wentOverMax = widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX && character != '\\n';                    widthCount = 0;                    String word = null;                    if (wentOverMax && iterator < lines.length - 1) {                        int index = newMessage.lastIndexOf(\" \");                        if (index != -1) {                            word = newMessage.substring(index + 1);                            newMessage.delete(index, newMessage.length());                        }                    }                    lines[iterator] = newMessage.toString();                    iterator++;                    if (iterator > lines.length - 1) {                        break;                    }                    newMessage = new StringBuilder();                    if (wentOverMax) {                        if (word != null) {                            newMessage.append(word);                            for (char wordCharacter : word.toCharArray()) {                                widthCount += SignUtils.getCharacterWidth(wordCharacter);                            }                        }                        newMessage.append(character);                        widthCount += SignUtils.getCharacterWidth(character);                    }                } else newMessage.append(character);            }            if (iterator < lines.length) lines[iterator] = newMessage.toString();            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));            ClientUpdateSignPacket clientUpdateSignPacket = new ClientUpdateSignPacket(pos, lines);            session.sendDownstreamPacket(clientUpdateSignPacket);            session.setLastSignMessage(null);        } else if (tag.getString(\"id\").equals(\"JigsawBlock\")) {            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));            String name = tag.getString(\"name\");            String target = tag.getString(\"target\");            String pool = tag.getString(\"target_pool\");            String finalState = tag.getString(\"final_state\");            String joint = tag.getString(\"joint\");            ClientUpdateJigsawBlockPacket jigsawPacket = new ClientUpdateJigsawBlockPacket(pos, name, target, pool,                    finalState, joint);            session.sendDownstreamPacket(jigsawPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateJigsawBlockPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientUpdateSignPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.SignUtils;@Translator(packet = BlockEntityDataPacket.class)public class BedrockBlockEntityDataTranslator extends PacketTranslator<BlockEntityDataPacket> {    @Override    public void translate(BlockEntityDataPacket packet, GeyserSession session) {        NbtMap tag = packet.getData();        if (tag.getString(\"id\").equals(\"Sign\")) {            if (!tag.getString(\"Text\").equals(session.getLastSignMessage())) {                session.setLastSignMessage(tag.getString(\"Text\"));                return;            }            StringBuilder newMessage = new StringBuilder();            String[] lines = new String[] {\"\", \"\", \"\", \"\"};            int iterator = 0;            int widthCount = 0;            for (char character : tag.getString(\"Text\").toCharArray()) {                widthCount += SignUtils.getCharacterWidth(character);                if (character == '\\n' || widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX) {                    boolean wentOverMax = widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX && character != '\\n';                    widthCount = 0;                    String word = null;                    if (wentOverMax && iterator < lines.length - 1) {                        int index = newMessage.lastIndexOf(\" \");                        if (index != -1) {                            word = newMessage.substring(index + 1);                            newMessage.delete(index, newMessage.length());                        }                    }                    lines[iterator] = newMessage.toString();                    iterator++;                    if (iterator > lines.length - 1) {                        break;                    }                    newMessage = new StringBuilder();                    if (wentOverMax) {                        if (word != null) {                            newMessage.append(word);                            for (char wordCharacter : word.toCharArray()) {                                widthCount += SignUtils.getCharacterWidth(wordCharacter);                            }                        }                        newMessage.append(character);                        widthCount += SignUtils.getCharacterWidth(character);                    }                } else newMessage.append(character);            }            if (iterator < lines.length) lines[iterator] = newMessage.toString();            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));            ClientUpdateSignPacket clientUpdateSignPacket = new ClientUpdateSignPacket(pos, lines);            session.sendDownstreamPacket(clientUpdateSignPacket);            session.setLastSignMessage(null);        } else if (tag.getString(\"id\").equals(\"JigsawBlock\")) {            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));            String name = tag.getString(\"name\");            String target = tag.getString(\"target\");            String pool = tag.getString(\"target_pool\");            String finalState = tag.getString(\"final_state\");            String joint = tag.getString(\"joint\");            ClientUpdateJigsawBlockPacket jigsawPacket = new ClientUpdateJigsawBlockPacket(pos, name, target, pool,                    finalState, joint);            session.sendDownstreamPacket(jigsawPacket);        }    }}"}
{"code": "    import com.nukkitx.math.vector.Vector3i; import com.nukkitx.protocol.bedrock.packet.BlockPickRequestPacket; import org.geysermc.connector.entity.ItemFrameEntity; import org.geysermc.connector.entity.type.EntityType; import org.geysermc.connector.network.session.GeyserSession; import org.geysermc.connector.network.translators.PacketTranslator; import org.geysermc.connector.network.translators.Translator; import org.geysermc.connector.network.translators.world.block.BlockStateValues; import org.geysermc.connector.registry.BlockRegistries; import org.geysermc.connector.utils.InventoryUtils;  @Translator(packet = BlockPickRequestPacket.class) public class BedrockBlockPickRequestTranslator extends PacketTranslator<BlockPickRequestPacket> {      @Override     public void translate(GeyserSession session, BlockPickRequestPacket packet) {         Vector3i vector = packet.getBlockPosition();         int blockToPick = session.getConnector().getWorldManager().getBlockAt(session, vector.getX(), vector.getY(), vector.getZ());                  if (blockToPick == BlockStateValues.JAVA_AIR_ID) {             ItemFrameEntity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());             if (entity != null) {                 if (entity.getHeldItem() != null && entity.getHeldItem().getId() != 0) {                     InventoryUtils.findOrCreateItem(session, entity.getHeldItem());                 } else {                     InventoryUtils.findOrCreateItem(session, entity.getEntityType() == EntityType.GLOW_ITEM_FRAME ? \"minecraft:glow_item_frame\" : \"minecraft:item_frame\");                 }             }             return;         }          InventoryUtils.findOrCreateItem(session, BlockRegistries.JAVA_BLOCKS.get(blockToPick).getPickItem());     } } ", "nl": "    import com.nukkitx.math.vector.Vector3i; import com.nukkitx.protocol.bedrock.packet.BlockPickRequestPacket; import org.geysermc.connector.entity.ItemFrameEntity; import org.geysermc.connector.entity.type.EntityType; import org.geysermc.connector.network.session.GeyserSession; import org.geysermc.connector.network.translators.PacketTranslator; import org.geysermc.connector.network.translators.Translator; import org.geysermc.connector.network.translators.world.block.BlockStateValues; import org.geysermc.connector.registry.BlockRegistries; import org.geysermc.connector.utils.InventoryUtils;  @Translator(packet = BlockPickRequestPacket.class) public class BedrockBlockPickRequestTranslator extends PacketTranslator<BlockPickRequestPacket> {      @Override     public void translate(BlockPickRequestPacket packet, GeyserSession session) {         Vector3i vector = packet.getBlockPosition();         int blockToPick = session.getConnector().getWorldManager().getBlockAt(session, vector.getX(), vector.getY(), vector.getZ());                  if (blockToPick == BlockStateValues.JAVA_AIR_ID) {             ItemFrameEntity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());             if (entity != null) {                 if (entity.getHeldItem() != null && entity.getHeldItem().getId() != 0) {                     InventoryUtils.findOrCreateItem(session, entity.getHeldItem());                 } else {                     InventoryUtils.findOrCreateItem(session, entity.getEntityType() == EntityType.GLOW_ITEM_FRAME ? \"minecraft:glow_item_frame\" : \"minecraft:item_frame\");                 }             }             return;         }          InventoryUtils.findOrCreateItem(session, BlockRegistries.JAVA_BLOCKS.get(blockToPick).getPickItem());     } } "}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientEditBookPacket;import com.github.steveice10.opennbt.tag.builtin.CompoundTag;import com.github.steveice10.opennbt.tag.builtin.ListTag;import com.github.steveice10.opennbt.tag.builtin.StringTag;import com.github.steveice10.opennbt.tag.builtin.Tag;import com.nukkitx.protocol.bedrock.packet.BookEditPacket;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;@Translator(packet = BookEditPacket.class)public class BedrockBookEditTranslator extends PacketTranslator<BookEditPacket> {    private static final int MAXIMUM_PAGE_LENGTH = 8192 * 4;    private static final int MAXIMUM_TITLE_LENGTH = 128 * 4;    @Override    public void translate(GeyserSession session, BookEditPacket packet) {        if (packet.getText() != null && !packet.getText().isEmpty() && packet.getText().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_PAGE_LENGTH) {            session.getConnector().getLogger().warning(\"Page length greater than server allowed!\");            return;        }        GeyserItemStack itemStack = session.getPlayerInventory().getItemInHand();        if (itemStack != null) {            CompoundTag tag = itemStack.getNbt() != null ? itemStack.getNbt() : new CompoundTag(\"\");            ItemStack bookItem = new ItemStack(itemStack.getJavaId(), itemStack.getAmount(), tag);            List<Tag> pages = tag.contains(\"pages\") ? new LinkedList<>(((ListTag) tag.get(\"pages\")).getValue()) : new LinkedList<>();            int page = packet.getPageNumber();            switch (packet.getAction()) {                case ADD_PAGE: {                    for (int i = pages.size(); i < page; i++) {                        pages.add(i, new StringTag(\"\", \"\"));                    }                    pages.add(page, new StringTag(\"\", packet.getText()));                    break;                }                case REPLACE_PAGE: {                    if (page < pages.size()) {                        pages.set(page, new StringTag(\"\", packet.getText()));                    } else {                        for (int i = pages.size(); i < page; i++) {                            pages.add(i, new StringTag(\"\", \"\"));                        }                        pages.add(page, new StringTag(\"\", packet.getText()));                    }                    break;                }                case DELETE_PAGE: {                    if (page < pages.size()) {                        pages.remove(page);                    }                    break;                }                case SWAP_PAGES: {                    int page2 = packet.getSecondaryPageNumber();                    if (page < pages.size() && page2 < pages.size()) {                        Collections.swap(pages, page, page2);                    }                    break;                }                case SIGN_BOOK: {                    tag.put(new StringTag(\"author\", packet.getAuthor()));                    tag.put(new StringTag(\"title\", packet.getTitle()));                    break;                }                default:                    return;            }            while (pages.size() > 0) {                StringTag currentPage = (StringTag) pages.get(pages.size() - 1);                if (currentPage.getValue() == null || currentPage.getValue().isEmpty()) {                    pages.remove(pages.size() - 1);                } else {                    break;                }            }            tag.put(new ListTag(\"pages\", pages));            session.getPlayerInventory().setItem(36 + session.getPlayerInventory().getHeldItemSlot(), GeyserItemStack.from(bookItem), session);            session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());            List<String> networkPages = new ArrayList<>();            for (Tag pageTag : pages) {                networkPages.add(((StringTag) pageTag).getValue());            }            String title;            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {                if (packet.getTitle().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_TITLE_LENGTH) {                    session.getConnector().getLogger().warning(\"Book title larger than server allows!\");                    return;                }                title = packet.getTitle();            } else {                title = null;            }            session.getBookEditCache().setPacket(new ClientEditBookPacket(session.getPlayerInventory().getHeldItemSlot(), networkPages, title));            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {                session.getBookEditCache().checkForSend();            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientEditBookPacket;import com.github.steveice10.opennbt.tag.builtin.CompoundTag;import com.github.steveice10.opennbt.tag.builtin.ListTag;import com.github.steveice10.opennbt.tag.builtin.StringTag;import com.github.steveice10.opennbt.tag.builtin.Tag;import com.nukkitx.protocol.bedrock.packet.BookEditPacket;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;@Translator(packet = BookEditPacket.class)public class BedrockBookEditTranslator extends PacketTranslator<BookEditPacket> {    private static final int MAXIMUM_PAGE_LENGTH = 8192 * 4;    private static final int MAXIMUM_TITLE_LENGTH = 128 * 4;    @Override    public void translate(BookEditPacket packet, GeyserSession session) {        if (packet.getText() != null && !packet.getText().isEmpty() && packet.getText().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_PAGE_LENGTH) {            session.getConnector().getLogger().warning(\"Page length greater than server allowed!\");            return;        }        GeyserItemStack itemStack = session.getPlayerInventory().getItemInHand();        if (itemStack != null) {            CompoundTag tag = itemStack.getNbt() != null ? itemStack.getNbt() : new CompoundTag(\"\");            ItemStack bookItem = new ItemStack(itemStack.getJavaId(), itemStack.getAmount(), tag);            List<Tag> pages = tag.contains(\"pages\") ? new LinkedList<>(((ListTag) tag.get(\"pages\")).getValue()) : new LinkedList<>();            int page = packet.getPageNumber();            switch (packet.getAction()) {                case ADD_PAGE: {                    for (int i = pages.size(); i < page; i++) {                        pages.add(i, new StringTag(\"\", \"\"));                    }                    pages.add(page, new StringTag(\"\", packet.getText()));                    break;                }                case REPLACE_PAGE: {                    if (page < pages.size()) {                        pages.set(page, new StringTag(\"\", packet.getText()));                    } else {                        for (int i = pages.size(); i < page; i++) {                            pages.add(i, new StringTag(\"\", \"\"));                        }                        pages.add(page, new StringTag(\"\", packet.getText()));                    }                    break;                }                case DELETE_PAGE: {                    if (page < pages.size()) {                        pages.remove(page);                    }                    break;                }                case SWAP_PAGES: {                    int page2 = packet.getSecondaryPageNumber();                    if (page < pages.size() && page2 < pages.size()) {                        Collections.swap(pages, page, page2);                    }                    break;                }                case SIGN_BOOK: {                    tag.put(new StringTag(\"author\", packet.getAuthor()));                    tag.put(new StringTag(\"title\", packet.getTitle()));                    break;                }                default:                    return;            }            while (pages.size() > 0) {                StringTag currentPage = (StringTag) pages.get(pages.size() - 1);                if (currentPage.getValue() == null || currentPage.getValue().isEmpty()) {                    pages.remove(pages.size() - 1);                } else {                    break;                }            }            tag.put(new ListTag(\"pages\", pages));            session.getPlayerInventory().setItem(36 + session.getPlayerInventory().getHeldItemSlot(), GeyserItemStack.from(bookItem), session);            session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());            List<String> networkPages = new ArrayList<>();            for (Tag pageTag : pages) {                networkPages.add(((StringTag) pageTag).getValue());            }            String title;            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {                if (packet.getTitle().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_TITLE_LENGTH) {                    session.getConnector().getLogger().warning(\"Book title larger than server allows!\");                    return;                }                title = packet.getTitle();            } else {                title = null;            }            session.getBookEditCache().setPacket(new ClientEditBookPacket(session.getPlayerInventory().getHeldItemSlot(), networkPages, title));            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {                session.getBookEditCache().checkForSend();            }        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.world.block.CommandBlockMode;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockMinecartPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockPacket;import com.nukkitx.protocol.bedrock.packet.CommandBlockUpdatePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = CommandBlockUpdatePacket.class)public class BedrockCommandBlockUpdateTranslator extends PacketTranslator<CommandBlockUpdatePacket> {    @Override    public void translate(GeyserSession session, CommandBlockUpdatePacket packet) {        String command = packet.getCommand();        boolean outputTracked = packet.isOutputTracked();        if (packet.isBlock()) {            CommandBlockMode mode;            switch (packet.getMode()) {                case CHAIN:                     mode = CommandBlockMode.SEQUENCE;                    break;                case REPEATING:                     mode = CommandBlockMode.AUTO;                    break;                default:                     mode = CommandBlockMode.REDSTONE;                    break;            }            boolean isConditional = packet.isConditional();            boolean automatic = !packet.isRedstoneMode();             ClientUpdateCommandBlockPacket commandBlockPacket = new ClientUpdateCommandBlockPacket(                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),                    command, mode, outputTracked, isConditional, automatic);            session.sendDownstreamPacket(commandBlockPacket);        } else {            ClientUpdateCommandBlockMinecartPacket commandMinecartPacket = new ClientUpdateCommandBlockMinecartPacket(                    (int) session.getEntityCache().getEntityByGeyserId(packet.getMinecartRuntimeEntityId()).getEntityId(),                    command, outputTracked            );            session.sendDownstreamPacket(commandMinecartPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.world.block.CommandBlockMode;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockMinecartPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockPacket;import com.nukkitx.protocol.bedrock.packet.CommandBlockUpdatePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = CommandBlockUpdatePacket.class)public class BedrockCommandBlockUpdateTranslator extends PacketTranslator<CommandBlockUpdatePacket> {    @Override    public void translate(CommandBlockUpdatePacket packet, GeyserSession session) {        String command = packet.getCommand();        boolean outputTracked = packet.isOutputTracked();        if (packet.isBlock()) {            CommandBlockMode mode;            switch (packet.getMode()) {                case CHAIN:                     mode = CommandBlockMode.SEQUENCE;                    break;                case REPEATING:                     mode = CommandBlockMode.AUTO;                    break;                default:                     mode = CommandBlockMode.REDSTONE;                    break;            }            boolean isConditional = packet.isConditional();            boolean automatic = !packet.isRedstoneMode();             ClientUpdateCommandBlockPacket commandBlockPacket = new ClientUpdateCommandBlockPacket(                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),                    command, mode, outputTracked, isConditional, automatic);            session.sendDownstreamPacket(commandBlockPacket);        } else {            ClientUpdateCommandBlockMinecartPacket commandMinecartPacket = new ClientUpdateCommandBlockMinecartPacket(                    (int) session.getEntityCache().getEntityByGeyserId(packet.getMinecartRuntimeEntityId()).getEntityId(),                    command, outputTracked            );            session.sendDownstreamPacket(commandMinecartPacket);        }    }}"}
{"code": "import org.geysermc.common.PlatformType;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.command.CommandManager;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;import com.nukkitx.protocol.bedrock.packet.CommandRequestPacket;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = CommandRequestPacket.class)public class BedrockCommandRequestTranslator extends PacketTranslator<CommandRequestPacket> {    @Override    public void translate(GeyserSession session, CommandRequestPacket packet) {        String command = packet.getCommand().replace(\"/\", \"\");        CommandManager commandManager = GeyserConnector.getInstance().getCommandManager();        if (session.getConnector().getPlatformType() == PlatformType.STANDALONE && command.trim().startsWith(\"geyser \") && commandManager.getCommands().containsKey(command.split(\" \")[1])) {            commandManager.runCommand(session, command);        } else {            String message = packet.getCommand().trim();            if (MessageTranslator.isTooLong(message, session)) {                return;            }            ClientChatPacket chatPacket = new ClientChatPacket(message);            session.sendDownstreamPacket(chatPacket);        }    }}", "nl": "import org.geysermc.common.PlatformType;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.command.CommandManager;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;import com.nukkitx.protocol.bedrock.packet.CommandRequestPacket;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = CommandRequestPacket.class)public class BedrockCommandRequestTranslator extends PacketTranslator<CommandRequestPacket> {    @Override    public void translate(CommandRequestPacket packet, GeyserSession session) {        String command = packet.getCommand().replace(\"/\", \"\");        CommandManager commandManager = GeyserConnector.getInstance().getCommandManager();        if (session.getConnector().getPlatformType() == PlatformType.STANDALONE && command.trim().startsWith(\"geyser \") && commandManager.getCommands().containsKey(command.split(\" \")[1])) {            commandManager.runCommand(session, command);        } else {            String message = packet.getCommand().trim();            if (MessageTranslator.isTooLong(message, session)) {                return;            }            ClientChatPacket chatPacket = new ClientChatPacket(message);            session.sendDownstreamPacket(chatPacket);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;import com.nukkitx.protocol.bedrock.packet.ContainerClosePacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.inventory.MerchantContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ContainerClosePacket.class)public class BedrockContainerCloseTranslator extends PacketTranslator<ContainerClosePacket> {    @Override    public void translate(GeyserSession session, ContainerClosePacket packet) {        byte windowId = packet.getId();        session.sendUpstreamPacket(packet);        session.setClosingInventory(false);        if (windowId == -1 && session.getOpenInventory() instanceof MerchantContainer) {            windowId = (byte) session.getOpenInventory().getId();        }        Inventory openInventory = session.getOpenInventory();        if (openInventory != null) {            if (windowId == openInventory.getId()) {                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(windowId);                session.sendDownstreamPacket(closeWindowPacket);                InventoryUtils.closeInventory(session, windowId, false);            } else if (openInventory.isPending()) {                InventoryUtils.displayInventory(session, openInventory);                openInventory.setPending(false);            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;import com.nukkitx.protocol.bedrock.packet.ContainerClosePacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.inventory.MerchantContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ContainerClosePacket.class)public class BedrockContainerCloseTranslator extends PacketTranslator<ContainerClosePacket> {    @Override    public void translate(ContainerClosePacket packet, GeyserSession session) {        byte windowId = packet.getId();        session.sendUpstreamPacket(packet);        session.setClosingInventory(false);        if (windowId == -1 && session.getOpenInventory() instanceof MerchantContainer) {            windowId = (byte) session.getOpenInventory().getId();        }        Inventory openInventory = session.getOpenInventory();        if (openInventory != null) {            if (windowId == openInventory.getId()) {                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(windowId);                session.sendDownstreamPacket(closeWindowPacket);                InventoryUtils.closeInventory(session, windowId, false);            } else if (openInventory.isPending()) {                InventoryUtils.displayInventory(session, openInventory);                openInventory.setPending(false);            }        }    }}"}
{"code": "import com.nukkitx.protocol.bedrock.packet.EmoteListPacket;import org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = EmoteListPacket.class)public class BedrockEmoteListTranslator extends PacketTranslator<EmoteListPacket> {    @Override    public void translate(GeyserSession session, EmoteListPacket packet) {        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {            return;        }        session.refreshEmotes(packet.getPieceIds());    }}", "nl": "import com.nukkitx.protocol.bedrock.packet.EmoteListPacket;import org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = EmoteListPacket.class)public class BedrockEmoteListTranslator extends PacketTranslator<EmoteListPacket> {    @Override    public void translate(EmoteListPacket packet, GeyserSession session) {        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {            return;        }        session.refreshEmotes(packet.getPieceIds());    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.packet.EntityPickRequestPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = EntityPickRequestPacket.class)public class BedrockEntityPickRequestTranslator extends PacketTranslator<EntityPickRequestPacket> {    @Override    public void translate(GeyserSession session, EntityPickRequestPacket packet) {        if (session.getGameMode() != GameMode.CREATIVE) return;         Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());        if (entity == null) return;        String itemName;        switch (entity.getEntityType()) {            case BOAT:                int variant = entity.getMetadata().getInt(EntityData.VARIANT);                String typeOfBoat;                switch (variant) {                    case 1:                        typeOfBoat = \"spruce\";                        break;                    case 2:                        typeOfBoat = \"birch\";                        break;                    case 3:                        typeOfBoat = \"jungle\";                        break;                    case 4:                        typeOfBoat = \"acacia\";                        break;                    case 5:                        typeOfBoat = \"dark_oak\";                        break;                    default:                        typeOfBoat = \"oak\";                        break;                }                itemName = typeOfBoat + \"_boat\";                break;            case LEASH_KNOT:                itemName = \"lead\";                break;            case MINECART_CHEST:            case MINECART_COMMAND_BLOCK:            case MINECART_FURNACE:            case MINECART_HOPPER:            case MINECART_TNT:                itemName = entity.getEntityType().toString().toLowerCase().replace(\"minecart_\", \"\") + \"_minecart\";                break;            case MINECART_SPAWNER:                itemName = \"minecart\";                break;            case ARMOR_STAND:            case END_CRYSTAL:            case MINECART:            case PAINTING:                itemName = entity.getEntityType().toString().toLowerCase();                break;            default:                itemName = entity.getEntityType().toString().toLowerCase() + \"_spawn_egg\";                break;        }        String fullItemName = \"minecraft:\" + itemName;        ItemMapping mapping = session.getItemMappings().getMapping(fullItemName);        if (mapping == null) return;        InventoryUtils.findOrCreateItem(session, fullItemName);    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.packet.EntityPickRequestPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = EntityPickRequestPacket.class)public class BedrockEntityPickRequestTranslator extends PacketTranslator<EntityPickRequestPacket> {    @Override    public void translate(EntityPickRequestPacket packet, GeyserSession session) {        if (session.getGameMode() != GameMode.CREATIVE) return;         Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());        if (entity == null) return;        String itemName;        switch (entity.getEntityType()) {            case BOAT:                int variant = entity.getMetadata().getInt(EntityData.VARIANT);                String typeOfBoat;                switch (variant) {                    case 1:                        typeOfBoat = \"spruce\";                        break;                    case 2:                        typeOfBoat = \"birch\";                        break;                    case 3:                        typeOfBoat = \"jungle\";                        break;                    case 4:                        typeOfBoat = \"acacia\";                        break;                    case 5:                        typeOfBoat = \"dark_oak\";                        break;                    default:                        typeOfBoat = \"oak\";                        break;                }                itemName = typeOfBoat + \"_boat\";                break;            case LEASH_KNOT:                itemName = \"lead\";                break;            case MINECART_CHEST:            case MINECART_COMMAND_BLOCK:            case MINECART_FURNACE:            case MINECART_HOPPER:            case MINECART_TNT:                itemName = entity.getEntityType().toString().toLowerCase().replace(\"minecart_\", \"\") + \"_minecart\";                break;            case MINECART_SPAWNER:                itemName = \"minecart\";                break;            case ARMOR_STAND:            case END_CRYSTAL:            case MINECART:            case PAINTING:                itemName = entity.getEntityType().toString().toLowerCase();                break;            default:                itemName = entity.getEntityType().toString().toLowerCase() + \"_spawn_egg\";                break;        }        String fullItemName = \"minecraft:\" + itemName;        ItemMapping mapping = session.getItemMappings().getMapping(fullItemName);        if (mapping == null) return;        InventoryUtils.findOrCreateItem(session, fullItemName);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientRenameItemPacket;import com.nukkitx.protocol.bedrock.packet.FilterTextPacket;import org.geysermc.connector.inventory.AnvilContainer;import org.geysermc.connector.inventory.CartographyContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = FilterTextPacket.class)public class BedrockFilterTextTranslator extends PacketTranslator<FilterTextPacket> {    @Override    public void translate(GeyserSession session, FilterTextPacket packet) {        if (session.getOpenInventory() instanceof CartographyContainer) {            return;        }        packet.setFromServer(true);        session.sendUpstreamPacket(packet);        if (session.getOpenInventory() instanceof AnvilContainer) {            ClientRenameItemPacket renameItemPacket = new ClientRenameItemPacket(packet.getText());            session.sendDownstreamPacket(renameItemPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientRenameItemPacket;import com.nukkitx.protocol.bedrock.packet.FilterTextPacket;import org.geysermc.connector.inventory.AnvilContainer;import org.geysermc.connector.inventory.CartographyContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = FilterTextPacket.class)public class BedrockFilterTextTranslator extends PacketTranslator<FilterTextPacket> {    @Override    public void translate(FilterTextPacket packet, GeyserSession session) {        if (session.getOpenInventory() instanceof CartographyContainer) {            return;        }        packet.setFromServer(true);        session.sendUpstreamPacket(packet);        if (session.getOpenInventory() instanceof AnvilContainer) {            ClientRenameItemPacket renameItemPacket = new ClientRenameItemPacket(packet.getText());            session.sendDownstreamPacket(renameItemPacket);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.inventory.*;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.CommandBlockMinecartEntity;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemFrameEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.sound.EntitySoundInteractionHandler;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.registry.type.ItemMappings;import org.geysermc.connector.utils.BlockUtils;import java.util.concurrent.TimeUnit;@Translator(packet = InventoryTransactionPacket.class)public class BedrockInventoryTransactionTranslator extends PacketTranslator<InventoryTransactionPacket> {    private static final float MAXIMUM_BLOCK_PLACING_DISTANCE = 64f;    private static final int CREATIVE_EYE_HEIGHT_PLACE_DISTANCE = 49;    private static final int SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE = 36;    private static final float MAXIMUM_BLOCK_DESTROYING_DISTANCE = 36f;    @Override    public void translate(GeyserSession session, InventoryTransactionPacket packet) {        session.getBookEditCache().checkForSend();        ItemMappings mappings = session.getItemMappings();        switch (packet.getTransactionType()) {            case NORMAL:                if (packet.getActions().size() == 2) {                    InventoryActionData worldAction = packet.getActions().get(0);                    InventoryActionData containerAction = packet.getActions().get(1);                    if (worldAction.getSource().getType() == InventorySource.Type.WORLD_INTERACTION                            && worldAction.getSource().getFlag() == InventorySource.Flag.DROP_ITEM) {                        if (session.getPlayerInventory().getHeldItemSlot() != containerAction.getSlot() ||                                session.getPlayerInventory().getItemInHand().isEmpty()) {                            return;                        }                        boolean dropAll = worldAction.getToItem().getCount() > 1;                        ClientPlayerActionPacket dropAllPacket = new ClientPlayerActionPacket(                                dropAll ? PlayerAction.DROP_ITEM_STACK : PlayerAction.DROP_ITEM,                                BlockUtils.POSITION_ZERO,                                BlockFace.DOWN                        );                        session.sendDownstreamPacket(dropAllPacket);                        if (dropAll) {                            session.getPlayerInventory().setItemInHand(GeyserItemStack.EMPTY);                        } else {                            session.getPlayerInventory().getItemInHand().sub(1);                        }                    }                }                break;            case INVENTORY_MISMATCH:                break;            case ITEM_USE:                switch (packet.getActionType()) {                    case 0:                        boolean hasAlreadyClicked = System.currentTimeMillis() - session.getLastInteractionTime() < 110.0 &&                                packet.getBlockPosition().distanceSquared(session.getLastInteractionBlockPosition()) < 0.00001;                        session.setLastInteractionBlockPosition(packet.getBlockPosition());                        session.setLastInteractionPlayerPosition(session.getPlayerEntity().getPosition());                        if (hasAlreadyClicked) {                            break;                        } else {                            session.setLastInteractionTime(System.currentTimeMillis());                        }                        if (session.getBlockMappings().isItemFrame(packet.getBlockRuntimeId())) {                            Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());                            if (itemFrameEntity != null) {                                int entityId = (int) itemFrameEntity.getEntityId();                                Vector3f vector = packet.getClickPosition();                                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket(entityId,                                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());                                ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket(entityId,                                        InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());                                session.sendDownstreamPacket(interactPacket);                                session.sendDownstreamPacket(interactAtPacket);                                break;                            }                        }                        Vector3i blockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getBlockFace());                        Vector3f playerPosition = session.getPlayerEntity().getPosition();                        switch (session.getPose()) {                            case SNEAKING:                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 1.27f), 0);                                break;                            case SWIMMING:                            case FALL_FLYING:                             case SPIN_ATTACK:                                 playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.4f), 0);                                break;                            case SLEEPING:                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.2f), 0);                                break;                        }                         float diffX = playerPosition.getX() - packet.getBlockPosition().getX();                        float diffY = playerPosition.getY() - packet.getBlockPosition().getY();                        float diffZ = playerPosition.getZ() - packet.getBlockPosition().getZ();                        if (((diffX * diffX) + (diffY * diffY) + (diffZ * diffZ)) >                                (session.getGameMode().equals(GameMode.CREATIVE) ? CREATIVE_EYE_HEIGHT_PLACE_DISTANCE : SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE)) {                            restoreCorrectBlock(session, blockPos, packet);                            return;                        }                        if (!(session.getPlayerEntity().getPosition().sub(0, EntityType.PLAYER.getOffset(), 0)                                .distanceSquared(packet.getBlockPosition().toFloat().add(0.5f, 0.5f, 0.5f)) < MAXIMUM_BLOCK_PLACING_DISTANCE)) {                            restoreCorrectBlock(session, blockPos, packet);                            return;                        }                        if (packet.getItemInHand() != null && session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {                            int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());                            if (blockState == BlockStateValues.JAVA_WATER_ID) {                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                                session.sendDownstreamPacket(itemPacket);                                break;                            }                        }                        ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(                                new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),                                BlockFace.values()[packet.getBlockFace()],                                Hand.MAIN_HAND,                                packet.getClickPosition().getX(), packet.getClickPosition().getY(), packet.getClickPosition().getZ(),                                false);                        session.sendDownstreamPacket(blockPacket);                        if (packet.getItemInHand() != null) {                            if (session.getItemMappings().getBoatIds().contains(packet.getItemInHand().getId())) {                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                                session.sendDownstreamPacket(itemPacket);                            } else if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId())) {                                InventorySlotPacket slotPacket = new InventorySlotPacket();                                slotPacket.setContainerId(ContainerId.INVENTORY);                                slotPacket.setSlot(packet.getHotbarSlot());                                slotPacket.setItem(packet.getItemInHand());                                session.sendUpstreamPacket(slotPacket);                                if (packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().powderSnowBucket().getBedrockId()) {                                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());                                    if (session.isSneaking() || blockState != BlockRegistries.JAVA_IDENTIFIERS.get(\"minecraft:crafting_table\")) {                                        session.setBucketScheduledFuture(session.scheduleInEventLoop(() -> {                                            ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                                            session.sendDownstreamPacket(itemPacket);                                        }, 5, TimeUnit.MILLISECONDS));                                    }                                }                            }                        }                        if (packet.getActions().isEmpty()) {                            if (session.getOpPermissionLevel() >= 2 && session.getGameMode() == GameMode.CREATIVE) {                                int blockState = session.getBlockMappings().getJavaBlockState(packet.getBlockRuntimeId());                                String blockName = BlockRegistries.JAVA_IDENTIFIERS.get().getOrDefault(blockState, \"\");                                if (blockName.contains(\"jigsaw\")) {                                    ContainerOpenPacket openPacket = new ContainerOpenPacket();                                    openPacket.setBlockPosition(packet.getBlockPosition());                                    openPacket.setId((byte) 1);                                    openPacket.setType(ContainerType.JIGSAW_EDITOR);                                    openPacket.setUniqueEntityId(-1);                                    session.sendUpstreamPacket(openPacket);                                }                            }                        }                        ItemMapping handItem = mappings.getMapping(packet.getItemInHand());                        if (handItem.isBlock()) {                            session.setLastBlockPlacePosition(blockPos);                            session.setLastBlockPlacedId(handItem.getJavaIdentifier());                        }                        session.setInteracting(true);                        break;                    case 1:                        if (packet.getActions().size() == 1 && packet.getLegacySlots().size() > 0) {                            InventoryActionData actionData = packet.getActions().get(0);                            LegacySetItemSlotData slotData = packet.getLegacySlots().get(0);                            if (slotData.getContainerId() == 6 && actionData.getToItem().getId() != 0) {                                session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());                            }                        }                        if (session.getPlayerInventory().getItemInHand().getJavaId() == mappings.getStoredItems().shield().getJavaId()) {                            break;                        }                        if (packet.getItemInHand() != null) {                            if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId()) &&                                    packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().milkBucket().getBedrockId()) {                                break;                            } else if (session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {                                break;                            }                        }                        ClientPlayerUseItemPacket useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                        session.sendDownstreamPacket(useItemPacket);                        break;                    case 2:                        int blockState = session.getGameMode() == GameMode.CREATIVE ?                                session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition()) : session.getBreakingBlock();                        session.setLastBlockPlacedId(null);                        session.setLastBlockPlacePosition(null);                        playerPosition = session.getPlayerEntity().getPosition();                        Vector3f floatBlockPosition = packet.getBlockPosition().toFloat();                        diffX = playerPosition.getX() - (floatBlockPosition.getX() + 0.5f);                        diffY = (playerPosition.getY() - EntityType.PLAYER.getOffset()) - (floatBlockPosition.getY() + 0.5f) + 1.5f;                        diffZ = playerPosition.getZ() - (floatBlockPosition.getZ() + 0.5f);                        float distanceSquared = diffX * diffX + diffY * diffY + diffZ * diffZ;                        if (distanceSquared > MAXIMUM_BLOCK_DESTROYING_DISTANCE) {                            restoreCorrectBlock(session, packet.getBlockPosition(), packet);                            return;                        }                        LevelEventPacket blockBreakPacket = new LevelEventPacket();                        blockBreakPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);                        blockBreakPacket.setPosition(packet.getBlockPosition().toFloat());                        blockBreakPacket.setData(session.getBlockMappings().getBedrockBlockId(blockState));                        session.sendUpstreamPacket(blockBreakPacket);                        session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);                        Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());                        if (itemFrameEntity != null) {                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),                                    InteractAction.ATTACK, session.isSneaking());                            session.sendDownstreamPacket(attackPacket);                            break;                        }                        PlayerAction action = session.getGameMode() == GameMode.CREATIVE ? PlayerAction.START_DIGGING : PlayerAction.FINISH_DIGGING;                        Position pos = new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ());                        ClientPlayerActionPacket breakPacket = new ClientPlayerActionPacket(action, pos, BlockFace.values()[packet.getBlockFace()]);                        session.sendDownstreamPacket(breakPacket);                        break;                }                break;            case ITEM_RELEASE:                if (packet.getActionType() == 0) {                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO,                            BlockFace.DOWN);                    session.sendDownstreamPacket(releaseItemPacket);                }                break;            case ITEM_USE_ON_ENTITY:                Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());                if (entity == null)                    return;                switch (packet.getActionType()) {                    case 0:                         if (entity instanceof CommandBlockMinecartEntity) {                            if (session.getOpPermissionLevel() < 2 || session.getGameMode() != GameMode.CREATIVE) return;                            ContainerOpenPacket openPacket = new ContainerOpenPacket();                            openPacket.setBlockPosition(Vector3i.ZERO);                            openPacket.setId((byte) 1);                            openPacket.setType(ContainerType.COMMAND_BLOCK);                            openPacket.setUniqueEntityId(entity.getGeyserId());                            session.sendUpstreamPacket(openPacket);                            break;                        }                        Vector3f vector = packet.getClickPosition().sub(entity.getPosition());                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                                InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());                        ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                                InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());                        session.sendDownstreamPacket(interactPacket);                        session.sendDownstreamPacket(interactAtPacket);                        EntitySoundInteractionHandler.handleEntityInteraction(session, packet.getClickPosition(), entity);                        break;                    case 1:                         if (entity.getEntityType() == EntityType.ENDER_DRAGON) {                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId() + 3,                                    InteractAction.ATTACK, session.isSneaking());                            session.sendDownstreamPacket(attackPacket);                        } else {                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                                    InteractAction.ATTACK, session.isSneaking());                            session.sendDownstreamPacket(attackPacket);                        }                        break;                }                break;        }    }    private void restoreCorrectBlock(GeyserSession session, Vector3i blockPos, InventoryTransactionPacket packet) {        int javaBlockState = session.getConnector().getWorldManager().getBlockAt(session, blockPos);        UpdateBlockPacket updateBlockPacket = new UpdateBlockPacket();        updateBlockPacket.setDataLayer(0);        updateBlockPacket.setBlockPosition(blockPos);        updateBlockPacket.setRuntimeId(session.getBlockMappings().getBedrockBlockId(javaBlockState));        updateBlockPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);        session.sendUpstreamPacket(updateBlockPacket);        UpdateBlockPacket updateWaterPacket = new UpdateBlockPacket();        updateWaterPacket.setDataLayer(1);        updateWaterPacket.setBlockPosition(blockPos);        updateWaterPacket.setRuntimeId(BlockRegistries.WATERLOGGED.get().contains(javaBlockState) ? session.getBlockMappings().getBedrockWaterId() : session.getBlockMappings().getBedrockAirId());        updateWaterPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);        session.sendUpstreamPacket(updateWaterPacket);        InventorySlotPacket slotPacket = new InventorySlotPacket();        slotPacket.setContainerId(ContainerId.INVENTORY);        slotPacket.setSlot(packet.getHotbarSlot());        slotPacket.setItem(packet.getItemInHand());        session.sendUpstreamPacket(slotPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.inventory.*;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.CommandBlockMinecartEntity;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemFrameEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.sound.EntitySoundInteractionHandler;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.registry.type.ItemMappings;import org.geysermc.connector.utils.BlockUtils;import java.util.concurrent.TimeUnit;@Translator(packet = InventoryTransactionPacket.class)public class BedrockInventoryTransactionTranslator extends PacketTranslator<InventoryTransactionPacket> {    private static final float MAXIMUM_BLOCK_PLACING_DISTANCE = 64f;    private static final int CREATIVE_EYE_HEIGHT_PLACE_DISTANCE = 49;    private static final int SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE = 36;    private static final float MAXIMUM_BLOCK_DESTROYING_DISTANCE = 36f;    @Override    public void translate(InventoryTransactionPacket packet, GeyserSession session) {        session.getBookEditCache().checkForSend();        ItemMappings mappings = session.getItemMappings();        switch (packet.getTransactionType()) {            case NORMAL:                if (packet.getActions().size() == 2) {                    InventoryActionData worldAction = packet.getActions().get(0);                    InventoryActionData containerAction = packet.getActions().get(1);                    if (worldAction.getSource().getType() == InventorySource.Type.WORLD_INTERACTION                            && worldAction.getSource().getFlag() == InventorySource.Flag.DROP_ITEM) {                        if (session.getPlayerInventory().getHeldItemSlot() != containerAction.getSlot() ||                                session.getPlayerInventory().getItemInHand().isEmpty()) {                            return;                        }                        boolean dropAll = worldAction.getToItem().getCount() > 1;                        ClientPlayerActionPacket dropAllPacket = new ClientPlayerActionPacket(                                dropAll ? PlayerAction.DROP_ITEM_STACK : PlayerAction.DROP_ITEM,                                BlockUtils.POSITION_ZERO,                                BlockFace.DOWN                        );                        session.sendDownstreamPacket(dropAllPacket);                        if (dropAll) {                            session.getPlayerInventory().setItemInHand(GeyserItemStack.EMPTY);                        } else {                            session.getPlayerInventory().getItemInHand().sub(1);                        }                    }                }                break;            case INVENTORY_MISMATCH:                break;            case ITEM_USE:                switch (packet.getActionType()) {                    case 0:                        boolean hasAlreadyClicked = System.currentTimeMillis() - session.getLastInteractionTime() < 110.0 &&                                packet.getBlockPosition().distanceSquared(session.getLastInteractionBlockPosition()) < 0.00001;                        session.setLastInteractionBlockPosition(packet.getBlockPosition());                        session.setLastInteractionPlayerPosition(session.getPlayerEntity().getPosition());                        if (hasAlreadyClicked) {                            break;                        } else {                            session.setLastInteractionTime(System.currentTimeMillis());                        }                        if (session.getBlockMappings().isItemFrame(packet.getBlockRuntimeId())) {                            Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());                            if (itemFrameEntity != null) {                                int entityId = (int) itemFrameEntity.getEntityId();                                Vector3f vector = packet.getClickPosition();                                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket(entityId,                                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());                                ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket(entityId,                                        InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());                                session.sendDownstreamPacket(interactPacket);                                session.sendDownstreamPacket(interactAtPacket);                                break;                            }                        }                        Vector3i blockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getBlockFace());                        Vector3f playerPosition = session.getPlayerEntity().getPosition();                        switch (session.getPose()) {                            case SNEAKING:                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 1.27f), 0);                                break;                            case SWIMMING:                            case FALL_FLYING:                             case SPIN_ATTACK:                                 playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.4f), 0);                                break;                            case SLEEPING:                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.2f), 0);                                break;                        }                         float diffX = playerPosition.getX() - packet.getBlockPosition().getX();                        float diffY = playerPosition.getY() - packet.getBlockPosition().getY();                        float diffZ = playerPosition.getZ() - packet.getBlockPosition().getZ();                        if (((diffX * diffX) + (diffY * diffY) + (diffZ * diffZ)) >                                (session.getGameMode().equals(GameMode.CREATIVE) ? CREATIVE_EYE_HEIGHT_PLACE_DISTANCE : SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE)) {                            restoreCorrectBlock(session, blockPos, packet);                            return;                        }                        if (!(session.getPlayerEntity().getPosition().sub(0, EntityType.PLAYER.getOffset(), 0)                                .distanceSquared(packet.getBlockPosition().toFloat().add(0.5f, 0.5f, 0.5f)) < MAXIMUM_BLOCK_PLACING_DISTANCE)) {                            restoreCorrectBlock(session, blockPos, packet);                            return;                        }                        if (packet.getItemInHand() != null && session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {                            int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());                            if (blockState == BlockStateValues.JAVA_WATER_ID) {                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                                session.sendDownstreamPacket(itemPacket);                                break;                            }                        }                        ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(                                new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),                                BlockFace.values()[packet.getBlockFace()],                                Hand.MAIN_HAND,                                packet.getClickPosition().getX(), packet.getClickPosition().getY(), packet.getClickPosition().getZ(),                                false);                        session.sendDownstreamPacket(blockPacket);                        if (packet.getItemInHand() != null) {                            if (session.getItemMappings().getBoatIds().contains(packet.getItemInHand().getId())) {                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                                session.sendDownstreamPacket(itemPacket);                            } else if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId())) {                                InventorySlotPacket slotPacket = new InventorySlotPacket();                                slotPacket.setContainerId(ContainerId.INVENTORY);                                slotPacket.setSlot(packet.getHotbarSlot());                                slotPacket.setItem(packet.getItemInHand());                                session.sendUpstreamPacket(slotPacket);                                if (packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().powderSnowBucket().getBedrockId()) {                                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());                                    if (session.isSneaking() || blockState != BlockRegistries.JAVA_IDENTIFIERS.get(\"minecraft:crafting_table\")) {                                        session.setBucketScheduledFuture(session.scheduleInEventLoop(() -> {                                            ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                                            session.sendDownstreamPacket(itemPacket);                                        }, 5, TimeUnit.MILLISECONDS));                                    }                                }                            }                        }                        if (packet.getActions().isEmpty()) {                            if (session.getOpPermissionLevel() >= 2 && session.getGameMode() == GameMode.CREATIVE) {                                int blockState = session.getBlockMappings().getJavaBlockState(packet.getBlockRuntimeId());                                String blockName = BlockRegistries.JAVA_IDENTIFIERS.get().getOrDefault(blockState, \"\");                                if (blockName.contains(\"jigsaw\")) {                                    ContainerOpenPacket openPacket = new ContainerOpenPacket();                                    openPacket.setBlockPosition(packet.getBlockPosition());                                    openPacket.setId((byte) 1);                                    openPacket.setType(ContainerType.JIGSAW_EDITOR);                                    openPacket.setUniqueEntityId(-1);                                    session.sendUpstreamPacket(openPacket);                                }                            }                        }                        ItemMapping handItem = mappings.getMapping(packet.getItemInHand());                        if (handItem.isBlock()) {                            session.setLastBlockPlacePosition(blockPos);                            session.setLastBlockPlacedId(handItem.getJavaIdentifier());                        }                        session.setInteracting(true);                        break;                    case 1:                        if (packet.getActions().size() == 1 && packet.getLegacySlots().size() > 0) {                            InventoryActionData actionData = packet.getActions().get(0);                            LegacySetItemSlotData slotData = packet.getLegacySlots().get(0);                            if (slotData.getContainerId() == 6 && actionData.getToItem().getId() != 0) {                                session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());                            }                        }                        if (session.getPlayerInventory().getItemInHand().getJavaId() == mappings.getStoredItems().shield().getJavaId()) {                            break;                        }                        if (packet.getItemInHand() != null) {                            if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId()) &&                                    packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().milkBucket().getBedrockId()) {                                break;                            } else if (session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {                                break;                            }                        }                        ClientPlayerUseItemPacket useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                        session.sendDownstreamPacket(useItemPacket);                        break;                    case 2:                        int blockState = session.getGameMode() == GameMode.CREATIVE ?                                session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition()) : session.getBreakingBlock();                        session.setLastBlockPlacedId(null);                        session.setLastBlockPlacePosition(null);                        playerPosition = session.getPlayerEntity().getPosition();                        Vector3f floatBlockPosition = packet.getBlockPosition().toFloat();                        diffX = playerPosition.getX() - (floatBlockPosition.getX() + 0.5f);                        diffY = (playerPosition.getY() - EntityType.PLAYER.getOffset()) - (floatBlockPosition.getY() + 0.5f) + 1.5f;                        diffZ = playerPosition.getZ() - (floatBlockPosition.getZ() + 0.5f);                        float distanceSquared = diffX * diffX + diffY * diffY + diffZ * diffZ;                        if (distanceSquared > MAXIMUM_BLOCK_DESTROYING_DISTANCE) {                            restoreCorrectBlock(session, packet.getBlockPosition(), packet);                            return;                        }                        LevelEventPacket blockBreakPacket = new LevelEventPacket();                        blockBreakPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);                        blockBreakPacket.setPosition(packet.getBlockPosition().toFloat());                        blockBreakPacket.setData(session.getBlockMappings().getBedrockBlockId(blockState));                        session.sendUpstreamPacket(blockBreakPacket);                        session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);                        Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());                        if (itemFrameEntity != null) {                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),                                    InteractAction.ATTACK, session.isSneaking());                            session.sendDownstreamPacket(attackPacket);                            break;                        }                        PlayerAction action = session.getGameMode() == GameMode.CREATIVE ? PlayerAction.START_DIGGING : PlayerAction.FINISH_DIGGING;                        Position pos = new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ());                        ClientPlayerActionPacket breakPacket = new ClientPlayerActionPacket(action, pos, BlockFace.values()[packet.getBlockFace()]);                        session.sendDownstreamPacket(breakPacket);                        break;                }                break;            case ITEM_RELEASE:                if (packet.getActionType() == 0) {                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO,                            BlockFace.DOWN);                    session.sendDownstreamPacket(releaseItemPacket);                }                break;            case ITEM_USE_ON_ENTITY:                Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());                if (entity == null)                    return;                switch (packet.getActionType()) {                    case 0:                         if (entity instanceof CommandBlockMinecartEntity) {                            if (session.getOpPermissionLevel() < 2 || session.getGameMode() != GameMode.CREATIVE) return;                            ContainerOpenPacket openPacket = new ContainerOpenPacket();                            openPacket.setBlockPosition(Vector3i.ZERO);                            openPacket.setId((byte) 1);                            openPacket.setType(ContainerType.COMMAND_BLOCK);                            openPacket.setUniqueEntityId(entity.getGeyserId());                            session.sendUpstreamPacket(openPacket);                            break;                        }                        Vector3f vector = packet.getClickPosition().sub(entity.getPosition());                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                                InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());                        ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                                InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());                        session.sendDownstreamPacket(interactPacket);                        session.sendDownstreamPacket(interactAtPacket);                        EntitySoundInteractionHandler.handleEntityInteraction(session, packet.getClickPosition(), entity);                        break;                    case 1:                         if (entity.getEntityType() == EntityType.ENDER_DRAGON) {                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId() + 3,                                    InteractAction.ATTACK, session.isSneaking());                            session.sendDownstreamPacket(attackPacket);                        } else {                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                                    InteractAction.ATTACK, session.isSneaking());                            session.sendDownstreamPacket(attackPacket);                        }                        break;                }                break;        }    }    private void restoreCorrectBlock(GeyserSession session, Vector3i blockPos, InventoryTransactionPacket packet) {        int javaBlockState = session.getConnector().getWorldManager().getBlockAt(session, blockPos);        UpdateBlockPacket updateBlockPacket = new UpdateBlockPacket();        updateBlockPacket.setDataLayer(0);        updateBlockPacket.setBlockPosition(blockPos);        updateBlockPacket.setRuntimeId(session.getBlockMappings().getBedrockBlockId(javaBlockState));        updateBlockPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);        session.sendUpstreamPacket(updateBlockPacket);        UpdateBlockPacket updateWaterPacket = new UpdateBlockPacket();        updateWaterPacket.setDataLayer(1);        updateWaterPacket.setBlockPosition(blockPos);        updateWaterPacket.setRuntimeId(BlockRegistries.WATERLOGGED.get().contains(javaBlockState) ? session.getBlockMappings().getBedrockWaterId() : session.getBlockMappings().getBedrockAirId());        updateWaterPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);        session.sendUpstreamPacket(updateWaterPacket);        InventorySlotPacket slotPacket = new InventorySlotPacket();        slotPacket.setContainerId(ContainerId.INVENTORY);        slotPacket.setSlot(packet.getHotbarSlot());        slotPacket.setItem(packet.getItemInHand());        session.sendUpstreamPacket(slotPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;import com.nukkitx.protocol.bedrock.packet.ItemFrameDropItemPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemFrameEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ItemFrameDropItemPacket.class)public class BedrockItemFrameDropItemTranslator extends PacketTranslator<ItemFrameDropItemPacket> {    @Override    public void translate(GeyserSession session, ItemFrameDropItemPacket packet) {        Entity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());        if (entity != null) {            ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                    InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());            session.sendDownstreamPacket(interactPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;import com.nukkitx.protocol.bedrock.packet.ItemFrameDropItemPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemFrameEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ItemFrameDropItemPacket.class)public class BedrockItemFrameDropItemTranslator extends PacketTranslator<ItemFrameDropItemPacket> {    @Override    public void translate(ItemFrameDropItemPacket packet, GeyserSession session) {        Entity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());        if (entity != null) {            ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                    InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());            session.sendDownstreamPacket(interactPacket);        }    }}"}
{"code": "import com.nukkitx.protocol.bedrock.packet.ItemStackRequestPacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;@Translator(packet = ItemStackRequestPacket.class)public class BedrockItemStackRequestTranslator extends PacketTranslator<ItemStackRequestPacket> {    @Override    public void translate(GeyserSession session, ItemStackRequestPacket packet) {        Inventory inventory = session.getOpenInventory();        if (inventory == null)            return;        InventoryTranslator translator = session.getInventoryTranslator();        translator.translateRequests(session, inventory, packet.getRequests());    }}", "nl": "import com.nukkitx.protocol.bedrock.packet.ItemStackRequestPacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;@Translator(packet = ItemStackRequestPacket.class)public class BedrockItemStackRequestTranslator extends PacketTranslator<ItemStackRequestPacket> {    @Override    public void translate(ItemStackRequestPacket packet, GeyserSession session) {        Inventory inventory = session.getOpenInventory();        if (inventory == null)            return;        InventoryTranslator translator = session.getInventoryTranslator();        translator.translateRequests(session, inventory, packet.getRequests());    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientClickWindowButtonPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;import com.nukkitx.protocol.bedrock.packet.LecternUpdatePacket;import org.geysermc.connector.inventory.LecternContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = LecternUpdatePacket.class)public class BedrockLecternUpdateTranslator extends PacketTranslator<LecternUpdatePacket> {    @Override    public void translate(GeyserSession session, LecternUpdatePacket packet) {        if (packet.isDroppingBook()) {            session.setDroppingLecternBook(true);            ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),                    BlockFace.DOWN,                    Hand.MAIN_HAND,                    0, 0, 0,                     false);            session.sendDownstreamPacket(blockPacket);        } else {            if (!(session.getOpenInventory() instanceof LecternContainer)) {                session.getConnector().getLogger().debug(\"Expected lectern but it wasn't open!\");                return;            }            LecternContainer lecternContainer = (LecternContainer) session.getOpenInventory();            if (lecternContainer.getCurrentBedrockPage() == packet.getPage()) {                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(lecternContainer.getId());                session.sendDownstreamPacket(closeWindowPacket);                InventoryUtils.closeInventory(session, lecternContainer.getId(), false);            } else {                int newJavaPage = (packet.getPage() * 2);                int currentJavaPage = (lecternContainer.getCurrentBedrockPage() * 2);                if (newJavaPage > currentJavaPage) {                    for (int i = currentJavaPage; i < newJavaPage; i++) {                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 2);                        session.sendDownstreamPacket(clickButtonPacket);                    }                } else {                    for (int i = currentJavaPage; i > newJavaPage; i--) {                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 1);                        session.sendDownstreamPacket(clickButtonPacket);                    }                }            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientClickWindowButtonPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;import com.nukkitx.protocol.bedrock.packet.LecternUpdatePacket;import org.geysermc.connector.inventory.LecternContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = LecternUpdatePacket.class)public class BedrockLecternUpdateTranslator extends PacketTranslator<LecternUpdatePacket> {    @Override    public void translate(LecternUpdatePacket packet, GeyserSession session) {        if (packet.isDroppingBook()) {            session.setDroppingLecternBook(true);            ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),                    BlockFace.DOWN,                    Hand.MAIN_HAND,                    0, 0, 0,                     false);            session.sendDownstreamPacket(blockPacket);        } else {            if (!(session.getOpenInventory() instanceof LecternContainer)) {                session.getConnector().getLogger().debug(\"Expected lectern but it wasn't open!\");                return;            }            LecternContainer lecternContainer = (LecternContainer) session.getOpenInventory();            if (lecternContainer.getCurrentBedrockPage() == packet.getPage()) {                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(lecternContainer.getId());                session.sendDownstreamPacket(closeWindowPacket);                InventoryUtils.closeInventory(session, lecternContainer.getId(), false);            } else {                int newJavaPage = (packet.getPage() * 2);                int currentJavaPage = (lecternContainer.getCurrentBedrockPage() * 2);                if (newJavaPage > currentJavaPage) {                    for (int i = currentJavaPage; i < newJavaPage; i++) {                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 2);                        session.sendDownstreamPacket(clickButtonPacket);                    }                } else {                    for (int i = currentJavaPage; i > newJavaPage; i--) {                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 1);                        session.sendDownstreamPacket(clickButtonPacket);                    }                }            }        }    }}"}
{"code": "import com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;import com.nukkitx.protocol.bedrock.packet.MapInfoRequestPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.concurrent.TimeUnit;@Translator(packet = MapInfoRequestPacket.class)public class BedrockMapInfoRequestTranslator extends PacketTranslator<MapInfoRequestPacket> {    @Override    public void translate(GeyserSession session, MapInfoRequestPacket packet) {        long mapId = packet.getUniqueMapId();        ClientboundMapItemDataPacket mapPacket = session.getStoredMaps().remove(mapId);        if (mapPacket != null) {            GeyserConnector.getInstance().getGeneralThreadPool().schedule(() -> session.sendUpstreamPacket(mapPacket),                    100, TimeUnit.MILLISECONDS);        }    }}", "nl": "import com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;import com.nukkitx.protocol.bedrock.packet.MapInfoRequestPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.concurrent.TimeUnit;@Translator(packet = MapInfoRequestPacket.class)public class BedrockMapInfoRequestTranslator extends PacketTranslator<MapInfoRequestPacket> {    @Override    public void translate(MapInfoRequestPacket packet, GeyserSession session) {        long mapId = packet.getUniqueMapId();        ClientboundMapItemDataPacket mapPacket = session.getStoredMaps().remove(mapId);        if (mapPacket != null) {            GeyserConnector.getInstance().getGeneralThreadPool().schedule(() -> session.sendUpstreamPacket(mapPacket),                    100, TimeUnit.MILLISECONDS);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerChangeHeldItemPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;import com.nukkitx.protocol.bedrock.data.inventory.ContainerId;import com.nukkitx.protocol.bedrock.packet.MobEquipmentPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.CooldownUtils;import org.geysermc.connector.utils.InteractiveTagManager;import java.util.concurrent.TimeUnit;@Translator(packet = MobEquipmentPacket.class)public class BedrockMobEquipmentTranslator extends PacketTranslator<MobEquipmentPacket> {    @Override    public void translate(GeyserSession session, MobEquipmentPacket packet) {        if (!session.isSpawned() || packet.getHotbarSlot() > 8 ||                packet.getContainerId() != ContainerId.INVENTORY || session.getPlayerInventory().getHeldItemSlot() == packet.getHotbarSlot()) {            return;        }        session.getBookEditCache().checkForSend();        session.getPlayerInventory().setHeldItemSlot(packet.getHotbarSlot());        ClientPlayerChangeHeldItemPacket changeHeldItemPacket = new ClientPlayerChangeHeldItemPacket(packet.getHotbarSlot());        session.sendDownstreamPacket(changeHeldItemPacket);        if (session.isSneaking() && session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {            session.getConnector().getGeneralThreadPool().schedule(() -> session.sendDownstreamPacket(new ClientPlayerUseItemPacket(Hand.MAIN_HAND)),                    50, TimeUnit.MILLISECONDS);        }        CooldownUtils.sendCooldown(session);        if (session.getMouseoverEntity() != null) {            InteractiveTagManager.updateTag(session, session.getMouseoverEntity());        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerChangeHeldItemPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;import com.nukkitx.protocol.bedrock.data.inventory.ContainerId;import com.nukkitx.protocol.bedrock.packet.MobEquipmentPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.CooldownUtils;import org.geysermc.connector.utils.InteractiveTagManager;import java.util.concurrent.TimeUnit;@Translator(packet = MobEquipmentPacket.class)public class BedrockMobEquipmentTranslator extends PacketTranslator<MobEquipmentPacket> {    @Override    public void translate(MobEquipmentPacket packet, GeyserSession session) {        if (!session.isSpawned() || packet.getHotbarSlot() > 8 ||                packet.getContainerId() != ContainerId.INVENTORY || session.getPlayerInventory().getHeldItemSlot() == packet.getHotbarSlot()) {            return;        }        session.getBookEditCache().checkForSend();        session.getPlayerInventory().setHeldItemSlot(packet.getHotbarSlot());        ClientPlayerChangeHeldItemPacket changeHeldItemPacket = new ClientPlayerChangeHeldItemPacket(packet.getHotbarSlot());        session.sendDownstreamPacket(changeHeldItemPacket);        if (session.isSneaking() && session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {            session.getConnector().getGeneralThreadPool().schedule(() -> session.sendDownstreamPacket(new ClientPlayerUseItemPacket(Hand.MAIN_HAND)),                    50, TimeUnit.MILLISECONDS);        }        CooldownUtils.sendCooldown(session);        if (session.getMouseoverEntity() != null) {            InteractiveTagManager.updateTag(session, session.getMouseoverEntity());        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;import com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;import org.geysermc.connector.entity.BoatEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = MoveEntityAbsolutePacket.class)public class BedrockMoveEntityAbsoluteTranslator extends PacketTranslator<MoveEntityAbsolutePacket> {    @Override    public void translate(GeyserSession session, MoveEntityAbsolutePacket packet) {        session.setLastVehicleMoveTimestamp(System.currentTimeMillis());        float y = packet.getPosition().getY();        if (session.getRidingVehicleEntity() instanceof BoatEntity) {            y -= EntityType.BOAT.getOffset();        }        ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(                packet.getPosition().getX(), y, packet.getPosition().getZ(),                packet.getRotation().getY() - 90, packet.getRotation().getX()        );        session.sendDownstreamPacket(clientVehicleMovePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;import com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;import org.geysermc.connector.entity.BoatEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = MoveEntityAbsolutePacket.class)public class BedrockMoveEntityAbsoluteTranslator extends PacketTranslator<MoveEntityAbsolutePacket> {    @Override    public void translate(MoveEntityAbsolutePacket packet, GeyserSession session) {        session.setLastVehicleMoveTimestamp(System.currentTimeMillis());        float y = packet.getPosition().getY();        if (session.getRidingVehicleEntity() instanceof BoatEntity) {            y -= EntityType.BOAT.getOffset();        }        ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(                packet.getPosition().getX(), y, packet.getPosition().getZ(),                packet.getRotation().getY() - 90, packet.getRotation().getX()        );        session.sendDownstreamPacket(clientVehicleMovePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.ClientKeepAlivePacket;import com.nukkitx.protocol.bedrock.data.AttributeData;import com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;import com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.floodgate.util.DeviceOs;import java.util.Collections;import java.util.concurrent.TimeUnit;@Translator(packet = NetworkStackLatencyPacket.class)public class BedrockNetworkStackLatencyTranslator extends PacketTranslator<NetworkStackLatencyPacket> {    @Override    public void translate(GeyserSession session, NetworkStackLatencyPacket packet) {        long pingId;        if (session.getClientData().getDeviceOs().equals(DeviceOs.PS4)) {            pingId = packet.getTimestamp();        } else {            pingId = packet.getTimestamp() / 1000;        }        if (packet.getTimestamp() > 0) {            if (session.getConnector().getConfig().isForwardPlayerPing()) {                ClientKeepAlivePacket keepAlivePacket = new ClientKeepAlivePacket(pingId);                session.sendDownstreamPacket(keepAlivePacket);            }            return;        }        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());        AttributeData attribute = session.getPlayerEntity().getAttributes().get(GeyserAttributeType.EXPERIENCE_LEVEL);        if (attribute != null) {            attributesPacket.setAttributes(Collections.singletonList(attribute));        } else {            attributesPacket.setAttributes(Collections.singletonList(GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(0)));        }        session.getConnector().getGeneralThreadPool().schedule(                () -> session.sendUpstreamPacket(attributesPacket),                500, TimeUnit.MILLISECONDS);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.ClientKeepAlivePacket;import com.nukkitx.protocol.bedrock.data.AttributeData;import com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;import com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.floodgate.util.DeviceOs;import java.util.Collections;import java.util.concurrent.TimeUnit;@Translator(packet = NetworkStackLatencyPacket.class)public class BedrockNetworkStackLatencyTranslator extends PacketTranslator<NetworkStackLatencyPacket> {    @Override    public void translate(NetworkStackLatencyPacket packet, GeyserSession session) {        long pingId;        if (session.getClientData().getDeviceOs().equals(DeviceOs.PS4)) {            pingId = packet.getTimestamp();        } else {            pingId = packet.getTimestamp() / 1000;        }        if (packet.getTimestamp() > 0) {            if (session.getConnector().getConfig().isForwardPlayerPing()) {                ClientKeepAlivePacket keepAlivePacket = new ClientKeepAlivePacket(pingId);                session.sendDownstreamPacket(keepAlivePacket);            }            return;        }        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());        AttributeData attribute = session.getPlayerEntity().getAttributes().get(GeyserAttributeType.EXPERIENCE_LEVEL);        if (attribute != null) {            attributesPacket.setAttributes(Collections.singletonList(attribute));        } else {            attributesPacket.setAttributes(Collections.singletonList(GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(0)));        }        session.getConnector().getGeneralThreadPool().schedule(                () -> session.sendUpstreamPacket(attributesPacket),                500, TimeUnit.MILLISECONDS);    }}"}
{"code": "import com.nukkitx.protocol.bedrock.packet.PacketViolationWarningPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = PacketViolationWarningPacket.class)public class BedrockPacketViolationWarningTranslator extends PacketTranslator<PacketViolationWarningPacket> {    @Override    public void translate(GeyserSession session, PacketViolationWarningPacket packet) {        session.getConnector().getLogger().error(\"Packet violation warning sent from client! \" + packet.toString());    }}", "nl": "import com.nukkitx.protocol.bedrock.packet.PacketViolationWarningPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = PacketViolationWarningPacket.class)public class BedrockPacketViolationWarningTranslator extends PacketTranslator<PacketViolationWarningPacket> {    @Override    public void translate(PacketViolationWarningPacket packet, GeyserSession session) {        session.getConnector().getLogger().error(\"Packet violation warning sent from client! \" + packet.toString());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerVehiclePacket;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.packet.PlayerInputPacket;import org.geysermc.connector.entity.BoatEntity;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.entity.living.animal.horse.LlamaEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = PlayerInputPacket.class)public class BedrockPlayerInputTranslator extends PacketTranslator<PlayerInputPacket> {    @Override    public void translate(GeyserSession session, PlayerInputPacket packet) {        ClientSteerVehiclePacket clientSteerVehiclePacket = new ClientSteerVehiclePacket(                packet.getInputMotion().getX(), packet.getInputMotion().getY(), packet.isJumping(), packet.isSneaking()        );        session.sendDownstreamPacket(clientSteerVehiclePacket);        Entity vehicle = session.getRidingVehicleEntity();        boolean sendMovement = false;        if (vehicle instanceof AbstractHorseEntity && !(vehicle instanceof LlamaEntity)) {            sendMovement = vehicle.isOnGround();        } else if (vehicle instanceof BoatEntity) {            if (vehicle.getPassengers().size() == 1) {                sendMovement = true;            } else {                Vector3f seatPos = session.getPlayerEntity().getMetadata().getVector3f(EntityData.RIDER_SEAT_POSITION, null);                if (seatPos != null && seatPos.getX() > 0) {                    sendMovement = true;                }            }        }        if (sendMovement) {            long timeSinceVehicleMove = System.currentTimeMillis() - session.getLastVehicleMoveTimestamp();            if (timeSinceVehicleMove >= 100) {                Vector3f vehiclePosition = vehicle.getPosition();                Vector3f vehicleRotation = vehicle.getRotation();                if (vehicle instanceof BoatEntity) {                    vehiclePosition = vehiclePosition.down(EntityType.BOAT.getOffset());                }                ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(                        vehiclePosition.getX(), vehiclePosition.getY(), vehiclePosition.getZ(),                        vehicleRotation.getX() - 90, vehicleRotation.getY()                );                session.sendDownstreamPacket(clientVehicleMovePacket);            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerVehiclePacket;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.packet.PlayerInputPacket;import org.geysermc.connector.entity.BoatEntity;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.entity.living.animal.horse.LlamaEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = PlayerInputPacket.class)public class BedrockPlayerInputTranslator extends PacketTranslator<PlayerInputPacket> {    @Override    public void translate(PlayerInputPacket packet, GeyserSession session) {        ClientSteerVehiclePacket clientSteerVehiclePacket = new ClientSteerVehiclePacket(                packet.getInputMotion().getX(), packet.getInputMotion().getY(), packet.isJumping(), packet.isSneaking()        );        session.sendDownstreamPacket(clientSteerVehiclePacket);        Entity vehicle = session.getRidingVehicleEntity();        boolean sendMovement = false;        if (vehicle instanceof AbstractHorseEntity && !(vehicle instanceof LlamaEntity)) {            sendMovement = vehicle.isOnGround();        } else if (vehicle instanceof BoatEntity) {            if (vehicle.getPassengers().size() == 1) {                sendMovement = true;            } else {                Vector3f seatPos = session.getPlayerEntity().getMetadata().getVector3f(EntityData.RIDER_SEAT_POSITION, null);                if (seatPos != null && seatPos.getX() > 0) {                    sendMovement = true;                }            }        }        if (sendMovement) {            long timeSinceVehicleMove = System.currentTimeMillis() - session.getLastVehicleMoveTimestamp();            if (timeSinceVehicleMove >= 100) {                Vector3f vehiclePosition = vehicle.getPosition();                Vector3f vehicleRotation = vehicle.getRotation();                if (vehicle instanceof BoatEntity) {                    vehiclePosition = vehiclePosition.down(EntityType.BOAT.getOffset());                }                ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(                        vehiclePosition.getX(), vehiclePosition.getY(), vehiclePosition.getZ(),                        vehicleRotation.getX() - 90, vehicleRotation.getY()                );                session.sendDownstreamPacket(clientVehicleMovePacket);            }        }    }}"}
{"code": "import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.nbt.NbtType;import com.nukkitx.protocol.bedrock.packet.PositionTrackingDBClientRequestPacket;import com.nukkitx.protocol.bedrock.packet.PositionTrackingDBServerBroadcastPacket;import it.unimi.dsi.fastutil.ints.IntArrayList;import it.unimi.dsi.fastutil.ints.IntList;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.DimensionUtils;import org.geysermc.connector.utils.LoadstoneTracker;@Translator(packet = PositionTrackingDBClientRequestPacket.class)public class BedrockPositionTrackingDBClientRequestTranslator extends PacketTranslator<PositionTrackingDBClientRequestPacket> {    @Override    public void translate(GeyserSession session, PositionTrackingDBClientRequestPacket packet) {        PositionTrackingDBServerBroadcastPacket broadcastPacket = new PositionTrackingDBServerBroadcastPacket();        broadcastPacket.setTrackingId(packet.getTrackingId());        LoadstoneTracker.LoadstonePos pos = LoadstoneTracker.getPos(packet.getTrackingId());        if (pos == null) {            broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.NOT_FOUND);            session.sendUpstreamPacket(broadcastPacket);            return;        }        broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.UPDATE);        NbtMapBuilder builder = NbtMap.builder();        builder.putInt(\"dim\", DimensionUtils.javaToBedrock(pos.getDimension()));        builder.putString(\"id\", String.format(\"%08X\", packet.getTrackingId()));        builder.putByte(\"version\", (byte) 1);         builder.putByte(\"status\", (byte) 0);         IntList posList = new IntArrayList();        posList.add(pos.getX());        posList.add(pos.getY());        posList.add(pos.getZ());        builder.putList(\"pos\", NbtType.INT, posList);        broadcastPacket.setTag(builder.build());        session.sendUpstreamPacket(broadcastPacket);    }}", "nl": "import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.nbt.NbtType;import com.nukkitx.protocol.bedrock.packet.PositionTrackingDBClientRequestPacket;import com.nukkitx.protocol.bedrock.packet.PositionTrackingDBServerBroadcastPacket;import it.unimi.dsi.fastutil.ints.IntArrayList;import it.unimi.dsi.fastutil.ints.IntList;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.DimensionUtils;import org.geysermc.connector.utils.LoadstoneTracker;@Translator(packet = PositionTrackingDBClientRequestPacket.class)public class BedrockPositionTrackingDBClientRequestTranslator extends PacketTranslator<PositionTrackingDBClientRequestPacket> {    @Override    public void translate(PositionTrackingDBClientRequestPacket packet, GeyserSession session) {        PositionTrackingDBServerBroadcastPacket broadcastPacket = new PositionTrackingDBServerBroadcastPacket();        broadcastPacket.setTrackingId(packet.getTrackingId());        LoadstoneTracker.LoadstonePos pos = LoadstoneTracker.getPos(packet.getTrackingId());        if (pos == null) {            broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.NOT_FOUND);            session.sendUpstreamPacket(broadcastPacket);            return;        }        broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.UPDATE);        NbtMapBuilder builder = NbtMap.builder();        builder.putInt(\"dim\", DimensionUtils.javaToBedrock(pos.getDimension()));        builder.putString(\"id\", String.format(\"%08X\", packet.getTrackingId()));        builder.putByte(\"version\", (byte) 1);         builder.putByte(\"status\", (byte) 0);         IntList posList = new IntArrayList();        posList.add(pos.getX());        posList.add(pos.getY());        posList.add(pos.getZ());        builder.putList(\"pos\", NbtType.INT, posList);        broadcastPacket.setTag(builder.build());        session.sendUpstreamPacket(broadcastPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.ClientRequest;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;import com.nukkitx.protocol.bedrock.packet.RespawnPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = RespawnPacket.class)public class BedrockRespawnTranslator extends PacketTranslator<RespawnPacket> {    @Override    public void translate(GeyserSession session, RespawnPacket packet) {        if (packet.getState() == RespawnPacket.State.CLIENT_READY) {            RespawnPacket respawnPacket = new RespawnPacket();            respawnPacket.setRuntimeEntityId(0);            respawnPacket.setPosition(Vector3f.ZERO);            respawnPacket.setState(RespawnPacket.State.SERVER_READY);            session.sendUpstreamPacket(respawnPacket);            if (session.isSpawned()) {                PlayerEntity entity = session.getPlayerEntity();                if (entity == null) return;                SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();                entityDataPacket.setRuntimeEntityId(entity.getGeyserId());                entityDataPacket.getMetadata().putAll(entity.getMetadata());                session.sendUpstreamPacket(entityDataPacket);                MovePlayerPacket movePlayerPacket = new MovePlayerPacket();                movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());                movePlayerPacket.setPosition(entity.getPosition());                movePlayerPacket.setRotation(entity.getBedrockRotation());                movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);                session.sendUpstreamPacket(movePlayerPacket);            }            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);            session.sendDownstreamPacket(javaRespawnPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.ClientRequest;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;import com.nukkitx.protocol.bedrock.packet.RespawnPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = RespawnPacket.class)public class BedrockRespawnTranslator extends PacketTranslator<RespawnPacket> {    @Override    public void translate(RespawnPacket packet, GeyserSession session) {        if (packet.getState() == RespawnPacket.State.CLIENT_READY) {            RespawnPacket respawnPacket = new RespawnPacket();            respawnPacket.setRuntimeEntityId(0);            respawnPacket.setPosition(Vector3f.ZERO);            respawnPacket.setState(RespawnPacket.State.SERVER_READY);            session.sendUpstreamPacket(respawnPacket);            if (session.isSpawned()) {                PlayerEntity entity = session.getPlayerEntity();                if (entity == null) return;                SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();                entityDataPacket.setRuntimeEntityId(entity.getGeyserId());                entityDataPacket.getMetadata().putAll(entity.getMetadata());                session.sendUpstreamPacket(entityDataPacket);                MovePlayerPacket movePlayerPacket = new MovePlayerPacket();                movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());                movePlayerPacket.setPosition(entity.getPosition());                movePlayerPacket.setRotation(entity.getBedrockRotation());                movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);                session.sendUpstreamPacket(movePlayerPacket);            }            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);            session.sendDownstreamPacket(javaRespawnPacket);        }    }}"}
{"code": "import com.nukkitx.protocol.bedrock.packet.ServerSettingsRequestPacket;import com.nukkitx.protocol.bedrock.packet.ServerSettingsResponsePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.SettingsUtils;import org.geysermc.cumulus.CustomForm;import java.util.concurrent.TimeUnit;@Translator(packet = ServerSettingsRequestPacket.class)public class BedrockServerSettingsRequestTranslator extends PacketTranslator<ServerSettingsRequestPacket> {    @Override    public void translate(GeyserSession session, ServerSettingsRequestPacket packet) {        CustomForm window = SettingsUtils.buildForm(session);        int windowId = session.getFormCache().addForm(window);        session.getConnector().getGeneralThreadPool().schedule(() -> {            ServerSettingsResponsePacket serverSettingsResponsePacket = new ServerSettingsResponsePacket();            serverSettingsResponsePacket.setFormData(window.getJsonData());            serverSettingsResponsePacket.setFormId(windowId);            session.sendUpstreamPacket(serverSettingsResponsePacket);        }, 1, TimeUnit.SECONDS);    }}", "nl": "import com.nukkitx.protocol.bedrock.packet.ServerSettingsRequestPacket;import com.nukkitx.protocol.bedrock.packet.ServerSettingsResponsePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.SettingsUtils;import org.geysermc.cumulus.CustomForm;import java.util.concurrent.TimeUnit;@Translator(packet = ServerSettingsRequestPacket.class)public class BedrockServerSettingsRequestTranslator extends PacketTranslator<ServerSettingsRequestPacket> {    @Override    public void translate(ServerSettingsRequestPacket packet, GeyserSession session) {        CustomForm window = SettingsUtils.buildForm(session);        int windowId = session.getFormCache().addForm(window);        session.getConnector().getGeneralThreadPool().schedule(() -> {            ServerSettingsResponsePacket serverSettingsResponsePacket = new ServerSettingsResponsePacket();            serverSettingsResponsePacket.setFormData(window.getJsonData());            serverSettingsResponsePacket.setFormId(windowId);            session.sendUpstreamPacket(serverSettingsResponsePacket);        }, 1, TimeUnit.SECONDS);    }}"}
{"code": "import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.SetLocalPlayerAsInitializedPacket;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.skin.SkinManager;import org.geysermc.connector.skin.SkullSkinManager;@Translator(packet = SetLocalPlayerAsInitializedPacket.class)public class BedrockSetLocalPlayerAsInitializedTranslator extends PacketTranslator<SetLocalPlayerAsInitializedPacket> {    @Override    public void translate(GeyserSession session, SetLocalPlayerAsInitializedPacket packet) {        if (session.getPlayerEntity().getGeyserId() == packet.getRuntimeEntityId()) {            if (!session.getUpstream().isInitialized()) {                session.getUpstream().setInitialized(true);                session.login();                for (PlayerEntity entity : session.getEntityCache().getEntitiesByType(PlayerEntity.class)) {                    if (!entity.isValid()) {                        SkinManager.requestAndHandleSkinAndCape(entity, session, null);                        entity.sendPlayer(session);                    }                }                for (PlayerEntity entity : session.getSkullCache().values()) {                    entity.spawnEntity(session);                    SkullSkinManager.requestAndHandleSkin(entity, session, (skin) ->  {                        entity.getMetadata().getFlags().setFlag(EntityFlag.INVISIBLE, false);                        entity.updateBedrockMetadata(session);                    });                }            }        }    }}", "nl": "import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.SetLocalPlayerAsInitializedPacket;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.skin.SkinManager;import org.geysermc.connector.skin.SkullSkinManager;@Translator(packet = SetLocalPlayerAsInitializedPacket.class)public class BedrockSetLocalPlayerAsInitializedTranslator extends PacketTranslator<SetLocalPlayerAsInitializedPacket> {    @Override    public void translate(SetLocalPlayerAsInitializedPacket packet, GeyserSession session) {        if (session.getPlayerEntity().getGeyserId() == packet.getRuntimeEntityId()) {            if (!session.getUpstream().isInitialized()) {                session.getUpstream().setInitialized(true);                session.login();                for (PlayerEntity entity : session.getEntityCache().getEntitiesByType(PlayerEntity.class)) {                    if (!entity.isValid()) {                        SkinManager.requestAndHandleSkinAndCape(entity, session, null);                        entity.sendPlayer(session);                    }                }                for (PlayerEntity entity : session.getSkullCache().values()) {                    entity.spawnEntity(session);                    SkullSkinManager.requestAndHandleSkin(entity, session, (skin) ->  {                        entity.getMetadata().getFlags().setFlag(EntityFlag.INVISIBLE, false);                        entity.updateBedrockMetadata(session);                    });                }            }        }    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.data.game.ClientRequest;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;import com.nukkitx.protocol.bedrock.packet.ShowCreditsPacket;@Translator(packet = ShowCreditsPacket.class)public class BedrockShowCreditsTranslator extends PacketTranslator<ShowCreditsPacket> {    @Override    public void translate(GeyserSession session, ShowCreditsPacket packet) {        if (packet.getStatus() == ShowCreditsPacket.Status.END_CREDITS) {            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);            session.sendDownstreamPacket(javaRespawnPacket);        }    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.data.game.ClientRequest;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;import com.nukkitx.protocol.bedrock.packet.ShowCreditsPacket;@Translator(packet = ShowCreditsPacket.class)public class BedrockShowCreditsTranslator extends PacketTranslator<ShowCreditsPacket> {    @Override    public void translate(ShowCreditsPacket packet, GeyserSession session) {        if (packet.getStatus() == ShowCreditsPacket.Status.END_CREDITS) {            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);            session.sendDownstreamPacket(javaRespawnPacket);        }    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;import com.nukkitx.protocol.bedrock.packet.TextPacket;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = TextPacket.class)public class BedrockTextTranslator extends PacketTranslator<TextPacket> {    @Override    public void translate(GeyserSession session, TextPacket packet) {        String message = packet.getMessage();        if (MessageTranslator.isTooLong(message, session)) {            return;        }        ClientChatPacket chatPacket = new ClientChatPacket(message);        session.sendDownstreamPacket(chatPacket);    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;import com.nukkitx.protocol.bedrock.packet.TextPacket;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = TextPacket.class)public class BedrockTextTranslator extends PacketTranslator<TextPacket> {    @Override    public void translate(TextPacket packet, GeyserSession session) {        String message = packet.getMessage();        if (MessageTranslator.isTooLong(message, session)) {            return;        }        ClientChatPacket chatPacket = new ClientChatPacket(message);        session.sendDownstreamPacket(chatPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientSelectTradePacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.packet.EntityEventPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.inventory.MerchantContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.concurrent.TimeUnit;@Translator(packet = EntityEventPacket.class)public class BedrockEntityEventTranslator extends PacketTranslator<EntityEventPacket> {    @Override    public void translate(GeyserSession session, EntityEventPacket packet) {        switch (packet.getType()) {            case EATING_ITEM:                session.sendUpstreamPacket(packet);                return;            case COMPLETE_TRADE:                ClientSelectTradePacket selectTradePacket = new ClientSelectTradePacket(packet.getData());                session.sendDownstreamPacket(selectTradePacket);                session.scheduleInEventLoop(() -> {                    Entity villager = session.getPlayerEntity();                    Inventory openInventory = session.getOpenInventory();                    if (openInventory instanceof MerchantContainer) {                        MerchantContainer merchantInventory = (MerchantContainer) openInventory;                        VillagerTrade[] trades = merchantInventory.getVillagerTrades();                        if (trades != null && packet.getData() >= 0 && packet.getData() < trades.length) {                            VillagerTrade trade = merchantInventory.getVillagerTrades()[packet.getData()];                            openInventory.setItem(2, GeyserItemStack.from(trade.getOutput()), session);                            villager.getMetadata().put(EntityData.TRADE_XP, trade.getXp() + villager.getMetadata().getInt(EntityData.TRADE_XP));                            villager.updateBedrockMetadata(session);                        }                    }                }, 100, TimeUnit.MILLISECONDS);                return;        }        session.getConnector().getLogger().debug(\"Did not translate incoming EntityEventPacket: \" + packet.toString());    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientSelectTradePacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.packet.EntityEventPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.inventory.MerchantContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.concurrent.TimeUnit;@Translator(packet = EntityEventPacket.class)public class BedrockEntityEventTranslator extends PacketTranslator<EntityEventPacket> {    @Override    public void translate(EntityEventPacket packet, GeyserSession session) {        switch (packet.getType()) {            case EATING_ITEM:                session.sendUpstreamPacket(packet);                return;            case COMPLETE_TRADE:                ClientSelectTradePacket selectTradePacket = new ClientSelectTradePacket(packet.getData());                session.sendDownstreamPacket(selectTradePacket);                session.scheduleInEventLoop(() -> {                    Entity villager = session.getPlayerEntity();                    Inventory openInventory = session.getOpenInventory();                    if (openInventory instanceof MerchantContainer) {                        MerchantContainer merchantInventory = (MerchantContainer) openInventory;                        VillagerTrade[] trades = merchantInventory.getVillagerTrades();                        if (trades != null && packet.getData() >= 0 && packet.getData() < trades.length) {                            VillagerTrade trade = merchantInventory.getVillagerTrades()[packet.getData()];                            openInventory.setItem(2, GeyserItemStack.from(trade.getOutput()), session);                            villager.getMetadata().put(EntityData.TRADE_XP, trade.getXp() + villager.getMetadata().getInt(EntityData.TRADE_XP));                            villager.updateBedrockMetadata(session);                        }                    }                }, 100, TimeUnit.MILLISECONDS);                return;        }        session.getConnector().getLogger().debug(\"Did not translate incoming EntityEventPacket: \" + packet.toString());    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.entity.player.*;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.*;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.PlayerActionType;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemFrameEntity;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.inventory.PlayerInventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.BlockUtils;import java.util.ArrayList;@Translator(packet = PlayerActionPacket.class)public class BedrockActionTranslator extends PacketTranslator<PlayerActionPacket> {    @Override    public void translate(GeyserSession session, PlayerActionPacket packet) {        SessionPlayerEntity entity = session.getPlayerEntity();        if (packet.getAction() != PlayerActionType.RESPAWN) {            session.getBookEditCache().checkForSend();        }        Vector3i vector = packet.getBlockPosition();        Position position = new Position(vector.getX(), vector.getY(), vector.getZ());        switch (packet.getAction()) {            case RESPAWN:                EntityEventPacket eventPacket = new EntityEventPacket();                eventPacket.setRuntimeEntityId(entity.getGeyserId());                eventPacket.setType(EntityEventType.RESPAWN);                eventPacket.setData(0);                session.sendUpstreamPacket(eventPacket);                UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();                attributesPacket.setRuntimeEntityId(entity.getGeyserId());                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));                session.sendUpstreamPacket(attributesPacket);                break;            case START_SWIMMING:                ClientPlayerStatePacket startSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);                session.sendDownstreamPacket(startSwimPacket);                session.setSwimming(true);                break;            case STOP_SWIMMING:                ClientPlayerStatePacket stopSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);                session.sendDownstreamPacket(stopSwimPacket);                session.setSwimming(false);                break;            case START_GLIDE:                ClientPlayerAbilitiesPacket playerAbilitiesPacket = new ClientPlayerAbilitiesPacket(false);                session.sendDownstreamPacket(playerAbilitiesPacket);            case STOP_GLIDE:                ClientPlayerStatePacket glidePacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_ELYTRA_FLYING);                session.sendDownstreamPacket(glidePacket);                break;            case START_SNEAK:                ClientPlayerStatePacket startSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);                session.sendDownstreamPacket(startSneakPacket);                PlayerInventory playerInv = session.getPlayerInventory();                ItemMapping shield = session.getItemMappings().getMapping(\"minecraft:shield\");                if ((playerInv.getItemInHand().getJavaId() == shield.getJavaId()) ||                        (playerInv.getOffhand().getJavaId() == shield.getJavaId())) {                    ClientPlayerUseItemPacket useItemPacket;                    if (playerInv.getItemInHand().getJavaId() == shield.getJavaId()) {                        useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                    } else {                        useItemPacket = new ClientPlayerUseItemPacket(Hand.OFF_HAND);                    }                    session.sendDownstreamPacket(useItemPacket);                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, true);                }                session.setSneaking(true);                break;            case STOP_SNEAK:                ClientPlayerStatePacket stopSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SNEAKING);                session.sendDownstreamPacket(stopSneakPacket);                if (session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.BLOCKING)) {                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO, BlockFace.DOWN);                    session.sendDownstreamPacket(releaseItemPacket);                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, false);                }                session.setSneaking(false);                break;            case START_SPRINT:                ClientPlayerStatePacket startSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);                session.sendDownstreamPacket(startSprintPacket);                session.setSprinting(true);                break;            case STOP_SPRINT:                ClientPlayerStatePacket stopSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);                session.sendDownstreamPacket(stopSprintPacket);                session.setSprinting(false);                break;            case DROP_ITEM:                ClientPlayerActionPacket dropItemPacket = new ClientPlayerActionPacket(PlayerAction.DROP_ITEM, position, BlockFace.values()[packet.getFace()]);                session.sendDownstreamPacket(dropItemPacket);                break;            case STOP_SLEEP:                ClientPlayerStatePacket stopSleepingPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.LEAVE_BED);                session.sendDownstreamPacket(stopSleepingPacket);                break;            case BLOCK_INTERACT:                if (session.getBucketScheduledFuture() != null) {                    session.getBucketScheduledFuture().cancel(true);                    session.setBucketScheduledFuture(null);                }                break;            case START_BREAK:                if (session.getGameMode() != GameMode.CREATIVE) {                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, vector);                    LevelEventPacket startBreak = new LevelEventPacket();                    startBreak.setType(LevelEventType.BLOCK_START_BREAK);                    startBreak.setPosition(vector.toFloat());                    double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(blockState)) * 20;                    startBreak.setData((int) (65535 / breakTime));                    session.setBreakingBlock(blockState);                    session.sendUpstreamPacket(startBreak);                }                Vector3i fireBlockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getFace());                int blockUp = session.getConnector().getWorldManager().getBlockAt(session, fireBlockPos);                String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(blockUp);                if (identifier.startsWith(\"minecraft:fire\") || identifier.startsWith(\"minecraft:soul_fire\")) {                    ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, new Position(fireBlockPos.getX(),                            fireBlockPos.getY(), fireBlockPos.getZ()), BlockFace.values()[packet.getFace()]);                    session.sendDownstreamPacket(startBreakingPacket);                    if (session.getGameMode() == GameMode.CREATIVE) {                        break;                    }                }                ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, position, BlockFace.values()[packet.getFace()]);                session.sendDownstreamPacket(startBreakingPacket);                break;            case CONTINUE_BREAK:                if (session.getGameMode() == GameMode.CREATIVE) {                    break;                }                Vector3f vectorFloat = vector.toFloat();                LevelEventPacket continueBreakPacket = new LevelEventPacket();                continueBreakPacket.setType(LevelEventType.PARTICLE_CRACK_BLOCK);                continueBreakPacket.setData((session.getBlockMappings().getBedrockBlockId(session.getBreakingBlock())) | (packet.getFace() << 24));                continueBreakPacket.setPosition(vectorFloat);                session.sendUpstreamPacket(continueBreakPacket);                LevelEventPacket updateBreak = new LevelEventPacket();                updateBreak.setType(LevelEventType.BLOCK_UPDATE_BREAK);                updateBreak.setPosition(vectorFloat);                double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(session.getBreakingBlock())) * 20;                updateBreak.setData((int) (65535 / breakTime));                session.sendUpstreamPacket(updateBreak);                break;            case ABORT_BREAK:                if (session.getGameMode() != GameMode.CREATIVE) {                    Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());                    if (itemFrameEntity != null) {                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),                                InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());                        session.sendDownstreamPacket(interactPacket);                        break;                    }                }                ClientPlayerActionPacket abortBreakingPacket = new ClientPlayerActionPacket(PlayerAction.CANCEL_DIGGING, position, BlockFace.DOWN);                session.sendDownstreamPacket(abortBreakingPacket);                LevelEventPacket stopBreak = new LevelEventPacket();                stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);                stopBreak.setPosition(vector.toFloat());                stopBreak.setData(0);                session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);                session.sendUpstreamPacket(stopBreak);                break;            case STOP_BREAK:                break;            case DIMENSION_CHANGE_SUCCESS:                PlayStatusPacket spawnPacket = new PlayStatusPacket();                spawnPacket.setStatus(PlayStatusPacket.Status.PLAYER_SPAWN);                session.sendUpstreamPacket(spawnPacket);                attributesPacket = new UpdateAttributesPacket();                attributesPacket.setRuntimeEntityId(entity.getGeyserId());                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));                session.sendUpstreamPacket(attributesPacket);                session.getEntityCache().updateBossBars();                break;            case JUMP:                entity.setOnGround(false);                 break;        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.entity.player.*;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.*;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.PlayerActionType;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemFrameEntity;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.inventory.PlayerInventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.BlockUtils;import java.util.ArrayList;@Translator(packet = PlayerActionPacket.class)public class BedrockActionTranslator extends PacketTranslator<PlayerActionPacket> {    @Override    public void translate(PlayerActionPacket packet, GeyserSession session) {        SessionPlayerEntity entity = session.getPlayerEntity();        if (packet.getAction() != PlayerActionType.RESPAWN) {            session.getBookEditCache().checkForSend();        }        Vector3i vector = packet.getBlockPosition();        Position position = new Position(vector.getX(), vector.getY(), vector.getZ());        switch (packet.getAction()) {            case RESPAWN:                EntityEventPacket eventPacket = new EntityEventPacket();                eventPacket.setRuntimeEntityId(entity.getGeyserId());                eventPacket.setType(EntityEventType.RESPAWN);                eventPacket.setData(0);                session.sendUpstreamPacket(eventPacket);                UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();                attributesPacket.setRuntimeEntityId(entity.getGeyserId());                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));                session.sendUpstreamPacket(attributesPacket);                break;            case START_SWIMMING:                ClientPlayerStatePacket startSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);                session.sendDownstreamPacket(startSwimPacket);                session.setSwimming(true);                break;            case STOP_SWIMMING:                ClientPlayerStatePacket stopSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);                session.sendDownstreamPacket(stopSwimPacket);                session.setSwimming(false);                break;            case START_GLIDE:                ClientPlayerAbilitiesPacket playerAbilitiesPacket = new ClientPlayerAbilitiesPacket(false);                session.sendDownstreamPacket(playerAbilitiesPacket);            case STOP_GLIDE:                ClientPlayerStatePacket glidePacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_ELYTRA_FLYING);                session.sendDownstreamPacket(glidePacket);                break;            case START_SNEAK:                ClientPlayerStatePacket startSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);                session.sendDownstreamPacket(startSneakPacket);                PlayerInventory playerInv = session.getPlayerInventory();                ItemMapping shield = session.getItemMappings().getMapping(\"minecraft:shield\");                if ((playerInv.getItemInHand().getJavaId() == shield.getJavaId()) ||                        (playerInv.getOffhand().getJavaId() == shield.getJavaId())) {                    ClientPlayerUseItemPacket useItemPacket;                    if (playerInv.getItemInHand().getJavaId() == shield.getJavaId()) {                        useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);                    } else {                        useItemPacket = new ClientPlayerUseItemPacket(Hand.OFF_HAND);                    }                    session.sendDownstreamPacket(useItemPacket);                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, true);                }                session.setSneaking(true);                break;            case STOP_SNEAK:                ClientPlayerStatePacket stopSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SNEAKING);                session.sendDownstreamPacket(stopSneakPacket);                if (session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.BLOCKING)) {                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO, BlockFace.DOWN);                    session.sendDownstreamPacket(releaseItemPacket);                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, false);                }                session.setSneaking(false);                break;            case START_SPRINT:                ClientPlayerStatePacket startSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);                session.sendDownstreamPacket(startSprintPacket);                session.setSprinting(true);                break;            case STOP_SPRINT:                ClientPlayerStatePacket stopSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);                session.sendDownstreamPacket(stopSprintPacket);                session.setSprinting(false);                break;            case DROP_ITEM:                ClientPlayerActionPacket dropItemPacket = new ClientPlayerActionPacket(PlayerAction.DROP_ITEM, position, BlockFace.values()[packet.getFace()]);                session.sendDownstreamPacket(dropItemPacket);                break;            case STOP_SLEEP:                ClientPlayerStatePacket stopSleepingPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.LEAVE_BED);                session.sendDownstreamPacket(stopSleepingPacket);                break;            case BLOCK_INTERACT:                if (session.getBucketScheduledFuture() != null) {                    session.getBucketScheduledFuture().cancel(true);                    session.setBucketScheduledFuture(null);                }                break;            case START_BREAK:                if (session.getGameMode() != GameMode.CREATIVE) {                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, vector);                    LevelEventPacket startBreak = new LevelEventPacket();                    startBreak.setType(LevelEventType.BLOCK_START_BREAK);                    startBreak.setPosition(vector.toFloat());                    double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(blockState)) * 20;                    startBreak.setData((int) (65535 / breakTime));                    session.setBreakingBlock(blockState);                    session.sendUpstreamPacket(startBreak);                }                Vector3i fireBlockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getFace());                int blockUp = session.getConnector().getWorldManager().getBlockAt(session, fireBlockPos);                String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(blockUp);                if (identifier.startsWith(\"minecraft:fire\") || identifier.startsWith(\"minecraft:soul_fire\")) {                    ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, new Position(fireBlockPos.getX(),                            fireBlockPos.getY(), fireBlockPos.getZ()), BlockFace.values()[packet.getFace()]);                    session.sendDownstreamPacket(startBreakingPacket);                    if (session.getGameMode() == GameMode.CREATIVE) {                        break;                    }                }                ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, position, BlockFace.values()[packet.getFace()]);                session.sendDownstreamPacket(startBreakingPacket);                break;            case CONTINUE_BREAK:                if (session.getGameMode() == GameMode.CREATIVE) {                    break;                }                Vector3f vectorFloat = vector.toFloat();                LevelEventPacket continueBreakPacket = new LevelEventPacket();                continueBreakPacket.setType(LevelEventType.PARTICLE_CRACK_BLOCK);                continueBreakPacket.setData((session.getBlockMappings().getBedrockBlockId(session.getBreakingBlock())) | (packet.getFace() << 24));                continueBreakPacket.setPosition(vectorFloat);                session.sendUpstreamPacket(continueBreakPacket);                LevelEventPacket updateBreak = new LevelEventPacket();                updateBreak.setType(LevelEventType.BLOCK_UPDATE_BREAK);                updateBreak.setPosition(vectorFloat);                double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(session.getBreakingBlock())) * 20;                updateBreak.setData((int) (65535 / breakTime));                session.sendUpstreamPacket(updateBreak);                break;            case ABORT_BREAK:                if (session.getGameMode() != GameMode.CREATIVE) {                    Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());                    if (itemFrameEntity != null) {                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),                                InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());                        session.sendDownstreamPacket(interactPacket);                        break;                    }                }                ClientPlayerActionPacket abortBreakingPacket = new ClientPlayerActionPacket(PlayerAction.CANCEL_DIGGING, position, BlockFace.DOWN);                session.sendDownstreamPacket(abortBreakingPacket);                LevelEventPacket stopBreak = new LevelEventPacket();                stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);                stopBreak.setPosition(vector.toFloat());                stopBreak.setData(0);                session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);                session.sendUpstreamPacket(stopBreak);                break;            case STOP_BREAK:                break;            case DIMENSION_CHANGE_SUCCESS:                PlayStatusPacket spawnPacket = new PlayStatusPacket();                spawnPacket.setStatus(PlayStatusPacket.Status.PLAYER_SPAWN);                session.sendUpstreamPacket(spawnPacket);                attributesPacket = new UpdateAttributesPacket();                attributesPacket.setRuntimeEntityId(entity.getGeyserId());                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));                session.sendUpstreamPacket(attributesPacket);                session.getEntityCache().updateBossBars();                break;            case JUMP:                entity.setOnGround(false);                 break;        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;import com.nukkitx.protocol.bedrock.packet.EmotePacket;import org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.BlockUtils;@Translator(packet = EmotePacket.class)public class BedrockEmoteTranslator extends PacketTranslator<EmotePacket> {    @Override    public void translate(GeyserSession session, EmotePacket packet) {        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() != EmoteOffhandWorkaroundOption.DISABLED) {            ClientPlayerActionPacket swapHandsPacket = new ClientPlayerActionPacket(PlayerAction.SWAP_HANDS, BlockUtils.POSITION_ZERO,                    BlockFace.DOWN);            session.sendDownstreamPacket(swapHandsPacket);            if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {                return;            }        }        long javaId = session.getPlayerEntity().getEntityId();        for (GeyserSession otherSession : session.getConnector().getPlayers()) {            if (otherSession != session) {                if (otherSession.isClosed()) continue;                if (otherSession.getEventLoop().inEventLoop()) {                    playEmote(otherSession, javaId, packet.getEmoteId());                } else {                    session.executeInEventLoop(() -> playEmote(otherSession, javaId, packet.getEmoteId()));                }            }        }    }    private void playEmote(GeyserSession otherSession, long javaId, String emoteId) {        Entity otherEntity = otherSession.getEntityCache().getEntityByJavaId(javaId);         if (otherEntity == null) return;        EmotePacket otherEmotePacket = new EmotePacket();        otherEmotePacket.setEmoteId(emoteId);        otherEmotePacket.setRuntimeEntityId(otherEntity.getGeyserId());        otherSession.sendUpstreamPacket(otherEmotePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;import com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;import com.nukkitx.protocol.bedrock.packet.EmotePacket;import org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.BlockUtils;@Translator(packet = EmotePacket.class)public class BedrockEmoteTranslator extends PacketTranslator<EmotePacket> {    @Override    public void translate(EmotePacket packet, GeyserSession session) {        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() != EmoteOffhandWorkaroundOption.DISABLED) {            ClientPlayerActionPacket swapHandsPacket = new ClientPlayerActionPacket(PlayerAction.SWAP_HANDS, BlockUtils.POSITION_ZERO,                    BlockFace.DOWN);            session.sendDownstreamPacket(swapHandsPacket);            if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {                return;            }        }        long javaId = session.getPlayerEntity().getEntityId();        for (GeyserSession otherSession : session.getConnector().getPlayers()) {            if (otherSession != session) {                if (otherSession.isClosed()) continue;                if (otherSession.getEventLoop().inEventLoop()) {                    playEmote(otherSession, javaId, packet.getEmoteId());                } else {                    session.executeInEventLoop(() -> playEmote(otherSession, javaId, packet.getEmoteId()));                }            }        }    }    private void playEmote(GeyserSession otherSession, long javaId, String emoteId) {        Entity otherEntity = otherSession.getEntityCache().getEntityByJavaId(javaId);         if (otherEntity == null) return;        EmotePacket otherEmotePacket = new EmotePacket();        otherEmotePacket.setEmoteId(emoteId);        otherEmotePacket.setRuntimeEntityId(otherEntity.getGeyserId());        otherSession.sendUpstreamPacket(otherEmotePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;import com.nukkitx.protocol.bedrock.packet.InteractPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InteractiveTagManager;@Translator(packet = InteractPacket.class)public class BedrockInteractTranslator extends PacketTranslator<InteractPacket> {    @Override    public void translate(GeyserSession session, InteractPacket packet) {        Entity entity;        if (packet.getRuntimeEntityId() == session.getPlayerEntity().getGeyserId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());        }        if (entity == null)            return;        switch (packet.getAction()) {            case INTERACT:                if (session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {                    break;                }                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());                session.sendDownstreamPacket(interactPacket);                break;            case DAMAGE:                ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                        InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());                session.sendDownstreamPacket(attackPacket);                break;            case LEAVE_VEHICLE:                ClientPlayerStatePacket sneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);                session.sendDownstreamPacket(sneakPacket);                session.setRidingVehicleEntity(null);                break;            case MOUSEOVER:                if (packet.getRuntimeEntityId() != 0) {                    Entity interactEntity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());                    session.setMouseoverEntity(interactEntity);                    if (interactEntity == null) {                        return;                    }                    InteractiveTagManager.updateTag(session, interactEntity);                } else {                    if (session.getMouseoverEntity() != null) {                        session.setMouseoverEntity(null);                        session.getPlayerEntity().getMetadata().put(EntityData.INTERACTIVE_TAG, \"\");                        session.getPlayerEntity().updateBedrockMetadata(session);                    }                }                break;            case OPEN_INVENTORY:                if (session.getOpenInventory() == null) {                    Entity ridingEntity = session.getRidingVehicleEntity();                    if (ridingEntity instanceof AbstractHorseEntity) {                        if (ridingEntity.getMetadata().getFlags().getFlag(EntityFlag.TAMED)) {                            ClientPlayerStatePacket openHorseWindowPacket = new ClientPlayerStatePacket((int) session.getPlayerEntity().getEntityId(), PlayerState.OPEN_HORSE_INVENTORY);                            session.sendDownstreamPacket(openHorseWindowPacket);                        }                    } else {                        session.setOpenInventory(session.getPlayerInventory());                        ContainerOpenPacket containerOpenPacket = new ContainerOpenPacket();                        containerOpenPacket.setId((byte) 0);                        containerOpenPacket.setType(ContainerType.INVENTORY);                        containerOpenPacket.setUniqueEntityId(-1);                        containerOpenPacket.setBlockPosition(entity.getPosition().toInt());                        session.sendUpstreamPacket(containerOpenPacket);                    }                }                break;        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.Hand;import com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;import com.nukkitx.protocol.bedrock.packet.InteractPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InteractiveTagManager;@Translator(packet = InteractPacket.class)public class BedrockInteractTranslator extends PacketTranslator<InteractPacket> {    @Override    public void translate(InteractPacket packet, GeyserSession session) {        Entity entity;        if (packet.getRuntimeEntityId() == session.getPlayerEntity().getGeyserId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());        }        if (entity == null)            return;        switch (packet.getAction()) {            case INTERACT:                if (session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {                    break;                }                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());                session.sendDownstreamPacket(interactPacket);                break;            case DAMAGE:                ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),                        InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());                session.sendDownstreamPacket(attackPacket);                break;            case LEAVE_VEHICLE:                ClientPlayerStatePacket sneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);                session.sendDownstreamPacket(sneakPacket);                session.setRidingVehicleEntity(null);                break;            case MOUSEOVER:                if (packet.getRuntimeEntityId() != 0) {                    Entity interactEntity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());                    session.setMouseoverEntity(interactEntity);                    if (interactEntity == null) {                        return;                    }                    InteractiveTagManager.updateTag(session, interactEntity);                } else {                    if (session.getMouseoverEntity() != null) {                        session.setMouseoverEntity(null);                        session.getPlayerEntity().getMetadata().put(EntityData.INTERACTIVE_TAG, \"\");                        session.getPlayerEntity().updateBedrockMetadata(session);                    }                }                break;            case OPEN_INVENTORY:                if (session.getOpenInventory() == null) {                    Entity ridingEntity = session.getRidingVehicleEntity();                    if (ridingEntity instanceof AbstractHorseEntity) {                        if (ridingEntity.getMetadata().getFlags().getFlag(EntityFlag.TAMED)) {                            ClientPlayerStatePacket openHorseWindowPacket = new ClientPlayerStatePacket((int) session.getPlayerEntity().getEntityId(), PlayerState.OPEN_HORSE_INVENTORY);                            session.sendDownstreamPacket(openHorseWindowPacket);                        }                    } else {                        session.setOpenInventory(session.getPlayerInventory());                        ContainerOpenPacket containerOpenPacket = new ContainerOpenPacket();                        containerOpenPacket.setId((byte) 0);                        containerOpenPacket.setType(ContainerType.INVENTORY);                        containerOpenPacket.setUniqueEntityId(-1);                        containerOpenPacket.setBlockPosition(entity.getPosition().toInt());                        session.sendUpstreamPacket(containerOpenPacket);                    }                }                break;        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionRotationPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerRotationPacket;import com.github.steveice10.packetlib.packet.Packet;import com.nukkitx.math.vector.Vector3d;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;import com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.common.ChatColor;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = MovePlayerPacket.class)public class BedrockMovePlayerTranslator extends PacketTranslator<MovePlayerPacket> {    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y;    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y;    static {        BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight() ? -104 : -40;        BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y = BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y + 2;    }    @Override    public void translate(GeyserSession session, MovePlayerPacket packet) {        SessionPlayerEntity entity = session.getPlayerEntity();        if (!session.isSpawned()) return;        if (!session.getUpstream().isInitialized()) {            MoveEntityAbsolutePacket moveEntityBack = new MoveEntityAbsolutePacket();            moveEntityBack.setRuntimeEntityId(entity.getGeyserId());            moveEntityBack.setPosition(entity.getPosition());            moveEntityBack.setRotation(entity.getBedrockRotation());            moveEntityBack.setTeleported(true);            moveEntityBack.setOnGround(true);            session.sendUpstreamPacketImmediately(moveEntityBack);            return;        }        session.setLastMovementTimestamp(System.currentTimeMillis());        session.getBookEditCache().checkForSend();        session.confirmTeleport(packet.getPosition().toDouble().sub(0, EntityType.PLAYER.getOffset(), 0));        Vector3f rotation = Vector3f.from(packet.getRotation().getY(), packet.getRotation().getX(), packet.getRotation().getY());        boolean positionChanged = !entity.getPosition().equals(packet.getPosition());        boolean rotationChanged = !entity.getRotation().equals(rotation);        if (!positionChanged && rotationChanged) {            ClientPlayerRotationPacket playerRotationPacket = new ClientPlayerRotationPacket(                    packet.isOnGround(), packet.getRotation().getY(), packet.getRotation().getX());            entity.setRotation(rotation);            entity.setOnGround(packet.isOnGround());            session.sendDownstreamPacket(playerRotationPacket);        } else {            Vector3d position = session.getCollisionManager().adjustBedrockPosition(packet.getPosition(), packet.isOnGround());            if (position != null) {                 if (isValidMove(session, packet.getMode(), entity.getPosition(), packet.getPosition())) {                    Packet movePacket;                    if (rotationChanged) {                        movePacket = new ClientPlayerPositionRotationPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ(),                                packet.getRotation().getY(), packet.getRotation().getX());                        entity.setRotation(rotation);                    } else {                        movePacket = new ClientPlayerPositionPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ());                    }                    boolean notMovingUp = entity.getPosition().getY() >= packet.getPosition().getY();                    entity.setPositionManual(packet.getPosition());                    entity.setOnGround(packet.isOnGround());                    session.sendDownstreamPacket(movePacket);                    if (notMovingUp) {                        int floorY = position.getFloorY();                        boolean extendedWorld = session.getChunkCache().isExtendedHeight();                        if (floorY <= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y : -38)                                && floorY >= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y : -40)) {                            entity.setPosition(entity.getPosition().sub(0, 4f, 0));                            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();                            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());                            movePlayerPacket.setPosition(entity.getPosition());                            movePlayerPacket.setRotation(entity.getBedrockRotation());                            movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);                            movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.BEHAVIOR);                            session.sendUpstreamPacket(movePlayerPacket);                        }                    }                } else {                    session.getConnector().getLogger().debug(\"Recalculating position...\");                    session.getCollisionManager().recalculatePosition();                }            }        }        if (entity.getLeftParrot() != null) {            entity.getLeftParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);        }        if (entity.getRightParrot() != null) {            entity.getRightParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);        }    }    private boolean isValidMove(GeyserSession session, MovePlayerPacket.Mode mode, Vector3f currentPosition, Vector3f newPosition) {        if (mode != MovePlayerPacket.Mode.NORMAL)            return true;        double xRange = newPosition.getX() - currentPosition.getX();        double yRange = newPosition.getY() - currentPosition.getY();        double zRange = newPosition.getZ() - currentPosition.getZ();        if (xRange < 0)            xRange = -xRange;        if (yRange < 0)            yRange = -yRange;        if (zRange < 0)            zRange = -zRange;        if ((xRange + yRange + zRange) > 100) {            session.getConnector().getLogger().debug(ChatColor.RED + session.getName() + \" moved too quickly.\" +                    \" current position: \" + currentPosition + \", new position: \" + newPosition);            return false;        }        return true;    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionRotationPacket;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerRotationPacket;import com.github.steveice10.packetlib.packet.Packet;import com.nukkitx.math.vector.Vector3d;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;import com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.common.ChatColor;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = MovePlayerPacket.class)public class BedrockMovePlayerTranslator extends PacketTranslator<MovePlayerPacket> {    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y;    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y;    static {        BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight() ? -104 : -40;        BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y = BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y + 2;    }    @Override    public void translate(MovePlayerPacket packet, GeyserSession session) {        SessionPlayerEntity entity = session.getPlayerEntity();        if (!session.isSpawned()) return;        if (!session.getUpstream().isInitialized()) {            MoveEntityAbsolutePacket moveEntityBack = new MoveEntityAbsolutePacket();            moveEntityBack.setRuntimeEntityId(entity.getGeyserId());            moveEntityBack.setPosition(entity.getPosition());            moveEntityBack.setRotation(entity.getBedrockRotation());            moveEntityBack.setTeleported(true);            moveEntityBack.setOnGround(true);            session.sendUpstreamPacketImmediately(moveEntityBack);            return;        }        session.setLastMovementTimestamp(System.currentTimeMillis());        session.getBookEditCache().checkForSend();        session.confirmTeleport(packet.getPosition().toDouble().sub(0, EntityType.PLAYER.getOffset(), 0));        Vector3f rotation = Vector3f.from(packet.getRotation().getY(), packet.getRotation().getX(), packet.getRotation().getY());        boolean positionChanged = !entity.getPosition().equals(packet.getPosition());        boolean rotationChanged = !entity.getRotation().equals(rotation);        if (!positionChanged && rotationChanged) {            ClientPlayerRotationPacket playerRotationPacket = new ClientPlayerRotationPacket(                    packet.isOnGround(), packet.getRotation().getY(), packet.getRotation().getX());            entity.setRotation(rotation);            entity.setOnGround(packet.isOnGround());            session.sendDownstreamPacket(playerRotationPacket);        } else {            Vector3d position = session.getCollisionManager().adjustBedrockPosition(packet.getPosition(), packet.isOnGround());            if (position != null) {                 if (isValidMove(session, packet.getMode(), entity.getPosition(), packet.getPosition())) {                    Packet movePacket;                    if (rotationChanged) {                        movePacket = new ClientPlayerPositionRotationPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ(),                                packet.getRotation().getY(), packet.getRotation().getX());                        entity.setRotation(rotation);                    } else {                        movePacket = new ClientPlayerPositionPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ());                    }                    boolean notMovingUp = entity.getPosition().getY() >= packet.getPosition().getY();                    entity.setPositionManual(packet.getPosition());                    entity.setOnGround(packet.isOnGround());                    session.sendDownstreamPacket(movePacket);                    if (notMovingUp) {                        int floorY = position.getFloorY();                        boolean extendedWorld = session.getChunkCache().isExtendedHeight();                        if (floorY <= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y : -38)                                && floorY >= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y : -40)) {                            entity.setPosition(entity.getPosition().sub(0, 4f, 0));                            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();                            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());                            movePlayerPacket.setPosition(entity.getPosition());                            movePlayerPacket.setRotation(entity.getBedrockRotation());                            movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);                            movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.BEHAVIOR);                            session.sendUpstreamPacket(movePlayerPacket);                        }                    }                } else {                    session.getConnector().getLogger().debug(\"Recalculating position...\");                    session.getCollisionManager().recalculatePosition();                }            }        }        if (entity.getLeftParrot() != null) {            entity.getLeftParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);        }        if (entity.getRightParrot() != null) {            entity.getRightParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);        }    }    private boolean isValidMove(GeyserSession session, MovePlayerPacket.Mode mode, Vector3f currentPosition, Vector3f newPosition) {        if (mode != MovePlayerPacket.Mode.NORMAL)            return true;        double xRange = newPosition.getX() - currentPosition.getX();        double yRange = newPosition.getY() - currentPosition.getY();        double zRange = newPosition.getZ() - currentPosition.getZ();        if (xRange < 0)            xRange = -xRange;        if (yRange < 0)            yRange = -yRange;        if (zRange < 0)            zRange = -zRange;        if ((xRange + yRange + zRange) > 100) {            session.getConnector().getLogger().debug(ChatColor.RED + session.getName() + \" moved too quickly.\" +                    \" current position: \" + currentPosition + \", new position: \" + newPosition);            return false;        }        return true;    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;import com.nukkitx.protocol.bedrock.packet.RiderJumpPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = RiderJumpPacket.class)public class BedrockRiderJumpTranslator extends PacketTranslator<RiderJumpPacket> {    @Override    public void translate(GeyserSession session, RiderJumpPacket packet) {        Entity vehicle = session.getRidingVehicleEntity();        if (vehicle instanceof AbstractHorseEntity) {            ClientPlayerStatePacket playerStatePacket = new ClientPlayerStatePacket((int) vehicle.getEntityId(),  PlayerState.START_HORSE_JUMP, packet.getJumpStrength());            session.sendDownstreamPacket(playerStatePacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;import com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;import com.nukkitx.protocol.bedrock.packet.RiderJumpPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = RiderJumpPacket.class)public class BedrockRiderJumpTranslator extends PacketTranslator<RiderJumpPacket> {    @Override    public void translate(RiderJumpPacket packet, GeyserSession session) {        Entity vehicle = session.getRidingVehicleEntity();        if (vehicle instanceof AbstractHorseEntity) {            ClientPlayerStatePacket playerStatePacket = new ClientPlayerStatePacket((int) vehicle.getEntityId(),  PlayerState.START_HORSE_JUMP, packet.getJumpStrength());            session.sendDownstreamPacket(playerStatePacket);        }    }}"}
{"code": "import com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = SetPlayerGameTypePacket.class)public class BedrockSetPlayerGameTypeTranslator extends PacketTranslator<SetPlayerGameTypePacket> {    @Override    public void translate(GeyserSession session, SetPlayerGameTypePacket packet) {        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();        playerGameTypePacket.setGamemode(session.getGameMode().ordinal());        session.sendUpstreamPacket(playerGameTypePacket);    }}", "nl": "import com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = SetPlayerGameTypePacket.class)public class BedrockSetPlayerGameTypeTranslator extends PacketTranslator<SetPlayerGameTypePacket> {    @Override    public void translate(SetPlayerGameTypePacket packet, GeyserSession session) {        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();        playerGameTypePacket.setGamemode(session.getGameMode().ordinal());        session.sendUpstreamPacket(playerGameTypePacket);    }}"}
{"code": "import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.CooldownUtils;@Translator(packet = LevelSoundEventPacket.class)public class BedrockLevelSoundEventTranslator extends PacketTranslator<LevelSoundEventPacket> {    @Override    public void translate(GeyserSession session, LevelSoundEventPacket packet) {        session.sendUpstreamPacket(packet);        if (packet.getSound() == SoundEvent.ATTACK_NODAMAGE || packet.getSound() == SoundEvent.ATTACK || packet.getSound() == SoundEvent.ATTACK_STRONG) {            CooldownUtils.sendCooldown(session);        }    }}", "nl": "import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.CooldownUtils;@Translator(packet = LevelSoundEventPacket.class)public class BedrockLevelSoundEventTranslator extends PacketTranslator<LevelSoundEventPacket> {    @Override    public void translate(LevelSoundEventPacket packet, GeyserSession session) {        session.sendUpstreamPacket(packet);        if (packet.getSound() == SoundEvent.ATTACK_NODAMAGE || packet.getSound() == SoundEvent.ATTACK || packet.getSound() == SoundEvent.ATTACK_STRONG) {            CooldownUtils.sendCooldown(session);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementTabPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.AdvancementsCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerAdvancementTabPacket.class)public class JavaAdvancementsTabTranslator extends PacketTranslator<ServerAdvancementTabPacket> {    @Override    public void translate(GeyserSession session, ServerAdvancementTabPacket packet) {        AdvancementsCache advancementsCache = session.getAdvancementsCache();        advancementsCache.setCurrentAdvancementCategoryId(packet.getTabId());        advancementsCache.buildAndShowListForm();    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementTabPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.AdvancementsCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerAdvancementTabPacket.class)public class JavaAdvancementsTabTranslator extends PacketTranslator<ServerAdvancementTabPacket> {    @Override    public void translate(ServerAdvancementTabPacket packet, GeyserSession session) {        AdvancementsCache advancementsCache = session.getAdvancementsCache();        advancementsCache.setCurrentAdvancementCategoryId(packet.getTabId());        advancementsCache.buildAndShowListForm();    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.advancement.Advancement;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementsPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;import org.geysermc.connector.network.session.cache.AdvancementsCache;import org.geysermc.connector.utils.GeyserAdvancement;import org.geysermc.connector.utils.LocaleUtils;import java.util.Map;@Translator(packet = ServerAdvancementsPacket.class)public class JavaAdvancementsTranslator extends PacketTranslator<ServerAdvancementsPacket> {    @Override    public void translate(GeyserSession session, ServerAdvancementsPacket packet) {        AdvancementsCache advancementsCache = session.getAdvancementsCache();        if (packet.isReset()) {            advancementsCache.getStoredAdvancements().clear();            advancementsCache.getStoredAdvancementProgress().clear();        }        for (String removedAdvancement : packet.getRemovedAdvancements()) {            advancementsCache.getStoredAdvancements().remove(removedAdvancement);        }        advancementsCache.getStoredAdvancementProgress().putAll(packet.getProgress());        sendToolbarAdvancementUpdates(session, packet);        for (Advancement advancement : packet.getAdvancements()) {            if (advancement.getDisplayData() != null && !advancement.getDisplayData().isHidden()) {                GeyserAdvancement geyserAdvancement = GeyserAdvancement.from(advancement);                advancementsCache.getStoredAdvancements().put(advancement.getId(), geyserAdvancement);            } else {                advancementsCache.getStoredAdvancements().remove(advancement.getId());            }        }    }    public void sendToolbarAdvancementUpdates(GeyserSession session, ServerAdvancementsPacket packet) {        if (packet.isReset()) {            return;        }        for (Map.Entry<String, Map<String, Long>> progress : packet.getProgress().entrySet()) {            GeyserAdvancement advancement = session.getAdvancementsCache().getStoredAdvancements().get(progress.getKey());            if (advancement != null && advancement.getDisplayData() != null) {                if (session.getAdvancementsCache().isEarned(advancement)) {                    String color = advancement.getDisplayData().getFrameType() == Advancement.DisplayData.FrameType.CHALLENGE ?                            \"§d\" : \"§a\";                    String advancementName = MessageTranslator.convertMessage(advancement.getDisplayData().getTitle(), session.getLocale());                    SetTitlePacket titlePacket = new SetTitlePacket();                    titlePacket.setText(color + \"[\" + LocaleUtils.getLocaleString(\"advancements.toast.\" +                            advancement.getDisplayData().getFrameType().toString().toLowerCase(), session.getLocale()) + \"]§f \" + advancementName);                    titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);                    titlePacket.setFadeOutTime(3);                    titlePacket.setFadeInTime(3);                    titlePacket.setStayTime(3);                    titlePacket.setXuid(\"\");                    titlePacket.setPlatformOnlineId(\"\");                    session.sendUpstreamPacket(titlePacket);                }            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.advancement.Advancement;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementsPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;import org.geysermc.connector.network.session.cache.AdvancementsCache;import org.geysermc.connector.utils.GeyserAdvancement;import org.geysermc.connector.utils.LocaleUtils;import java.util.Map;@Translator(packet = ServerAdvancementsPacket.class)public class JavaAdvancementsTranslator extends PacketTranslator<ServerAdvancementsPacket> {    @Override    public void translate(ServerAdvancementsPacket packet, GeyserSession session) {        AdvancementsCache advancementsCache = session.getAdvancementsCache();        if (packet.isReset()) {            advancementsCache.getStoredAdvancements().clear();            advancementsCache.getStoredAdvancementProgress().clear();        }        for (String removedAdvancement : packet.getRemovedAdvancements()) {            advancementsCache.getStoredAdvancements().remove(removedAdvancement);        }        advancementsCache.getStoredAdvancementProgress().putAll(packet.getProgress());        sendToolbarAdvancementUpdates(session, packet);        for (Advancement advancement : packet.getAdvancements()) {            if (advancement.getDisplayData() != null && !advancement.getDisplayData().isHidden()) {                GeyserAdvancement geyserAdvancement = GeyserAdvancement.from(advancement);                advancementsCache.getStoredAdvancements().put(advancement.getId(), geyserAdvancement);            } else {                advancementsCache.getStoredAdvancements().remove(advancement.getId());            }        }    }    public void sendToolbarAdvancementUpdates(GeyserSession session, ServerAdvancementsPacket packet) {        if (packet.isReset()) {            return;        }        for (Map.Entry<String, Map<String, Long>> progress : packet.getProgress().entrySet()) {            GeyserAdvancement advancement = session.getAdvancementsCache().getStoredAdvancements().get(progress.getKey());            if (advancement != null && advancement.getDisplayData() != null) {                if (session.getAdvancementsCache().isEarned(advancement)) {                    String color = advancement.getDisplayData().getFrameType() == Advancement.DisplayData.FrameType.CHALLENGE ?                            \"§d\" : \"§a\";                    String advancementName = MessageTranslator.convertMessage(advancement.getDisplayData().getTitle(), session.getLocale());                    SetTitlePacket titlePacket = new SetTitlePacket();                    titlePacket.setText(color + \"[\" + LocaleUtils.getLocaleString(\"advancements.toast.\" +                            advancement.getDisplayData().getFrameType().toString().toLowerCase(), session.getLocale()) + \"]§f \" + advancementName);                    titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);                    titlePacket.setFadeOutTime(3);                    titlePacket.setFadeInTime(3);                    titlePacket.setStayTime(3);                    titlePacket.setXuid(\"\");                    titlePacket.setPlatformOnlineId(\"\");                    session.sendUpstreamPacket(titlePacket);                }            }        }    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.BossBar;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerBossBarPacket;@Translator(packet = ServerBossBarPacket.class)public class JavaBossBarTranslator extends PacketTranslator<ServerBossBarPacket> {    @Override    public void translate(GeyserSession session, ServerBossBarPacket packet) {        BossBar bossBar = session.getEntityCache().getBossBar(packet.getUuid());        switch (packet.getAction()) {            case ADD:                long entityId = session.getEntityCache().getNextEntityId().incrementAndGet();                bossBar = new BossBar(session, entityId, packet.getTitle(), packet.getHealth(), 0, 1, 0);                session.getEntityCache().addBossBar(packet.getUuid(), bossBar);                break;            case UPDATE_TITLE:                if (bossBar != null) bossBar.updateTitle(packet.getTitle());                break;            case UPDATE_HEALTH:                if (bossBar != null) bossBar.updateHealth(packet.getHealth());                break;            case REMOVE:                session.getEntityCache().removeBossBar(packet.getUuid());                break;            case UPDATE_STYLE:            case UPDATE_FLAGS:        }    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.BossBar;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerBossBarPacket;@Translator(packet = ServerBossBarPacket.class)public class JavaBossBarTranslator extends PacketTranslator<ServerBossBarPacket> {    @Override    public void translate(ServerBossBarPacket packet, GeyserSession session) {        BossBar bossBar = session.getEntityCache().getBossBar(packet.getUuid());        switch (packet.getAction()) {            case ADD:                long entityId = session.getEntityCache().getNextEntityId().incrementAndGet();                bossBar = new BossBar(session, entityId, packet.getTitle(), packet.getHealth(), 0, 1, 0);                session.getEntityCache().addBossBar(packet.getUuid(), bossBar);                break;            case UPDATE_TITLE:                if (bossBar != null) bossBar.updateTitle(packet.getTitle());                break;            case UPDATE_HEALTH:                if (bossBar != null) bossBar.updateHealth(packet.getHealth());                break;            case REMOVE:                session.getEntityCache().removeBossBar(packet.getUuid());                break;            case UPDATE_STYLE:            case UPDATE_FLAGS:        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerChatPacket;import com.nukkitx.protocol.bedrock.packet.TextPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerChatPacket.class)public class JavaChatTranslator extends PacketTranslator<ServerChatPacket> {    @Override    public void translate(GeyserSession session, ServerChatPacket packet) {        TextPacket textPacket = new TextPacket();        textPacket.setPlatformChatId(\"\");        textPacket.setSourceName(\"\");        textPacket.setXuid(session.getAuthData().getXboxUUID());        switch (packet.getType()) {            case CHAT:                textPacket.setType(TextPacket.Type.CHAT);                break;            case SYSTEM:                textPacket.setType(TextPacket.Type.SYSTEM);                break;            case NOTIFICATION:                textPacket.setType(TextPacket.Type.TIP);                break;            default:                textPacket.setType(TextPacket.Type.RAW);                break;        }        textPacket.setNeedsTranslation(false);        textPacket.setMessage(MessageTranslator.convertMessage(packet.getMessage(), session.getLocale()));        session.sendUpstreamPacket(textPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerChatPacket;import com.nukkitx.protocol.bedrock.packet.TextPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerChatPacket.class)public class JavaChatTranslator extends PacketTranslator<ServerChatPacket> {    @Override    public void translate(ServerChatPacket packet, GeyserSession session) {        TextPacket textPacket = new TextPacket();        textPacket.setPlatformChatId(\"\");        textPacket.setSourceName(\"\");        textPacket.setXuid(session.getAuthData().getXboxUUID());        switch (packet.getType()) {            case CHAT:                textPacket.setType(TextPacket.Type.CHAT);                break;            case SYSTEM:                textPacket.setType(TextPacket.Type.SYSTEM);                break;            case NOTIFICATION:                textPacket.setType(TextPacket.Type.TIP);                break;            default:                textPacket.setType(TextPacket.Type.RAW);                break;        }        textPacket.setNeedsTranslation(false);        textPacket.setMessage(MessageTranslator.convertMessage(packet.getMessage(), session.getLocale()));        session.sendUpstreamPacket(textPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.command.CommandNode;import com.github.steveice10.mc.protocol.data.game.command.CommandParser;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareCommandsPacket;import com.nukkitx.protocol.bedrock.data.command.CommandData;import com.nukkitx.protocol.bedrock.data.command.CommandEnumData;import com.nukkitx.protocol.bedrock.data.command.CommandParam;import com.nukkitx.protocol.bedrock.data.command.CommandParamData;import com.nukkitx.protocol.bedrock.packet.AvailableCommandsPacket;import it.unimi.dsi.fastutil.Hash;import it.unimi.dsi.fastutil.ints.Int2ObjectMap;import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;import it.unimi.dsi.fastutil.ints.IntOpenHashSet;import it.unimi.dsi.fastutil.ints.IntSet;import it.unimi.dsi.fastutil.objects.Object2ObjectOpenCustomHashMap;import lombok.Getter;import lombok.ToString;import net.kyori.adventure.text.format.NamedTextColor;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.Enchantment;import org.geysermc.connector.registry.BlockRegistries;import java.util.*;@Translator(packet = ServerDeclareCommandsPacket.class)public class JavaDeclareCommandsTranslator extends PacketTranslator<ServerDeclareCommandsPacket> {    private static final String[] ENUM_BOOLEAN = {\"true\", \"false\"};    private static final String[] VALID_COLORS;    private static final String[] VALID_SCOREBOARD_SLOTS;    private static final Hash.Strategy<CommandParamData[][]> PARAM_STRATEGY = new Hash.Strategy<CommandParamData[][]>() {        @Override        public int hashCode(CommandParamData[][] o) {            return Arrays.deepHashCode(o);        }        @Override        public boolean equals(CommandParamData[][] a, CommandParamData[][] b) {            if (a == b) return true;            if (a == null || b == null) return false;            if (a.length != b.length) return false;            for (int i = 0; i < a.length; i++) {                CommandParamData[] a1 = a[i];                CommandParamData[] b1 = b[i];                if (a1.length != b1.length) return false;                for (int j = 0; j < a1.length; j++) {                    if (!a1[j].equals(b1[j])) return false;                }            }            return true;        }    };    static {        List<String> validColors = new ArrayList<>(NamedTextColor.NAMES.keys());        validColors.add(\"reset\");        VALID_COLORS = validColors.toArray(new String[0]);        List<String> teamOptions = new ArrayList<>(Arrays.asList(\"list\", \"sidebar\", \"belowName\"));        for (String color : NamedTextColor.NAMES.keys()) {            teamOptions.add(\"sidebar.team.\" + color);        }        VALID_SCOREBOARD_SLOTS = teamOptions.toArray(new String[0]);    }    @Override    public void translate(GeyserSession session, ServerDeclareCommandsPacket packet) {        if (!session.getConnector().getConfig().isCommandSuggestions()) {            session.getConnector().getLogger().debug(\"Not sending translated command suggestions as they are disabled.\");            AvailableCommandsPacket emptyPacket = new AvailableCommandsPacket();            session.sendUpstreamPacket(emptyPacket);            return;        }        CommandNode[] nodes = packet.getNodes();        List<CommandData> commandData = new ArrayList<>();        IntSet commandNodes = new IntOpenHashSet();        Set<String> knownAliases = new HashSet<>();        Map<CommandParamData[][], Set<String>> commands = new Object2ObjectOpenCustomHashMap<>(PARAM_STRATEGY);        Int2ObjectMap<List<CommandNode>> commandArgs = new Int2ObjectOpenHashMap<>();        CommandNode rootNode = nodes[packet.getFirstNodeIndex()];        for (int nodeIndex : rootNode.getChildIndices()) {            CommandNode node = nodes[nodeIndex];            if (!commandNodes.add(nodeIndex) || !knownAliases.add(node.getName().toLowerCase())) continue;            if (node.getChildIndices().length >= 1) {                for (int childIndex : node.getChildIndices()) {                    commandArgs.computeIfAbsent(nodeIndex, ArrayList::new).add(nodes[childIndex]);                }            }            CommandParamData[][] params = getParams(session, nodes[nodeIndex], nodes);            commands.computeIfAbsent(params, index -> new HashSet<>()).add(node.getName().toLowerCase());        }        List<CommandData.Flag> flags = Collections.emptyList();        for (Map.Entry<CommandParamData[][], Set<String>> entry : commands.entrySet()) {            String commandName = entry.getValue().iterator().next();             CommandEnumData aliases = new CommandEnumData(commandName + \"Aliases\", entry.getValue().toArray(new String[0]), false);            CommandData data = new CommandData(commandName, session.getConnector().getCommandManager().getDescription(commandName), flags, (byte) 0, aliases, entry.getKey());            commandData.add(data);        }        AvailableCommandsPacket availableCommandsPacket = new AvailableCommandsPacket();        availableCommandsPacket.getCommands().addAll(commandData);        session.getConnector().getLogger().debug(\"Sending command packet of \" + commandData.size() + \" commands\");        session.sendUpstreamPacket(availableCommandsPacket);    }    private static CommandParamData[][] getParams(GeyserSession session, CommandNode commandNode, CommandNode[] allNodes) {        if (commandNode.getRedirectIndex() != -1) {            GeyserConnector.getInstance().getLogger().debug(\"Redirecting command \" + commandNode.getName() + \" to \" + allNodes[commandNode.getRedirectIndex()].getName());            commandNode = allNodes[commandNode.getRedirectIndex()];        }        if (commandNode.getChildIndices().length >= 1) {            ParamInfo rootParam = new ParamInfo(commandNode, null);            rootParam.buildChildren(session, allNodes);            List<CommandParamData[]> treeData = rootParam.getTree();            return treeData.toArray(new CommandParamData[0][]);        }        return new CommandParamData[0][0];    }    private static Object mapCommandType(GeyserSession session, CommandParser parser) {        if (parser == null) {            return CommandParam.STRING;        }        switch (parser) {            case FLOAT:            case ROTATION:            case DOUBLE:                return CommandParam.FLOAT;            case INTEGER:            case LONG:                return CommandParam.INT;            case ENTITY:            case GAME_PROFILE:                return CommandParam.TARGET;            case BLOCK_POS:                return CommandParam.BLOCK_POSITION;            case COLUMN_POS:            case VEC3:                return CommandParam.POSITION;            case MESSAGE:                return CommandParam.MESSAGE;            case NBT:            case NBT_COMPOUND_TAG:            case NBT_TAG:            case NBT_PATH:                return CommandParam.JSON;            case RESOURCE_LOCATION:            case FUNCTION:                return CommandParam.FILE_PATH;            case BOOL:                return ENUM_BOOLEAN;            case OPERATION:                 return CommandParam.OPERATOR;            case BLOCK_STATE:                return BlockRegistries.JAVA_TO_BEDROCK_IDENTIFIERS.get().keySet().toArray(new String[0]);            case ITEM_STACK:                return session.getItemMappings().getItemNames();            case ITEM_ENCHANTMENT:                return Enchantment.JavaEnchantment.ALL_JAVA_IDENTIFIERS;            case ENTITY_SUMMON:                return EntityType.ALL_JAVA_IDENTIFIERS;            case COLOR:                return VALID_COLORS;            case SCOREBOARD_SLOT:                return VALID_SCOREBOARD_SLOTS;            default:                return CommandParam.STRING;        }    }    @Getter    @ToString    private static class ParamInfo {        private final CommandNode paramNode;        private final CommandParamData paramData;        private final List<ParamInfo> children;        public ParamInfo(CommandNode paramNode, CommandParamData paramData) {            this.paramNode = paramNode;            this.paramData = paramData;            this.children = new ArrayList<>();        }        public void buildChildren(GeyserSession session, CommandNode[] allNodes) {            for (int paramID : paramNode.getChildIndices()) {                CommandNode paramNode = allNodes[paramID];                if (paramNode == this.paramNode) {                    continue;                }                if (paramNode.getParser() == null) {                    boolean foundCompatible = false;                    for (int i = 0; i < children.size(); i++) {                        ParamInfo enumParamInfo = children.get(i);                        if (isCompatible(allNodes, enumParamInfo.getParamNode(), paramNode)) {                            foundCompatible = true;                            String[] enumOptions = Arrays.copyOf(enumParamInfo.getParamData().getEnumData().getValues(), enumParamInfo.getParamData().getEnumData().getValues().length + 1);                            enumOptions[enumOptions.length - 1] = paramNode.getName();                            CommandEnumData enumData = new CommandEnumData(enumParamInfo.getParamData().getEnumData().getName(), enumOptions, false);                            children.set(i, new ParamInfo(enumParamInfo.getParamNode(), new CommandParamData(enumParamInfo.getParamData().getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));                            break;                        }                    }                    if (!foundCompatible) {                        CommandEnumData enumData = new CommandEnumData(paramNode.getName(), new String[]{paramNode.getName()}, false);                        children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));                    }                } else {                    Object mappedType = mapCommandType(session, paramNode.getParser());                    CommandEnumData enumData = null;                    CommandParam type = null;                    if (mappedType instanceof String[]) {                        enumData = new CommandEnumData(paramNode.getParser().name().toLowerCase(), (String[]) mappedType, false);                    } else {                        type = (CommandParam) mappedType;                    }                    children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, type, null, Collections.emptyList())));                }            }            for (ParamInfo child : children) {                child.buildChildren(session, allNodes);            }        }        private boolean isCompatible(CommandNode[] allNodes, CommandNode a, CommandNode b) {            if (a == b) return true;            if (a.getParser() != b.getParser()) return false;            if (a.getChildIndices().length != b.getChildIndices().length) return false;            for (int i = 0; i < a.getChildIndices().length; i++) {                boolean hasSimilarity = false;                CommandNode a1 = allNodes[a.getChildIndices()[i]];                for (int j = 0; j < b.getChildIndices().length; j++) {                    if (isCompatible(allNodes, a1, allNodes[b.getChildIndices()[j]])) {                        hasSimilarity = true;                        break;                    }                }                if (!hasSimilarity) {                    return false;                }            }            return true;        }        public List<CommandParamData[]> getTree() {            List<CommandParamData[]> treeParamData = new ArrayList<>();            for (ParamInfo child : children) {                List<CommandParamData[]> childTree = child.getTree();                for (CommandParamData[] subChild : childTree) {                    CommandParamData[] tmpTree = new CommandParamData[subChild.length + 1];                    tmpTree[0] = child.getParamData();                    System.arraycopy(subChild, 0, tmpTree, 1, subChild.length);                    treeParamData.add(tmpTree);                }                if (childTree.size() == 0) {                    treeParamData.add(new CommandParamData[] { child.getParamData() });                }            }            return treeParamData;        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.command.CommandNode;import com.github.steveice10.mc.protocol.data.game.command.CommandParser;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareCommandsPacket;import com.nukkitx.protocol.bedrock.data.command.CommandData;import com.nukkitx.protocol.bedrock.data.command.CommandEnumData;import com.nukkitx.protocol.bedrock.data.command.CommandParam;import com.nukkitx.protocol.bedrock.data.command.CommandParamData;import com.nukkitx.protocol.bedrock.packet.AvailableCommandsPacket;import it.unimi.dsi.fastutil.Hash;import it.unimi.dsi.fastutil.ints.Int2ObjectMap;import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;import it.unimi.dsi.fastutil.ints.IntOpenHashSet;import it.unimi.dsi.fastutil.ints.IntSet;import it.unimi.dsi.fastutil.objects.Object2ObjectOpenCustomHashMap;import lombok.Getter;import lombok.ToString;import net.kyori.adventure.text.format.NamedTextColor;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.Enchantment;import org.geysermc.connector.registry.BlockRegistries;import java.util.*;@Translator(packet = ServerDeclareCommandsPacket.class)public class JavaDeclareCommandsTranslator extends PacketTranslator<ServerDeclareCommandsPacket> {    private static final String[] ENUM_BOOLEAN = {\"true\", \"false\"};    private static final String[] VALID_COLORS;    private static final String[] VALID_SCOREBOARD_SLOTS;    private static final Hash.Strategy<CommandParamData[][]> PARAM_STRATEGY = new Hash.Strategy<CommandParamData[][]>() {        @Override        public int hashCode(CommandParamData[][] o) {            return Arrays.deepHashCode(o);        }        @Override        public boolean equals(CommandParamData[][] a, CommandParamData[][] b) {            if (a == b) return true;            if (a == null || b == null) return false;            if (a.length != b.length) return false;            for (int i = 0; i < a.length; i++) {                CommandParamData[] a1 = a[i];                CommandParamData[] b1 = b[i];                if (a1.length != b1.length) return false;                for (int j = 0; j < a1.length; j++) {                    if (!a1[j].equals(b1[j])) return false;                }            }            return true;        }    };    static {        List<String> validColors = new ArrayList<>(NamedTextColor.NAMES.keys());        validColors.add(\"reset\");        VALID_COLORS = validColors.toArray(new String[0]);        List<String> teamOptions = new ArrayList<>(Arrays.asList(\"list\", \"sidebar\", \"belowName\"));        for (String color : NamedTextColor.NAMES.keys()) {            teamOptions.add(\"sidebar.team.\" + color);        }        VALID_SCOREBOARD_SLOTS = teamOptions.toArray(new String[0]);    }    @Override    public void translate(ServerDeclareCommandsPacket packet, GeyserSession session) {        if (!session.getConnector().getConfig().isCommandSuggestions()) {            session.getConnector().getLogger().debug(\"Not sending translated command suggestions as they are disabled.\");            AvailableCommandsPacket emptyPacket = new AvailableCommandsPacket();            session.sendUpstreamPacket(emptyPacket);            return;        }        CommandNode[] nodes = packet.getNodes();        List<CommandData> commandData = new ArrayList<>();        IntSet commandNodes = new IntOpenHashSet();        Set<String> knownAliases = new HashSet<>();        Map<CommandParamData[][], Set<String>> commands = new Object2ObjectOpenCustomHashMap<>(PARAM_STRATEGY);        Int2ObjectMap<List<CommandNode>> commandArgs = new Int2ObjectOpenHashMap<>();        CommandNode rootNode = nodes[packet.getFirstNodeIndex()];        for (int nodeIndex : rootNode.getChildIndices()) {            CommandNode node = nodes[nodeIndex];            if (!commandNodes.add(nodeIndex) || !knownAliases.add(node.getName().toLowerCase())) continue;            if (node.getChildIndices().length >= 1) {                for (int childIndex : node.getChildIndices()) {                    commandArgs.computeIfAbsent(nodeIndex, ArrayList::new).add(nodes[childIndex]);                }            }            CommandParamData[][] params = getParams(session, nodes[nodeIndex], nodes);            commands.computeIfAbsent(params, index -> new HashSet<>()).add(node.getName().toLowerCase());        }        List<CommandData.Flag> flags = Collections.emptyList();        for (Map.Entry<CommandParamData[][], Set<String>> entry : commands.entrySet()) {            String commandName = entry.getValue().iterator().next();             CommandEnumData aliases = new CommandEnumData(commandName + \"Aliases\", entry.getValue().toArray(new String[0]), false);            CommandData data = new CommandData(commandName, session.getConnector().getCommandManager().getDescription(commandName), flags, (byte) 0, aliases, entry.getKey());            commandData.add(data);        }        AvailableCommandsPacket availableCommandsPacket = new AvailableCommandsPacket();        availableCommandsPacket.getCommands().addAll(commandData);        session.getConnector().getLogger().debug(\"Sending command packet of \" + commandData.size() + \" commands\");        session.sendUpstreamPacket(availableCommandsPacket);    }    private static CommandParamData[][] getParams(GeyserSession session, CommandNode commandNode, CommandNode[] allNodes) {        if (commandNode.getRedirectIndex() != -1) {            GeyserConnector.getInstance().getLogger().debug(\"Redirecting command \" + commandNode.getName() + \" to \" + allNodes[commandNode.getRedirectIndex()].getName());            commandNode = allNodes[commandNode.getRedirectIndex()];        }        if (commandNode.getChildIndices().length >= 1) {            ParamInfo rootParam = new ParamInfo(commandNode, null);            rootParam.buildChildren(session, allNodes);            List<CommandParamData[]> treeData = rootParam.getTree();            return treeData.toArray(new CommandParamData[0][]);        }        return new CommandParamData[0][0];    }    private static Object mapCommandType(GeyserSession session, CommandParser parser) {        if (parser == null) {            return CommandParam.STRING;        }        switch (parser) {            case FLOAT:            case ROTATION:            case DOUBLE:                return CommandParam.FLOAT;            case INTEGER:            case LONG:                return CommandParam.INT;            case ENTITY:            case GAME_PROFILE:                return CommandParam.TARGET;            case BLOCK_POS:                return CommandParam.BLOCK_POSITION;            case COLUMN_POS:            case VEC3:                return CommandParam.POSITION;            case MESSAGE:                return CommandParam.MESSAGE;            case NBT:            case NBT_COMPOUND_TAG:            case NBT_TAG:            case NBT_PATH:                return CommandParam.JSON;            case RESOURCE_LOCATION:            case FUNCTION:                return CommandParam.FILE_PATH;            case BOOL:                return ENUM_BOOLEAN;            case OPERATION:                 return CommandParam.OPERATOR;            case BLOCK_STATE:                return BlockRegistries.JAVA_TO_BEDROCK_IDENTIFIERS.get().keySet().toArray(new String[0]);            case ITEM_STACK:                return session.getItemMappings().getItemNames();            case ITEM_ENCHANTMENT:                return Enchantment.JavaEnchantment.ALL_JAVA_IDENTIFIERS;            case ENTITY_SUMMON:                return EntityType.ALL_JAVA_IDENTIFIERS;            case COLOR:                return VALID_COLORS;            case SCOREBOARD_SLOT:                return VALID_SCOREBOARD_SLOTS;            default:                return CommandParam.STRING;        }    }    @Getter    @ToString    private static class ParamInfo {        private final CommandNode paramNode;        private final CommandParamData paramData;        private final List<ParamInfo> children;        public ParamInfo(CommandNode paramNode, CommandParamData paramData) {            this.paramNode = paramNode;            this.paramData = paramData;            this.children = new ArrayList<>();        }        public void buildChildren(GeyserSession session, CommandNode[] allNodes) {            for (int paramID : paramNode.getChildIndices()) {                CommandNode paramNode = allNodes[paramID];                if (paramNode == this.paramNode) {                    continue;                }                if (paramNode.getParser() == null) {                    boolean foundCompatible = false;                    for (int i = 0; i < children.size(); i++) {                        ParamInfo enumParamInfo = children.get(i);                        if (isCompatible(allNodes, enumParamInfo.getParamNode(), paramNode)) {                            foundCompatible = true;                            String[] enumOptions = Arrays.copyOf(enumParamInfo.getParamData().getEnumData().getValues(), enumParamInfo.getParamData().getEnumData().getValues().length + 1);                            enumOptions[enumOptions.length - 1] = paramNode.getName();                            CommandEnumData enumData = new CommandEnumData(enumParamInfo.getParamData().getEnumData().getName(), enumOptions, false);                            children.set(i, new ParamInfo(enumParamInfo.getParamNode(), new CommandParamData(enumParamInfo.getParamData().getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));                            break;                        }                    }                    if (!foundCompatible) {                        CommandEnumData enumData = new CommandEnumData(paramNode.getName(), new String[]{paramNode.getName()}, false);                        children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));                    }                } else {                    Object mappedType = mapCommandType(session, paramNode.getParser());                    CommandEnumData enumData = null;                    CommandParam type = null;                    if (mappedType instanceof String[]) {                        enumData = new CommandEnumData(paramNode.getParser().name().toLowerCase(), (String[]) mappedType, false);                    } else {                        type = (CommandParam) mappedType;                    }                    children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, type, null, Collections.emptyList())));                }            }            for (ParamInfo child : children) {                child.buildChildren(session, allNodes);            }        }        private boolean isCompatible(CommandNode[] allNodes, CommandNode a, CommandNode b) {            if (a == b) return true;            if (a.getParser() != b.getParser()) return false;            if (a.getChildIndices().length != b.getChildIndices().length) return false;            for (int i = 0; i < a.getChildIndices().length; i++) {                boolean hasSimilarity = false;                CommandNode a1 = allNodes[a.getChildIndices()[i]];                for (int j = 0; j < b.getChildIndices().length; j++) {                    if (isCompatible(allNodes, a1, allNodes[b.getChildIndices()[j]])) {                        hasSimilarity = true;                        break;                    }                }                if (!hasSimilarity) {                    return false;                }            }            return true;        }        public List<CommandParamData[]> getTree() {            List<CommandParamData[]> treeParamData = new ArrayList<>();            for (ParamInfo child : children) {                List<CommandParamData[]> childTree = child.getTree();                for (CommandParamData[] subChild : childTree) {                    CommandParamData[] tmpTree = new CommandParamData[subChild.length + 1];                    tmpTree[0] = child.getParamData();                    System.arraycopy(subChild, 0, tmpTree, 1, subChild.length);                    treeParamData.add(tmpTree);                }                if (childTree.size() == 0) {                    treeParamData.add(new CommandParamData[] { child.getParamData() });                }            }            return treeParamData;        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;import com.github.steveice10.mc.protocol.data.game.recipe.Recipe;import com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;import com.github.steveice10.mc.protocol.data.game.recipe.data.StoneCuttingRecipeData;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareRecipesPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.protocol.bedrock.data.inventory.CraftingData;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;import it.unimi.dsi.fastutil.ints.*;import lombok.AllArgsConstructor;import lombok.EqualsAndHashCode;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.InventoryUtils;import java.util.*;import java.util.stream.Collectors;import static org.geysermc.connector.utils.InventoryUtils.LAST_RECIPE_NET_ID;@Translator(packet = ServerDeclareRecipesPacket.class)public class JavaDeclareRecipesTranslator extends PacketTranslator<ServerDeclareRecipesPacket> {    private static final List<CraftingData> CARTOGRAPHY_RECIPES = Arrays.asList(            CraftingData.fromMulti(UUID.fromString(\"8b36268c-1829-483c-a0f1-993b7156a8f2\"), ++LAST_RECIPE_NET_ID),             CraftingData.fromMulti(UUID.fromString(\"442d85ed-8272-4543-a6f1-418f90ded05d\"), ++LAST_RECIPE_NET_ID),             CraftingData.fromMulti(UUID.fromString(\"98c84b38-1085-46bd-b1ce-dd38c159e6cc\"), ++LAST_RECIPE_NET_ID),             CraftingData.fromMulti(UUID.fromString(\"602234e4-cac1-4353-8bb7-b1ebff70024b\"), ++LAST_RECIPE_NET_ID)     );    @Override    public void translate(GeyserSession session, ServerDeclareRecipesPacket packet) {        Map<RecipeType, List<CraftingData>> recipeTypes = Registries.CRAFTING_DATA.forVersion(session.getUpstream().getProtocolVersion());        int netId = InventoryUtils.LAST_RECIPE_NET_ID + 1;        Int2ObjectMap<Recipe> recipeMap = new Int2ObjectOpenHashMap<>(Registries.RECIPES.forVersion(session.getUpstream().getProtocolVersion()));        Int2ObjectMap<List<StoneCuttingRecipeData>> unsortedStonecutterData = new Int2ObjectOpenHashMap<>();        CraftingDataPacket craftingDataPacket = new CraftingDataPacket();        craftingDataPacket.setCleanRecipes(true);        for (Recipe recipe : packet.getRecipes()) {            switch (recipe.getType()) {                case CRAFTING_SHAPELESS: {                    ShapelessRecipeData shapelessRecipeData = (ShapelessRecipeData) recipe.getData();                    ItemData output = ItemTranslator.translateToBedrock(session, shapelessRecipeData.getResult());                    output = output.toBuilder().tag(null).build();                    ItemData[][] inputCombinations = combinations(session, shapelessRecipeData.getIngredients());                    for (ItemData[] inputs : inputCombinations) {                        UUID uuid = UUID.randomUUID();                        craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),                                Arrays.asList(inputs), Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));                        recipeMap.put(netId++, recipe);                    }                    break;                }                case CRAFTING_SHAPED: {                    ShapedRecipeData shapedRecipeData = (ShapedRecipeData) recipe.getData();                    ItemData output = ItemTranslator.translateToBedrock(session, shapedRecipeData.getResult());                    output = output.toBuilder().tag(null).build();                    ItemData[][] inputCombinations = combinations(session, shapedRecipeData.getIngredients());                    for (ItemData[] inputs : inputCombinations) {                        UUID uuid = UUID.randomUUID();                        craftingDataPacket.getCraftingData().add(CraftingData.fromShaped(uuid.toString(),                                shapedRecipeData.getWidth(), shapedRecipeData.getHeight(), Arrays.asList(inputs),                                        Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));                        recipeMap.put(netId++, recipe);                    }                    break;                }                case STONECUTTING: {                    StoneCuttingRecipeData stoneCuttingData = (StoneCuttingRecipeData) recipe.getData();                    ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];                    List<StoneCuttingRecipeData> data = unsortedStonecutterData.get(ingredient.getId());                    if (data == null) {                        data = new ArrayList<>();                        unsortedStonecutterData.put(ingredient.getId(), data);                    }                    data.add(stoneCuttingData);                    break;                }                default: {                    List<CraftingData> craftingData = recipeTypes.get(recipe.getType());                    if (craftingData != null) {                        craftingDataPacket.getCraftingData().addAll(craftingData);                    }                    break;                }            }        }        craftingDataPacket.getCraftingData().addAll(CARTOGRAPHY_RECIPES);        craftingDataPacket.getPotionMixData().addAll(Registries.POTION_MIXES.get());        Int2ObjectMap<IntList> stonecutterRecipeMap = new Int2ObjectOpenHashMap<>();        for (Int2ObjectMap.Entry<List<StoneCuttingRecipeData>> data : unsortedStonecutterData.int2ObjectEntrySet()) {            data.getValue().sort(Comparator.comparing((stoneCuttingRecipeData ->                    session.getItemMappings().getItems().get(stoneCuttingRecipeData.getResult().getId()).getJavaIdentifier())));            for (StoneCuttingRecipeData stoneCuttingData : data.getValue()) {                ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];                ItemData input = ItemTranslator.translateToBedrock(session, ingredient);                ItemData output = ItemTranslator.translateToBedrock(session, stoneCuttingData.getResult());                UUID uuid = UUID.randomUUID();                craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),                        Collections.singletonList(input), Collections.singletonList(output), uuid, \"stonecutter\", 0, netId++));                IntList outputs = stonecutterRecipeMap.get(ingredient.getId());                if (outputs == null) {                    outputs = new IntArrayList();                    stonecutterRecipeMap.put(ingredient.getId(), outputs);                }                outputs.add(stoneCuttingData.getResult().getId());            }        }        session.sendUpstreamPacket(craftingDataPacket);        session.setCraftingRecipes(recipeMap);        session.getUnlockedRecipes().clear();        session.setStonecutterRecipes(stonecutterRecipeMap);        session.getLastRecipeNetId().set(netId);    }    private ItemData[][] combinations(GeyserSession session, Ingredient[] ingredients) {        Map<Set<ItemData>, IntSet> squashedOptions = new HashMap<>();        for (int i = 0; i < ingredients.length; i++) {            if (ingredients[i].getOptions().length == 0) {                squashedOptions.computeIfAbsent(Collections.singleton(ItemData.AIR), k -> new IntOpenHashSet()).add(i);                continue;            }            Ingredient ingredient = ingredients[i];            Map<GroupedItem, List<ItemData>> groupedByIds = Arrays.stream(ingredient.getOptions())                    .map(item -> ItemTranslator.translateToBedrock(session, item))                    .collect(Collectors.groupingBy(item -> new GroupedItem(item.getId(), item.getCount(), item.getTag())));            Set<ItemData> optionSet = new HashSet<>(groupedByIds.size());            for (Map.Entry<GroupedItem, List<ItemData>> entry : groupedByIds.entrySet()) {                if (entry.getValue().size() > 1) {                    GroupedItem groupedItem = entry.getKey();                    int idCount = 0;                    for (ItemMapping mapping : session.getItemMappings().getItems().values()) {                        if (mapping.getBedrockId() == groupedItem.id) {                            idCount++;                        }                    }                    if (entry.getValue().size() < idCount) {                        optionSet.addAll(entry.getValue());                    } else {                        optionSet.add(ItemData.builder()                                .id(groupedItem.id)                                .damage(Short.MAX_VALUE)                                .count(groupedItem.count)                                .tag(groupedItem.tag).build());                    }                } else {                    ItemData item = entry.getValue().get(0);                    optionSet.add(item);                }            }            squashedOptions.computeIfAbsent(optionSet, k -> new IntOpenHashSet()).add(i);        }        int totalCombinations = 1;        for (Set<ItemData> optionSet : squashedOptions.keySet()) {            totalCombinations *= optionSet.size();        }        if (totalCombinations > 500) {            ItemData[] translatedItems = new ItemData[ingredients.length];            for (int i = 0; i < ingredients.length; i++) {                if (ingredients[i].getOptions().length > 0) {                    translatedItems[i] = ItemTranslator.translateToBedrock(session, ingredients[i].getOptions()[0]);                } else {                    translatedItems[i] = ItemData.AIR;                }            }            return new ItemData[][]{translatedItems};        }        List<Set<ItemData>> sortedSets = new ArrayList<>(squashedOptions.keySet());        sortedSets.sort(Comparator.comparing(Set::size, Comparator.reverseOrder()));        ItemData[][] combinations = new ItemData[totalCombinations][ingredients.length];        int x = 1;        for (Set<ItemData> set : sortedSets) {            IntSet slotSet = squashedOptions.get(set);            int i = 0;            for (ItemData item : set) {                for (int j = 0; j < totalCombinations / set.size(); j++) {                    final int comboIndex = (i * x) + (j % x) + ((j / x) * set.size() * x);                    for (int slot : slotSet) {                        combinations[comboIndex][slot] = item;                    }                }                i++;            }            x *= set.size();        }        return combinations;    }    @EqualsAndHashCode    @AllArgsConstructor    private static class GroupedItem {        int id;        int count;        NbtMap tag;    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;import com.github.steveice10.mc.protocol.data.game.recipe.Recipe;import com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;import com.github.steveice10.mc.protocol.data.game.recipe.data.StoneCuttingRecipeData;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareRecipesPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.protocol.bedrock.data.inventory.CraftingData;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;import it.unimi.dsi.fastutil.ints.*;import lombok.AllArgsConstructor;import lombok.EqualsAndHashCode;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.InventoryUtils;import java.util.*;import java.util.stream.Collectors;import static org.geysermc.connector.utils.InventoryUtils.LAST_RECIPE_NET_ID;@Translator(packet = ServerDeclareRecipesPacket.class)public class JavaDeclareRecipesTranslator extends PacketTranslator<ServerDeclareRecipesPacket> {    private static final List<CraftingData> CARTOGRAPHY_RECIPES = Arrays.asList(            CraftingData.fromMulti(UUID.fromString(\"8b36268c-1829-483c-a0f1-993b7156a8f2\"), ++LAST_RECIPE_NET_ID),             CraftingData.fromMulti(UUID.fromString(\"442d85ed-8272-4543-a6f1-418f90ded05d\"), ++LAST_RECIPE_NET_ID),             CraftingData.fromMulti(UUID.fromString(\"98c84b38-1085-46bd-b1ce-dd38c159e6cc\"), ++LAST_RECIPE_NET_ID),             CraftingData.fromMulti(UUID.fromString(\"602234e4-cac1-4353-8bb7-b1ebff70024b\"), ++LAST_RECIPE_NET_ID)     );    @Override    public void translate(ServerDeclareRecipesPacket packet, GeyserSession session) {        Map<RecipeType, List<CraftingData>> recipeTypes = Registries.CRAFTING_DATA.forVersion(session.getUpstream().getProtocolVersion());        int netId = InventoryUtils.LAST_RECIPE_NET_ID + 1;        Int2ObjectMap<Recipe> recipeMap = new Int2ObjectOpenHashMap<>(Registries.RECIPES.forVersion(session.getUpstream().getProtocolVersion()));        Int2ObjectMap<List<StoneCuttingRecipeData>> unsortedStonecutterData = new Int2ObjectOpenHashMap<>();        CraftingDataPacket craftingDataPacket = new CraftingDataPacket();        craftingDataPacket.setCleanRecipes(true);        for (Recipe recipe : packet.getRecipes()) {            switch (recipe.getType()) {                case CRAFTING_SHAPELESS: {                    ShapelessRecipeData shapelessRecipeData = (ShapelessRecipeData) recipe.getData();                    ItemData output = ItemTranslator.translateToBedrock(session, shapelessRecipeData.getResult());                    output = output.toBuilder().tag(null).build();                    ItemData[][] inputCombinations = combinations(session, shapelessRecipeData.getIngredients());                    for (ItemData[] inputs : inputCombinations) {                        UUID uuid = UUID.randomUUID();                        craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),                                Arrays.asList(inputs), Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));                        recipeMap.put(netId++, recipe);                    }                    break;                }                case CRAFTING_SHAPED: {                    ShapedRecipeData shapedRecipeData = (ShapedRecipeData) recipe.getData();                    ItemData output = ItemTranslator.translateToBedrock(session, shapedRecipeData.getResult());                    output = output.toBuilder().tag(null).build();                    ItemData[][] inputCombinations = combinations(session, shapedRecipeData.getIngredients());                    for (ItemData[] inputs : inputCombinations) {                        UUID uuid = UUID.randomUUID();                        craftingDataPacket.getCraftingData().add(CraftingData.fromShaped(uuid.toString(),                                shapedRecipeData.getWidth(), shapedRecipeData.getHeight(), Arrays.asList(inputs),                                        Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));                        recipeMap.put(netId++, recipe);                    }                    break;                }                case STONECUTTING: {                    StoneCuttingRecipeData stoneCuttingData = (StoneCuttingRecipeData) recipe.getData();                    ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];                    List<StoneCuttingRecipeData> data = unsortedStonecutterData.get(ingredient.getId());                    if (data == null) {                        data = new ArrayList<>();                        unsortedStonecutterData.put(ingredient.getId(), data);                    }                    data.add(stoneCuttingData);                    break;                }                default: {                    List<CraftingData> craftingData = recipeTypes.get(recipe.getType());                    if (craftingData != null) {                        craftingDataPacket.getCraftingData().addAll(craftingData);                    }                    break;                }            }        }        craftingDataPacket.getCraftingData().addAll(CARTOGRAPHY_RECIPES);        craftingDataPacket.getPotionMixData().addAll(Registries.POTION_MIXES.get());        Int2ObjectMap<IntList> stonecutterRecipeMap = new Int2ObjectOpenHashMap<>();        for (Int2ObjectMap.Entry<List<StoneCuttingRecipeData>> data : unsortedStonecutterData.int2ObjectEntrySet()) {            data.getValue().sort(Comparator.comparing((stoneCuttingRecipeData ->                    session.getItemMappings().getItems().get(stoneCuttingRecipeData.getResult().getId()).getJavaIdentifier())));            for (StoneCuttingRecipeData stoneCuttingData : data.getValue()) {                ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];                ItemData input = ItemTranslator.translateToBedrock(session, ingredient);                ItemData output = ItemTranslator.translateToBedrock(session, stoneCuttingData.getResult());                UUID uuid = UUID.randomUUID();                craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),                        Collections.singletonList(input), Collections.singletonList(output), uuid, \"stonecutter\", 0, netId++));                IntList outputs = stonecutterRecipeMap.get(ingredient.getId());                if (outputs == null) {                    outputs = new IntArrayList();                    stonecutterRecipeMap.put(ingredient.getId(), outputs);                }                outputs.add(stoneCuttingData.getResult().getId());            }        }        session.sendUpstreamPacket(craftingDataPacket);        session.setCraftingRecipes(recipeMap);        session.getUnlockedRecipes().clear();        session.setStonecutterRecipes(stonecutterRecipeMap);        session.getLastRecipeNetId().set(netId);    }    private ItemData[][] combinations(GeyserSession session, Ingredient[] ingredients) {        Map<Set<ItemData>, IntSet> squashedOptions = new HashMap<>();        for (int i = 0; i < ingredients.length; i++) {            if (ingredients[i].getOptions().length == 0) {                squashedOptions.computeIfAbsent(Collections.singleton(ItemData.AIR), k -> new IntOpenHashSet()).add(i);                continue;            }            Ingredient ingredient = ingredients[i];            Map<GroupedItem, List<ItemData>> groupedByIds = Arrays.stream(ingredient.getOptions())                    .map(item -> ItemTranslator.translateToBedrock(session, item))                    .collect(Collectors.groupingBy(item -> new GroupedItem(item.getId(), item.getCount(), item.getTag())));            Set<ItemData> optionSet = new HashSet<>(groupedByIds.size());            for (Map.Entry<GroupedItem, List<ItemData>> entry : groupedByIds.entrySet()) {                if (entry.getValue().size() > 1) {                    GroupedItem groupedItem = entry.getKey();                    int idCount = 0;                    for (ItemMapping mapping : session.getItemMappings().getItems().values()) {                        if (mapping.getBedrockId() == groupedItem.id) {                            idCount++;                        }                    }                    if (entry.getValue().size() < idCount) {                        optionSet.addAll(entry.getValue());                    } else {                        optionSet.add(ItemData.builder()                                .id(groupedItem.id)                                .damage(Short.MAX_VALUE)                                .count(groupedItem.count)                                .tag(groupedItem.tag).build());                    }                } else {                    ItemData item = entry.getValue().get(0);                    optionSet.add(item);                }            }            squashedOptions.computeIfAbsent(optionSet, k -> new IntOpenHashSet()).add(i);        }        int totalCombinations = 1;        for (Set<ItemData> optionSet : squashedOptions.keySet()) {            totalCombinations *= optionSet.size();        }        if (totalCombinations > 500) {            ItemData[] translatedItems = new ItemData[ingredients.length];            for (int i = 0; i < ingredients.length; i++) {                if (ingredients[i].getOptions().length > 0) {                    translatedItems[i] = ItemTranslator.translateToBedrock(session, ingredients[i].getOptions()[0]);                } else {                    translatedItems[i] = ItemData.AIR;                }            }            return new ItemData[][]{translatedItems};        }        List<Set<ItemData>> sortedSets = new ArrayList<>(squashedOptions.keySet());        sortedSets.sort(Comparator.comparing(Set::size, Comparator.reverseOrder()));        ItemData[][] combinations = new ItemData[totalCombinations][ingredients.length];        int x = 1;        for (Set<ItemData> set : sortedSets) {            IntSet slotSet = squashedOptions.get(set);            int i = 0;            for (ItemData item : set) {                for (int j = 0; j < totalCombinations / set.size(); j++) {                    final int comboIndex = (i * x) + (j % x) + ((j / x) * set.size() * x);                    for (int slot : slotSet) {                        combinations[comboIndex][slot] = item;                    }                }                i++;            }            x *= set.size();        }        return combinations;    }    @EqualsAndHashCode    @AllArgsConstructor    private static class GroupedItem {        int id;        int count;        NbtMap tag;    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareTagsPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerDeclareTagsPacket.class)public class JavaDeclareTagsTranslator extends PacketTranslator<ServerDeclareTagsPacket> {    @Override    public void translate(GeyserSession session, ServerDeclareTagsPacket packet) {        session.getTagCache().loadPacket(packet);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareTagsPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerDeclareTagsPacket.class)public class JavaDeclareTagsTranslator extends PacketTranslator<ServerDeclareTagsPacket> {    @Override    public void translate(ServerDeclareTagsPacket packet, GeyserSession session) {        session.getTagCache().loadPacket(packet);    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDifficultyPacket;import com.nukkitx.protocol.bedrock.packet.SetDifficultyPacket;@Translator(packet = ServerDifficultyPacket.class)public class JavaDifficultyTranslator extends PacketTranslator<ServerDifficultyPacket> {    @Override    public void translate(GeyserSession session, ServerDifficultyPacket packet) {        SetDifficultyPacket setDifficultyPacket = new SetDifficultyPacket();        setDifficultyPacket.setDifficulty(packet.getDifficulty().ordinal());        session.sendUpstreamPacket(setDifficultyPacket);        session.getWorldCache().setDifficulty(packet.getDifficulty());    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDifficultyPacket;import com.nukkitx.protocol.bedrock.packet.SetDifficultyPacket;@Translator(packet = ServerDifficultyPacket.class)public class JavaDifficultyTranslator extends PacketTranslator<ServerDifficultyPacket> {    @Override    public void translate(ServerDifficultyPacket packet, GeyserSession session) {        SetDifficultyPacket setDifficultyPacket = new SetDifficultyPacket();        setDifficultyPacket.setDifficulty(packet.getDifficulty().ordinal());        session.sendUpstreamPacket(setDifficultyPacket);        session.getWorldCache().setDifficulty(packet.getDifficulty());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDisconnectPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerDisconnectPacket.class)public class JavaDisconnectPacket extends PacketTranslator<ServerDisconnectPacket> {    @Override    public void translate(GeyserSession session, ServerDisconnectPacket packet) {        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerDisconnectPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerDisconnectPacket.class)public class JavaDisconnectPacket extends PacketTranslator<ServerDisconnectPacket> {    @Override    public void translate(ServerDisconnectPacket packet, GeyserSession session) {        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.HandPreference;import com.github.steveice10.mc.protocol.data.game.setting.ChatVisibility;import com.github.steveice10.mc.protocol.data.game.setting.SkinPart;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientSettingsPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerJoinGamePacket;import com.nukkitx.protocol.bedrock.data.GameRuleData;import com.nukkitx.protocol.bedrock.data.PlayerPermission;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.BiomeTranslator;import org.geysermc.connector.utils.ChunkUtils;import org.geysermc.connector.utils.DimensionUtils;import org.geysermc.connector.utils.PluginMessageUtils;import java.util.Arrays;import java.util.List;@Translator(packet = ServerJoinGamePacket.class)public class JavaJoinGameTranslator extends PacketTranslator<ServerJoinGamePacket> {    private static final List<SkinPart> SKIN_PART_VALUES = Arrays.asList(SkinPart.values());    @Override    public void translate(GeyserSession session, ServerJoinGamePacket packet) {        PlayerEntity entity = session.getPlayerEntity();        entity.setEntityId(packet.getEntityId());        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());        if (session.isSpawned()) {            String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);            DimensionUtils.switchDimension(session, fakeDim);            session.getWorldCache().removeScoreboard();        }        session.setWorldName(packet.getWorldName());        BiomeTranslator.loadServerBiomes(session, packet.getDimensionCodec());        session.getTagCache().clear();        AdventureSettingsPacket bedrockPacket = new AdventureSettingsPacket();        bedrockPacket.setUniqueEntityId(session.getPlayerEntity().getGeyserId());        bedrockPacket.setPlayerPermission(PlayerPermission.MEMBER);        session.sendUpstreamPacket(bedrockPacket);        PlayStatusPacket playStatus = new PlayStatusPacket();        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();        playerGameTypePacket.setGamemode(packet.getGameMode().ordinal());        session.sendUpstreamPacket(playerGameTypePacket);        session.setGameMode(packet.getGameMode());        SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();        entityDataPacket.setRuntimeEntityId(entity.getGeyserId());        entityDataPacket.getMetadata().putAll(entity.getMetadata());        session.sendUpstreamPacket(entityDataPacket);        GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();        gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\", !packet.isEnableRespawnScreen()));        session.sendUpstreamPacket(gamerulePacket);        session.setReducedDebugInfo(packet.isReducedDebugInfo());        session.setRenderDistance(packet.getViewDistance());        String locale = session.getLocale();        ClientSettingsPacket clientSettingsPacket = new ClientSettingsPacket(locale, (byte) session.getRenderDistance(), ChatVisibility.FULL, true, SKIN_PART_VALUES, HandPreference.RIGHT_HAND, false);        session.sendDownstreamPacket(clientSettingsPacket);        session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:brand\", PluginMessageUtils.getGeyserBrandData()));        if (session.getRemoteAuthType() == AuthType.FLOODGATE) {            session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:register\", PluginMessageUtils.getFloodgateRegisterData()));        }        if (!newDimension.equals(session.getDimension())) {            DimensionUtils.switchDimension(session, newDimension);        }        ChunkUtils.applyDimensionHeight(session, packet.getDimension());    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.HandPreference;import com.github.steveice10.mc.protocol.data.game.setting.ChatVisibility;import com.github.steveice10.mc.protocol.data.game.setting.SkinPart;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientSettingsPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerJoinGamePacket;import com.nukkitx.protocol.bedrock.data.GameRuleData;import com.nukkitx.protocol.bedrock.data.PlayerPermission;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.BiomeTranslator;import org.geysermc.connector.utils.ChunkUtils;import org.geysermc.connector.utils.DimensionUtils;import org.geysermc.connector.utils.PluginMessageUtils;import java.util.Arrays;import java.util.List;@Translator(packet = ServerJoinGamePacket.class)public class JavaJoinGameTranslator extends PacketTranslator<ServerJoinGamePacket> {    private static final List<SkinPart> SKIN_PART_VALUES = Arrays.asList(SkinPart.values());    @Override    public void translate(ServerJoinGamePacket packet, GeyserSession session) {        PlayerEntity entity = session.getPlayerEntity();        entity.setEntityId(packet.getEntityId());        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());        if (session.isSpawned()) {            String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);            DimensionUtils.switchDimension(session, fakeDim);            session.getWorldCache().removeScoreboard();        }        session.setWorldName(packet.getWorldName());        BiomeTranslator.loadServerBiomes(session, packet.getDimensionCodec());        session.getTagCache().clear();        AdventureSettingsPacket bedrockPacket = new AdventureSettingsPacket();        bedrockPacket.setUniqueEntityId(session.getPlayerEntity().getGeyserId());        bedrockPacket.setPlayerPermission(PlayerPermission.MEMBER);        session.sendUpstreamPacket(bedrockPacket);        PlayStatusPacket playStatus = new PlayStatusPacket();        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();        playerGameTypePacket.setGamemode(packet.getGameMode().ordinal());        session.sendUpstreamPacket(playerGameTypePacket);        session.setGameMode(packet.getGameMode());        SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();        entityDataPacket.setRuntimeEntityId(entity.getGeyserId());        entityDataPacket.getMetadata().putAll(entity.getMetadata());        session.sendUpstreamPacket(entityDataPacket);        GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();        gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\", !packet.isEnableRespawnScreen()));        session.sendUpstreamPacket(gamerulePacket);        session.setReducedDebugInfo(packet.isReducedDebugInfo());        session.setRenderDistance(packet.getViewDistance());        String locale = session.getLocale();        ClientSettingsPacket clientSettingsPacket = new ClientSettingsPacket(locale, (byte) session.getRenderDistance(), ChatVisibility.FULL, true, SKIN_PART_VALUES, HandPreference.RIGHT_HAND, false);        session.sendDownstreamPacket(clientSettingsPacket);        session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:brand\", PluginMessageUtils.getGeyserBrandData()));        if (session.getRemoteAuthType() == AuthType.FLOODGATE) {            session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:register\", PluginMessageUtils.getFloodgateRegisterData()));        }        if (!newDimension.equals(session.getDimension())) {            DimensionUtils.switchDimension(session, newDimension);        }        ChunkUtils.applyDimensionHeight(session, packet.getDimension());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerKeepAlivePacket;import com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerKeepAlivePacket.class)public class JavaKeepAliveTranslator extends PacketTranslator<ServerKeepAlivePacket> {    @Override    public void translate(GeyserSession session, ServerKeepAlivePacket packet) {        if (!session.getConnector().getConfig().isForwardPlayerPing()) {            return;        }        NetworkStackLatencyPacket latencyPacket = new NetworkStackLatencyPacket();        latencyPacket.setFromServer(true);        latencyPacket.setTimestamp(packet.getPingId() * 1000);        session.sendUpstreamPacket(latencyPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerKeepAlivePacket;import com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerKeepAlivePacket.class)public class JavaKeepAliveTranslator extends PacketTranslator<ServerKeepAlivePacket> {    @Override    public void translate(ServerKeepAlivePacket packet, GeyserSession session) {        if (!session.getConnector().getConfig().isForwardPlayerPing()) {            return;        }        NetworkStackLatencyPacket latencyPacket = new NetworkStackLatencyPacket();        latencyPacket.setFromServer(true);        latencyPacket.setTimestamp(packet.getPingId() * 1000);        session.sendUpstreamPacket(latencyPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.login.server.LoginDisconnectPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = LoginDisconnectPacket.class)public class JavaLoginDisconnectTranslator extends PacketTranslator<LoginDisconnectPacket> {    @Override    public void translate(GeyserSession session, LoginDisconnectPacket packet) {        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));    }}", "nl": "import com.github.steveice10.mc.protocol.packet.login.server.LoginDisconnectPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = LoginDisconnectPacket.class)public class JavaLoginDisconnectTranslator extends PacketTranslator<LoginDisconnectPacket> {    @Override    public void translate(LoginDisconnectPacket packet, GeyserSession session) {        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.login.client.LoginPluginResponsePacket;import com.github.steveice10.mc.protocol.packet.login.server.LoginPluginRequestPacket;@Translator(packet = LoginPluginRequestPacket.class)public class JavaLoginPluginRequestTranslator extends PacketTranslator<LoginPluginRequestPacket> {    @Override    public void translate(GeyserSession session, LoginPluginRequestPacket packet) {        session.sendDownstreamPacket(                new LoginPluginResponsePacket(packet.getMessageId(), null)        );    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.login.client.LoginPluginResponsePacket;import com.github.steveice10.mc.protocol.packet.login.server.LoginPluginRequestPacket;@Translator(packet = LoginPluginRequestPacket.class)public class JavaLoginPluginRequestTranslator extends PacketTranslator<LoginPluginRequestPacket> {    @Override    public void translate(LoginPluginRequestPacket packet, GeyserSession session) {        session.sendDownstreamPacket(                new LoginPluginResponsePacket(packet.getMessageId(), null)        );    }}"}
{"code": "import com.github.steveice10.mc.auth.data.GameProfile;import com.github.steveice10.mc.protocol.packet.login.server.LoginSuccessPacket;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.skin.SkinManager;@Translator(packet = LoginSuccessPacket.class)public class JavaLoginSuccessTranslator extends PacketTranslator<LoginSuccessPacket> {    @Override    public void translate(GeyserSession session, LoginSuccessPacket packet) {        PlayerEntity playerEntity = session.getPlayerEntity();        AuthType remoteAuthType = session.getRemoteAuthType();        GameProfile profile = packet.getProfile();        playerEntity.setUsername(profile.getName());        playerEntity.setUuid(profile.getId());        if (remoteAuthType == AuthType.OFFLINE || playerEntity.getUuid().getMostSignificantBits() == 0) {            SkinManager.handleBedrockSkin(playerEntity, session.getClientData());        }        if (remoteAuthType == AuthType.FLOODGATE) {            session.getAuthData().upload(session.getConnector());        }    }}", "nl": "import com.github.steveice10.mc.auth.data.GameProfile;import com.github.steveice10.mc.protocol.packet.login.server.LoginSuccessPacket;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.skin.SkinManager;@Translator(packet = LoginSuccessPacket.class)public class JavaLoginSuccessTranslator extends PacketTranslator<LoginSuccessPacket> {    @Override    public void translate(LoginSuccessPacket packet, GeyserSession session) {        PlayerEntity playerEntity = session.getPlayerEntity();        AuthType remoteAuthType = session.getRemoteAuthType();        GameProfile profile = packet.getProfile();        playerEntity.setUsername(profile.getName());        playerEntity.setUuid(profile.getId());        if (remoteAuthType == AuthType.OFFLINE || playerEntity.getUuid().getMostSignificantBits() == 0) {            SkinManager.handleBedrockSkin(playerEntity, session.getClientData());        }        if (remoteAuthType == AuthType.FLOODGATE) {            session.getAuthData().upload(session.getConnector());        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.ClientPongPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPingPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerPingPacket.class)public class JavaPingPacket extends PacketTranslator<ServerPingPacket> {    @Override    public void translate(GeyserSession session, ServerPingPacket packet) {        session.sendDownstreamPacket(new ClientPongPacket(packet.getId()));    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.ClientPongPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPingPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerPingPacket.class)public class JavaPingPacket extends PacketTranslator<ServerPingPacket> {    @Override    public void translate(ServerPingPacket packet, GeyserSession session) {        session.sendDownstreamPacket(new ClientPongPacket(packet.getId()));    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPluginMessagePacket;import com.google.common.base.Charsets;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.cumulus.Form;import org.geysermc.cumulus.Forms;import org.geysermc.cumulus.util.FormType;import java.nio.charset.StandardCharsets;@Translator(packet = ServerPluginMessagePacket.class)public class JavaPluginMessageTranslator extends PacketTranslator<ServerPluginMessagePacket> {    @Override    public void translate(GeyserSession session, ServerPluginMessagePacket packet) {        if (session.getRemoteAuthType() != AuthType.FLOODGATE) {            return;        }        String channel = packet.getChannel();        if (channel.equals(\"floodgate:form\")) {            byte[] data = packet.getData();            FormType type = FormType.getByOrdinal(data[0]);            if (type == null) {                throw new NullPointerException(                        \"Got type \" + data[0] + \" which isn't a valid form type!\");            }            String dataString = new String(data, 3, data.length - 3, Charsets.UTF_8);            Form form = Forms.fromJson(dataString, type);            form.setResponseHandler(response -> {                byte[] raw = response.getBytes(StandardCharsets.UTF_8);                byte[] finalData = new byte[raw.length + 2];                finalData[0] = data[1];                finalData[1] = data[2];                System.arraycopy(raw, 0, finalData, 2, raw.length);                session.sendDownstreamPacket(new ClientPluginMessagePacket(channel, finalData));            });            session.sendForm(form);        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPluginMessagePacket;import com.google.common.base.Charsets;import org.geysermc.connector.common.AuthType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.cumulus.Form;import org.geysermc.cumulus.Forms;import org.geysermc.cumulus.util.FormType;import java.nio.charset.StandardCharsets;@Translator(packet = ServerPluginMessagePacket.class)public class JavaPluginMessageTranslator extends PacketTranslator<ServerPluginMessagePacket> {    @Override    public void translate(ServerPluginMessagePacket packet, GeyserSession session) {        if (session.getRemoteAuthType() != AuthType.FLOODGATE) {            return;        }        String channel = packet.getChannel();        if (channel.equals(\"floodgate:form\")) {            byte[] data = packet.getData();            FormType type = FormType.getByOrdinal(data[0]);            if (type == null) {                throw new NullPointerException(                        \"Got type \" + data[0] + \" which isn't a valid form type!\");            }            String dataString = new String(data, 3, data.length - 3, Charsets.UTF_8);            Form form = Forms.fromJson(dataString, type);            form.setResponseHandler(response -> {                byte[] raw = response.getBytes(StandardCharsets.UTF_8);                byte[] finalData = new byte[raw.length + 2];                finalData[0] = data[1];                finalData[1] = data[2];                System.arraycopy(raw, 0, finalData, 2, raw.length);                session.sendDownstreamPacket(new ClientPluginMessagePacket(channel, finalData));            });            session.sendForm(form);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerRespawnPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.ChunkUtils;import org.geysermc.connector.utils.DimensionUtils;@Translator(packet = ServerRespawnPacket.class)public class JavaRespawnTranslator extends PacketTranslator<ServerRespawnPacket> {    @Override    public void translate(GeyserSession session, ServerRespawnPacket packet) {        SessionPlayerEntity entity = session.getPlayerEntity();        entity.setHealth(entity.getMaxHealth());        entity.getAttributes().put(GeyserAttributeType.HEALTH, entity.createHealthAttribute());        session.setInventoryTranslator(InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR);        session.setOpenInventory(null);        session.setClosingInventory(false);        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();        playerGameTypePacket.setGamemode(packet.getGamemode().ordinal());        session.sendUpstreamPacket(playerGameTypePacket);        session.setGameMode(packet.getGamemode());        if (session.isRaining()) {            LevelEventPacket stopRainPacket = new LevelEventPacket();            stopRainPacket.setType(LevelEventType.STOP_RAINING);            stopRainPacket.setData(0);            stopRainPacket.setPosition(Vector3f.ZERO);            session.sendUpstreamPacket(stopRainPacket);            session.setRaining(false);        }        if (session.isThunder()) {            LevelEventPacket stopThunderPacket = new LevelEventPacket();            stopThunderPacket.setType(LevelEventType.STOP_THUNDERSTORM);            stopThunderPacket.setData(0);            stopThunderPacket.setPosition(Vector3f.ZERO);            session.sendUpstreamPacket(stopThunderPacket);            session.setThunder(false);        }        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());        if (!session.getDimension().equals(newDimension) || !packet.getWorldName().equals(session.getWorldName())) {            if (!packet.getWorldName().equals(session.getWorldName()) && (session.getDimension().equals(newDimension)                    || DimensionUtils.javaToBedrock(session.getDimension()) == DimensionUtils.javaToBedrock(newDimension))) {                String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);                DimensionUtils.switchDimension(session, fakeDim);            }            session.setWorldName(packet.getWorldName());            DimensionUtils.switchDimension(session, newDimension);        }        ChunkUtils.applyDimensionHeight(session, packet.getDimension());    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerRespawnPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.ChunkUtils;import org.geysermc.connector.utils.DimensionUtils;@Translator(packet = ServerRespawnPacket.class)public class JavaRespawnTranslator extends PacketTranslator<ServerRespawnPacket> {    @Override    public void translate(ServerRespawnPacket packet, GeyserSession session) {        SessionPlayerEntity entity = session.getPlayerEntity();        entity.setHealth(entity.getMaxHealth());        entity.getAttributes().put(GeyserAttributeType.HEALTH, entity.createHealthAttribute());        session.setInventoryTranslator(InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR);        session.setOpenInventory(null);        session.setClosingInventory(false);        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();        playerGameTypePacket.setGamemode(packet.getGamemode().ordinal());        session.sendUpstreamPacket(playerGameTypePacket);        session.setGameMode(packet.getGamemode());        if (session.isRaining()) {            LevelEventPacket stopRainPacket = new LevelEventPacket();            stopRainPacket.setType(LevelEventType.STOP_RAINING);            stopRainPacket.setData(0);            stopRainPacket.setPosition(Vector3f.ZERO);            session.sendUpstreamPacket(stopRainPacket);            session.setRaining(false);        }        if (session.isThunder()) {            LevelEventPacket stopThunderPacket = new LevelEventPacket();            stopThunderPacket.setType(LevelEventType.STOP_THUNDERSTORM);            stopThunderPacket.setData(0);            stopThunderPacket.setPosition(Vector3f.ZERO);            session.sendUpstreamPacket(stopThunderPacket);            session.setThunder(false);        }        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());        if (!session.getDimension().equals(newDimension) || !packet.getWorldName().equals(session.getWorldName())) {            if (!packet.getWorldName().equals(session.getWorldName()) && (session.getDimension().equals(newDimension)                    || DimensionUtils.javaToBedrock(session.getDimension()) == DimensionUtils.javaToBedrock(newDimension))) {                String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);                DimensionUtils.switchDimension(session, fakeDim);            }            session.setWorldName(packet.getWorldName());            DimensionUtils.switchDimension(session, newDimension);        }        ChunkUtils.applyDimensionHeight(session, packet.getDimension());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerStatisticsPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.StatisticsUtils;@Translator(packet = ServerStatisticsPacket.class)public class JavaStatisticsTranslator extends PacketTranslator<ServerStatisticsPacket> {    @Override    public void translate(GeyserSession session, ServerStatisticsPacket packet) {        session.updateStatistics(packet.getStatistics());        if (session.isWaitingForStatistics()) {            session.setWaitingForStatistics(false);            StatisticsUtils.buildAndSendStatisticsMenu(session);        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.ServerStatisticsPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.StatisticsUtils;@Translator(packet = ServerStatisticsPacket.class)public class JavaStatisticsTranslator extends PacketTranslator<ServerStatisticsPacket> {    @Override    public void translate(ServerStatisticsPacket packet, GeyserSession session) {        session.updateStatistics(packet.getStatistics());        if (session.isWaitingForStatistics()) {            session.setWaitingForStatistics(false);            StatisticsUtils.buildAndSendStatisticsMenu(session);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.UnlockRecipesAction;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerUnlockRecipesPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.Arrays;@Translator(packet = ServerUnlockRecipesPacket.class)public class JavaUnlockRecipesTranslator extends PacketTranslator<ServerUnlockRecipesPacket> {    @Override    public void translate(GeyserSession session, ServerUnlockRecipesPacket packet) {        if (packet.getAction() == UnlockRecipesAction.REMOVE) {            session.getUnlockedRecipes().removeAll(Arrays.asList(packet.getRecipes()));        } else {            session.getUnlockedRecipes().addAll(Arrays.asList(packet.getRecipes()));        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.UnlockRecipesAction;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerUnlockRecipesPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.Arrays;@Translator(packet = ServerUnlockRecipesPacket.class)public class JavaUnlockRecipesTranslator extends PacketTranslator<ServerUnlockRecipesPacket> {    @Override    public void translate(ServerUnlockRecipesPacket packet, GeyserSession session) {        if (packet.getAction() == UnlockRecipesAction.REMOVE) {            session.getUnlockedRecipes().removeAll(Arrays.asList(packet.getRecipes()));        } else {            session.getUnlockedRecipes().addAll(Arrays.asList(packet.getRecipes()));        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAnimationPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.AnimateEntityPacket;import com.nukkitx.protocol.bedrock.packet.AnimatePacket;import com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.DimensionUtils;@Translator(packet = ServerEntityAnimationPacket.class)public class JavaEntityAnimationTranslator extends PacketTranslator<ServerEntityAnimationPacket> {    @Override    public void translate(GeyserSession session, ServerEntityAnimationPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        AnimatePacket animatePacket = new AnimatePacket();        animatePacket.setRuntimeEntityId(entity.getGeyserId());        switch (packet.getAnimation()) {            case SWING_ARM:                animatePacket.setAction(AnimatePacket.Action.SWING_ARM);                break;            case EAT_FOOD:                 AnimateEntityPacket offHandPacket = new AnimateEntityPacket();                offHandPacket.setAnimation(\"animation.player.attack.rotations.offhand\");                offHandPacket.setNextState(\"default\");                offHandPacket.setBlendOutTime(0.0f);                offHandPacket.setStopExpression(\"query.any_animation_finished\");                offHandPacket.setController(\"__runtime_controller\");                offHandPacket.getRuntimeEntityIds().add(entity.getGeyserId());                session.sendUpstreamPacket(offHandPacket);                return;            case CRITICAL_HIT:                animatePacket.setAction(AnimatePacket.Action.CRITICAL_HIT);                break;            case ENCHANTMENT_CRITICAL_HIT:                animatePacket.setAction(AnimatePacket.Action.MAGIC_CRITICAL_HIT);                 SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();                stringPacket.setIdentifier(\"geyseropt:enchanted_hit_multiple\");                stringPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));                stringPacket.setPosition(Vector3f.ZERO);                stringPacket.setUniqueEntityId(entity.getGeyserId());                session.sendUpstreamPacket(stringPacket);                break;            case LEAVE_BED:                animatePacket.setAction(AnimatePacket.Action.WAKE_UP);                break;            default:                return;        }        session.sendUpstreamPacket(animatePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAnimationPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.AnimateEntityPacket;import com.nukkitx.protocol.bedrock.packet.AnimatePacket;import com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.DimensionUtils;@Translator(packet = ServerEntityAnimationPacket.class)public class JavaEntityAnimationTranslator extends PacketTranslator<ServerEntityAnimationPacket> {    @Override    public void translate(ServerEntityAnimationPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        AnimatePacket animatePacket = new AnimatePacket();        animatePacket.setRuntimeEntityId(entity.getGeyserId());        switch (packet.getAnimation()) {            case SWING_ARM:                animatePacket.setAction(AnimatePacket.Action.SWING_ARM);                break;            case EAT_FOOD:                 AnimateEntityPacket offHandPacket = new AnimateEntityPacket();                offHandPacket.setAnimation(\"animation.player.attack.rotations.offhand\");                offHandPacket.setNextState(\"default\");                offHandPacket.setBlendOutTime(0.0f);                offHandPacket.setStopExpression(\"query.any_animation_finished\");                offHandPacket.setController(\"__runtime_controller\");                offHandPacket.getRuntimeEntityIds().add(entity.getGeyserId());                session.sendUpstreamPacket(offHandPacket);                return;            case CRITICAL_HIT:                animatePacket.setAction(AnimatePacket.Action.CRITICAL_HIT);                break;            case ENCHANTMENT_CRITICAL_HIT:                animatePacket.setAction(AnimatePacket.Action.MAGIC_CRITICAL_HIT);                 SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();                stringPacket.setIdentifier(\"geyseropt:enchanted_hit_multiple\");                stringPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));                stringPacket.setPosition(Vector3f.ZERO);                stringPacket.setUniqueEntityId(entity.getGeyserId());                session.sendUpstreamPacket(stringPacket);                break;            case LEAVE_BED:                animatePacket.setAction(AnimatePacket.Action.WAKE_UP);                break;            default:                return;        }        session.sendUpstreamPacket(animatePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAttachPacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.EntityEventPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityAttachPacket.class)public class JavaEntityAttachTranslator extends PacketTranslator<ServerEntityAttachPacket> {    @Override    public void translate(GeyserSession session, ServerEntityAttachPacket packet) {        Entity holderId;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            holderId = session.getPlayerEntity();        } else {            holderId = session.getEntityCache().getEntityByJavaId(packet.getEntityId());            if (holderId == null) {                return;            }        }        Entity attachedToId;        if (packet.getAttachedToId() == session.getPlayerEntity().getEntityId()) {            attachedToId = session.getPlayerEntity();        } else {            attachedToId = session.getEntityCache().getEntityByJavaId(packet.getAttachedToId());            if ((attachedToId == null || packet.getAttachedToId() == 0)) {                holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, false);                holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, -1L);                holderId.updateBedrockMetadata(session);                EntityEventPacket eventPacket = new EntityEventPacket();                eventPacket.setRuntimeEntityId(holderId.getGeyserId());                eventPacket.setType(EntityEventType.REMOVE_LEASH);                eventPacket.setData(0);                session.sendUpstreamPacket(eventPacket);                return;            }        }        holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, true);        holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, attachedToId.getGeyserId());        holderId.updateBedrockMetadata(session);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAttachPacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.data.entity.EntityFlag;import com.nukkitx.protocol.bedrock.packet.EntityEventPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityAttachPacket.class)public class JavaEntityAttachTranslator extends PacketTranslator<ServerEntityAttachPacket> {    @Override    public void translate(ServerEntityAttachPacket packet, GeyserSession session) {        Entity holderId;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            holderId = session.getPlayerEntity();        } else {            holderId = session.getEntityCache().getEntityByJavaId(packet.getEntityId());            if (holderId == null) {                return;            }        }        Entity attachedToId;        if (packet.getAttachedToId() == session.getPlayerEntity().getEntityId()) {            attachedToId = session.getPlayerEntity();        } else {            attachedToId = session.getEntityCache().getEntityByJavaId(packet.getAttachedToId());            if ((attachedToId == null || packet.getAttachedToId() == 0)) {                holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, false);                holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, -1L);                holderId.updateBedrockMetadata(session);                EntityEventPacket eventPacket = new EntityEventPacket();                eventPacket.setRuntimeEntityId(holderId.getGeyserId());                eventPacket.setType(EntityEventType.REMOVE_LEASH);                eventPacket.setData(0);                session.sendUpstreamPacket(eventPacket);                return;            }        }        holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, true);        holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, attachedToId.getGeyserId());        holderId.updateBedrockMetadata(session);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityCollectItemPacket;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.TakeItemEntityPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ExpOrbEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityCollectItemPacket.class)public class JavaEntityCollectItemTranslator extends PacketTranslator<ServerEntityCollectItemPacket> {    @Override    public void translate(GeyserSession session, ServerEntityCollectItemPacket packet) {        Entity collectedEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectedEntityId());        if (collectedEntity == null) return;        Entity collectorEntity;        if (packet.getCollectorEntityId() == session.getPlayerEntity().getEntityId()) {            collectorEntity = session.getPlayerEntity();        } else {            collectorEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectorEntityId());        }        if (collectorEntity == null) return;        if (collectedEntity instanceof ExpOrbEntity) {            LevelEventPacket xpPacket = new LevelEventPacket();            xpPacket.setType(LevelEventType.SOUND_EXPERIENCE_ORB_PICKUP);            xpPacket.setPosition(collectedEntity.getPosition());            xpPacket.setData(0);            session.sendUpstreamPacket(xpPacket);        } else {            TakeItemEntityPacket takeItemEntityPacket = new TakeItemEntityPacket();            takeItemEntityPacket.setRuntimeEntityId(collectorEntity.getGeyserId());            takeItemEntityPacket.setItemRuntimeEntityId(collectedEntity.getGeyserId());            session.sendUpstreamPacket(takeItemEntityPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityCollectItemPacket;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.TakeItemEntityPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ExpOrbEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityCollectItemPacket.class)public class JavaEntityCollectItemTranslator extends PacketTranslator<ServerEntityCollectItemPacket> {    @Override    public void translate(ServerEntityCollectItemPacket packet, GeyserSession session) {        Entity collectedEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectedEntityId());        if (collectedEntity == null) return;        Entity collectorEntity;        if (packet.getCollectorEntityId() == session.getPlayerEntity().getEntityId()) {            collectorEntity = session.getPlayerEntity();        } else {            collectorEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectorEntityId());        }        if (collectorEntity == null) return;        if (collectedEntity instanceof ExpOrbEntity) {            LevelEventPacket xpPacket = new LevelEventPacket();            xpPacket.setType(LevelEventType.SOUND_EXPERIENCE_ORB_PICKUP);            xpPacket.setPosition(collectedEntity.getPosition());            xpPacket.setData(0);            session.sendUpstreamPacket(xpPacket);        } else {            TakeItemEntityPacket takeItemEntityPacket = new TakeItemEntityPacket();            takeItemEntityPacket.setRuntimeEntityId(collectorEntity.getGeyserId());            takeItemEntityPacket.setItemRuntimeEntityId(collectedEntity.getGeyserId());            session.sendUpstreamPacket(takeItemEntityPacket);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEffectPacket;import com.nukkitx.protocol.bedrock.packet.MobEffectPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;@Translator(packet = ServerEntityEffectPacket.class)public class JavaEntityEffectTranslator extends PacketTranslator<ServerEntityEffectPacket> {    @Override    public void translate(GeyserSession session, ServerEntityEffectPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();            session.getEffectCache().setEffect(packet.getEffect(), packet.getAmplifier());        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        MobEffectPacket mobEffectPacket = new MobEffectPacket();        mobEffectPacket.setAmplifier(packet.getAmplifier());        mobEffectPacket.setDuration(packet.getDuration());        mobEffectPacket.setEvent(MobEffectPacket.Event.ADD);        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());        mobEffectPacket.setParticles(packet.isShowParticles());        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));        session.sendUpstreamPacket(mobEffectPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEffectPacket;import com.nukkitx.protocol.bedrock.packet.MobEffectPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;@Translator(packet = ServerEntityEffectPacket.class)public class JavaEntityEffectTranslator extends PacketTranslator<ServerEntityEffectPacket> {    @Override    public void translate(ServerEntityEffectPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();            session.getEffectCache().setEffect(packet.getEffect(), packet.getAmplifier());        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        MobEffectPacket mobEffectPacket = new MobEffectPacket();        mobEffectPacket.setAmplifier(packet.getAmplifier());        mobEffectPacket.setDuration(packet.getDuration());        mobEffectPacket.setEvent(MobEffectPacket.Event.ADD);        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());        mobEffectPacket.setParticles(packet.isShowParticles());        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));        session.sendUpstreamPacket(mobEffectPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Equipment;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEquipmentPacket;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.LivingEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;@Translator(packet = ServerEntityEquipmentPacket.class)public class JavaEntityEquipmentTranslator extends PacketTranslator<ServerEntityEquipmentPacket> {    @Override    public void translate(GeyserSession session, ServerEntityEquipmentPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        if (!(entity instanceof LivingEntity)) {            session.getConnector().getLogger().debug(\"Attempted to add armor to a non-living entity type (\" +                    entity.getEntityType().name() + \").\");            return;        }        boolean armorUpdated = false;        boolean mainHandUpdated = false;        boolean offHandUpdated = false;        LivingEntity livingEntity = (LivingEntity) entity;        for (Equipment equipment : packet.getEquipment()) {            ItemData item = ItemTranslator.translateToBedrock(session, equipment.getItem());            switch (equipment.getSlot()) {                case HELMET:                    livingEntity.setHelmet(item);                    armorUpdated = true;                    break;                case CHESTPLATE:                    livingEntity.setChestplate(item);                    armorUpdated = true;                    break;                case LEGGINGS:                    livingEntity.setLeggings(item);                    armorUpdated = true;                    break;                case BOOTS:                    livingEntity.setBoots(item);                    armorUpdated = true;                    break;                case MAIN_HAND:                    livingEntity.setHand(item);                    mainHandUpdated = true;                    break;                case OFF_HAND:                    livingEntity.setOffHand(item);                    offHandUpdated = true;                    break;            }        }        if (armorUpdated) {            livingEntity.updateArmor(session);        }        if (mainHandUpdated) {            livingEntity.updateMainHand(session);        }        if (offHandUpdated) {            livingEntity.updateOffHand(session);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Equipment;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEquipmentPacket;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.LivingEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;@Translator(packet = ServerEntityEquipmentPacket.class)public class JavaEntityEquipmentTranslator extends PacketTranslator<ServerEntityEquipmentPacket> {    @Override    public void translate(ServerEntityEquipmentPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        if (!(entity instanceof LivingEntity)) {            session.getConnector().getLogger().debug(\"Attempted to add armor to a non-living entity type (\" +                    entity.getEntityType().name() + \").\");            return;        }        boolean armorUpdated = false;        boolean mainHandUpdated = false;        boolean offHandUpdated = false;        LivingEntity livingEntity = (LivingEntity) entity;        for (Equipment equipment : packet.getEquipment()) {            ItemData item = ItemTranslator.translateToBedrock(session, equipment.getItem());            switch (equipment.getSlot()) {                case HELMET:                    livingEntity.setHelmet(item);                    armorUpdated = true;                    break;                case CHESTPLATE:                    livingEntity.setChestplate(item);                    armorUpdated = true;                    break;                case LEGGINGS:                    livingEntity.setLeggings(item);                    armorUpdated = true;                    break;                case BOOTS:                    livingEntity.setBoots(item);                    armorUpdated = true;                    break;                case MAIN_HAND:                    livingEntity.setHand(item);                    mainHandUpdated = true;                    break;                case OFF_HAND:                    livingEntity.setOffHand(item);                    offHandUpdated = true;                    break;            }        }        if (armorUpdated) {            livingEntity.updateArmor(session);        }        if (mainHandUpdated) {            livingEntity.updateMainHand(session);        }        if (offHandUpdated) {            livingEntity.updateOffHand(session);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityHeadLookPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityHeadLookPacket.class)public class JavaEntityHeadLookTranslator extends PacketTranslator<ServerEntityHeadLookPacket> {    @Override    public void translate(GeyserSession session, ServerEntityHeadLookPacket packet) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.updateHeadLookRotation(session, packet.getHeadYaw());    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityHeadLookPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityHeadLookPacket.class)public class JavaEntityHeadLookTranslator extends PacketTranslator<ServerEntityHeadLookPacket> {    @Override    public void translate(ServerEntityHeadLookPacket packet, GeyserSession session) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.updateHeadLookRotation(session, packet.getHeadYaw());    }}"}
{"code": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.data.game.entity.metadata.EntityMetadata;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityMetadataPacket;import org.geysermc.connector.utils.InteractiveTagManager;import org.geysermc.connector.utils.LanguageUtils;@Translator(packet = ServerEntityMetadataPacket.class)public class JavaEntityMetadataTranslator extends PacketTranslator<ServerEntityMetadataPacket> {    @Override    public void translate(GeyserSession session, ServerEntityMetadataPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null) return;        for (EntityMetadata metadata : packet.getMetadata()) {            try {                entity.updateBedrockMetadata(metadata, session);            } catch (ClassCastException e) {                session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.metadata.failed\", metadata, entity.getEntityType()));                session.getConnector().getLogger().debug(\"Entity Java ID: \" + entity.getEntityId() + \", Geyser ID: \" + entity.getGeyserId());                if (session.getConnector().getConfig().isDebugMode()) {                    e.printStackTrace();                }            }        }        entity.updateBedrockMetadata(session);        if (session.getMouseoverEntity() != null && session.getMouseoverEntity().getEntityId() == entity.getEntityId()) {            InteractiveTagManager.updateTag(session, entity);        }    }}", "nl": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.data.game.entity.metadata.EntityMetadata;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityMetadataPacket;import org.geysermc.connector.utils.InteractiveTagManager;import org.geysermc.connector.utils.LanguageUtils;@Translator(packet = ServerEntityMetadataPacket.class)public class JavaEntityMetadataTranslator extends PacketTranslator<ServerEntityMetadataPacket> {    @Override    public void translate(ServerEntityMetadataPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null) return;        for (EntityMetadata metadata : packet.getMetadata()) {            try {                entity.updateBedrockMetadata(metadata, session);            } catch (ClassCastException e) {                session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.metadata.failed\", metadata, entity.getEntityType()));                session.getConnector().getLogger().debug(\"Entity Java ID: \" + entity.getEntityId() + \", Geyser ID: \" + entity.getGeyserId());                if (session.getConnector().getConfig().isDebugMode()) {                    e.printStackTrace();                }            }        }        entity.updateBedrockMetadata(session);        if (session.getMouseoverEntity() != null && session.getMouseoverEntity().getEntityId() == entity.getEntityId()) {            InteractiveTagManager.updateTag(session, entity);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionRotationPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityPositionRotationPacket.class)public class JavaEntityPositionRotationTranslator extends PacketTranslator<ServerEntityPositionRotationPacket> {    @Override    public void translate(GeyserSession session, ServerEntityPositionRotationPacket packet) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.updatePositionAndRotation(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), packet.getYaw(), packet.getPitch(), packet.isOnGround());    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionRotationPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityPositionRotationPacket.class)public class JavaEntityPositionRotationTranslator extends PacketTranslator<ServerEntityPositionRotationPacket> {    @Override    public void translate(ServerEntityPositionRotationPacket packet, GeyserSession session) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.updatePositionAndRotation(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), packet.getYaw(), packet.getPitch(), packet.isOnGround());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityPositionPacket.class)public class JavaEntityPositionTranslator extends PacketTranslator<ServerEntityPositionPacket> {    @Override    public void translate(GeyserSession session, ServerEntityPositionPacket packet) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.moveRelative(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), entity.getRotation(), packet.isOnGround());    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityPositionPacket.class)public class JavaEntityPositionTranslator extends PacketTranslator<ServerEntityPositionPacket> {    @Override    public void translate(ServerEntityPositionPacket packet, GeyserSession session) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.moveRelative(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), entity.getRotation(), packet.isOnGround());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPropertiesPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.LivingEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityPropertiesPacket.class)public class JavaEntityPropertiesTranslator extends PacketTranslator<ServerEntityPropertiesPacket> {    @Override    public void translate(GeyserSession session, ServerEntityPropertiesPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (!(entity instanceof LivingEntity)) return;        ((LivingEntity) entity).updateBedrockAttributes(session, packet.getAttributes());    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPropertiesPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.LivingEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityPropertiesPacket.class)public class JavaEntityPropertiesTranslator extends PacketTranslator<ServerEntityPropertiesPacket> {    @Override    public void translate(ServerEntityPropertiesPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (!(entity instanceof LivingEntity)) return;        ((LivingEntity) entity).updateBedrockAttributes(session, packet.getAttributes());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRemoveEffectPacket;import com.nukkitx.protocol.bedrock.packet.MobEffectPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;@Translator(packet = ServerEntityRemoveEffectPacket.class)public class JavaEntityRemoveEffectTranslator extends PacketTranslator<ServerEntityRemoveEffectPacket> {    @Override    public void translate(GeyserSession session, ServerEntityRemoveEffectPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();            session.getEffectCache().removeEffect(packet.getEffect());        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        MobEffectPacket mobEffectPacket = new MobEffectPacket();        mobEffectPacket.setEvent(MobEffectPacket.Event.REMOVE);        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));        session.sendUpstreamPacket(mobEffectPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRemoveEffectPacket;import com.nukkitx.protocol.bedrock.packet.MobEffectPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;@Translator(packet = ServerEntityRemoveEffectPacket.class)public class JavaEntityRemoveEffectTranslator extends PacketTranslator<ServerEntityRemoveEffectPacket> {    @Override    public void translate(ServerEntityRemoveEffectPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();            session.getEffectCache().removeEffect(packet.getEffect());        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        MobEffectPacket mobEffectPacket = new MobEffectPacket();        mobEffectPacket.setEvent(MobEffectPacket.Event.REMOVE);        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));        session.sendUpstreamPacket(mobEffectPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRotationPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityRotationPacket.class)public class JavaEntityRotationTranslator extends PacketTranslator<ServerEntityRotationPacket> {    @Override    public void translate(GeyserSession session, ServerEntityRotationPacket packet) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.updateRotation(session, packet.getYaw(), packet.getPitch(), packet.isOnGround());    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRotationPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityRotationPacket.class)public class JavaEntityRotationTranslator extends PacketTranslator<ServerEntityRotationPacket> {    @Override    public void translate(ServerEntityRotationPacket packet, GeyserSession session) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.updateRotation(session, packet.getYaw(), packet.getPitch(), packet.isOnGround());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntitySetPassengersPacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;import com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;import it.unimi.dsi.fastutil.longs.LongOpenHashSet;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;import java.util.Arrays;@Translator(packet = ServerEntitySetPassengersPacket.class)public class JavaEntitySetPassengersTranslator extends PacketTranslator<ServerEntitySetPassengersPacket> {    @Override    public void translate(GeyserSession session, ServerEntitySetPassengersPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null) return;        LongOpenHashSet passengers = entity.getPassengers().clone();        boolean rider = true;        for (long passengerId : packet.getPassengerIds()) {            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);            if (passengerId == session.getPlayerEntity().getEntityId()) {                passenger = session.getPlayerEntity();                session.setRidingVehicleEntity(entity);                session.confirmTeleport(passenger.getPosition().sub(0, EntityType.PLAYER.getOffset(), 0).toDouble());            }            if (passenger == null && passengerId != 0) {                session.getEntityCache().addCachedPlayerEntityLink(passengerId, packet.getEntityId());            }            if (passenger == null) {                continue;            }            EntityLinkData.Type type = rider ? EntityLinkData.Type.RIDER : EntityLinkData.Type.PASSENGER;            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();            linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), type, false));            session.sendUpstreamPacket(linkPacket);            passengers.add(passengerId);            if (entity.getEntityType() == EntityType.BOAT) {                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 1);                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 90f);                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 1f);                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, -90f);            } else {                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);            }            passenger.updateBedrockMetadata(session);            rider = false;        }        entity.setPassengers(passengers);        for (long passengerId : entity.getPassengers()) {            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);            if (passengerId == session.getPlayerEntity().getEntityId()) {                passenger = session.getPlayerEntity();            }            if (passenger == null) {                continue;            }            if (Arrays.stream(packet.getPassengerIds()).noneMatch(id -> id == passengerId)) {                SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();                linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), EntityLinkData.Type.REMOVE, false));                session.sendUpstreamPacket(linkPacket);                passengers.remove(passenger.getEntityId());                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);                EntityUtils.updateMountOffset(passenger, entity, session, false, false, (packet.getPassengerIds().length > 1));            } else {                EntityUtils.updateMountOffset(passenger, entity, session, (packet.getPassengerIds()[0] == passengerId), true, (packet.getPassengerIds().length > 1));            }            passenger.updateBedrockMetadata(session);        }        switch (entity.getEntityType()) {            case HORSE:            case SKELETON_HORSE:            case DONKEY:            case MULE:            case RAVAGER:                entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 181.0f);                entity.updateBedrockMetadata(session);                break;        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntitySetPassengersPacket;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;import com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;import it.unimi.dsi.fastutil.longs.LongOpenHashSet;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;import java.util.Arrays;@Translator(packet = ServerEntitySetPassengersPacket.class)public class JavaEntitySetPassengersTranslator extends PacketTranslator<ServerEntitySetPassengersPacket> {    @Override    public void translate(ServerEntitySetPassengersPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null) return;        LongOpenHashSet passengers = entity.getPassengers().clone();        boolean rider = true;        for (long passengerId : packet.getPassengerIds()) {            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);            if (passengerId == session.getPlayerEntity().getEntityId()) {                passenger = session.getPlayerEntity();                session.setRidingVehicleEntity(entity);                session.confirmTeleport(passenger.getPosition().sub(0, EntityType.PLAYER.getOffset(), 0).toDouble());            }            if (passenger == null && passengerId != 0) {                session.getEntityCache().addCachedPlayerEntityLink(passengerId, packet.getEntityId());            }            if (passenger == null) {                continue;            }            EntityLinkData.Type type = rider ? EntityLinkData.Type.RIDER : EntityLinkData.Type.PASSENGER;            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();            linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), type, false));            session.sendUpstreamPacket(linkPacket);            passengers.add(passengerId);            if (entity.getEntityType() == EntityType.BOAT) {                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 1);                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 90f);                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 1f);                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, -90f);            } else {                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);            }            passenger.updateBedrockMetadata(session);            rider = false;        }        entity.setPassengers(passengers);        for (long passengerId : entity.getPassengers()) {            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);            if (passengerId == session.getPlayerEntity().getEntityId()) {                passenger = session.getPlayerEntity();            }            if (passenger == null) {                continue;            }            if (Arrays.stream(packet.getPassengerIds()).noneMatch(id -> id == passengerId)) {                SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();                linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), EntityLinkData.Type.REMOVE, false));                session.sendUpstreamPacket(linkPacket);                passengers.remove(passenger.getEntityId());                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);                EntityUtils.updateMountOffset(passenger, entity, session, false, false, (packet.getPassengerIds().length > 1));            } else {                EntityUtils.updateMountOffset(passenger, entity, session, (packet.getPassengerIds()[0] == passengerId), true, (packet.getPassengerIds().length > 1));            }            passenger.updateBedrockMetadata(session);        }        switch (entity.getEntityType()) {            case HORSE:            case SKELETON_HORSE:            case DONKEY:            case MULE:            case RAVAGER:                entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 181.0f);                entity.updateBedrockMetadata(session);                break;        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityStatusPacket;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.LivingEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityStatusPacket.class)public class JavaEntityStatusTranslator extends PacketTranslator<ServerEntityStatusPacket> {    @Override    public void translate(GeyserSession session, ServerEntityStatusPacket packet) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        EntityEventPacket entityEventPacket = new EntityEventPacket();        entityEventPacket.setRuntimeEntityId(entity.getGeyserId());        switch (packet.getStatus()) {            case PLAYER_ENABLE_REDUCED_DEBUG:                session.setReducedDebugInfo(true);                return;            case PLAYER_DISABLE_REDUCED_DEBUG:                session.setReducedDebugInfo(false);                return;            case PLAYER_OP_PERMISSION_LEVEL_0:                session.setOpPermissionLevel(0);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_1:                session.setOpPermissionLevel(1);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_2:                session.setOpPermissionLevel(2);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_3:                session.setOpPermissionLevel(3);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_4:                session.setOpPermissionLevel(4);                session.sendAdventureSettings();                return;            case LIVING_BURN:            case LIVING_DROWN:            case LIVING_HURT:            case LIVING_HURT_SWEET_BERRY_BUSH:            case LIVING_HURT_THORNS:            case LIVING_FREEZE:                entityEventPacket.setType(EntityEventType.HURT);                break;            case LIVING_DEATH:                entityEventPacket.setType(EntityEventType.DEATH);                if (entity.getEntityType() == EntityType.THROWN_EGG) {                    LevelEventPacket particlePacket = new LevelEventPacket();                    particlePacket.setType(LevelEventType.PARTICLE_ITEM_BREAK);                    particlePacket.setData(session.getItemMappings().getStoredItems().egg().getBedrockId() << 16);                    particlePacket.setPosition(entity.getPosition());                    for (int i = 0; i < 6; i++) {                        session.sendUpstreamPacket(particlePacket);                    }                } else if (entity.getEntityType() == EntityType.SNOWBALL) {                    LevelEventPacket particlePacket = new LevelEventPacket();                    particlePacket.setType(LevelEventType.PARTICLE_SNOWBALL_POOF);                    particlePacket.setPosition(entity.getPosition());                    for (int i = 0; i < 8; i++) {                        session.sendUpstreamPacket(particlePacket);                    }                }                break;            case WOLF_SHAKE_WATER:                entityEventPacket.setType(EntityEventType.SHAKE_WETNESS);                break;            case PLAYER_FINISH_USING_ITEM:                entityEventPacket.setType(EntityEventType.USE_ITEM);                break;            case FISHING_HOOK_PULL_PLAYER:                long pulledById = entity.getMetadata().getLong(EntityData.TARGET_EID);                if (session.getPlayerEntity().getGeyserId() == pulledById) {                    Entity hookOwner = session.getEntityCache().getEntityByGeyserId(entity.getMetadata().getLong(EntityData.OWNER_EID));                    if (hookOwner != null) {                        SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();                        motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());                        motionPacket.setMotion(hookOwner.getPosition().sub(session.getPlayerEntity().getPosition()).mul(0.1f));                        session.sendUpstreamPacket(motionPacket);                    }                }                return;            case TAMEABLE_TAMING_FAILED:                entityEventPacket.setType(EntityEventType.TAME_FAILED);                break;            case TAMEABLE_TAMING_SUCCEEDED:                entityEventPacket.setType(EntityEventType.TAME_SUCCEEDED);                break;            case ZOMBIE_VILLAGER_CURE:                 LevelSoundEvent2Packet soundPacket = new LevelSoundEvent2Packet();                soundPacket.setSound(SoundEvent.REMEDY);                soundPacket.setPosition(entity.getPosition());                soundPacket.setExtraData(-1);                soundPacket.setIdentifier(\"\");                soundPacket.setRelativeVolumeDisabled(false);                session.sendUpstreamPacket(soundPacket);                return;            case ANIMAL_EMIT_HEARTS:                entityEventPacket.setType(EntityEventType.LOVE_PARTICLES);                break;            case FIREWORK_EXPLODE:                entityEventPacket.setType(EntityEventType.FIREWORK_EXPLODE);                break;            case WITCH_EMIT_PARTICLES:                entityEventPacket.setType(EntityEventType.WITCH_HAT_MAGIC);                 break;            case TOTEM_OF_UNDYING_MAKE_SOUND:                entityEventPacket.setType(EntityEventType.CONSUME_TOTEM);                break;            case SHEEP_GRAZE_OR_TNT_CART_EXPLODE:                if (entity.getEntityType() == EntityType.SHEEP) {                    entityEventPacket.setType(EntityEventType.EAT_GRASS);                } else {                    entityEventPacket.setType(EntityEventType.PRIME_TNT_MINECART);                }                break;            case IRON_GOLEM_HOLD_POPPY:                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_OFFER);                break;            case IRON_GOLEM_EMPTY_HAND:                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_WITHDRAW);                break;            case IRON_GOLEM_ATTACK:                if (entity.getEntityType() == EntityType.IRON_GOLEM) {                    entityEventPacket.setType(EntityEventType.ATTACK_START);                }                break;            case RABBIT_JUMP_OR_MINECART_SPAWNER_DELAY_RESET:                if (entity.getEntityType() == EntityType.RABBIT) {                    SetEntityDataPacket dataPacket = new SetEntityDataPacket();                    dataPacket.getMetadata().put(EntityData.JUMP_DURATION, (byte) 3);                    dataPacket.setRuntimeEntityId(entity.getGeyserId());                    session.sendUpstreamPacket(dataPacket);                    return;                }                break;            case LIVING_EQUIPMENT_BREAK_HEAD:            case LIVING_EQUIPMENT_BREAK_CHEST:            case LIVING_EQUIPMENT_BREAK_LEGS:            case LIVING_EQUIPMENT_BREAK_FEET:            case LIVING_EQUIPMENT_BREAK_MAIN_HAND:            case LIVING_EQUIPMENT_BREAK_OFF_HAND:                LevelSoundEvent2Packet equipmentBreakPacket = new LevelSoundEvent2Packet();                equipmentBreakPacket.setSound(SoundEvent.BREAK);                equipmentBreakPacket.setPosition(entity.getPosition());                equipmentBreakPacket.setExtraData(-1);                equipmentBreakPacket.setIdentifier(\"\");                session.sendUpstreamPacket(equipmentBreakPacket);                return;            case PLAYER_SWAP_SAME_ITEM:                 if (entity instanceof LivingEntity) {                    LivingEntity livingEntity = (LivingEntity) entity;                    ItemData newMainHand = livingEntity.getOffHand();                    livingEntity.setOffHand(livingEntity.getHand());                    livingEntity.setHand(newMainHand);                    livingEntity.updateMainHand(session);                    livingEntity.updateOffHand(session);                } else {                    session.getConnector().getLogger().debug(\"Got status message to swap hands for a non-living entity.\");                }                return;            case GOAT_LOWERING_HEAD:                if (entity.getEntityType() == EntityType.GOAT) {                    entityEventPacket.setType(EntityEventType.ATTACK_START);                }                break;            case GOAT_STOP_LOWERING_HEAD:                if (entity.getEntityType() == EntityType.GOAT) {                    entityEventPacket.setType(EntityEventType.ATTACK_STOP);                }                break;            case MAKE_POOF_PARTICLES:                if (entity instanceof LivingEntity) {                    entityEventPacket.setType(EntityEventType.DEATH_SMOKE_CLOUD);                }                break;        }        if (entityEventPacket.getType() != null) {            session.sendUpstreamPacket(entityEventPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityStatusPacket;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.LivingEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerEntityStatusPacket.class)public class JavaEntityStatusTranslator extends PacketTranslator<ServerEntityStatusPacket> {    @Override    public void translate(ServerEntityStatusPacket packet, GeyserSession session) {        Entity entity;        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        } else {            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        }        if (entity == null)            return;        EntityEventPacket entityEventPacket = new EntityEventPacket();        entityEventPacket.setRuntimeEntityId(entity.getGeyserId());        switch (packet.getStatus()) {            case PLAYER_ENABLE_REDUCED_DEBUG:                session.setReducedDebugInfo(true);                return;            case PLAYER_DISABLE_REDUCED_DEBUG:                session.setReducedDebugInfo(false);                return;            case PLAYER_OP_PERMISSION_LEVEL_0:                session.setOpPermissionLevel(0);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_1:                session.setOpPermissionLevel(1);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_2:                session.setOpPermissionLevel(2);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_3:                session.setOpPermissionLevel(3);                session.sendAdventureSettings();                return;            case PLAYER_OP_PERMISSION_LEVEL_4:                session.setOpPermissionLevel(4);                session.sendAdventureSettings();                return;            case LIVING_BURN:            case LIVING_DROWN:            case LIVING_HURT:            case LIVING_HURT_SWEET_BERRY_BUSH:            case LIVING_HURT_THORNS:            case LIVING_FREEZE:                entityEventPacket.setType(EntityEventType.HURT);                break;            case LIVING_DEATH:                entityEventPacket.setType(EntityEventType.DEATH);                if (entity.getEntityType() == EntityType.THROWN_EGG) {                    LevelEventPacket particlePacket = new LevelEventPacket();                    particlePacket.setType(LevelEventType.PARTICLE_ITEM_BREAK);                    particlePacket.setData(session.getItemMappings().getStoredItems().egg().getBedrockId() << 16);                    particlePacket.setPosition(entity.getPosition());                    for (int i = 0; i < 6; i++) {                        session.sendUpstreamPacket(particlePacket);                    }                } else if (entity.getEntityType() == EntityType.SNOWBALL) {                    LevelEventPacket particlePacket = new LevelEventPacket();                    particlePacket.setType(LevelEventType.PARTICLE_SNOWBALL_POOF);                    particlePacket.setPosition(entity.getPosition());                    for (int i = 0; i < 8; i++) {                        session.sendUpstreamPacket(particlePacket);                    }                }                break;            case WOLF_SHAKE_WATER:                entityEventPacket.setType(EntityEventType.SHAKE_WETNESS);                break;            case PLAYER_FINISH_USING_ITEM:                entityEventPacket.setType(EntityEventType.USE_ITEM);                break;            case FISHING_HOOK_PULL_PLAYER:                long pulledById = entity.getMetadata().getLong(EntityData.TARGET_EID);                if (session.getPlayerEntity().getGeyserId() == pulledById) {                    Entity hookOwner = session.getEntityCache().getEntityByGeyserId(entity.getMetadata().getLong(EntityData.OWNER_EID));                    if (hookOwner != null) {                        SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();                        motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());                        motionPacket.setMotion(hookOwner.getPosition().sub(session.getPlayerEntity().getPosition()).mul(0.1f));                        session.sendUpstreamPacket(motionPacket);                    }                }                return;            case TAMEABLE_TAMING_FAILED:                entityEventPacket.setType(EntityEventType.TAME_FAILED);                break;            case TAMEABLE_TAMING_SUCCEEDED:                entityEventPacket.setType(EntityEventType.TAME_SUCCEEDED);                break;            case ZOMBIE_VILLAGER_CURE:                 LevelSoundEvent2Packet soundPacket = new LevelSoundEvent2Packet();                soundPacket.setSound(SoundEvent.REMEDY);                soundPacket.setPosition(entity.getPosition());                soundPacket.setExtraData(-1);                soundPacket.setIdentifier(\"\");                soundPacket.setRelativeVolumeDisabled(false);                session.sendUpstreamPacket(soundPacket);                return;            case ANIMAL_EMIT_HEARTS:                entityEventPacket.setType(EntityEventType.LOVE_PARTICLES);                break;            case FIREWORK_EXPLODE:                entityEventPacket.setType(EntityEventType.FIREWORK_EXPLODE);                break;            case WITCH_EMIT_PARTICLES:                entityEventPacket.setType(EntityEventType.WITCH_HAT_MAGIC);                 break;            case TOTEM_OF_UNDYING_MAKE_SOUND:                entityEventPacket.setType(EntityEventType.CONSUME_TOTEM);                break;            case SHEEP_GRAZE_OR_TNT_CART_EXPLODE:                if (entity.getEntityType() == EntityType.SHEEP) {                    entityEventPacket.setType(EntityEventType.EAT_GRASS);                } else {                    entityEventPacket.setType(EntityEventType.PRIME_TNT_MINECART);                }                break;            case IRON_GOLEM_HOLD_POPPY:                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_OFFER);                break;            case IRON_GOLEM_EMPTY_HAND:                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_WITHDRAW);                break;            case IRON_GOLEM_ATTACK:                if (entity.getEntityType() == EntityType.IRON_GOLEM) {                    entityEventPacket.setType(EntityEventType.ATTACK_START);                }                break;            case RABBIT_JUMP_OR_MINECART_SPAWNER_DELAY_RESET:                if (entity.getEntityType() == EntityType.RABBIT) {                    SetEntityDataPacket dataPacket = new SetEntityDataPacket();                    dataPacket.getMetadata().put(EntityData.JUMP_DURATION, (byte) 3);                    dataPacket.setRuntimeEntityId(entity.getGeyserId());                    session.sendUpstreamPacket(dataPacket);                    return;                }                break;            case LIVING_EQUIPMENT_BREAK_HEAD:            case LIVING_EQUIPMENT_BREAK_CHEST:            case LIVING_EQUIPMENT_BREAK_LEGS:            case LIVING_EQUIPMENT_BREAK_FEET:            case LIVING_EQUIPMENT_BREAK_MAIN_HAND:            case LIVING_EQUIPMENT_BREAK_OFF_HAND:                LevelSoundEvent2Packet equipmentBreakPacket = new LevelSoundEvent2Packet();                equipmentBreakPacket.setSound(SoundEvent.BREAK);                equipmentBreakPacket.setPosition(entity.getPosition());                equipmentBreakPacket.setExtraData(-1);                equipmentBreakPacket.setIdentifier(\"\");                session.sendUpstreamPacket(equipmentBreakPacket);                return;            case PLAYER_SWAP_SAME_ITEM:                 if (entity instanceof LivingEntity) {                    LivingEntity livingEntity = (LivingEntity) entity;                    ItemData newMainHand = livingEntity.getOffHand();                    livingEntity.setOffHand(livingEntity.getHand());                    livingEntity.setHand(newMainHand);                    livingEntity.updateMainHand(session);                    livingEntity.updateOffHand(session);                } else {                    session.getConnector().getLogger().debug(\"Got status message to swap hands for a non-living entity.\");                }                return;            case GOAT_LOWERING_HEAD:                if (entity.getEntityType() == EntityType.GOAT) {                    entityEventPacket.setType(EntityEventType.ATTACK_START);                }                break;            case GOAT_STOP_LOWERING_HEAD:                if (entity.getEntityType() == EntityType.GOAT) {                    entityEventPacket.setType(EntityEventType.ATTACK_STOP);                }                break;            case MAKE_POOF_PARTICLES:                if (entity instanceof LivingEntity) {                    entityEventPacket.setType(EntityEventType.DEATH_SMOKE_CLOUD);                }                break;        }        if (entityEventPacket.getType() != null) {            session.sendUpstreamPacket(entityEventPacket);        }    }}"}
{"code": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityTeleportPacket;import com.nukkitx.math.vector.Vector3f;@Translator(packet = ServerEntityTeleportPacket.class)public class JavaEntityTeleportTranslator extends PacketTranslator<ServerEntityTeleportPacket> {    @Override    public void translate(GeyserSession session, ServerEntityTeleportPacket packet) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.teleport(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), packet.isOnGround());    }}", "nl": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityTeleportPacket;import com.nukkitx.math.vector.Vector3f;@Translator(packet = ServerEntityTeleportPacket.class)public class JavaEntityTeleportTranslator extends PacketTranslator<ServerEntityTeleportPacket> {    @Override    public void translate(ServerEntityTeleportPacket packet, GeyserSession session) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.teleport(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), packet.isOnGround());    }}"}
{"code": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemEntity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityVelocityPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;@Translator(packet = ServerEntityVelocityPacket.class)public class JavaEntityVelocityTranslator extends PacketTranslator<ServerEntityVelocityPacket> {    @Override    public void translate(GeyserSession session, ServerEntityVelocityPacket packet) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.setMotion(Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ()));        if (entity == session.getRidingVehicleEntity() && entity instanceof AbstractHorseEntity) {            return;        }        if (entity instanceof ItemEntity) {            return;        }        SetEntityMotionPacket entityMotionPacket = new SetEntityMotionPacket();        entityMotionPacket.setRuntimeEntityId(entity.getGeyserId());        entityMotionPacket.setMotion(entity.getMotion());        session.sendUpstreamPacket(entityMotionPacket);    }}", "nl": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ItemEntity;import org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityVelocityPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;@Translator(packet = ServerEntityVelocityPacket.class)public class JavaEntityVelocityTranslator extends PacketTranslator<ServerEntityVelocityPacket> {    @Override    public void translate(ServerEntityVelocityPacket packet, GeyserSession session) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {            entity = session.getPlayerEntity();        }        if (entity == null) return;        entity.setMotion(Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ()));        if (entity == session.getRidingVehicleEntity() && entity instanceof AbstractHorseEntity) {            return;        }        if (entity instanceof ItemEntity) {            return;        }        SetEntityMotionPacket entityMotionPacket = new SetEntityMotionPacket();        entityMotionPacket.setRuntimeEntityId(entity.getGeyserId());        entityMotionPacket.setMotion(entity.getMotion());        session.sendUpstreamPacket(entityMotionPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerRemoveEntitiesPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerRemoveEntitiesPacket.class)public class JavaRemoveEntitiesTranslator extends PacketTranslator<ServerRemoveEntitiesPacket> {    @Override    public void translate(GeyserSession session, ServerRemoveEntitiesPacket packet) {        for (int entityId : packet.getEntityIds()) {            Entity entity = session.getEntityCache().getEntityByJavaId(entityId);            if (entity != null) {                session.getEntityCache().removeEntity(entity, false);            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerRemoveEntitiesPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerRemoveEntitiesPacket.class)public class JavaRemoveEntitiesTranslator extends PacketTranslator<ServerRemoveEntitiesPacket> {    @Override    public void translate(ServerRemoveEntitiesPacket packet, GeyserSession session) {        for (int entityId : packet.getEntityIds()) {            Entity entity = session.getEntityCache().getEntityByJavaId(entityId);            if (entity != null) {                session.getEntityCache().removeEntity(entity, false);            }        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerAbilitiesPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerPlayerAbilitiesPacket.class)public class JavaPlayerAbilitiesTranslator extends PacketTranslator<ServerPlayerAbilitiesPacket> {    @Override    public void translate(GeyserSession session, ServerPlayerAbilitiesPacket packet) {        session.setCanFly(packet.isCanFly());        session.setFlying(packet.isFlying());        session.sendAdventureSettings();    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerAbilitiesPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerPlayerAbilitiesPacket.class)public class JavaPlayerAbilitiesTranslator extends PacketTranslator<ServerPlayerAbilitiesPacket> {    @Override    public void translate(ServerPlayerAbilitiesPacket packet, GeyserSession session) {        session.setCanFly(packet.isCanFly());        session.setFlying(packet.isFlying());        session.sendAdventureSettings();    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerActionAckPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.utils.ChunkUtils;@Translator(packet = ServerPlayerActionAckPacket.class)public class JavaPlayerActionAckTranslator extends PacketTranslator<ServerPlayerActionAckPacket> {    @Override    public void translate(GeyserSession session, ServerPlayerActionAckPacket packet) {        ChunkUtils.updateBlock(session, packet.getNewState(), packet.getPosition());        if (packet.getAction() == PlayerAction.START_DIGGING && !packet.isSuccessful()) {            LevelEventPacket stopBreak = new LevelEventPacket();            stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);            stopBreak.setPosition(Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));            stopBreak.setData(0);            session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);            session.sendUpstreamPacket(stopBreak);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerActionAckPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.utils.ChunkUtils;@Translator(packet = ServerPlayerActionAckPacket.class)public class JavaPlayerActionAckTranslator extends PacketTranslator<ServerPlayerActionAckPacket> {    @Override    public void translate(ServerPlayerActionAckPacket packet, GeyserSession session) {        ChunkUtils.updateBlock(session, packet.getNewState(), packet.getPosition());        if (packet.getAction() == PlayerAction.START_DIGGING && !packet.isSuccessful()) {            LevelEventPacket stopBreak = new LevelEventPacket();            stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);            stopBreak.setPosition(Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));            stopBreak.setData(0);            session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);            session.sendUpstreamPacket(stopBreak);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerChangeHeldItemPacket;import com.nukkitx.protocol.bedrock.packet.PlayerHotbarPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerPlayerChangeHeldItemPacket.class)public class JavaPlayerChangeHeldItemTranslator extends PacketTranslator<ServerPlayerChangeHeldItemPacket> {    @Override    public void translate(GeyserSession session, ServerPlayerChangeHeldItemPacket packet) {        PlayerHotbarPacket hotbarPacket = new PlayerHotbarPacket();        hotbarPacket.setContainerId(0);        hotbarPacket.setSelectedHotbarSlot(packet.getSlot());        hotbarPacket.setSelectHotbarSlot(true);        session.sendUpstreamPacket(hotbarPacket);        session.getPlayerInventory().setHeldItemSlot(packet.getSlot());    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerChangeHeldItemPacket;import com.nukkitx.protocol.bedrock.packet.PlayerHotbarPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerPlayerChangeHeldItemPacket.class)public class JavaPlayerChangeHeldItemTranslator extends PacketTranslator<ServerPlayerChangeHeldItemPacket> {    @Override    public void translate(ServerPlayerChangeHeldItemPacket packet, GeyserSession session) {        PlayerHotbarPacket hotbarPacket = new PlayerHotbarPacket();        hotbarPacket.setContainerId(0);        hotbarPacket.setSelectedHotbarSlot(packet.getSlot());        hotbarPacket.setSelectHotbarSlot(true);        session.sendUpstreamPacket(hotbarPacket);        session.getPlayerInventory().setHeldItemSlot(packet.getSlot());    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerHealthPacket;import com.nukkitx.protocol.bedrock.data.AttributeData;import com.nukkitx.protocol.bedrock.packet.SetHealthPacket;import com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.List;@Translator(packet = ServerPlayerHealthPacket.class)public class JavaPlayerHealthTranslator extends PacketTranslator<ServerPlayerHealthPacket> {    @Override    public void translate(GeyserSession session, ServerPlayerHealthPacket packet) {        SessionPlayerEntity entity = session.getPlayerEntity();        int health = (int) Math.ceil(packet.getHealth());        SetHealthPacket setHealthPacket = new SetHealthPacket();        setHealthPacket.setHealth(health);        session.sendUpstreamPacket(setHealthPacket);        entity.setHealth(packet.getHealth());        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();        List<AttributeData> attributes = attributesPacket.getAttributes();        AttributeData healthAttribute = entity.createHealthAttribute();        entity.getAttributes().put(GeyserAttributeType.HEALTH, healthAttribute);        attributes.add(healthAttribute);        AttributeData hungerAttribute = GeyserAttributeType.HUNGER.getAttribute(packet.getFood());        entity.getAttributes().put(GeyserAttributeType.HUNGER, hungerAttribute);        attributes.add(hungerAttribute);        AttributeData saturationAttribute = GeyserAttributeType.SATURATION.getAttribute(packet.getSaturation());        entity.getAttributes().put(GeyserAttributeType.SATURATION, saturationAttribute);        attributes.add(saturationAttribute);        attributesPacket.setRuntimeEntityId(entity.getGeyserId());        session.sendUpstreamPacket(attributesPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerHealthPacket;import com.nukkitx.protocol.bedrock.data.AttributeData;import com.nukkitx.protocol.bedrock.packet.SetHealthPacket;import com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.List;@Translator(packet = ServerPlayerHealthPacket.class)public class JavaPlayerHealthTranslator extends PacketTranslator<ServerPlayerHealthPacket> {    @Override    public void translate(ServerPlayerHealthPacket packet, GeyserSession session) {        SessionPlayerEntity entity = session.getPlayerEntity();        int health = (int) Math.ceil(packet.getHealth());        SetHealthPacket setHealthPacket = new SetHealthPacket();        setHealthPacket.setHealth(health);        session.sendUpstreamPacket(setHealthPacket);        entity.setHealth(packet.getHealth());        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();        List<AttributeData> attributes = attributesPacket.getAttributes();        AttributeData healthAttribute = entity.createHealthAttribute();        entity.getAttributes().put(GeyserAttributeType.HEALTH, healthAttribute);        attributes.add(healthAttribute);        AttributeData hungerAttribute = GeyserAttributeType.HUNGER.getAttribute(packet.getFood());        entity.getAttributes().put(GeyserAttributeType.HUNGER, hungerAttribute);        attributes.add(hungerAttribute);        AttributeData saturationAttribute = GeyserAttributeType.SATURATION.getAttribute(packet.getSaturation());        entity.getAttributes().put(GeyserAttributeType.SATURATION, saturationAttribute);        attributes.add(saturationAttribute);        attributesPacket.setRuntimeEntityId(entity.getGeyserId());        session.sendUpstreamPacket(attributesPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.PlayerListEntry;import com.github.steveice10.mc.protocol.data.game.PlayerListEntryAction;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListEntryPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.PlayerListPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.skin.SkinManager;@Translator(packet = ServerPlayerListEntryPacket.class)public class JavaPlayerListEntryTranslator extends PacketTranslator<ServerPlayerListEntryPacket> {    @Override    public void translate(GeyserSession session, ServerPlayerListEntryPacket packet) {        if (packet.getAction() != PlayerListEntryAction.ADD_PLAYER && packet.getAction() != PlayerListEntryAction.REMOVE_PLAYER)            return;        PlayerListPacket translate = new PlayerListPacket();        translate.setAction(packet.getAction() == PlayerListEntryAction.ADD_PLAYER ? PlayerListPacket.Action.ADD : PlayerListPacket.Action.REMOVE);        for (PlayerListEntry entry : packet.getEntries()) {            switch (packet.getAction()) {                case ADD_PLAYER:                    PlayerEntity playerEntity;                    boolean self = entry.getProfile().getId().equals(session.getPlayerEntity().getUuid());                    if (self) {                        playerEntity = session.getPlayerEntity();                    } else {                        playerEntity = session.getEntityCache().getPlayerEntity(entry.getProfile().getId());                    }                    if (playerEntity == null) {                        playerEntity = new PlayerEntity(                                entry.getProfile(),                                -1,                                session.getEntityCache().getNextEntityId().incrementAndGet(),                                Vector3f.ZERO,                                Vector3f.ZERO,                                Vector3f.ZERO                        );                        session.getEntityCache().addPlayerEntity(playerEntity);                    } else {                        playerEntity.setProfile(entry.getProfile());                    }                    playerEntity.setPlayerList(true);                    if (self) {                        SkinManager.requestAndHandleSkinAndCape(playerEntity, session, skinAndCape ->                                GeyserConnector.getInstance().getLogger().debug(\"Loaded Local Bedrock Java Skin Data for \" + session.getClientData().getUsername()));                    } else {                        playerEntity.setValid(true);                        PlayerListPacket.Entry playerListEntry = SkinManager.buildCachedEntry(session, playerEntity);                        translate.getEntries().add(playerListEntry);                    }                    break;                case REMOVE_PLAYER:                    PlayerEntity entity = session.getEntityCache().removePlayerEntity(entry.getProfile().getId());                    if (entity != null) {                        entity.setPlayerList(false);                    }                    if (entity == session.getPlayerEntity()) {                        translate.getEntries().add(new PlayerListPacket.Entry(session.getAuthData().getUUID()));                    } else {                        translate.getEntries().add(new PlayerListPacket.Entry(entry.getProfile().getId()));                    }                    break;            }        }        if (!translate.getEntries().isEmpty() && (packet.getAction() == PlayerListEntryAction.REMOVE_PLAYER || session.getUpstream().isInitialized())) {            session.sendUpstreamPacket(translate);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.PlayerListEntry;import com.github.steveice10.mc.protocol.data.game.PlayerListEntryAction;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListEntryPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.PlayerListPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.skin.SkinManager;@Translator(packet = ServerPlayerListEntryPacket.class)public class JavaPlayerListEntryTranslator extends PacketTranslator<ServerPlayerListEntryPacket> {    @Override    public void translate(ServerPlayerListEntryPacket packet, GeyserSession session) {        if (packet.getAction() != PlayerListEntryAction.ADD_PLAYER && packet.getAction() != PlayerListEntryAction.REMOVE_PLAYER)            return;        PlayerListPacket translate = new PlayerListPacket();        translate.setAction(packet.getAction() == PlayerListEntryAction.ADD_PLAYER ? PlayerListPacket.Action.ADD : PlayerListPacket.Action.REMOVE);        for (PlayerListEntry entry : packet.getEntries()) {            switch (packet.getAction()) {                case ADD_PLAYER:                    PlayerEntity playerEntity;                    boolean self = entry.getProfile().getId().equals(session.getPlayerEntity().getUuid());                    if (self) {                        playerEntity = session.getPlayerEntity();                    } else {                        playerEntity = session.getEntityCache().getPlayerEntity(entry.getProfile().getId());                    }                    if (playerEntity == null) {                        playerEntity = new PlayerEntity(                                entry.getProfile(),                                -1,                                session.getEntityCache().getNextEntityId().incrementAndGet(),                                Vector3f.ZERO,                                Vector3f.ZERO,                                Vector3f.ZERO                        );                        session.getEntityCache().addPlayerEntity(playerEntity);                    } else {                        playerEntity.setProfile(entry.getProfile());                    }                    playerEntity.setPlayerList(true);                    if (self) {                        SkinManager.requestAndHandleSkinAndCape(playerEntity, session, skinAndCape ->                                GeyserConnector.getInstance().getLogger().debug(\"Loaded Local Bedrock Java Skin Data for \" + session.getClientData().getUsername()));                    } else {                        playerEntity.setValid(true);                        PlayerListPacket.Entry playerListEntry = SkinManager.buildCachedEntry(session, playerEntity);                        translate.getEntries().add(playerListEntry);                    }                    break;                case REMOVE_PLAYER:                    PlayerEntity entity = session.getEntityCache().removePlayerEntity(entry.getProfile().getId());                    if (entity != null) {                        entity.setPlayerList(false);                    }                    if (entity == session.getPlayerEntity()) {                        translate.getEntries().add(new PlayerListPacket.Entry(session.getAuthData().getUUID()));                    } else {                        translate.getEntries().add(new PlayerListPacket.Entry(entry.getProfile().getId()));                    }                    break;            }        }        if (!translate.getEntries().isEmpty() && (packet.getAction() == PlayerListEntryAction.REMOVE_PLAYER || session.getUpstream().isInitialized())) {            session.sendUpstreamPacket(translate);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.PositionElement;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientTeleportConfirmPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerPositionRotationPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;import com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;import com.nukkitx.protocol.bedrock.packet.RespawnPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.TeleportCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.ChunkUtils;import org.geysermc.connector.utils.EntityUtils;import org.geysermc.connector.utils.LanguageUtils;@Translator(packet = ServerPlayerPositionRotationPacket.class)public class JavaPlayerPositionRotationTranslator extends PacketTranslator<ServerPlayerPositionRotationPacket> {    @Override    public void translate(GeyserSession session, ServerPlayerPositionRotationPacket packet) {        if (!session.isLoggedIn())            return;        PlayerEntity entity = session.getPlayerEntity();        if (!session.isSpawned()) {            Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());            entity.setPosition(pos);            entity.setRotation(Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw()));            RespawnPacket respawnPacket = new RespawnPacket();            respawnPacket.setRuntimeEntityId(0);             respawnPacket.setPosition(entity.getPosition());            respawnPacket.setState(RespawnPacket.State.SERVER_READY);            session.sendUpstreamPacket(respawnPacket);            SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();            entityDataPacket.setRuntimeEntityId(entity.getGeyserId());            entityDataPacket.getMetadata().putAll(entity.getMetadata());            session.sendUpstreamPacket(entityDataPacket);            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());            movePlayerPacket.setPosition(entity.getPosition());            movePlayerPacket.setRotation(Vector3f.from(packet.getPitch(), packet.getYaw(), 0));            movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);            session.sendUpstreamPacket(movePlayerPacket);            session.setSpawned(true);            ClientTeleportConfirmPacket teleportConfirmPacket = new ClientTeleportConfirmPacket(packet.getTeleportId());            session.sendDownstreamPacket(teleportConfirmPacket);            ChunkUtils.updateChunkPosition(session, pos.toInt());            session.getConnector().getLogger().debug(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.spawn\", packet.getX(), packet.getY(), packet.getZ()));            return;        }        session.setSpawned(true);        if (packet.isDismountVehicle() && session.getRidingVehicleEntity() != null) {            Entity vehicle = session.getRidingVehicleEntity();            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();            linkPacket.setEntityLink(new EntityLinkData(vehicle.getGeyserId(), entity.getGeyserId(), EntityLinkData.Type.REMOVE, false, false));            session.sendUpstreamPacket(linkPacket);            vehicle.getPassengers().remove(entity.getEntityId());            entity.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);            entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);            entity.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);            entity.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);            session.setRidingVehicleEntity(null);            entity.updateBedrockMetadata(session);            EntityUtils.updateMountOffset(entity, vehicle, session, false, false, entity.getPassengers().size() > 1);        }        double newX = packet.getX() +                (packet.getRelative().contains(PositionElement.X) ? entity.getPosition().getX() : 0);        double newY = packet.getY() +                (packet.getRelative().contains(PositionElement.Y) ? entity.getPosition().getY() - EntityType.PLAYER.getOffset() : 0);        double newZ = packet.getZ() +                (packet.getRelative().contains(PositionElement.Z) ? entity.getPosition().getZ() : 0);        float newPitch = packet.getPitch() +                (packet.getRelative().contains(PositionElement.PITCH) ? entity.getBedrockRotation().getX() : 0);        float newYaw = packet.getYaw() +                (packet.getRelative().contains(PositionElement.YAW) ? entity.getBedrockRotation().getY() : 0);        session.getConnector().getLogger().debug(\"Teleport from \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());        session.addTeleport(new TeleportCache(newX, newY, newZ, newPitch, newYaw, packet.getTeleportId()));        Vector3f lastPlayerPosition = entity.getPosition().down(EntityType.PLAYER.getOffset());        float lastPlayerPitch = entity.getBedrockRotation().getX();        Vector3f teleportDestination = Vector3f.from(newX, newY, newZ);        entity.moveAbsolute(session, teleportDestination, newYaw, newPitch, true, true);        session.getConnector().getLogger().debug(\"to \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());        if (lastPlayerPosition.distanceSquared(teleportDestination) < 0.001 && Math.abs(newPitch - lastPlayerPitch) < 5) {            session.confirmTeleport(lastPlayerPosition.toDouble());        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.PositionElement;import com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientTeleportConfirmPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerPositionRotationPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;import com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;import com.nukkitx.protocol.bedrock.packet.RespawnPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.TeleportCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.ChunkUtils;import org.geysermc.connector.utils.EntityUtils;import org.geysermc.connector.utils.LanguageUtils;@Translator(packet = ServerPlayerPositionRotationPacket.class)public class JavaPlayerPositionRotationTranslator extends PacketTranslator<ServerPlayerPositionRotationPacket> {    @Override    public void translate(ServerPlayerPositionRotationPacket packet, GeyserSession session) {        if (!session.isLoggedIn())            return;        PlayerEntity entity = session.getPlayerEntity();        if (!session.isSpawned()) {            Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());            entity.setPosition(pos);            entity.setRotation(Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw()));            RespawnPacket respawnPacket = new RespawnPacket();            respawnPacket.setRuntimeEntityId(0);             respawnPacket.setPosition(entity.getPosition());            respawnPacket.setState(RespawnPacket.State.SERVER_READY);            session.sendUpstreamPacket(respawnPacket);            SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();            entityDataPacket.setRuntimeEntityId(entity.getGeyserId());            entityDataPacket.getMetadata().putAll(entity.getMetadata());            session.sendUpstreamPacket(entityDataPacket);            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());            movePlayerPacket.setPosition(entity.getPosition());            movePlayerPacket.setRotation(Vector3f.from(packet.getPitch(), packet.getYaw(), 0));            movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);            session.sendUpstreamPacket(movePlayerPacket);            session.setSpawned(true);            ClientTeleportConfirmPacket teleportConfirmPacket = new ClientTeleportConfirmPacket(packet.getTeleportId());            session.sendDownstreamPacket(teleportConfirmPacket);            ChunkUtils.updateChunkPosition(session, pos.toInt());            session.getConnector().getLogger().debug(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.spawn\", packet.getX(), packet.getY(), packet.getZ()));            return;        }        session.setSpawned(true);        if (packet.isDismountVehicle() && session.getRidingVehicleEntity() != null) {            Entity vehicle = session.getRidingVehicleEntity();            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();            linkPacket.setEntityLink(new EntityLinkData(vehicle.getGeyserId(), entity.getGeyserId(), EntityLinkData.Type.REMOVE, false, false));            session.sendUpstreamPacket(linkPacket);            vehicle.getPassengers().remove(entity.getEntityId());            entity.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);            entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);            entity.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);            entity.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);            session.setRidingVehicleEntity(null);            entity.updateBedrockMetadata(session);            EntityUtils.updateMountOffset(entity, vehicle, session, false, false, entity.getPassengers().size() > 1);        }        double newX = packet.getX() +                (packet.getRelative().contains(PositionElement.X) ? entity.getPosition().getX() : 0);        double newY = packet.getY() +                (packet.getRelative().contains(PositionElement.Y) ? entity.getPosition().getY() - EntityType.PLAYER.getOffset() : 0);        double newZ = packet.getZ() +                (packet.getRelative().contains(PositionElement.Z) ? entity.getPosition().getZ() : 0);        float newPitch = packet.getPitch() +                (packet.getRelative().contains(PositionElement.PITCH) ? entity.getBedrockRotation().getX() : 0);        float newYaw = packet.getYaw() +                (packet.getRelative().contains(PositionElement.YAW) ? entity.getBedrockRotation().getY() : 0);        session.getConnector().getLogger().debug(\"Teleport from \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());        session.addTeleport(new TeleportCache(newX, newY, newZ, newPitch, newYaw, packet.getTeleportId()));        Vector3f lastPlayerPosition = entity.getPosition().down(EntityType.PLAYER.getOffset());        float lastPlayerPitch = entity.getBedrockRotation().getX();        Vector3f teleportDestination = Vector3f.from(newX, newY, newZ);        entity.moveAbsolute(session, teleportDestination, newYaw, newPitch, true, true);        session.getConnector().getLogger().debug(\"to \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());        if (lastPlayerPosition.distanceSquared(teleportDestination) < 0.001 && Math.abs(newPitch - lastPlayerPitch) < 5) {            session.confirmTeleport(lastPlayerPosition.toDouble());        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerSetExperiencePacket;import com.nukkitx.protocol.bedrock.data.AttributeData;import com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.Arrays;@Translator(packet = ServerPlayerSetExperiencePacket.class)public class JavaPlayerSetExperienceTranslator extends PacketTranslator<ServerPlayerSetExperiencePacket> {    @Override    public void translate(GeyserSession session, ServerPlayerSetExperiencePacket packet) {        SessionPlayerEntity entity = session.getPlayerEntity();        AttributeData experience = GeyserAttributeType.EXPERIENCE.getAttribute(packet.getExperience());        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE, experience);        AttributeData experienceLevel = GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(packet.getLevel());        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE_LEVEL, experienceLevel);        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());        attributesPacket.setAttributes(Arrays.asList(experience, experienceLevel));        session.sendUpstreamPacket(attributesPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerSetExperiencePacket;import com.nukkitx.protocol.bedrock.data.AttributeData;import com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;import org.geysermc.connector.entity.attribute.GeyserAttributeType;import org.geysermc.connector.entity.player.SessionPlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.Arrays;@Translator(packet = ServerPlayerSetExperiencePacket.class)public class JavaPlayerSetExperienceTranslator extends PacketTranslator<ServerPlayerSetExperiencePacket> {    @Override    public void translate(ServerPlayerSetExperiencePacket packet, GeyserSession session) {        SessionPlayerEntity entity = session.getPlayerEntity();        AttributeData experience = GeyserAttributeType.EXPERIENCE.getAttribute(packet.getExperience());        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE, experience);        AttributeData experienceLevel = GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(packet.getLevel());        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE_LEVEL, experienceLevel);        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());        attributesPacket.setAttributes(Arrays.asList(experience, experienceLevel));        session.sendUpstreamPacket(attributesPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.object.FallingBlockData;import com.github.steveice10.mc.protocol.data.game.entity.object.HangingDirection;import com.github.steveice10.mc.protocol.data.game.entity.object.ProjectileData;import com.github.steveice10.mc.protocol.data.game.entity.type.EntityType;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnEntityPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.*;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;import org.geysermc.connector.utils.LanguageUtils;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;@Translator(packet = ServerSpawnEntityPacket.class)public class JavaSpawnEntityTranslator extends PacketTranslator<ServerSpawnEntityPacket> {    @Override    public void translate(GeyserSession session, ServerSpawnEntityPacket packet) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), 0);        org.geysermc.connector.entity.type.EntityType type = EntityUtils.toBedrockEntity(packet.getType());        if (type == null) {            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));            return;        }        Class<? extends Entity> entityClass = type.getEntityClass();        try {            Entity entity;            if (packet.getType() == EntityType.FALLING_BLOCK) {                entity = new FallingBlockEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, rotation, ((FallingBlockData) packet.getData()).getId());            } else if (packet.getType() == EntityType.ITEM_FRAME || packet.getType() == EntityType.GLOW_ITEM_FRAME) {                entity = new ItemFrameEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, rotation, (HangingDirection) packet.getData());            } else if (packet.getType() == EntityType.FISHING_BOBBER) {                int ownerEntityId = ((ProjectileData) packet.getData()).getOwnerId();                Entity owner = session.getEntityCache().getEntityByJavaId(ownerEntityId);                if (owner == null && session.getPlayerEntity().getEntityId() == ownerEntityId) {                    owner = session.getPlayerEntity();                }                if (owner instanceof PlayerEntity) {                    entity = new FishingHookEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                            type, position, motion, rotation, (PlayerEntity) owner);                } else {                    return;                }            } else if (packet.getType() == EntityType.BOAT) {                entity = new BoatEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, Vector3f.from(packet.getYaw(), 0, packet.getYaw()));            } else {                Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, org.geysermc.connector.entity.type.EntityType.class,                        Vector3f.class, Vector3f.class, Vector3f.class);                entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, rotation                );            }            session.getEntityCache().spawnEntity(entity);        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {            ex.printStackTrace();        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.object.FallingBlockData;import com.github.steveice10.mc.protocol.data.game.entity.object.HangingDirection;import com.github.steveice10.mc.protocol.data.game.entity.object.ProjectileData;import com.github.steveice10.mc.protocol.data.game.entity.type.EntityType;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnEntityPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.*;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;import org.geysermc.connector.utils.LanguageUtils;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;@Translator(packet = ServerSpawnEntityPacket.class)public class JavaSpawnEntityTranslator extends PacketTranslator<ServerSpawnEntityPacket> {    @Override    public void translate(ServerSpawnEntityPacket packet, GeyserSession session) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), 0);        org.geysermc.connector.entity.type.EntityType type = EntityUtils.toBedrockEntity(packet.getType());        if (type == null) {            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));            return;        }        Class<? extends Entity> entityClass = type.getEntityClass();        try {            Entity entity;            if (packet.getType() == EntityType.FALLING_BLOCK) {                entity = new FallingBlockEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, rotation, ((FallingBlockData) packet.getData()).getId());            } else if (packet.getType() == EntityType.ITEM_FRAME || packet.getType() == EntityType.GLOW_ITEM_FRAME) {                entity = new ItemFrameEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, rotation, (HangingDirection) packet.getData());            } else if (packet.getType() == EntityType.FISHING_BOBBER) {                int ownerEntityId = ((ProjectileData) packet.getData()).getOwnerId();                Entity owner = session.getEntityCache().getEntityByJavaId(ownerEntityId);                if (owner == null && session.getPlayerEntity().getEntityId() == ownerEntityId) {                    owner = session.getPlayerEntity();                }                if (owner instanceof PlayerEntity) {                    entity = new FishingHookEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                            type, position, motion, rotation, (PlayerEntity) owner);                } else {                    return;                }            } else if (packet.getType() == EntityType.BOAT) {                entity = new BoatEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, Vector3f.from(packet.getYaw(), 0, packet.getYaw()));            } else {                Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, org.geysermc.connector.entity.type.EntityType.class,                        Vector3f.class, Vector3f.class, Vector3f.class);                entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                        type, position, motion, rotation                );            }            session.getEntityCache().spawnEntity(entity);        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {            ex.printStackTrace();        }    }}"}
{"code": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ExpOrbEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnExpOrbPacket;import com.nukkitx.math.vector.Vector3f;@Translator(packet = ServerSpawnExpOrbPacket.class)public class JavaSpawnExpOrbTranslator extends PacketTranslator<ServerSpawnExpOrbPacket> {    @Override    public void translate(GeyserSession session, ServerSpawnExpOrbPacket packet) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Entity entity = new ExpOrbEntity(                packet.getExp(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                EntityType.EXPERIENCE_ORB, position, Vector3f.ZERO, Vector3f.ZERO        );        session.getEntityCache().spawnEntity(entity);    }}", "nl": "import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.ExpOrbEntity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnExpOrbPacket;import com.nukkitx.math.vector.Vector3f;@Translator(packet = ServerSpawnExpOrbPacket.class)public class JavaSpawnExpOrbTranslator extends PacketTranslator<ServerSpawnExpOrbPacket> {    @Override    public void translate(ServerSpawnExpOrbPacket packet, GeyserSession session) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Entity entity = new ExpOrbEntity(                packet.getExp(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                EntityType.EXPERIENCE_ORB, position, Vector3f.ZERO, Vector3f.ZERO        );        session.getEntityCache().spawnEntity(entity);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnLivingEntityPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;import org.geysermc.connector.utils.LanguageUtils;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;@Translator(packet = ServerSpawnLivingEntityPacket.class)public class JavaSpawnLivingEntityTranslator extends PacketTranslator<ServerSpawnLivingEntityPacket> {    @Override    public void translate(GeyserSession session, ServerSpawnLivingEntityPacket packet) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getHeadYaw());        EntityType type = EntityUtils.toBedrockEntity(packet.getType());        if (type == null) {            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));            return;        }        Class<? extends Entity> entityClass = type.getEntityClass();        try {            Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, EntityType.class,                    Vector3f.class, Vector3f.class, Vector3f.class);            Entity entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                    type, position, motion, rotation            );            session.getEntityCache().spawnEntity(entity);        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {            ex.printStackTrace();        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnLivingEntityPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.type.EntityType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.EntityUtils;import org.geysermc.connector.utils.LanguageUtils;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;@Translator(packet = ServerSpawnLivingEntityPacket.class)public class JavaSpawnLivingEntityTranslator extends PacketTranslator<ServerSpawnLivingEntityPacket> {    @Override    public void translate(ServerSpawnLivingEntityPacket packet, GeyserSession session) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getHeadYaw());        EntityType type = EntityUtils.toBedrockEntity(packet.getType());        if (type == null) {            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));            return;        }        Class<? extends Entity> entityClass = type.getEntityClass();        try {            Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, EntityType.class,                    Vector3f.class, Vector3f.class, Vector3f.class);            Entity entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),                    type, position, motion, rotation            );            session.getEntityCache().spawnEntity(entity);        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {            ex.printStackTrace();        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPaintingPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.PaintingEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.PaintingType;@Translator(packet = ServerSpawnPaintingPacket.class)public class JavaSpawnPaintingTranslator extends PacketTranslator<ServerSpawnPaintingPacket> {    @Override    public void translate(GeyserSession session, ServerSpawnPaintingPacket packet) {        Vector3f position = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());        PaintingEntity entity = new PaintingEntity(packet.getEntityId(),                session.getEntityCache().getNextEntityId().incrementAndGet(),                position, PaintingType.getByPaintingType(packet.getPaintingType()), packet.getDirection().ordinal());        session.getEntityCache().spawnEntity(entity);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPaintingPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.PaintingEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.PaintingType;@Translator(packet = ServerSpawnPaintingPacket.class)public class JavaSpawnPaintingTranslator extends PacketTranslator<ServerSpawnPaintingPacket> {    @Override    public void translate(ServerSpawnPaintingPacket packet, GeyserSession session) {        Vector3f position = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());        PaintingEntity entity = new PaintingEntity(packet.getEntityId(),                session.getEntityCache().getNextEntityId().incrementAndGet(),                position, PaintingType.getByPaintingType(packet.getPaintingType()), packet.getDirection().ordinal());        session.getEntityCache().spawnEntity(entity);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPlayerPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.LanguageUtils;import org.geysermc.connector.skin.SkinManager;@Translator(packet = ServerSpawnPlayerPacket.class)public class JavaSpawnPlayerTranslator extends PacketTranslator<ServerSpawnPlayerPacket> {    @Override    public void translate(GeyserSession session, ServerSpawnPlayerPacket packet) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw());        PlayerEntity entity;        if (packet.getUuid().equals(session.getPlayerEntity().getUuid())) {            entity = new PlayerEntity(session.getPlayerEntity().getProfile(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(), position, Vector3f.ZERO, rotation);        } else {            entity = session.getEntityCache().getPlayerEntity(packet.getUuid());            if (entity == null) {                GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.failed_list\", packet.getUuid()));                return;            }            entity.setEntityId(packet.getEntityId());            entity.setPosition(position);            entity.setRotation(rotation);        }        session.getEntityCache().cacheEntity(entity);        entity.sendPlayer(session);        SkinManager.requestAndHandleSkinAndCape(entity, session, null);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPlayerPacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.LanguageUtils;import org.geysermc.connector.skin.SkinManager;@Translator(packet = ServerSpawnPlayerPacket.class)public class JavaSpawnPlayerTranslator extends PacketTranslator<ServerSpawnPlayerPacket> {    @Override    public void translate(ServerSpawnPlayerPacket packet, GeyserSession session) {        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw());        PlayerEntity entity;        if (packet.getUuid().equals(session.getPlayerEntity().getUuid())) {            entity = new PlayerEntity(session.getPlayerEntity().getProfile(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(), position, Vector3f.ZERO, rotation);        } else {            entity = session.getEntityCache().getPlayerEntity(packet.getUuid());            if (entity == null) {                GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.failed_list\", packet.getUuid()));                return;            }            entity.setEntityId(packet.getEntityId());            entity.setPosition(position);            entity.setRotation(rotation);        }        session.getEntityCache().cacheEntity(entity);        entity.sendPlayer(session);        SkinManager.requestAndHandleSkinAndCape(entity, session, null);    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerDisplayScoreboardPacket;@Translator(packet = ServerDisplayScoreboardPacket.class)public class JavaDisplayScoreboardTranslator extends PacketTranslator<ServerDisplayScoreboardPacket> {    @Override    public void translate(GeyserSession session, ServerDisplayScoreboardPacket packet) {        session.getWorldCache().getScoreboard()                .displayObjective(packet.getName(), packet.getPosition());    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerDisplayScoreboardPacket;@Translator(packet = ServerDisplayScoreboardPacket.class)public class JavaDisplayScoreboardTranslator extends PacketTranslator<ServerDisplayScoreboardPacket> {    @Override    public void translate(ServerDisplayScoreboardPacket packet, GeyserSession session) {        session.getWorldCache().getScoreboard()                .displayObjective(packet.getName(), packet.getPosition());    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.WorldCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.scoreboard.Objective;import org.geysermc.connector.scoreboard.Scoreboard;import org.geysermc.connector.scoreboard.ScoreboardUpdater;import org.geysermc.connector.network.translators.chat.MessageTranslator;import com.github.steveice10.mc.protocol.data.game.scoreboard.ObjectiveAction;import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerScoreboardObjectivePacket;@Translator(packet = ServerScoreboardObjectivePacket.class)public class JavaScoreboardObjectiveTranslator extends PacketTranslator<ServerScoreboardObjectivePacket> {    @Override    public void translate(GeyserSession session, ServerScoreboardObjectivePacket packet) {        WorldCache worldCache = session.getWorldCache();        Scoreboard scoreboard = worldCache.getScoreboard();        Objective objective = scoreboard.getObjective(packet.getName());        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();        if (objective == null && packet.getAction() != ObjectiveAction.REMOVE) {            objective = scoreboard.registerNewObjective(packet.getName(), false);        }        switch (packet.getAction()) {            case ADD:            case UPDATE:                objective.setDisplayName(MessageTranslator.convertMessage(packet.getDisplayName()))                        .setType(packet.getType().ordinal());                break;            case REMOVE:                scoreboard.unregisterObjective(packet.getName());                break;        }        if (objective == null || !objective.isActive()) {            return;        }        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {            scoreboard.onUpdate();        }    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.WorldCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.scoreboard.Objective;import org.geysermc.connector.scoreboard.Scoreboard;import org.geysermc.connector.scoreboard.ScoreboardUpdater;import org.geysermc.connector.network.translators.chat.MessageTranslator;import com.github.steveice10.mc.protocol.data.game.scoreboard.ObjectiveAction;import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerScoreboardObjectivePacket;@Translator(packet = ServerScoreboardObjectivePacket.class)public class JavaScoreboardObjectiveTranslator extends PacketTranslator<ServerScoreboardObjectivePacket> {    @Override    public void translate(ServerScoreboardObjectivePacket packet, GeyserSession session) {        WorldCache worldCache = session.getWorldCache();        Scoreboard scoreboard = worldCache.getScoreboard();        Objective objective = scoreboard.getObjective(packet.getName());        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();        if (objective == null && packet.getAction() != ObjectiveAction.REMOVE) {            objective = scoreboard.registerNewObjective(packet.getName(), false);        }        switch (packet.getAction()) {            case ADD:            case UPDATE:                objective.setDisplayName(MessageTranslator.convertMessage(packet.getDisplayName()))                        .setType(packet.getType().ordinal());                break;            case REMOVE:                scoreboard.unregisterObjective(packet.getName());                break;        }        if (objective == null || !objective.isActive()) {            return;        }        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {            scoreboard.onUpdate();        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerTeamPacket;import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.GeyserLogger;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.scoreboard.Scoreboard;import org.geysermc.connector.scoreboard.ScoreboardUpdater;import org.geysermc.connector.scoreboard.Team;import org.geysermc.connector.scoreboard.UpdateType;import org.geysermc.connector.utils.LanguageUtils;import org.geysermc.connector.network.translators.chat.MessageTranslator;import java.util.Arrays;import java.util.Set;@Translator(packet = ServerTeamPacket.class)public class JavaTeamTranslator extends PacketTranslator<ServerTeamPacket> {    private static final GeyserLogger LOGGER = GeyserConnector.getInstance().getLogger();    @Override    public void translate(GeyserSession session, ServerTeamPacket packet) {        if (LOGGER.isDebug()) {            LOGGER.debug(\"Team packet \" + packet.getTeamName() + \" \" + packet.getAction() + \" \" + Arrays.toString(packet.getPlayers()));        }        int pps = session.getWorldCache().increaseAndGetScoreboardPacketsPerSecond();        Scoreboard scoreboard = session.getWorldCache().getScoreboard();        Team team = scoreboard.getTeam(packet.getTeamName());        switch (packet.getAction()) {            case CREATE:                scoreboard.registerNewTeam(packet.getTeamName(), toPlayerSet(packet.getPlayers()))                        .setName(MessageTranslator.convertMessage(packet.getDisplayName()))                        .setColor(packet.getColor())                        .setNameTagVisibility(packet.getNameTagVisibility())                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()));                break;            case UPDATE:                if (team == null) {                    LOGGER.debug(LanguageUtils.getLocaleStringLog(                            \"geyser.network.translator.team.failed_not_registered\",                            packet.getAction(), packet.getTeamName()                    ));                    return;                }                team.setName(MessageTranslator.convertMessage(packet.getDisplayName()))                        .setColor(packet.getColor())                        .setNameTagVisibility(packet.getNameTagVisibility())                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()))                        .setUpdateType(UpdateType.UPDATE);                break;            case ADD_PLAYER:                if (team == null) {                    LOGGER.debug(LanguageUtils.getLocaleStringLog(                            \"geyser.network.translator.team.failed_not_registered\",                            packet.getAction(), packet.getTeamName()                    ));                    return;                }                team.addEntities(packet.getPlayers());                break;            case REMOVE_PLAYER:                if (team == null) {                    LOGGER.debug(LanguageUtils.getLocaleStringLog(                            \"geyser.network.translator.team.failed_not_registered\",                            packet.getAction(), packet.getTeamName()                    ));                    return;                }                team.removeEntities(packet.getPlayers());                break;            case REMOVE:                scoreboard.removeTeam(packet.getTeamName());                break;        }        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {            scoreboard.onUpdate();        }    }    private Set<String> toPlayerSet(String[] players) {        return new ObjectOpenHashSet<>(players);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerTeamPacket;import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.GeyserLogger;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.scoreboard.Scoreboard;import org.geysermc.connector.scoreboard.ScoreboardUpdater;import org.geysermc.connector.scoreboard.Team;import org.geysermc.connector.scoreboard.UpdateType;import org.geysermc.connector.utils.LanguageUtils;import org.geysermc.connector.network.translators.chat.MessageTranslator;import java.util.Arrays;import java.util.Set;@Translator(packet = ServerTeamPacket.class)public class JavaTeamTranslator extends PacketTranslator<ServerTeamPacket> {    private static final GeyserLogger LOGGER = GeyserConnector.getInstance().getLogger();    @Override    public void translate(ServerTeamPacket packet, GeyserSession session) {        if (LOGGER.isDebug()) {            LOGGER.debug(\"Team packet \" + packet.getTeamName() + \" \" + packet.getAction() + \" \" + Arrays.toString(packet.getPlayers()));        }        int pps = session.getWorldCache().increaseAndGetScoreboardPacketsPerSecond();        Scoreboard scoreboard = session.getWorldCache().getScoreboard();        Team team = scoreboard.getTeam(packet.getTeamName());        switch (packet.getAction()) {            case CREATE:                scoreboard.registerNewTeam(packet.getTeamName(), toPlayerSet(packet.getPlayers()))                        .setName(MessageTranslator.convertMessage(packet.getDisplayName()))                        .setColor(packet.getColor())                        .setNameTagVisibility(packet.getNameTagVisibility())                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()));                break;            case UPDATE:                if (team == null) {                    LOGGER.debug(LanguageUtils.getLocaleStringLog(                            \"geyser.network.translator.team.failed_not_registered\",                            packet.getAction(), packet.getTeamName()                    ));                    return;                }                team.setName(MessageTranslator.convertMessage(packet.getDisplayName()))                        .setColor(packet.getColor())                        .setNameTagVisibility(packet.getNameTagVisibility())                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()))                        .setUpdateType(UpdateType.UPDATE);                break;            case ADD_PLAYER:                if (team == null) {                    LOGGER.debug(LanguageUtils.getLocaleStringLog(                            \"geyser.network.translator.team.failed_not_registered\",                            packet.getAction(), packet.getTeamName()                    ));                    return;                }                team.addEntities(packet.getPlayers());                break;            case REMOVE_PLAYER:                if (team == null) {                    LOGGER.debug(LanguageUtils.getLocaleStringLog(                            \"geyser.network.translator.team.failed_not_registered\",                            packet.getAction(), packet.getTeamName()                    ));                    return;                }                team.removeEntities(packet.getPlayers());                break;            case REMOVE:                scoreboard.removeTeam(packet.getTeamName());                break;        }        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {            scoreboard.onUpdate();        }    }    private Set<String> toPlayerSet(String[] players) {        return new ObjectOpenHashSet<>(players);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.scoreboard.ScoreboardAction;import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerUpdateScorePacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.GeyserLogger;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.WorldCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.scoreboard.Objective;import org.geysermc.connector.scoreboard.Scoreboard;import org.geysermc.connector.scoreboard.ScoreboardUpdater;import org.geysermc.connector.utils.LanguageUtils;@Translator(packet = ServerUpdateScorePacket.class)public class JavaUpdateScoreTranslator extends PacketTranslator<ServerUpdateScorePacket> {    private final GeyserLogger logger;    public JavaUpdateScoreTranslator() {        logger = GeyserConnector.getInstance().getLogger();    }    @Override    public void translate(GeyserSession session, ServerUpdateScorePacket packet) {        WorldCache worldCache = session.getWorldCache();        Scoreboard scoreboard = worldCache.getScoreboard();        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();        Objective objective = scoreboard.getObjective(packet.getObjective());        if (objective == null && packet.getAction() != ScoreboardAction.REMOVE) {            logger.info(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.score.failed_objective\", packet.getObjective()));            return;        }        switch (packet.getAction()) {            case ADD_OR_UPDATE:                objective.setScore(packet.getEntry(), packet.getValue());                break;            case REMOVE:                if (objective != null) {                    objective.removeScore(packet.getEntry());                } else {                    for (Objective objective1 : scoreboard.getObjectives().values()) {                        objective1.removeScore(packet.getEntry());                    }                }                break;        }        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {            scoreboard.onUpdate();        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.scoreboard.ScoreboardAction;import com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerUpdateScorePacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.GeyserLogger;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.cache.WorldCache;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.scoreboard.Objective;import org.geysermc.connector.scoreboard.Scoreboard;import org.geysermc.connector.scoreboard.ScoreboardUpdater;import org.geysermc.connector.utils.LanguageUtils;@Translator(packet = ServerUpdateScorePacket.class)public class JavaUpdateScoreTranslator extends PacketTranslator<ServerUpdateScorePacket> {    private final GeyserLogger logger;    public JavaUpdateScoreTranslator() {        logger = GeyserConnector.getInstance().getLogger();    }    @Override    public void translate(ServerUpdateScorePacket packet, GeyserSession session) {        WorldCache worldCache = session.getWorldCache();        Scoreboard scoreboard = worldCache.getScoreboard();        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();        Objective objective = scoreboard.getObjective(packet.getObjective());        if (objective == null && packet.getAction() != ScoreboardAction.REMOVE) {            logger.info(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.score.failed_objective\", packet.getObjective()));            return;        }        switch (packet.getAction()) {            case ADD_OR_UPDATE:                objective.setScore(packet.getEntry(), packet.getValue());                break;            case REMOVE:                if (objective != null) {                    objective.removeScore(packet.getEntry());                } else {                    for (Objective objective1 : scoreboard.getObjectives().values()) {                        objective1.removeScore(packet.getEntry());                    }                }                break;        }        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {            scoreboard.onUpdate();        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerClearTitlesPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerClearTitlesPacket.class)public class JavaClearTitlesTranslator extends PacketTranslator<ServerClearTitlesPacket> {    @Override    public void translate(GeyserSession session, ServerClearTitlesPacket packet) {        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.CLEAR);        titlePacket.setText(\"\");        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerClearTitlesPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerClearTitlesPacket.class)public class JavaClearTitlesTranslator extends PacketTranslator<ServerClearTitlesPacket> {    @Override    public void translate(ServerClearTitlesPacket packet, GeyserSession session) {        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.CLEAR);        titlePacket.setText(\"\");        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetActionBarTextPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerSetActionBarTextPacket.class)public class JavaSetActionBarTextTranslator extends PacketTranslator<ServerSetActionBarTextPacket> {    @Override    public void translate(GeyserSession session, ServerSetActionBarTextPacket packet) {        String text;        if (packet.getText() == null) {             text = \" \";        } else {            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());        }        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);        titlePacket.setText(text);        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetActionBarTextPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerSetActionBarTextPacket.class)public class JavaSetActionBarTextTranslator extends PacketTranslator<ServerSetActionBarTextPacket> {    @Override    public void translate(ServerSetActionBarTextPacket packet, GeyserSession session) {        String text;        if (packet.getText() == null) {             text = \" \";        } else {            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());        }        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);        titlePacket.setText(text);        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetSubtitleTextPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerSetSubtitleTextPacket.class)public class JavaSetSubtitleTextTranslator extends PacketTranslator<ServerSetSubtitleTextPacket> {    @Override    public void translate(GeyserSession session, ServerSetSubtitleTextPacket packet) {        String text;        if (packet.getText() == null) {             text = \" \";        } else {            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());        }        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.SUBTITLE);        titlePacket.setText(text);        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetSubtitleTextPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerSetSubtitleTextPacket.class)public class JavaSetSubtitleTextTranslator extends PacketTranslator<ServerSetSubtitleTextPacket> {    @Override    public void translate(ServerSetSubtitleTextPacket packet, GeyserSession session) {        String text;        if (packet.getText() == null) {             text = \" \";        } else {            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());        }        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.SUBTITLE);        titlePacket.setText(text);        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitleTextPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerSetTitleTextPacket.class)public class JavaSetTitleTextTranslator extends PacketTranslator<ServerSetTitleTextPacket> {    @Override    public void translate(GeyserSession session, ServerSetTitleTextPacket packet) {        String text;        if (packet.getText() == null) {             text = \" \";        } else {            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());        }        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.TITLE);        titlePacket.setText(text);        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitleTextPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;@Translator(packet = ServerSetTitleTextPacket.class)public class JavaSetTitleTextTranslator extends PacketTranslator<ServerSetTitleTextPacket> {    @Override    public void translate(ServerSetTitleTextPacket packet, GeyserSession session) {        String text;        if (packet.getText() == null) {             text = \" \";        } else {            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());        }        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.TITLE);        titlePacket.setText(text);        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitlesAnimationPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerSetTitlesAnimationPacket.class)public class JavaSetTitlesAnimationTranslator extends PacketTranslator<ServerSetTitlesAnimationPacket> {    @Override    public void translate(GeyserSession session, ServerSetTitlesAnimationPacket packet) {        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.TIMES);        titlePacket.setText(\"\");        titlePacket.setFadeInTime(packet.getFadeIn());        titlePacket.setFadeOutTime(packet.getFadeOut());        titlePacket.setStayTime(packet.getStay());        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitlesAnimationPacket;import com.nukkitx.protocol.bedrock.packet.SetTitlePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerSetTitlesAnimationPacket.class)public class JavaSetTitlesAnimationTranslator extends PacketTranslator<ServerSetTitlesAnimationPacket> {    @Override    public void translate(ServerSetTitlesAnimationPacket packet, GeyserSession session) {        SetTitlePacket titlePacket = new SetTitlePacket();        titlePacket.setType(SetTitlePacket.Type.TIMES);        titlePacket.setText(\"\");        titlePacket.setFadeInTime(packet.getFadeIn());        titlePacket.setFadeOutTime(packet.getFadeOut());        titlePacket.setStayTime(packet.getStay());        titlePacket.setXuid(\"\");        titlePacket.setPlatformOnlineId(\"\");        session.sendUpstreamPacket(titlePacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerCloseWindowPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ServerCloseWindowPacket.class)public class JavaCloseWindowTranslator extends PacketTranslator<ServerCloseWindowPacket> {    @Override    public void translate(GeyserSession session, ServerCloseWindowPacket packet) {        InventoryUtils.closeInventory(session, packet.getWindowId(), (session.getOpenInventory() != null && session.getOpenInventory().getId() == packet.getWindowId()));    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerCloseWindowPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ServerCloseWindowPacket.class)public class JavaCloseWindowTranslator extends PacketTranslator<ServerCloseWindowPacket> {    @Override    public void translate(ServerCloseWindowPacket packet, GeyserSession session) {        InventoryUtils.closeInventory(session, packet.getWindowId(), (session.getOpenInventory() != null && session.getOpenInventory().getId() == packet.getWindowId()));    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenHorseWindowPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.nbt.NbtType;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.packet.UpdateEquipPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.ChestedHorseEntity;import org.geysermc.connector.entity.living.animal.horse.LlamaEntity;import org.geysermc.connector.inventory.Container;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.horse.DonkeyInventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.horse.HorseInventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.horse.LlamaInventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;import java.util.ArrayList;import java.util.Collections;import java.util.List;@Translator(packet = ServerOpenHorseWindowPacket.class)public class JavaOpenHorseWindowTranslator extends PacketTranslator<ServerOpenHorseWindowPacket> {    private static final NbtMap ARMOR_SLOT;    private static final NbtMap CARPET_SLOT;    private static final NbtMap SADDLE_SLOT;    static {        String[] acceptedHorseArmorIdentifiers = new String[] {\"minecraft:horsearmorleather\", \"minecraft:horsearmoriron\",                \"minecraft:horsearmorgold\", \"minecraft:horsearmordiamond\"};        NbtMapBuilder armorBuilder = NbtMap.builder();        List<NbtMap> acceptedArmors = new ArrayList<>(4);        for (String identifier : acceptedHorseArmorIdentifiers) {            NbtMapBuilder acceptedItemBuilder = NbtMap.builder()                    .putShort(\"Aux\", Short.MAX_VALUE)                    .putString(\"Name\", identifier);            acceptedArmors.add(NbtMap.builder().putCompound(\"slotItem\", acceptedItemBuilder.build()).build());        }        armorBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedArmors);        NbtMapBuilder armorItem = NbtMap.builder()                .putShort(\"Aux\", Short.MAX_VALUE)                .putString(\"Name\", \"minecraft:horsearmoriron\");        armorBuilder.putCompound(\"item\", armorItem.build());        armorBuilder.putInt(\"slotNumber\", 1);        ARMOR_SLOT = armorBuilder.build();        NbtMapBuilder carpetBuilder = NbtMap.builder();        NbtMapBuilder carpetItem = NbtMap.builder()                .putShort(\"Aux\", Short.MAX_VALUE)                .putString(\"Name\", \"minecraft:carpet\");        List<NbtMap> acceptedCarpet = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", carpetItem.build()).build());        carpetBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedCarpet);        carpetBuilder.putCompound(\"item\", carpetItem.build());        carpetBuilder.putInt(\"slotNumber\", 1);        CARPET_SLOT = carpetBuilder.build();        NbtMapBuilder saddleBuilder = NbtMap.builder();        NbtMapBuilder acceptedSaddle = NbtMap.builder()                .putShort(\"Aux\", Short.MAX_VALUE)                .putString(\"Name\", \"minecraft:saddle\");        List<NbtMap> acceptedItem = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", acceptedSaddle.build()).build());        saddleBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedItem);        saddleBuilder.putCompound(\"item\", acceptedSaddle.build());        saddleBuilder.putInt(\"slotNumber\", 0);        SADDLE_SLOT = saddleBuilder.build();    }    @Override    public void translate(GeyserSession session, ServerOpenHorseWindowPacket packet) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (entity == null) {            return;        }        UpdateEquipPacket updateEquipPacket = new UpdateEquipPacket();        updateEquipPacket.setWindowId((short) packet.getWindowId());        updateEquipPacket.setWindowType((short) ContainerType.HORSE.getId());        updateEquipPacket.setUniqueEntityId(entity.getGeyserId());        NbtMapBuilder builder = NbtMap.builder();        List<NbtMap> slots = new ArrayList<>();        InventoryTranslator inventoryTranslator;        if (entity instanceof LlamaEntity) {            inventoryTranslator = new LlamaInventoryTranslator(packet.getNumberOfSlots());            slots.add(CARPET_SLOT);        } else if (entity instanceof ChestedHorseEntity) {            inventoryTranslator = new DonkeyInventoryTranslator(packet.getNumberOfSlots());            slots.add(SADDLE_SLOT);        } else {            inventoryTranslator = new HorseInventoryTranslator(packet.getNumberOfSlots());            slots.add(SADDLE_SLOT);            slots.add(ARMOR_SLOT);        }        builder.putList(\"slots\", NbtType.COMPOUND, slots);        updateEquipPacket.setTag(builder.build());        session.sendUpstreamPacket(updateEquipPacket);        session.setInventoryTranslator(inventoryTranslator);        InventoryUtils.openInventory(session, new Container(entity.getMetadata().getString(EntityData.NAMETAG), packet.getWindowId(), packet.getNumberOfSlots(), null, session.getPlayerInventory()));    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenHorseWindowPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.nbt.NbtType;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.packet.UpdateEquipPacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.entity.living.animal.horse.ChestedHorseEntity;import org.geysermc.connector.entity.living.animal.horse.LlamaEntity;import org.geysermc.connector.inventory.Container;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.horse.DonkeyInventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.horse.HorseInventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.horse.LlamaInventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;import java.util.ArrayList;import java.util.Collections;import java.util.List;@Translator(packet = ServerOpenHorseWindowPacket.class)public class JavaOpenHorseWindowTranslator extends PacketTranslator<ServerOpenHorseWindowPacket> {    private static final NbtMap ARMOR_SLOT;    private static final NbtMap CARPET_SLOT;    private static final NbtMap SADDLE_SLOT;    static {        String[] acceptedHorseArmorIdentifiers = new String[] {\"minecraft:horsearmorleather\", \"minecraft:horsearmoriron\",                \"minecraft:horsearmorgold\", \"minecraft:horsearmordiamond\"};        NbtMapBuilder armorBuilder = NbtMap.builder();        List<NbtMap> acceptedArmors = new ArrayList<>(4);        for (String identifier : acceptedHorseArmorIdentifiers) {            NbtMapBuilder acceptedItemBuilder = NbtMap.builder()                    .putShort(\"Aux\", Short.MAX_VALUE)                    .putString(\"Name\", identifier);            acceptedArmors.add(NbtMap.builder().putCompound(\"slotItem\", acceptedItemBuilder.build()).build());        }        armorBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedArmors);        NbtMapBuilder armorItem = NbtMap.builder()                .putShort(\"Aux\", Short.MAX_VALUE)                .putString(\"Name\", \"minecraft:horsearmoriron\");        armorBuilder.putCompound(\"item\", armorItem.build());        armorBuilder.putInt(\"slotNumber\", 1);        ARMOR_SLOT = armorBuilder.build();        NbtMapBuilder carpetBuilder = NbtMap.builder();        NbtMapBuilder carpetItem = NbtMap.builder()                .putShort(\"Aux\", Short.MAX_VALUE)                .putString(\"Name\", \"minecraft:carpet\");        List<NbtMap> acceptedCarpet = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", carpetItem.build()).build());        carpetBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedCarpet);        carpetBuilder.putCompound(\"item\", carpetItem.build());        carpetBuilder.putInt(\"slotNumber\", 1);        CARPET_SLOT = carpetBuilder.build();        NbtMapBuilder saddleBuilder = NbtMap.builder();        NbtMapBuilder acceptedSaddle = NbtMap.builder()                .putShort(\"Aux\", Short.MAX_VALUE)                .putString(\"Name\", \"minecraft:saddle\");        List<NbtMap> acceptedItem = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", acceptedSaddle.build()).build());        saddleBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedItem);        saddleBuilder.putCompound(\"item\", acceptedSaddle.build());        saddleBuilder.putInt(\"slotNumber\", 0);        SADDLE_SLOT = saddleBuilder.build();    }    @Override    public void translate(ServerOpenHorseWindowPacket packet, GeyserSession session) {        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());        if (entity == null) {            return;        }        UpdateEquipPacket updateEquipPacket = new UpdateEquipPacket();        updateEquipPacket.setWindowId((short) packet.getWindowId());        updateEquipPacket.setWindowType((short) ContainerType.HORSE.getId());        updateEquipPacket.setUniqueEntityId(entity.getGeyserId());        NbtMapBuilder builder = NbtMap.builder();        List<NbtMap> slots = new ArrayList<>();        InventoryTranslator inventoryTranslator;        if (entity instanceof LlamaEntity) {            inventoryTranslator = new LlamaInventoryTranslator(packet.getNumberOfSlots());            slots.add(CARPET_SLOT);        } else if (entity instanceof ChestedHorseEntity) {            inventoryTranslator = new DonkeyInventoryTranslator(packet.getNumberOfSlots());            slots.add(SADDLE_SLOT);        } else {            inventoryTranslator = new HorseInventoryTranslator(packet.getNumberOfSlots());            slots.add(SADDLE_SLOT);            slots.add(ARMOR_SLOT);        }        builder.putList(\"slots\", NbtType.COMPOUND, slots);        updateEquipPacket.setTag(builder.build());        session.sendUpstreamPacket(updateEquipPacket);        session.setInventoryTranslator(inventoryTranslator);        InventoryUtils.openInventory(session, new Container(entity.getMetadata().getString(EntityData.NAMETAG), packet.getWindowId(), packet.getNumberOfSlots(), null, session.getPlayerInventory()));    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenWindowPacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;import org.geysermc.connector.utils.LocaleUtils;@Translator(packet = ServerOpenWindowPacket.class)public class JavaOpenWindowTranslator extends PacketTranslator<ServerOpenWindowPacket> {    @Override    public void translate(GeyserSession session, ServerOpenWindowPacket packet) {        if (packet.getWindowId() == 0) {            return;        }        InventoryTranslator newTranslator = InventoryTranslator.INVENTORY_TRANSLATORS.get(packet.getType());        Inventory openInventory = session.getOpenInventory();        if (newTranslator == null) {            if (openInventory != null) {                InventoryUtils.closeInventory(session, openInventory.getId(), true);            }            ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(packet.getWindowId());            session.sendDownstreamPacket(closeWindowPacket);            return;        }        String name = MessageTranslator.convertMessageLenient(packet.getName(), session.getLocale());        name = LocaleUtils.getLocaleString(name, session.getLocale());        Inventory newInventory = newTranslator.createInventory(name, packet.getWindowId(), packet.getType(), session.getPlayerInventory());        if (openInventory != null) {            if (openInventory.getWindowType() != packet.getType()) {                InventoryUtils.closeInventory(session, openInventory.getId(), openInventory.getId() != packet.getWindowId());            }        }        session.setInventoryTranslator(newTranslator);        InventoryUtils.openInventory(session, newInventory);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenWindowPacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.chat.MessageTranslator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;import org.geysermc.connector.utils.LocaleUtils;@Translator(packet = ServerOpenWindowPacket.class)public class JavaOpenWindowTranslator extends PacketTranslator<ServerOpenWindowPacket> {    @Override    public void translate(ServerOpenWindowPacket packet, GeyserSession session) {        if (packet.getWindowId() == 0) {            return;        }        InventoryTranslator newTranslator = InventoryTranslator.INVENTORY_TRANSLATORS.get(packet.getType());        Inventory openInventory = session.getOpenInventory();        if (newTranslator == null) {            if (openInventory != null) {                InventoryUtils.closeInventory(session, openInventory.getId(), true);            }            ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(packet.getWindowId());            session.sendDownstreamPacket(closeWindowPacket);            return;        }        String name = MessageTranslator.convertMessageLenient(packet.getName(), session.getLocale());        name = LocaleUtils.getLocaleString(name, session.getLocale());        Inventory newInventory = newTranslator.createInventory(name, packet.getWindowId(), packet.getType(), session.getPlayerInventory());        if (openInventory != null) {            if (openInventory.getWindowType() != packet.getType()) {                InventoryUtils.closeInventory(session, openInventory.getId(), openInventory.getId() != packet.getWindowId());            }        }        session.setInventoryTranslator(newTranslator);        InventoryUtils.openInventory(session, newInventory);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;import com.github.steveice10.mc.protocol.data.game.recipe.Recipe;import com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerSetSlotPacket;import com.nukkitx.protocol.bedrock.data.inventory.ContainerId;import com.nukkitx.protocol.bedrock.data.inventory.CraftingData;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;import com.nukkitx.protocol.bedrock.packet.InventorySlotPacket;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.CraftingInventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.utils.InventoryUtils;import java.util.Arrays;import java.util.Collections;import java.util.Objects;import java.util.UUID;import java.util.concurrent.TimeUnit;@Translator(packet = ServerSetSlotPacket.class)public class JavaSetSlotTranslator extends PacketTranslator<ServerSetSlotPacket> {    @Override    public void translate(GeyserSession session, ServerSetSlotPacket packet) {        if (packet.getWindowId() == 255) {             GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());            session.getPlayerInventory().setCursor(newItem, session);            InventoryUtils.updateCursor(session);            return;        }        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());        if (inventory == null)            return;        inventory.setStateId(packet.getStateId());        InventoryTranslator translator = session.getInventoryTranslator();        if (translator != null) {            if (session.getCraftingGridFuture() != null) {                session.getCraftingGridFuture().cancel(false);            }            session.setCraftingGridFuture(session.scheduleInEventLoop(() -> updateCraftingGrid(session, packet, inventory, translator), 150, TimeUnit.MILLISECONDS));            GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());            if (packet.getWindowId() == 0 && !(translator instanceof PlayerInventoryTranslator)) {                session.getPlayerInventory().setItem(packet.getSlot(), newItem, session);                InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR.updateSlot(session, session.getPlayerInventory(), packet.getSlot());            } else {                inventory.setItem(packet.getSlot(), newItem, session);                translator.updateSlot(session, inventory, packet.getSlot());            }        }    }    private static void updateCraftingGrid(GeyserSession session, ServerSetSlotPacket packet, Inventory inventory, InventoryTranslator translator) {        if (packet.getSlot() == 0) {            int gridSize;            if (translator instanceof PlayerInventoryTranslator) {                gridSize = 4;            } else if (translator instanceof CraftingInventoryTranslator) {                gridSize = 9;            } else {                return;            }            if (packet.getItem() == null || packet.getItem().getId() == 0) {                return;            }            int offset = gridSize == 4 ? 28 : 32;            int gridDimensions = gridSize == 4 ? 2 : 3;            int firstRow = -1, height = -1;            int firstCol = -1, width = -1;            for (int row = 0; row < gridDimensions; row++) {                for (int col = 0; col < gridDimensions; col++) {                    if (!inventory.getItem(col + (row * gridDimensions) + 1).isEmpty()) {                        if (firstRow == -1) {                            firstRow = row;                            firstCol = col;                        } else {                            firstCol = Math.min(firstCol, col);                        }                        height = Math.max(height, row);                        width = Math.max(width, col);                    }                }            }            if (firstRow == -1) {                return;            }            height += -firstRow + 1;            width += -firstCol + 1;            recipes:            for (Recipe recipe : session.getCraftingRecipes().values()) {                if (recipe.getType() == RecipeType.CRAFTING_SHAPED) {                    ShapedRecipeData data = (ShapedRecipeData) recipe.getData();                    if (!data.getResult().equals(packet.getItem())) {                        continue;                    }                    if (data.getWidth() != width || data.getHeight() != height || width * height != data.getIngredients().length) {                        continue;                    }                    Ingredient[] ingredients = data.getIngredients();                    if (!testShapedRecipe(ingredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {                        Ingredient[] mirroredIngredients = new Ingredient[data.getIngredients().length];                        for (int row = 0; row < height; row++) {                            for (int col = 0; col < width; col++) {                                mirroredIngredients[col + (row * width)] = ingredients[(width - 1 - col) + (row * width)];                            }                        }                        if (Arrays.equals(ingredients, mirroredIngredients) ||                                !testShapedRecipe(mirroredIngredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {                            continue;                        }                    }                    return;                } else if (recipe.getType() == RecipeType.CRAFTING_SHAPELESS) {                    ShapelessRecipeData data = (ShapelessRecipeData) recipe.getData();                    if (!data.getResult().equals(packet.getItem())) {                        continue;                    }                    for (int i = 0; i < data.getIngredients().length; i++) {                        Ingredient ingredient = data.getIngredients()[i];                        for (ItemStack itemStack : ingredient.getOptions()) {                            boolean inventoryHasItem = false;                            for (int j = 0; j < inventory.getSize(); j++) {                                GeyserItemStack geyserItemStack = inventory.getItem(j);                                if (geyserItemStack.isEmpty()) {                                    inventoryHasItem = itemStack == null || itemStack.getId() == 0;                                    if (inventoryHasItem) {                                        break;                                    }                                } else if (itemStack.equals(geyserItemStack.getItemStack(1))) {                                    inventoryHasItem = true;                                    break;                                }                            }                            if (!inventoryHasItem) {                                continue recipes;                            }                        }                    }                    return;                }            }            UUID uuid = UUID.randomUUID();            int newRecipeId = session.getLastRecipeNetId().incrementAndGet();            ItemData[] ingredients = new ItemData[height * width];            Ingredient[] javaIngredients = new Ingredient[height * width];            int index = 0;            for (int row = firstRow; row < height + firstRow; row++) {                for (int col = firstCol; col < width + firstCol; col++) {                    GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);                    ingredients[index] = geyserItemStack.getItemData(session);                    ItemStack[] itemStacks = new ItemStack[] {geyserItemStack.isEmpty() ? null : geyserItemStack.getItemStack(1)};                    javaIngredients[index] = new Ingredient(itemStacks);                    InventorySlotPacket slotPacket = new InventorySlotPacket();                    slotPacket.setContainerId(ContainerId.UI);                    slotPacket.setSlot(col + (row * gridDimensions) + offset);                    slotPacket.setItem(ItemData.AIR);                    session.sendUpstreamPacket(slotPacket);                    index++;                }            }            ShapedRecipeData data = new ShapedRecipeData(width, height, \"\", javaIngredients, packet.getItem());            session.getCraftingRecipes().put(newRecipeId, new Recipe(RecipeType.CRAFTING_SHAPED, uuid.toString(), data));            CraftingDataPacket craftPacket = new CraftingDataPacket();            craftPacket.getCraftingData().add(CraftingData.fromShaped(                    uuid.toString(),                    width,                    height,                    Arrays.asList(ingredients),                    Collections.singletonList(ItemTranslator.translateToBedrock(session, packet.getItem())),                    uuid,                    \"crafting_table\",                    0,                    newRecipeId            ));            craftPacket.setCleanRecipes(false);            session.sendUpstreamPacket(craftPacket);            index = 0;            for (int row = firstRow; row < height + firstRow; row++) {                for (int col = firstCol; col < width + firstCol; col++) {                    InventorySlotPacket slotPacket = new InventorySlotPacket();                    slotPacket.setContainerId(ContainerId.UI);                    slotPacket.setSlot(col + (row * gridDimensions) + offset);                    slotPacket.setItem(ingredients[index]);                    session.sendUpstreamPacket(slotPacket);                    index++;                }            }        }    }    private static boolean testShapedRecipe(Ingredient[] ingredients, Inventory inventory, int gridDimensions, int firstRow, int height, int firstCol, int width) {        int ingredientIndex = 0;        for (int row = firstRow; row < height + firstRow; row++) {            for (int col = firstCol; col < width + firstCol; col++) {                GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);                Ingredient ingredient = ingredients[ingredientIndex++];                if (ingredient.getOptions().length == 0) {                    if (!geyserItemStack.isEmpty()) {                        return false;                    }                } else {                    boolean inventoryHasItem = false;                    for (ItemStack item : ingredient.getOptions()) {                        if (Objects.equals(geyserItemStack.getItemStack(1), item)) {                            inventoryHasItem = true;                            break;                        }                    }                    if (!inventoryHasItem) {                        return false;                    }                }            }        }        return true;    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;import com.github.steveice10.mc.protocol.data.game.recipe.Recipe;import com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;import com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerSetSlotPacket;import com.nukkitx.protocol.bedrock.data.inventory.ContainerId;import com.nukkitx.protocol.bedrock.data.inventory.CraftingData;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;import com.nukkitx.protocol.bedrock.packet.InventorySlotPacket;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.CraftingInventoryTranslator;import org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.utils.InventoryUtils;import java.util.Arrays;import java.util.Collections;import java.util.Objects;import java.util.UUID;import java.util.concurrent.TimeUnit;@Translator(packet = ServerSetSlotPacket.class)public class JavaSetSlotTranslator extends PacketTranslator<ServerSetSlotPacket> {    @Override    public void translate(ServerSetSlotPacket packet, GeyserSession session) {        if (packet.getWindowId() == 255) {             GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());            session.getPlayerInventory().setCursor(newItem, session);            InventoryUtils.updateCursor(session);            return;        }        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());        if (inventory == null)            return;        inventory.setStateId(packet.getStateId());        InventoryTranslator translator = session.getInventoryTranslator();        if (translator != null) {            if (session.getCraftingGridFuture() != null) {                session.getCraftingGridFuture().cancel(false);            }            session.setCraftingGridFuture(session.scheduleInEventLoop(() -> updateCraftingGrid(session, packet, inventory, translator), 150, TimeUnit.MILLISECONDS));            GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());            if (packet.getWindowId() == 0 && !(translator instanceof PlayerInventoryTranslator)) {                session.getPlayerInventory().setItem(packet.getSlot(), newItem, session);                InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR.updateSlot(session, session.getPlayerInventory(), packet.getSlot());            } else {                inventory.setItem(packet.getSlot(), newItem, session);                translator.updateSlot(session, inventory, packet.getSlot());            }        }    }    private static void updateCraftingGrid(GeyserSession session, ServerSetSlotPacket packet, Inventory inventory, InventoryTranslator translator) {        if (packet.getSlot() == 0) {            int gridSize;            if (translator instanceof PlayerInventoryTranslator) {                gridSize = 4;            } else if (translator instanceof CraftingInventoryTranslator) {                gridSize = 9;            } else {                return;            }            if (packet.getItem() == null || packet.getItem().getId() == 0) {                return;            }            int offset = gridSize == 4 ? 28 : 32;            int gridDimensions = gridSize == 4 ? 2 : 3;            int firstRow = -1, height = -1;            int firstCol = -1, width = -1;            for (int row = 0; row < gridDimensions; row++) {                for (int col = 0; col < gridDimensions; col++) {                    if (!inventory.getItem(col + (row * gridDimensions) + 1).isEmpty()) {                        if (firstRow == -1) {                            firstRow = row;                            firstCol = col;                        } else {                            firstCol = Math.min(firstCol, col);                        }                        height = Math.max(height, row);                        width = Math.max(width, col);                    }                }            }            if (firstRow == -1) {                return;            }            height += -firstRow + 1;            width += -firstCol + 1;            recipes:            for (Recipe recipe : session.getCraftingRecipes().values()) {                if (recipe.getType() == RecipeType.CRAFTING_SHAPED) {                    ShapedRecipeData data = (ShapedRecipeData) recipe.getData();                    if (!data.getResult().equals(packet.getItem())) {                        continue;                    }                    if (data.getWidth() != width || data.getHeight() != height || width * height != data.getIngredients().length) {                        continue;                    }                    Ingredient[] ingredients = data.getIngredients();                    if (!testShapedRecipe(ingredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {                        Ingredient[] mirroredIngredients = new Ingredient[data.getIngredients().length];                        for (int row = 0; row < height; row++) {                            for (int col = 0; col < width; col++) {                                mirroredIngredients[col + (row * width)] = ingredients[(width - 1 - col) + (row * width)];                            }                        }                        if (Arrays.equals(ingredients, mirroredIngredients) ||                                !testShapedRecipe(mirroredIngredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {                            continue;                        }                    }                    return;                } else if (recipe.getType() == RecipeType.CRAFTING_SHAPELESS) {                    ShapelessRecipeData data = (ShapelessRecipeData) recipe.getData();                    if (!data.getResult().equals(packet.getItem())) {                        continue;                    }                    for (int i = 0; i < data.getIngredients().length; i++) {                        Ingredient ingredient = data.getIngredients()[i];                        for (ItemStack itemStack : ingredient.getOptions()) {                            boolean inventoryHasItem = false;                            for (int j = 0; j < inventory.getSize(); j++) {                                GeyserItemStack geyserItemStack = inventory.getItem(j);                                if (geyserItemStack.isEmpty()) {                                    inventoryHasItem = itemStack == null || itemStack.getId() == 0;                                    if (inventoryHasItem) {                                        break;                                    }                                } else if (itemStack.equals(geyserItemStack.getItemStack(1))) {                                    inventoryHasItem = true;                                    break;                                }                            }                            if (!inventoryHasItem) {                                continue recipes;                            }                        }                    }                    return;                }            }            UUID uuid = UUID.randomUUID();            int newRecipeId = session.getLastRecipeNetId().incrementAndGet();            ItemData[] ingredients = new ItemData[height * width];            Ingredient[] javaIngredients = new Ingredient[height * width];            int index = 0;            for (int row = firstRow; row < height + firstRow; row++) {                for (int col = firstCol; col < width + firstCol; col++) {                    GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);                    ingredients[index] = geyserItemStack.getItemData(session);                    ItemStack[] itemStacks = new ItemStack[] {geyserItemStack.isEmpty() ? null : geyserItemStack.getItemStack(1)};                    javaIngredients[index] = new Ingredient(itemStacks);                    InventorySlotPacket slotPacket = new InventorySlotPacket();                    slotPacket.setContainerId(ContainerId.UI);                    slotPacket.setSlot(col + (row * gridDimensions) + offset);                    slotPacket.setItem(ItemData.AIR);                    session.sendUpstreamPacket(slotPacket);                    index++;                }            }            ShapedRecipeData data = new ShapedRecipeData(width, height, \"\", javaIngredients, packet.getItem());            session.getCraftingRecipes().put(newRecipeId, new Recipe(RecipeType.CRAFTING_SHAPED, uuid.toString(), data));            CraftingDataPacket craftPacket = new CraftingDataPacket();            craftPacket.getCraftingData().add(CraftingData.fromShaped(                    uuid.toString(),                    width,                    height,                    Arrays.asList(ingredients),                    Collections.singletonList(ItemTranslator.translateToBedrock(session, packet.getItem())),                    uuid,                    \"crafting_table\",                    0,                    newRecipeId            ));            craftPacket.setCleanRecipes(false);            session.sendUpstreamPacket(craftPacket);            index = 0;            for (int row = firstRow; row < height + firstRow; row++) {                for (int col = firstCol; col < width + firstCol; col++) {                    InventorySlotPacket slotPacket = new InventorySlotPacket();                    slotPacket.setContainerId(ContainerId.UI);                    slotPacket.setSlot(col + (row * gridDimensions) + offset);                    slotPacket.setItem(ingredients[index]);                    session.sendUpstreamPacket(slotPacket);                    index++;                }            }        }    }    private static boolean testShapedRecipe(Ingredient[] ingredients, Inventory inventory, int gridDimensions, int firstRow, int height, int firstCol, int width) {        int ingredientIndex = 0;        for (int row = firstRow; row < height + firstRow; row++) {            for (int col = firstCol; col < width + firstCol; col++) {                GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);                Ingredient ingredient = ingredients[ingredientIndex++];                if (ingredient.getOptions().length == 0) {                    if (!geyserItemStack.isEmpty()) {                        return false;                    }                } else {                    boolean inventoryHasItem = false;                    for (ItemStack item : ingredient.getOptions()) {                        if (Objects.equals(geyserItemStack.getItemStack(1), item)) {                            inventoryHasItem = true;                            break;                        }                    }                    if (!inventoryHasItem) {                        return false;                    }                }            }        }        return true;    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowItemsPacket;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ServerWindowItemsPacket.class)public class JavaWindowItemsTranslator extends PacketTranslator<ServerWindowItemsPacket> {    @Override    public void translate(GeyserSession session, ServerWindowItemsPacket packet) {        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());        if (inventory == null)            return;        inventory.setStateId(packet.getStateId());        for (int i = 0; i < packet.getItems().length; i++) {            GeyserItemStack newItem = GeyserItemStack.from(packet.getItems()[i]);            inventory.setItem(i, newItem, session);        }        InventoryTranslator translator = session.getInventoryTranslator();        if (translator != null) {            translator.updateInventory(session, inventory);        }        session.getPlayerInventory().setCursor(GeyserItemStack.from(packet.getCarriedItem()), session);        InventoryUtils.updateCursor(session);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowItemsPacket;import org.geysermc.connector.inventory.GeyserItemStack;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ServerWindowItemsPacket.class)public class JavaWindowItemsTranslator extends PacketTranslator<ServerWindowItemsPacket> {    @Override    public void translate(ServerWindowItemsPacket packet, GeyserSession session) {        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());        if (inventory == null)            return;        inventory.setStateId(packet.getStateId());        for (int i = 0; i < packet.getItems().length; i++) {            GeyserItemStack newItem = GeyserItemStack.from(packet.getItems()[i]);            inventory.setItem(i, newItem, session);        }        InventoryTranslator translator = session.getInventoryTranslator();        if (translator != null) {            translator.updateInventory(session, inventory);        }        session.getPlayerInventory().setCursor(GeyserItemStack.from(packet.getCarriedItem()), session);        InventoryUtils.updateCursor(session);    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowPropertyPacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ServerWindowPropertyPacket.class)public class JavaWindowPropertyTranslator extends PacketTranslator<ServerWindowPropertyPacket> {    @Override    public void translate(GeyserSession session, ServerWindowPropertyPacket packet) {        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());        if (inventory == null)            return;        InventoryTranslator translator = session.getInventoryTranslator();        if (translator != null) {            translator.updateProperty(session, inventory, packet.getRawProperty(), packet.getValue());        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowPropertyPacket;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.InventoryTranslator;import org.geysermc.connector.utils.InventoryUtils;@Translator(packet = ServerWindowPropertyPacket.class)public class JavaWindowPropertyTranslator extends PacketTranslator<ServerWindowPropertyPacket> {    @Override    public void translate(ServerWindowPropertyPacket packet, GeyserSession session) {        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());        if (inventory == null)            return;        InventoryTranslator translator = session.getInventoryTranslator();        if (translator != null) {            translator.updateProperty(session, inventory, packet.getRawProperty(), packet.getValue());        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockBreakAnimPacket;import com.github.steveice10.opennbt.tag.builtin.CompoundTag;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.BlockUtils;@Translator(packet = ServerBlockBreakAnimPacket.class)public class JavaBlockBreakAnimTranslator extends PacketTranslator<ServerBlockBreakAnimPacket> {    @Override    public void translate(GeyserSession session, ServerBlockBreakAnimPacket packet) {        int state = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());        int breakTime = (int) (65535 / Math.ceil(BlockUtils.getBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(state), ItemMapping.AIR, new CompoundTag(\"\"), false) * 20));        LevelEventPacket levelEventPacket = new LevelEventPacket();        levelEventPacket.setPosition(Vector3f.from(                packet.getPosition().getX(),                packet.getPosition().getY(),                packet.getPosition().getZ()        ));        levelEventPacket.setType(LevelEventType.BLOCK_START_BREAK);        switch (packet.getStage()) {            case STAGE_1:                levelEventPacket.setData(breakTime);                break;            case STAGE_2:                levelEventPacket.setData(breakTime * 2);                break;            case STAGE_3:                levelEventPacket.setData(breakTime * 3);                break;            case STAGE_4:                levelEventPacket.setData(breakTime * 4);                break;            case STAGE_5:                levelEventPacket.setData(breakTime * 5);                break;            case STAGE_6:                levelEventPacket.setData(breakTime * 6);                break;            case STAGE_7:                levelEventPacket.setData(breakTime * 7);                break;            case STAGE_8:                levelEventPacket.setData(breakTime * 8);                break;            case STAGE_9:                levelEventPacket.setData(breakTime * 9);                break;            case STAGE_10:                levelEventPacket.setData(breakTime * 10);                break;            case RESET:                levelEventPacket.setType(LevelEventType.BLOCK_STOP_BREAK);                levelEventPacket.setData(0);                break;        }        session.sendUpstreamPacket(levelEventPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockBreakAnimPacket;import com.github.steveice10.opennbt.tag.builtin.CompoundTag;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.registry.type.ItemMapping;import org.geysermc.connector.utils.BlockUtils;@Translator(packet = ServerBlockBreakAnimPacket.class)public class JavaBlockBreakAnimTranslator extends PacketTranslator<ServerBlockBreakAnimPacket> {    @Override    public void translate(ServerBlockBreakAnimPacket packet, GeyserSession session) {        int state = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());        int breakTime = (int) (65535 / Math.ceil(BlockUtils.getBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(state), ItemMapping.AIR, new CompoundTag(\"\"), false) * 20));        LevelEventPacket levelEventPacket = new LevelEventPacket();        levelEventPacket.setPosition(Vector3f.from(                packet.getPosition().getX(),                packet.getPosition().getY(),                packet.getPosition().getZ()        ));        levelEventPacket.setType(LevelEventType.BLOCK_START_BREAK);        switch (packet.getStage()) {            case STAGE_1:                levelEventPacket.setData(breakTime);                break;            case STAGE_2:                levelEventPacket.setData(breakTime * 2);                break;            case STAGE_3:                levelEventPacket.setData(breakTime * 3);                break;            case STAGE_4:                levelEventPacket.setData(breakTime * 4);                break;            case STAGE_5:                levelEventPacket.setData(breakTime * 5);                break;            case STAGE_6:                levelEventPacket.setData(breakTime * 6);                break;            case STAGE_7:                levelEventPacket.setData(breakTime * 7);                break;            case STAGE_8:                levelEventPacket.setData(breakTime * 8);                break;            case STAGE_9:                levelEventPacket.setData(breakTime * 9);                break;            case STAGE_10:                levelEventPacket.setData(breakTime * 10);                break;            case RESET:                levelEventPacket.setType(LevelEventType.BLOCK_STOP_BREAK);                levelEventPacket.setData(0);                break;        }        session.sendUpstreamPacket(levelEventPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockChangePacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import org.geysermc.common.PlatformType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.sound.BlockSoundInteractionHandler;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.utils.ChunkUtils;@Translator(packet = ServerBlockChangePacket.class)public class JavaBlockChangeTranslator extends PacketTranslator<ServerBlockChangePacket> {    @Override    public void translate(GeyserSession session, ServerBlockChangePacket packet) {        Position pos = packet.getRecord().getPosition();        boolean updatePlacement = session.getConnector().getPlatformType() != PlatformType.SPIGOT &&                 session.getConnector().getWorldManager().getBlockAt(session, pos) != packet.getRecord().getBlock();        ChunkUtils.updateBlock(session, packet.getRecord().getBlock(), pos);        if (updatePlacement) {            this.checkPlace(session, packet);        }        this.checkInteract(session, packet);    }    private boolean checkPlace(GeyserSession session, ServerBlockChangePacket packet) {        Vector3i lastPlacePos = session.getLastBlockPlacePosition();        if (lastPlacePos == null) {            return false;        }        if ((lastPlacePos.getX() != packet.getRecord().getPosition().getX()                || lastPlacePos.getY() != packet.getRecord().getPosition().getY()                || lastPlacePos.getZ() != packet.getRecord().getPosition().getZ())) {            return false;        }        boolean contains = false;        String identifier = BlockRegistries.JAVA_BLOCKS.get(packet.getRecord().getBlock()).getItemIdentifier();        if (identifier.equals(session.getLastBlockPlacedId())) {            contains = true;        }        if (!contains) {            session.setLastBlockPlacePosition(null);            session.setLastBlockPlacedId(null);            return false;        }        LevelSoundEventPacket placeBlockSoundPacket = new LevelSoundEventPacket();        placeBlockSoundPacket.setSound(SoundEvent.PLACE);        placeBlockSoundPacket.setPosition(lastPlacePos.toFloat());        placeBlockSoundPacket.setBabySound(false);        placeBlockSoundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(packet.getRecord().getBlock()));        placeBlockSoundPacket.setIdentifier(\":\");        session.sendUpstreamPacket(placeBlockSoundPacket);        session.setLastBlockPlacePosition(null);        session.setLastBlockPlacedId(null);        return true;    }    private void checkInteract(GeyserSession session, ServerBlockChangePacket packet) {        Vector3i lastInteractPos = session.getLastInteractionBlockPosition();        if (lastInteractPos == null || !session.isInteracting()) {            return;        }        if ((lastInteractPos.getX() != packet.getRecord().getPosition().getX()                || lastInteractPos.getY() != packet.getRecord().getPosition().getY()                || lastInteractPos.getZ() != packet.getRecord().getPosition().getZ())) {            return;        }        String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(packet.getRecord().getBlock());        session.setInteracting(false);        BlockSoundInteractionHandler.handleBlockInteraction(session, lastInteractPos.toFloat(), identifier);    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockChangePacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import org.geysermc.common.PlatformType;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.sound.BlockSoundInteractionHandler;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.utils.ChunkUtils;@Translator(packet = ServerBlockChangePacket.class)public class JavaBlockChangeTranslator extends PacketTranslator<ServerBlockChangePacket> {    @Override    public void translate(ServerBlockChangePacket packet, GeyserSession session) {        Position pos = packet.getRecord().getPosition();        boolean updatePlacement = session.getConnector().getPlatformType() != PlatformType.SPIGOT &&                 session.getConnector().getWorldManager().getBlockAt(session, pos) != packet.getRecord().getBlock();        ChunkUtils.updateBlock(session, packet.getRecord().getBlock(), pos);        if (updatePlacement) {            this.checkPlace(session, packet);        }        this.checkInteract(session, packet);    }    private boolean checkPlace(GeyserSession session, ServerBlockChangePacket packet) {        Vector3i lastPlacePos = session.getLastBlockPlacePosition();        if (lastPlacePos == null) {            return false;        }        if ((lastPlacePos.getX() != packet.getRecord().getPosition().getX()                || lastPlacePos.getY() != packet.getRecord().getPosition().getY()                || lastPlacePos.getZ() != packet.getRecord().getPosition().getZ())) {            return false;        }        boolean contains = false;        String identifier = BlockRegistries.JAVA_BLOCKS.get(packet.getRecord().getBlock()).getItemIdentifier();        if (identifier.equals(session.getLastBlockPlacedId())) {            contains = true;        }        if (!contains) {            session.setLastBlockPlacePosition(null);            session.setLastBlockPlacedId(null);            return false;        }        LevelSoundEventPacket placeBlockSoundPacket = new LevelSoundEventPacket();        placeBlockSoundPacket.setSound(SoundEvent.PLACE);        placeBlockSoundPacket.setPosition(lastPlacePos.toFloat());        placeBlockSoundPacket.setBabySound(false);        placeBlockSoundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(packet.getRecord().getBlock()));        placeBlockSoundPacket.setIdentifier(\":\");        session.sendUpstreamPacket(placeBlockSoundPacket);        session.setLastBlockPlacePosition(null);        session.setLastBlockPlacedId(null);        return true;    }    private void checkInteract(GeyserSession session, ServerBlockChangePacket packet) {        Vector3i lastInteractPos = session.getLastInteractionBlockPosition();        if (lastInteractPos == null || !session.isInteracting()) {            return;        }        if ((lastInteractPos.getX() != packet.getRecord().getPosition().getX()                || lastInteractPos.getY() != packet.getRecord().getPosition().getY()                || lastInteractPos.getZ() != packet.getRecord().getPosition().getZ())) {            return;        }        String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(packet.getRecord().getBlock());        session.setInteracting(false);        BlockSoundInteractionHandler.handleBlockInteraction(session, lastInteractPos.toFloat(), identifier);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.world.block.value.*;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockValuePacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;import com.nukkitx.protocol.bedrock.packet.BlockEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.network.translators.world.block.entity.NoteblockBlockEntityTranslator;import java.util.concurrent.TimeUnit;@Translator(packet = ServerBlockValuePacket.class)public class JavaBlockValueTranslator extends PacketTranslator<ServerBlockValuePacket> {    @Override    public void translate(GeyserSession session, ServerBlockValuePacket packet) {        BlockEventPacket blockEventPacket = new BlockEventPacket();        blockEventPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(),                packet.getPosition().getY(), packet.getPosition().getZ()));        if (packet.getValue() instanceof ChestValue) {            ChestValue value = (ChestValue) packet.getValue() ;            blockEventPacket.setEventType(1);            blockEventPacket.setEventData(value.getViewers() > 0 ? 1 : 0);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof EndGatewayValue) {            blockEventPacket.setEventType(1);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof NoteBlockValue) {            NoteblockBlockEntityTranslator.translate(session, packet.getPosition());        } else if (packet.getValue() instanceof PistonValue) {            PistonValueType type = (PistonValueType) packet.getType();            Vector3i position = Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());            if (type == PistonValueType.PUSHING) {                extendPiston(session, position, 0.0f, 0.0f);            } else {                retractPiston(session, position, 1.0f, 1.0f);            }        } else if (packet.getValue() instanceof MobSpawnerValue) {            blockEventPacket.setEventType(1);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof EndGatewayValue) {            blockEventPacket.setEventType(1);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof GenericBlockValue && packet.getBlockId() == BlockStateValues.JAVA_BELL_ID) {            GenericBlockValue bellValue = (GenericBlockValue) packet.getValue();            Position position = packet.getPosition();            BlockEntityDataPacket blockEntityPacket = new BlockEntityDataPacket();            blockEntityPacket.setBlockPosition(Vector3i.from(position.getX(), position.getY(), position.getZ()));            NbtMapBuilder builder = NbtMap.builder();            builder.putInt(\"x\", position.getX());            builder.putInt(\"y\", position.getY());            builder.putInt(\"z\", position.getZ());            builder.putString(\"id\", \"Bell\");            int bedrockRingDirection;            switch (bellValue.getValue()) {                case 3:                     bedrockRingDirection = 0;                    break;                case 4:                     bedrockRingDirection = 1;                    break;                case 5:                     bedrockRingDirection = 3;                    break;                default:                     bedrockRingDirection = bellValue.getValue();            }            builder.putInt(\"Direction\", bedrockRingDirection);            builder.putByte(\"Ringing\", (byte) 1);            builder.putInt(\"Ticks\", 0);            blockEntityPacket.setData(builder.build());            session.sendUpstreamPacket(blockEntityPacket);        }    }    private void extendPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();        blockEntityDataPacket.setBlockPosition(position);        byte state = (byte) ((progress == 1.0f && lastProgress == 1.0f) ? 2 : 1);        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));        session.sendUpstreamPacket(blockEntityDataPacket);        if (lastProgress != 1.0f) {            session.getConnector().getGeneralThreadPool().schedule(() ->                            extendPiston(session, position, (progress >= 1.0f) ? 1.0f : progress + 0.5f, progress),                    20, TimeUnit.MILLISECONDS);        }    }    private void retractPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();        blockEntityDataPacket.setBlockPosition(position);        byte state = (byte) ((progress == 0.0f && lastProgress == 0.0f) ? 0 : 3);        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));        session.sendUpstreamPacket(blockEntityDataPacket);        if (lastProgress != 0.0f) {            session.getConnector().getGeneralThreadPool().schedule(() ->                            retractPiston(session, position, (progress <= 0.0f) ? 0.0f : progress - 0.5f, progress),                    20, TimeUnit.MILLISECONDS);        }    }    private NbtMap buildPistonTag(Vector3i position, float progress, float lastProgress, byte state) {        NbtMapBuilder builder = NbtMap.builder()                .putInt(\"x\", position.getX())                .putInt(\"y\", position.getY())                .putInt(\"z\", position.getZ())                .putFloat(\"Progress\", progress)                .putFloat(\"LastProgress\", lastProgress)                .putString(\"id\", \"PistonArm\")                .putByte(\"NewState\", state)                .putByte(\"State\", state);        return builder.build();    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;import com.github.steveice10.mc.protocol.data.game.world.block.value.*;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockValuePacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;import com.nukkitx.protocol.bedrock.packet.BlockEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.network.translators.world.block.entity.NoteblockBlockEntityTranslator;import java.util.concurrent.TimeUnit;@Translator(packet = ServerBlockValuePacket.class)public class JavaBlockValueTranslator extends PacketTranslator<ServerBlockValuePacket> {    @Override    public void translate(ServerBlockValuePacket packet, GeyserSession session) {        BlockEventPacket blockEventPacket = new BlockEventPacket();        blockEventPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(),                packet.getPosition().getY(), packet.getPosition().getZ()));        if (packet.getValue() instanceof ChestValue) {            ChestValue value = (ChestValue) packet.getValue() ;            blockEventPacket.setEventType(1);            blockEventPacket.setEventData(value.getViewers() > 0 ? 1 : 0);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof EndGatewayValue) {            blockEventPacket.setEventType(1);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof NoteBlockValue) {            NoteblockBlockEntityTranslator.translate(session, packet.getPosition());        } else if (packet.getValue() instanceof PistonValue) {            PistonValueType type = (PistonValueType) packet.getType();            Vector3i position = Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());            if (type == PistonValueType.PUSHING) {                extendPiston(session, position, 0.0f, 0.0f);            } else {                retractPiston(session, position, 1.0f, 1.0f);            }        } else if (packet.getValue() instanceof MobSpawnerValue) {            blockEventPacket.setEventType(1);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof EndGatewayValue) {            blockEventPacket.setEventType(1);            session.sendUpstreamPacket(blockEventPacket);        } else if (packet.getValue() instanceof GenericBlockValue && packet.getBlockId() == BlockStateValues.JAVA_BELL_ID) {            GenericBlockValue bellValue = (GenericBlockValue) packet.getValue();            Position position = packet.getPosition();            BlockEntityDataPacket blockEntityPacket = new BlockEntityDataPacket();            blockEntityPacket.setBlockPosition(Vector3i.from(position.getX(), position.getY(), position.getZ()));            NbtMapBuilder builder = NbtMap.builder();            builder.putInt(\"x\", position.getX());            builder.putInt(\"y\", position.getY());            builder.putInt(\"z\", position.getZ());            builder.putString(\"id\", \"Bell\");            int bedrockRingDirection;            switch (bellValue.getValue()) {                case 3:                     bedrockRingDirection = 0;                    break;                case 4:                     bedrockRingDirection = 1;                    break;                case 5:                     bedrockRingDirection = 3;                    break;                default:                     bedrockRingDirection = bellValue.getValue();            }            builder.putInt(\"Direction\", bedrockRingDirection);            builder.putByte(\"Ringing\", (byte) 1);            builder.putInt(\"Ticks\", 0);            blockEntityPacket.setData(builder.build());            session.sendUpstreamPacket(blockEntityPacket);        }    }    private void extendPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();        blockEntityDataPacket.setBlockPosition(position);        byte state = (byte) ((progress == 1.0f && lastProgress == 1.0f) ? 2 : 1);        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));        session.sendUpstreamPacket(blockEntityDataPacket);        if (lastProgress != 1.0f) {            session.getConnector().getGeneralThreadPool().schedule(() ->                            extendPiston(session, position, (progress >= 1.0f) ? 1.0f : progress + 0.5f, progress),                    20, TimeUnit.MILLISECONDS);        }    }    private void retractPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();        blockEntityDataPacket.setBlockPosition(position);        byte state = (byte) ((progress == 0.0f && lastProgress == 0.0f) ? 0 : 3);        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));        session.sendUpstreamPacket(blockEntityDataPacket);        if (lastProgress != 0.0f) {            session.getConnector().getGeneralThreadPool().schedule(() ->                            retractPiston(session, position, (progress <= 0.0f) ? 0.0f : progress - 0.5f, progress),                    20, TimeUnit.MILLISECONDS);        }    }    private NbtMap buildPistonTag(Vector3i position, float progress, float lastProgress, byte state) {        NbtMapBuilder builder = NbtMap.builder()                .putInt(\"x\", position.getX())                .putInt(\"y\", position.getY())                .putInt(\"z\", position.getZ())                .putFloat(\"Progress\", progress)                .putFloat(\"LastProgress\", lastProgress)                .putString(\"id\", \"PistonArm\")                .putByte(\"NewState\", state)                .putByte(\"State\", state);        return builder.build();    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.chunk.Column;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerChunkDataPacket;import com.nukkitx.nbt.NBTOutputStream;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtUtils;import com.nukkitx.network.VarInts;import com.nukkitx.protocol.bedrock.packet.LevelChunkPacket;import io.netty.buffer.ByteBuf;import io.netty.buffer.ByteBufAllocator;import io.netty.buffer.ByteBufOutputStream;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.chunk.ChunkSection;import org.geysermc.connector.network.translators.world.BiomeTranslator;import org.geysermc.connector.utils.ChunkUtils;import static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT;import static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT_OVERWORLD;@Translator(packet = ServerChunkDataPacket.class)public class JavaChunkDataTranslator extends PacketTranslator<ServerChunkDataPacket> {    private static final boolean NEW_BIOME_WRITE = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight();    @Override    public void translate(GeyserSession session, ServerChunkDataPacket packet) {        if (session.isSpawned()) {            ChunkUtils.updateChunkPosition(session, session.getPlayerEntity().getPosition().toInt());        }        session.getChunkCache().addToCache(packet.getColumn());        Column column = packet.getColumn();        int yOffset = session.getChunkCache().getChunkMinY();        GeyserConnector.getInstance().getGeneralThreadPool().execute(() -> {            try {                if (session.isClosed()) {                    return;                }                ChunkUtils.ChunkData chunkData = ChunkUtils.translateToBedrock(session, column, yOffset);                ChunkSection[] sections = chunkData.getSections();                int sectionCount = sections.length - 1;                while (sectionCount >= 0 && sections[sectionCount] == null) {                    sectionCount--;                }                sectionCount++;                int size = 0;                for (int i = 0; i < sectionCount; i++) {                    ChunkSection section = sections[i];                    size += (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).estimateNetworkSize();                }                if (NEW_BIOME_WRITE) {                    size += ChunkUtils.EMPTY_CHUNK_DATA.length;                 } else {                    size += 256;                 }                size += 1;                 size += 1;                 size += chunkData.getBlockEntities().length * 64;                 ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(size);                byte[] payload;                try {                    for (int i = 0; i < sectionCount; i++) {                        ChunkSection section = sections[i];                        (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).writeToNetwork(byteBuf);                    }                    if (NEW_BIOME_WRITE) {                        boolean overworld = session.getChunkCache().isExtendedHeight();                        int dimensionOffset = (overworld ? MINIMUM_ACCEPTED_HEIGHT_OVERWORLD : MINIMUM_ACCEPTED_HEIGHT) >> 4;                        for (int i = 0; i < sectionCount; i++) {                            int biomeYOffset = dimensionOffset + i;                            if (biomeYOffset < yOffset) {                                byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);                                continue;                            }                            BiomeTranslator.toNewBedrockBiome(session, column.getBiomeData(), i + (dimensionOffset - yOffset)).writeToNetwork(byteBuf);                        }                        int remainingEmptyBiomes = 32 - sectionCount;                        for (int i = 0; i < remainingEmptyBiomes; i++) {                            byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);                        }                    } else {                        byteBuf.writeBytes(BiomeTranslator.toBedrockBiome(session, column.getBiomeData()));                     }                    byteBuf.writeByte(0);                     VarInts.writeUnsignedInt(byteBuf, 0);                     NBTOutputStream nbtStream = NbtUtils.createNetworkWriter(new ByteBufOutputStream(byteBuf));                    for (NbtMap blockEntity : chunkData.getBlockEntities()) {                        nbtStream.writeTag(blockEntity);                    }                    byteBuf.readBytes(payload = new byte[byteBuf.readableBytes()]);                } finally {                    byteBuf.release();                 }                LevelChunkPacket levelChunkPacket = new LevelChunkPacket();                levelChunkPacket.setSubChunksLength(sectionCount);                levelChunkPacket.setCachingEnabled(false);                levelChunkPacket.setChunkX(column.getX());                levelChunkPacket.setChunkZ(column.getZ());                levelChunkPacket.setData(payload);                session.sendUpstreamPacket(levelChunkPacket);            } catch (Exception ex) {                ex.printStackTrace();            }        });    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.chunk.Column;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerChunkDataPacket;import com.nukkitx.nbt.NBTOutputStream;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtUtils;import com.nukkitx.network.VarInts;import com.nukkitx.protocol.bedrock.packet.LevelChunkPacket;import io.netty.buffer.ByteBuf;import io.netty.buffer.ByteBufAllocator;import io.netty.buffer.ByteBufOutputStream;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.chunk.ChunkSection;import org.geysermc.connector.network.translators.world.BiomeTranslator;import org.geysermc.connector.utils.ChunkUtils;import static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT;import static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT_OVERWORLD;@Translator(packet = ServerChunkDataPacket.class)public class JavaChunkDataTranslator extends PacketTranslator<ServerChunkDataPacket> {    private static final boolean NEW_BIOME_WRITE = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight();    @Override    public void translate(ServerChunkDataPacket packet, GeyserSession session) {        if (session.isSpawned()) {            ChunkUtils.updateChunkPosition(session, session.getPlayerEntity().getPosition().toInt());        }        session.getChunkCache().addToCache(packet.getColumn());        Column column = packet.getColumn();        int yOffset = session.getChunkCache().getChunkMinY();        GeyserConnector.getInstance().getGeneralThreadPool().execute(() -> {            try {                if (session.isClosed()) {                    return;                }                ChunkUtils.ChunkData chunkData = ChunkUtils.translateToBedrock(session, column, yOffset);                ChunkSection[] sections = chunkData.getSections();                int sectionCount = sections.length - 1;                while (sectionCount >= 0 && sections[sectionCount] == null) {                    sectionCount--;                }                sectionCount++;                int size = 0;                for (int i = 0; i < sectionCount; i++) {                    ChunkSection section = sections[i];                    size += (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).estimateNetworkSize();                }                if (NEW_BIOME_WRITE) {                    size += ChunkUtils.EMPTY_CHUNK_DATA.length;                 } else {                    size += 256;                 }                size += 1;                 size += 1;                 size += chunkData.getBlockEntities().length * 64;                 ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(size);                byte[] payload;                try {                    for (int i = 0; i < sectionCount; i++) {                        ChunkSection section = sections[i];                        (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).writeToNetwork(byteBuf);                    }                    if (NEW_BIOME_WRITE) {                        boolean overworld = session.getChunkCache().isExtendedHeight();                        int dimensionOffset = (overworld ? MINIMUM_ACCEPTED_HEIGHT_OVERWORLD : MINIMUM_ACCEPTED_HEIGHT) >> 4;                        for (int i = 0; i < sectionCount; i++) {                            int biomeYOffset = dimensionOffset + i;                            if (biomeYOffset < yOffset) {                                byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);                                continue;                            }                            BiomeTranslator.toNewBedrockBiome(session, column.getBiomeData(), i + (dimensionOffset - yOffset)).writeToNetwork(byteBuf);                        }                        int remainingEmptyBiomes = 32 - sectionCount;                        for (int i = 0; i < remainingEmptyBiomes; i++) {                            byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);                        }                    } else {                        byteBuf.writeBytes(BiomeTranslator.toBedrockBiome(session, column.getBiomeData()));                     }                    byteBuf.writeByte(0);                     VarInts.writeUnsignedInt(byteBuf, 0);                     NBTOutputStream nbtStream = NbtUtils.createNetworkWriter(new ByteBufOutputStream(byteBuf));                    for (NbtMap blockEntity : chunkData.getBlockEntities()) {                        nbtStream.writeTag(blockEntity);                    }                    byteBuf.readBytes(payload = new byte[byteBuf.readableBytes()]);                } finally {                    byteBuf.release();                 }                LevelChunkPacket levelChunkPacket = new LevelChunkPacket();                levelChunkPacket.setSubChunksLength(sectionCount);                levelChunkPacket.setCachingEnabled(false);                levelChunkPacket.setChunkX(column.getX());                levelChunkPacket.setChunkZ(column.getZ());                levelChunkPacket.setData(payload);                session.sendUpstreamPacket(levelChunkPacket);            } catch (Exception ex) {                ex.printStackTrace();            }        });    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.world.block.ExplodedBlockRecord;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerExplosionPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.utils.ChunkUtils;@Translator(packet = ServerExplosionPacket.class)public class JavaExplosionTranslator extends PacketTranslator<ServerExplosionPacket> {    @Override    public void translate(GeyserSession session, ServerExplosionPacket packet) {        for (ExplodedBlockRecord record : packet.getExploded()) {            Vector3f pos = Vector3f.from(packet.getX() + record.getX(), packet.getY() + record.getY(), packet.getZ() + record.getZ());            ChunkUtils.updateBlock(session, BlockStateValues.JAVA_AIR_ID, pos.toInt());        }        Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        LevelEventPacket levelEventPacket = new LevelEventPacket();        levelEventPacket.setType(packet.getRadius() >= 2.0f ? LevelEventType.PARTICLE_HUGE_EXPLODE : LevelEventType.PARTICLE_EXPLOSION);        levelEventPacket.setData(0);        levelEventPacket.setPosition(pos.toFloat());        session.sendUpstreamPacket(levelEventPacket);        LevelSoundEventPacket levelSoundEventPacket = new LevelSoundEventPacket();        levelSoundEventPacket.setRelativeVolumeDisabled(false);        levelSoundEventPacket.setBabySound(false);        levelSoundEventPacket.setExtraData(-1);        levelSoundEventPacket.setSound(SoundEvent.EXPLODE);        levelSoundEventPacket.setIdentifier(\":\");        levelSoundEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));        session.sendUpstreamPacket(levelSoundEventPacket);        if (packet.getPushX() > 0f || packet.getPushY() > 0f || packet.getPushZ() > 0f) {            SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();            motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());            motionPacket.setMotion(Vector3f.from(packet.getPushX(), packet.getPushY(), packet.getPushZ()));            session.sendUpstreamPacket(motionPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.world.block.ExplodedBlockRecord;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerExplosionPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.utils.ChunkUtils;@Translator(packet = ServerExplosionPacket.class)public class JavaExplosionTranslator extends PacketTranslator<ServerExplosionPacket> {    @Override    public void translate(ServerExplosionPacket packet, GeyserSession session) {        for (ExplodedBlockRecord record : packet.getExploded()) {            Vector3f pos = Vector3f.from(packet.getX() + record.getX(), packet.getY() + record.getY(), packet.getZ() + record.getZ());            ChunkUtils.updateBlock(session, BlockStateValues.JAVA_AIR_ID, pos.toInt());        }        Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());        LevelEventPacket levelEventPacket = new LevelEventPacket();        levelEventPacket.setType(packet.getRadius() >= 2.0f ? LevelEventType.PARTICLE_HUGE_EXPLODE : LevelEventType.PARTICLE_EXPLOSION);        levelEventPacket.setData(0);        levelEventPacket.setPosition(pos.toFloat());        session.sendUpstreamPacket(levelEventPacket);        LevelSoundEventPacket levelSoundEventPacket = new LevelSoundEventPacket();        levelSoundEventPacket.setRelativeVolumeDisabled(false);        levelSoundEventPacket.setBabySound(false);        levelSoundEventPacket.setExtraData(-1);        levelSoundEventPacket.setSound(SoundEvent.EXPLODE);        levelSoundEventPacket.setIdentifier(\":\");        levelSoundEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));        session.sendUpstreamPacket(levelSoundEventPacket);        if (packet.getPushX() > 0f || packet.getPushY() > 0f || packet.getPushZ() > 0f) {            SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();            motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());            motionPacket.setMotion(Vector3f.from(packet.getPushX(), packet.getPushY(), packet.getPushZ()));            session.sendUpstreamPacket(motionPacket);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.world.map.MapData;import com.github.steveice10.mc.protocol.data.game.world.map.MapIcon;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMapDataPacket;import com.nukkitx.protocol.bedrock.data.MapDecoration;import com.nukkitx.protocol.bedrock.data.MapTrackedObject;import com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.BedrockMapIcon;import org.geysermc.connector.utils.DimensionUtils;import org.geysermc.connector.utils.MapColor;@Translator(packet = ServerMapDataPacket.class)public class JavaMapDataTranslator extends PacketTranslator<ServerMapDataPacket> {    @Override    public void translate(GeyserSession session, ServerMapDataPacket packet) {        ClientboundMapItemDataPacket mapItemDataPacket = new ClientboundMapItemDataPacket();        boolean shouldStore = false;        mapItemDataPacket.setUniqueMapId(packet.getMapId());        mapItemDataPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));        mapItemDataPacket.setLocked(packet.isLocked());        mapItemDataPacket.setScale(packet.getScale());        MapData data = packet.getData();        if (data != null) {            mapItemDataPacket.setXOffset(data.getX());            mapItemDataPacket.setYOffset(data.getY());            mapItemDataPacket.setWidth(data.getColumns());            mapItemDataPacket.setHeight(data.getRows());            if (mapItemDataPacket.getWidth() == 128 && mapItemDataPacket.getHeight() == 128) {                shouldStore = true;            }            int[] colors = new int[data.getData().length];            int idx = 0;            for (byte colorId : data.getData()) {                colors[idx++] = MapColor.fromId(colorId & 0xFF).toABGR();            }            mapItemDataPacket.setColors(colors);        }        int id = 0;        for (MapIcon icon : packet.getIcons()) {            BedrockMapIcon bedrockMapIcon = BedrockMapIcon.fromType(icon.getIconType());            mapItemDataPacket.getTrackedObjects().add(new MapTrackedObject(id));            mapItemDataPacket.getDecorations().add(new MapDecoration(bedrockMapIcon.getIconID(), icon.getIconRotation(), icon.getCenterX(), icon.getCenterZ(), \"\", bedrockMapIcon.toARGB()));            id++;        }        if (shouldStore) {            session.getStoredMaps().put(mapItemDataPacket.getUniqueMapId(), mapItemDataPacket);        }        session.sendUpstreamPacket(mapItemDataPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.world.map.MapData;import com.github.steveice10.mc.protocol.data.game.world.map.MapIcon;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMapDataPacket;import com.nukkitx.protocol.bedrock.data.MapDecoration;import com.nukkitx.protocol.bedrock.data.MapTrackedObject;import com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.BedrockMapIcon;import org.geysermc.connector.utils.DimensionUtils;import org.geysermc.connector.utils.MapColor;@Translator(packet = ServerMapDataPacket.class)public class JavaMapDataTranslator extends PacketTranslator<ServerMapDataPacket> {    @Override    public void translate(ServerMapDataPacket packet, GeyserSession session) {        ClientboundMapItemDataPacket mapItemDataPacket = new ClientboundMapItemDataPacket();        boolean shouldStore = false;        mapItemDataPacket.setUniqueMapId(packet.getMapId());        mapItemDataPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));        mapItemDataPacket.setLocked(packet.isLocked());        mapItemDataPacket.setScale(packet.getScale());        MapData data = packet.getData();        if (data != null) {            mapItemDataPacket.setXOffset(data.getX());            mapItemDataPacket.setYOffset(data.getY());            mapItemDataPacket.setWidth(data.getColumns());            mapItemDataPacket.setHeight(data.getRows());            if (mapItemDataPacket.getWidth() == 128 && mapItemDataPacket.getHeight() == 128) {                shouldStore = true;            }            int[] colors = new int[data.getData().length];            int idx = 0;            for (byte colorId : data.getData()) {                colors[idx++] = MapColor.fromId(colorId & 0xFF).toABGR();            }            mapItemDataPacket.setColors(colors);        }        int id = 0;        for (MapIcon icon : packet.getIcons()) {            BedrockMapIcon bedrockMapIcon = BedrockMapIcon.fromType(icon.getIconType());            mapItemDataPacket.getTrackedObjects().add(new MapTrackedObject(id));            mapItemDataPacket.getDecorations().add(new MapDecoration(bedrockMapIcon.getIconID(), icon.getIconRotation(), icon.getCenterX(), icon.getCenterZ(), \"\", bedrockMapIcon.toARGB()));            id++;        }        if (shouldStore) {            session.getStoredMaps().put(mapItemDataPacket.getUniqueMapId(), mapItemDataPacket);        }        session.sendUpstreamPacket(mapItemDataPacket);    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.ChunkUtils;import com.github.steveice10.mc.protocol.data.game.world.block.BlockChangeRecord;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMultiBlockChangePacket;@Translator(packet = ServerMultiBlockChangePacket.class)public class JavaMultiBlockChangeTranslator extends PacketTranslator<ServerMultiBlockChangePacket> {    @Override    public void translate(GeyserSession session, ServerMultiBlockChangePacket packet) {        for (BlockChangeRecord record : packet.getRecords()) {            ChunkUtils.updateBlock(session, record.getBlock(), record.getPosition());        }    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.ChunkUtils;import com.github.steveice10.mc.protocol.data.game.world.block.BlockChangeRecord;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMultiBlockChangePacket;@Translator(packet = ServerMultiBlockChangePacket.class)public class JavaMultiBlockChangeTranslator extends PacketTranslator<ServerMultiBlockChangePacket> {    @Override    public void translate(ServerMultiBlockChangePacket packet, GeyserSession session) {        for (BlockChangeRecord record : packet.getRecords()) {            ChunkUtils.updateBlock(session, record.getBlock(), record.getPosition());        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.ClientRequest;import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.data.game.world.notify.EnterCreditsValue;import com.github.steveice10.mc.protocol.data.game.world.notify.RainStrengthValue;import com.github.steveice10.mc.protocol.data.game.world.notify.RespawnScreenValue;import com.github.steveice10.mc.protocol.data.game.world.notify.ThunderStrengthValue;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerNotifyClientPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.GameRuleData;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;import org.geysermc.connector.utils.LocaleUtils;@Translator(packet = ServerNotifyClientPacket.class)public class JavaNotifyClientTranslator extends PacketTranslator<ServerNotifyClientPacket> {    @Override    public void translate(GeyserSession session, ServerNotifyClientPacket packet) {        PlayerEntity entity = session.getPlayerEntity();        switch (packet.getNotification()) {            case START_RAIN:                LevelEventPacket startRainPacket = new LevelEventPacket();                startRainPacket.setType(LevelEventType.START_RAINING);                startRainPacket.setData(Integer.MAX_VALUE);                startRainPacket.setPosition(Vector3f.ZERO);                session.sendUpstreamPacket(startRainPacket);                session.setRaining(true);                break;            case STOP_RAIN:                LevelEventPacket stopRainPacket = new LevelEventPacket();                stopRainPacket.setType(LevelEventType.STOP_RAINING);                stopRainPacket.setData(0);                stopRainPacket.setPosition(Vector3f.ZERO);                session.sendUpstreamPacket(stopRainPacket);                session.setRaining(false);                break;            case RAIN_STRENGTH:                RainStrengthValue value = (RainStrengthValue) packet.getValue();                boolean isCurrentlyRaining = value.getStrength() > 0f;                if (isCurrentlyRaining != session.isRaining()) {                    LevelEventPacket changeRainPacket = new LevelEventPacket();                    changeRainPacket.setType(isCurrentlyRaining ? LevelEventType.START_RAINING : LevelEventType.STOP_RAINING);                    changeRainPacket.setData(Integer.MAX_VALUE);                     changeRainPacket.setPosition(Vector3f.ZERO);                    session.sendUpstreamPacket(changeRainPacket);                    session.setRaining(isCurrentlyRaining);                }                break;            case THUNDER_STRENGTH:                ThunderStrengthValue thunderValue = (ThunderStrengthValue) packet.getValue();                boolean isCurrentlyThundering = thunderValue.getStrength() > 0f;                if (isCurrentlyThundering != session.isThunder()) {                    LevelEventPacket changeThunderPacket = new LevelEventPacket();                    changeThunderPacket.setType(isCurrentlyThundering ? LevelEventType.START_THUNDERSTORM : LevelEventType.STOP_THUNDERSTORM);                    changeThunderPacket.setData(Integer.MAX_VALUE);                    changeThunderPacket.setPosition(Vector3f.ZERO);                    session.sendUpstreamPacket(changeThunderPacket);                    session.setThunder(isCurrentlyThundering);                }                break;            case CHANGE_GAMEMODE:                GameMode gameMode = (GameMode) packet.getValue();                SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();                playerGameTypePacket.setGamemode(gameMode.ordinal());                session.sendUpstreamPacket(playerGameTypePacket);                session.setGameMode(gameMode);                session.sendAdventureSettings();                if (session.getPlayerEntity().isOnGround() && gameMode == GameMode.SPECTATOR) {                    MovePlayerPacket movePlayerPacket = new MovePlayerPacket();                    movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());                    movePlayerPacket.setPosition(entity.getPosition());                    movePlayerPacket.setRotation(entity.getBedrockRotation());                    movePlayerPacket.setOnGround(false);                    movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);                    movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.UNKNOWN);                    session.sendUpstreamPacket(movePlayerPacket);                }                PlayerInventoryTranslator.updateCraftingGrid(session, session.getPlayerInventory());                break;            case ENTER_CREDITS:                switch ((EnterCreditsValue) packet.getValue()) {                    case SEEN_BEFORE:                        ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);                        session.sendDownstreamPacket(javaRespawnPacket);                        break;                    case FIRST_TIME:                        ShowCreditsPacket showCreditsPacket = new ShowCreditsPacket();                        showCreditsPacket.setStatus(ShowCreditsPacket.Status.START_CREDITS);                        showCreditsPacket.setRuntimeEntityId(entity.getGeyserId());                        session.sendUpstreamPacket(showCreditsPacket);                        break;                }                break;            case AFFECTED_BY_ELDER_GUARDIAN:                EntityEventPacket eventPacket = new EntityEventPacket();                eventPacket.setType(EntityEventType.ELDER_GUARDIAN_CURSE);                eventPacket.setData(0);                eventPacket.setRuntimeEntityId(entity.getGeyserId());                session.sendUpstreamPacket(eventPacket);                break;            case ENABLE_RESPAWN_SCREEN:                GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();                gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\",                        packet.getValue() == RespawnScreenValue.IMMEDIATE_RESPAWN));                session.sendUpstreamPacket(gamerulePacket);                break;            case INVALID_BED:                session.sendMessage(LocaleUtils.getLocaleString(\"block.minecraft.spawn.not_valid\",                        session.getLocale()));                break;            case ARROW_HIT_PLAYER:                PlaySoundPacket arrowSoundPacket = new PlaySoundPacket();                arrowSoundPacket.setSound(\"random.orb\");                arrowSoundPacket.setPitch(0.5f);                arrowSoundPacket.setVolume(0.5f);                arrowSoundPacket.setPosition(entity.getPosition());                session.sendUpstreamPacket(arrowSoundPacket);                break;            default:                break;        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.ClientRequest;import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.data.game.world.notify.EnterCreditsValue;import com.github.steveice10.mc.protocol.data.game.world.notify.RainStrengthValue;import com.github.steveice10.mc.protocol.data.game.world.notify.RespawnScreenValue;import com.github.steveice10.mc.protocol.data.game.world.notify.ThunderStrengthValue;import com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerNotifyClientPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.GameRuleData;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.entity.EntityEventType;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.entity.player.PlayerEntity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;import org.geysermc.connector.utils.LocaleUtils;@Translator(packet = ServerNotifyClientPacket.class)public class JavaNotifyClientTranslator extends PacketTranslator<ServerNotifyClientPacket> {    @Override    public void translate(ServerNotifyClientPacket packet, GeyserSession session) {        PlayerEntity entity = session.getPlayerEntity();        switch (packet.getNotification()) {            case START_RAIN:                LevelEventPacket startRainPacket = new LevelEventPacket();                startRainPacket.setType(LevelEventType.START_RAINING);                startRainPacket.setData(Integer.MAX_VALUE);                startRainPacket.setPosition(Vector3f.ZERO);                session.sendUpstreamPacket(startRainPacket);                session.setRaining(true);                break;            case STOP_RAIN:                LevelEventPacket stopRainPacket = new LevelEventPacket();                stopRainPacket.setType(LevelEventType.STOP_RAINING);                stopRainPacket.setData(0);                stopRainPacket.setPosition(Vector3f.ZERO);                session.sendUpstreamPacket(stopRainPacket);                session.setRaining(false);                break;            case RAIN_STRENGTH:                RainStrengthValue value = (RainStrengthValue) packet.getValue();                boolean isCurrentlyRaining = value.getStrength() > 0f;                if (isCurrentlyRaining != session.isRaining()) {                    LevelEventPacket changeRainPacket = new LevelEventPacket();                    changeRainPacket.setType(isCurrentlyRaining ? LevelEventType.START_RAINING : LevelEventType.STOP_RAINING);                    changeRainPacket.setData(Integer.MAX_VALUE);                     changeRainPacket.setPosition(Vector3f.ZERO);                    session.sendUpstreamPacket(changeRainPacket);                    session.setRaining(isCurrentlyRaining);                }                break;            case THUNDER_STRENGTH:                ThunderStrengthValue thunderValue = (ThunderStrengthValue) packet.getValue();                boolean isCurrentlyThundering = thunderValue.getStrength() > 0f;                if (isCurrentlyThundering != session.isThunder()) {                    LevelEventPacket changeThunderPacket = new LevelEventPacket();                    changeThunderPacket.setType(isCurrentlyThundering ? LevelEventType.START_THUNDERSTORM : LevelEventType.STOP_THUNDERSTORM);                    changeThunderPacket.setData(Integer.MAX_VALUE);                    changeThunderPacket.setPosition(Vector3f.ZERO);                    session.sendUpstreamPacket(changeThunderPacket);                    session.setThunder(isCurrentlyThundering);                }                break;            case CHANGE_GAMEMODE:                GameMode gameMode = (GameMode) packet.getValue();                SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();                playerGameTypePacket.setGamemode(gameMode.ordinal());                session.sendUpstreamPacket(playerGameTypePacket);                session.setGameMode(gameMode);                session.sendAdventureSettings();                if (session.getPlayerEntity().isOnGround() && gameMode == GameMode.SPECTATOR) {                    MovePlayerPacket movePlayerPacket = new MovePlayerPacket();                    movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());                    movePlayerPacket.setPosition(entity.getPosition());                    movePlayerPacket.setRotation(entity.getBedrockRotation());                    movePlayerPacket.setOnGround(false);                    movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);                    movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.UNKNOWN);                    session.sendUpstreamPacket(movePlayerPacket);                }                PlayerInventoryTranslator.updateCraftingGrid(session, session.getPlayerInventory());                break;            case ENTER_CREDITS:                switch ((EnterCreditsValue) packet.getValue()) {                    case SEEN_BEFORE:                        ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);                        session.sendDownstreamPacket(javaRespawnPacket);                        break;                    case FIRST_TIME:                        ShowCreditsPacket showCreditsPacket = new ShowCreditsPacket();                        showCreditsPacket.setStatus(ShowCreditsPacket.Status.START_CREDITS);                        showCreditsPacket.setRuntimeEntityId(entity.getGeyserId());                        session.sendUpstreamPacket(showCreditsPacket);                        break;                }                break;            case AFFECTED_BY_ELDER_GUARDIAN:                EntityEventPacket eventPacket = new EntityEventPacket();                eventPacket.setType(EntityEventType.ELDER_GUARDIAN_CURSE);                eventPacket.setData(0);                eventPacket.setRuntimeEntityId(entity.getGeyserId());                session.sendUpstreamPacket(eventPacket);                break;            case ENABLE_RESPAWN_SCREEN:                GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();                gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\",                        packet.getValue() == RespawnScreenValue.IMMEDIATE_RESPAWN));                session.sendUpstreamPacket(gamerulePacket);                break;            case INVALID_BED:                session.sendMessage(LocaleUtils.getLocaleString(\"block.minecraft.spawn.not_valid\",                        session.getLocale()));                break;            case ARROW_HIT_PLAYER:                PlaySoundPacket arrowSoundPacket = new PlaySoundPacket();                arrowSoundPacket.setSound(\"random.orb\");                arrowSoundPacket.setPitch(0.5f);                arrowSoundPacket.setVolume(0.5f);                arrowSoundPacket.setPosition(entity.getPosition());                session.sendUpstreamPacket(arrowSoundPacket);                break;            default:                break;        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayBuiltinSoundPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.utils.SoundUtils;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.SoundMapping;@Translator(packet = ServerPlayBuiltinSoundPacket.class)public class JavaPlayBuiltinSoundTranslator extends PacketTranslator<ServerPlayBuiltinSoundPacket> {    @Override    public void translate(GeyserSession session, ServerPlayBuiltinSoundPacket packet) {        String packetSound = packet.getSound().getName();        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound);        if (soundMapping == null) {            session.getConnector().getLogger().debug(\"[Builtin] Sound mapping \" + packetSound + \" not found - \" + packet.toString());            return;        }        if (soundMapping.isLevelEvent()) {            LevelEventPacket levelEventPacket = new LevelEventPacket();            levelEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));            levelEventPacket.setData(0);            levelEventPacket.setType(LevelEventType.valueOf(soundMapping.getBedrock()));            session.sendUpstreamPacket(levelEventPacket);            return;        }        LevelSoundEventPacket soundPacket = new LevelSoundEventPacket();        SoundEvent sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());        if (sound == null) {            sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());        }        if (sound == null) {            sound = SoundUtils.toSoundEvent(packetSound);        }        if (sound == null) {            session.getConnector().getLogger().debug(\"[Builtin] Sound for original \" + packetSound + \" to mappings \" + soundPacket                            + \" was not a playable level sound, or has yet to be mapped to an enum in \"                            + \"NukkitX SoundEvent \");            return;        }        soundPacket.setSound(sound);        soundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));        soundPacket.setIdentifier(soundMapping.getIdentifier());        if (sound == SoundEvent.NOTE) {            soundPacket.setExtraData(soundMapping.getExtraData() + (int)(Math.round((Math.log10(packet.getPitch()) / Math.log10(2)) * 12)) + 12);        } else if (sound == SoundEvent.PLACE && soundMapping.getExtraData() == -1) {            if (!soundMapping.getIdentifier().equals(\":\")) {                soundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(                        BlockRegistries.JAVA_IDENTIFIERS.getOrDefault(soundMapping.getIdentifier(), BlockStateValues.JAVA_AIR_ID)));            } else {                session.getConnector().getLogger().debug(\"PLACE sound mapping identifier was invalid! Please report: \" + packet.toString());            }            soundPacket.setIdentifier(\":\");        } else {            soundPacket.setExtraData(soundMapping.getExtraData());        }        soundPacket.setBabySound(false);         soundPacket.setRelativeVolumeDisabled(false);        session.sendUpstreamPacket(soundPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayBuiltinSoundPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.registry.BlockRegistries;import org.geysermc.connector.utils.SoundUtils;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.SoundMapping;@Translator(packet = ServerPlayBuiltinSoundPacket.class)public class JavaPlayBuiltinSoundTranslator extends PacketTranslator<ServerPlayBuiltinSoundPacket> {    @Override    public void translate(ServerPlayBuiltinSoundPacket packet, GeyserSession session) {        String packetSound = packet.getSound().getName();        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound);        if (soundMapping == null) {            session.getConnector().getLogger().debug(\"[Builtin] Sound mapping \" + packetSound + \" not found - \" + packet.toString());            return;        }        if (soundMapping.isLevelEvent()) {            LevelEventPacket levelEventPacket = new LevelEventPacket();            levelEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));            levelEventPacket.setData(0);            levelEventPacket.setType(LevelEventType.valueOf(soundMapping.getBedrock()));            session.sendUpstreamPacket(levelEventPacket);            return;        }        LevelSoundEventPacket soundPacket = new LevelSoundEventPacket();        SoundEvent sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());        if (sound == null) {            sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());        }        if (sound == null) {            sound = SoundUtils.toSoundEvent(packetSound);        }        if (sound == null) {            session.getConnector().getLogger().debug(\"[Builtin] Sound for original \" + packetSound + \" to mappings \" + soundPacket                            + \" was not a playable level sound, or has yet to be mapped to an enum in \"                            + \"NukkitX SoundEvent \");            return;        }        soundPacket.setSound(sound);        soundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));        soundPacket.setIdentifier(soundMapping.getIdentifier());        if (sound == SoundEvent.NOTE) {            soundPacket.setExtraData(soundMapping.getExtraData() + (int)(Math.round((Math.log10(packet.getPitch()) / Math.log10(2)) * 12)) + 12);        } else if (sound == SoundEvent.PLACE && soundMapping.getExtraData() == -1) {            if (!soundMapping.getIdentifier().equals(\":\")) {                soundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(                        BlockRegistries.JAVA_IDENTIFIERS.getOrDefault(soundMapping.getIdentifier(), BlockStateValues.JAVA_AIR_ID)));            } else {                session.getConnector().getLogger().debug(\"PLACE sound mapping identifier was invalid! Please report: \" + packet.toString());            }            soundPacket.setIdentifier(\":\");        } else {            soundPacket.setExtraData(soundMapping.getExtraData());        }        soundPacket.setBabySound(false);         soundPacket.setRelativeVolumeDisabled(false);        session.sendUpstreamPacket(soundPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.world.effect.*;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayEffectPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import com.nukkitx.protocol.bedrock.packet.TextPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.effect.Effect;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.utils.LocaleUtils;import java.util.Collections;import java.util.Locale;@Translator(packet = ServerPlayEffectPacket.class)public class JavaPlayEffectTranslator extends PacketTranslator<ServerPlayEffectPacket> {    @Override    public void translate(GeyserSession session, ServerPlayEffectPacket packet) {        if (packet.getEffect() == SoundEffect.RECORD) {            RecordEffectData recordEffectData = (RecordEffectData) packet.getData();            SoundEvent soundEvent = Registries.RECORDS.getOrDefault(recordEffectData.getRecordId(), SoundEvent.STOP_RECORD);            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);            LevelSoundEventPacket levelSoundEvent = new LevelSoundEventPacket();            levelSoundEvent.setIdentifier(\"\");            levelSoundEvent.setSound(soundEvent);            levelSoundEvent.setPosition(pos);            levelSoundEvent.setRelativeVolumeDisabled(packet.isBroadcast());            levelSoundEvent.setExtraData(-1);            levelSoundEvent.setBabySound(false);            session.sendUpstreamPacket(levelSoundEvent);            if (soundEvent != SoundEvent.STOP_RECORD) {                TextPacket textPacket = new TextPacket();                textPacket.setType(TextPacket.Type.JUKEBOX_POPUP);                textPacket.setNeedsTranslation(true);                textPacket.setXuid(\"\");                textPacket.setPlatformChatId(\"\");                textPacket.setSourceName(null);                textPacket.setMessage(\"record.nowPlaying\");                String recordString = \"%item.\" + soundEvent.name().toLowerCase(Locale.ROOT) + \".desc\";                textPacket.setParameters(Collections.singletonList(LocaleUtils.getLocaleString(recordString, session.getLocale())));                session.sendUpstreamPacket(textPacket);            }            return;        }        if (packet.getEffect() instanceof SoundEffect) {            SoundEffect soundEffect = (SoundEffect) packet.getEffect();            Effect geyserEffect = Registries.SOUND_EFFECTS.get(soundEffect);            if (geyserEffect != null) {                geyserEffect.handleEffectPacket(session, packet);                return;            }            GeyserConnector.getInstance().getLogger().debug(\"Unhandled sound effect: \" + soundEffect.name());        } else if (packet.getEffect() instanceof ParticleEffect) {            ParticleEffect particleEffect = (ParticleEffect) packet.getEffect();            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);            LevelEventPacket effectPacket = new LevelEventPacket();            effectPacket.setPosition(pos);            effectPacket.setData(0);            switch (particleEffect) {                case COMPOSTER: {                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);                    ComposterEffectData composterEffectData = (ComposterEffectData) packet.getData();                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    switch (composterEffectData) {                        case FILL:                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL);                            break;                        case FILL_SUCCESS:                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL_LAYER);                            break;                    }                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BLOCK_LAVA_EXTINGUISH: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);                    effectPacket.setPosition(pos.add(-0.5f, 0.7f, -0.5f));                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BLOCK_REDSTONE_TORCH_BURNOUT: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);                    effectPacket.setPosition(pos.add(-0.5f, 0, -0.5f));                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BLOCK_END_PORTAL_FRAME_FILL: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);                    effectPacket.setPosition(pos.add(-0.5f, 0.3125f, -0.5f));                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.BLOCK_END_PORTAL_FRAME_FILL);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case SMOKE: {                    effectPacket.setType(LevelEventType.PARTICLE_SHOOT);                    SmokeEffectData smokeEffectData = (SmokeEffectData) packet.getData();                    int data = 0;                    switch (smokeEffectData) {                        case DOWN:                            data = 4;                            pos = pos.add(0, -0.9f, 0);                            break;                        case UP:                            data = 4;                            pos = pos.add(0, 0.5f, 0);                            break;                        case NORTH:                            data = 1;                            pos = pos.add(0, -0.2f, -0.7f);                            break;                        case SOUTH:                            data = 7;                            pos = pos.add(0, -0.2f, 0.7f);                            break;                        case WEST:                            data = 3;                            pos = pos.add(-0.7f, -0.2f, 0);                            break;                        case EAST:                            data = 5;                            pos = pos.add(0.7f, -0.2f, 0);                            break;                    }                    effectPacket.setPosition(pos);                    effectPacket.setData(data);                    break;                }                case BREAK_BLOCK: {                    effectPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);                    BreakBlockEffectData breakBlockEffectData = (BreakBlockEffectData) packet.getData();                    effectPacket.setData(session.getBlockMappings().getBedrockBlockId(breakBlockEffectData.getBlockState()));                    break;                }                case BREAK_SPLASH_POTION: {                    effectPacket.setType(LevelEventType.PARTICLE_POTION_SPLASH);                    effectPacket.setPosition(pos.add(0, -0.5f, 0));                    BreakPotionEffectData splashPotionData = (BreakPotionEffectData) packet.getData();                    effectPacket.setData(splashPotionData.getPotionId());                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.GLASS);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BREAK_EYE_OF_ENDER: {                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH);                    break;                }                case MOB_SPAWN: {                    effectPacket.setType(LevelEventType.PARTICLE_MOB_BLOCK_SPAWN);                     break;                }                case BONEMEAL_GROW_WITH_SOUND:                 case BONEMEAL_GROW: {                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);                    BonemealGrowEffectData growEffectData = (BonemealGrowEffectData) packet.getData();                    effectPacket.setData(growEffectData.getParticleCount());                    break;                }                case ENDERDRAGON_FIREBALL_EXPLODE: {                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH);                     DragonFireballEffectData fireballEffectData = (DragonFireballEffectData) packet.getData();                    if (fireballEffectData == DragonFireballEffectData.HAS_SOUND) {                        LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                        soundEventPacket.setSound(SoundEvent.EXPLODE);                        soundEventPacket.setPosition(pos);                        soundEventPacket.setIdentifier(\"\");                        soundEventPacket.setExtraData(-1);                        soundEventPacket.setBabySound(false);                        soundEventPacket.setRelativeVolumeDisabled(false);                        session.sendUpstreamPacket(soundEventPacket);                    }                    break;                }                case EXPLOSION: {                    effectPacket.setType(LevelEventType.PARTICLE_GENERIC_SPAWN);                    effectPacket.setData(61);                    break;                }                case EVAPORATE: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE_WATER);                    effectPacket.setPosition(pos.add(-0.5f, 0.5f, -0.5f));                    break;                }                case END_GATEWAY_SPAWN: {                    effectPacket.setType(LevelEventType.PARTICLE_EXPLOSION);                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.EXPLODE);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case DRIPSTONE_DRIP: {                    effectPacket.setType(LevelEventType.PARTICLE_DRIPSTONE_DRIP);                    break;                }                case ELECTRIC_SPARK: {                    effectPacket.setType(LevelEventType.PARTICLE_ELECTRIC_SPARK);                    break;                }                case WAX_ON: {                    effectPacket.setType(LevelEventType.PARTICLE_WAX_ON);                    break;                }                case WAX_OFF: {                    effectPacket.setType(LevelEventType.PARTICLE_WAX_OFF);                    break;                }                case SCRAPE: {                    effectPacket.setType(LevelEventType.PARTICLE_SCRAPE);                    break;                }                default: {                    GeyserConnector.getInstance().getLogger().debug(\"Unhandled particle effect: \" + particleEffect.name());                    return;                }            }            session.sendUpstreamPacket(effectPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.world.effect.*;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayEffectPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.SoundEvent;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;import com.nukkitx.protocol.bedrock.packet.TextPacket;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.effect.Effect;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.utils.LocaleUtils;import java.util.Collections;import java.util.Locale;@Translator(packet = ServerPlayEffectPacket.class)public class JavaPlayEffectTranslator extends PacketTranslator<ServerPlayEffectPacket> {    @Override    public void translate(ServerPlayEffectPacket packet, GeyserSession session) {        if (packet.getEffect() == SoundEffect.RECORD) {            RecordEffectData recordEffectData = (RecordEffectData) packet.getData();            SoundEvent soundEvent = Registries.RECORDS.getOrDefault(recordEffectData.getRecordId(), SoundEvent.STOP_RECORD);            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);            LevelSoundEventPacket levelSoundEvent = new LevelSoundEventPacket();            levelSoundEvent.setIdentifier(\"\");            levelSoundEvent.setSound(soundEvent);            levelSoundEvent.setPosition(pos);            levelSoundEvent.setRelativeVolumeDisabled(packet.isBroadcast());            levelSoundEvent.setExtraData(-1);            levelSoundEvent.setBabySound(false);            session.sendUpstreamPacket(levelSoundEvent);            if (soundEvent != SoundEvent.STOP_RECORD) {                TextPacket textPacket = new TextPacket();                textPacket.setType(TextPacket.Type.JUKEBOX_POPUP);                textPacket.setNeedsTranslation(true);                textPacket.setXuid(\"\");                textPacket.setPlatformChatId(\"\");                textPacket.setSourceName(null);                textPacket.setMessage(\"record.nowPlaying\");                String recordString = \"%item.\" + soundEvent.name().toLowerCase(Locale.ROOT) + \".desc\";                textPacket.setParameters(Collections.singletonList(LocaleUtils.getLocaleString(recordString, session.getLocale())));                session.sendUpstreamPacket(textPacket);            }            return;        }        if (packet.getEffect() instanceof SoundEffect) {            SoundEffect soundEffect = (SoundEffect) packet.getEffect();            Effect geyserEffect = Registries.SOUND_EFFECTS.get(soundEffect);            if (geyserEffect != null) {                geyserEffect.handleEffectPacket(session, packet);                return;            }            GeyserConnector.getInstance().getLogger().debug(\"Unhandled sound effect: \" + soundEffect.name());        } else if (packet.getEffect() instanceof ParticleEffect) {            ParticleEffect particleEffect = (ParticleEffect) packet.getEffect();            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);            LevelEventPacket effectPacket = new LevelEventPacket();            effectPacket.setPosition(pos);            effectPacket.setData(0);            switch (particleEffect) {                case COMPOSTER: {                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);                    ComposterEffectData composterEffectData = (ComposterEffectData) packet.getData();                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    switch (composterEffectData) {                        case FILL:                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL);                            break;                        case FILL_SUCCESS:                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL_LAYER);                            break;                    }                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BLOCK_LAVA_EXTINGUISH: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);                    effectPacket.setPosition(pos.add(-0.5f, 0.7f, -0.5f));                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BLOCK_REDSTONE_TORCH_BURNOUT: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);                    effectPacket.setPosition(pos.add(-0.5f, 0, -0.5f));                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BLOCK_END_PORTAL_FRAME_FILL: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);                    effectPacket.setPosition(pos.add(-0.5f, 0.3125f, -0.5f));                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.BLOCK_END_PORTAL_FRAME_FILL);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case SMOKE: {                    effectPacket.setType(LevelEventType.PARTICLE_SHOOT);                    SmokeEffectData smokeEffectData = (SmokeEffectData) packet.getData();                    int data = 0;                    switch (smokeEffectData) {                        case DOWN:                            data = 4;                            pos = pos.add(0, -0.9f, 0);                            break;                        case UP:                            data = 4;                            pos = pos.add(0, 0.5f, 0);                            break;                        case NORTH:                            data = 1;                            pos = pos.add(0, -0.2f, -0.7f);                            break;                        case SOUTH:                            data = 7;                            pos = pos.add(0, -0.2f, 0.7f);                            break;                        case WEST:                            data = 3;                            pos = pos.add(-0.7f, -0.2f, 0);                            break;                        case EAST:                            data = 5;                            pos = pos.add(0.7f, -0.2f, 0);                            break;                    }                    effectPacket.setPosition(pos);                    effectPacket.setData(data);                    break;                }                case BREAK_BLOCK: {                    effectPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);                    BreakBlockEffectData breakBlockEffectData = (BreakBlockEffectData) packet.getData();                    effectPacket.setData(session.getBlockMappings().getBedrockBlockId(breakBlockEffectData.getBlockState()));                    break;                }                case BREAK_SPLASH_POTION: {                    effectPacket.setType(LevelEventType.PARTICLE_POTION_SPLASH);                    effectPacket.setPosition(pos.add(0, -0.5f, 0));                    BreakPotionEffectData splashPotionData = (BreakPotionEffectData) packet.getData();                    effectPacket.setData(splashPotionData.getPotionId());                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.GLASS);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case BREAK_EYE_OF_ENDER: {                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH);                    break;                }                case MOB_SPAWN: {                    effectPacket.setType(LevelEventType.PARTICLE_MOB_BLOCK_SPAWN);                     break;                }                case BONEMEAL_GROW_WITH_SOUND:                 case BONEMEAL_GROW: {                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);                    BonemealGrowEffectData growEffectData = (BonemealGrowEffectData) packet.getData();                    effectPacket.setData(growEffectData.getParticleCount());                    break;                }                case ENDERDRAGON_FIREBALL_EXPLODE: {                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH);                     DragonFireballEffectData fireballEffectData = (DragonFireballEffectData) packet.getData();                    if (fireballEffectData == DragonFireballEffectData.HAS_SOUND) {                        LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                        soundEventPacket.setSound(SoundEvent.EXPLODE);                        soundEventPacket.setPosition(pos);                        soundEventPacket.setIdentifier(\"\");                        soundEventPacket.setExtraData(-1);                        soundEventPacket.setBabySound(false);                        soundEventPacket.setRelativeVolumeDisabled(false);                        session.sendUpstreamPacket(soundEventPacket);                    }                    break;                }                case EXPLOSION: {                    effectPacket.setType(LevelEventType.PARTICLE_GENERIC_SPAWN);                    effectPacket.setData(61);                    break;                }                case EVAPORATE: {                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE_WATER);                    effectPacket.setPosition(pos.add(-0.5f, 0.5f, -0.5f));                    break;                }                case END_GATEWAY_SPAWN: {                    effectPacket.setType(LevelEventType.PARTICLE_EXPLOSION);                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();                    soundEventPacket.setSound(SoundEvent.EXPLODE);                    soundEventPacket.setPosition(pos);                    soundEventPacket.setIdentifier(\"\");                    soundEventPacket.setExtraData(-1);                    soundEventPacket.setBabySound(false);                    soundEventPacket.setRelativeVolumeDisabled(false);                    session.sendUpstreamPacket(soundEventPacket);                    break;                }                case DRIPSTONE_DRIP: {                    effectPacket.setType(LevelEventType.PARTICLE_DRIPSTONE_DRIP);                    break;                }                case ELECTRIC_SPARK: {                    effectPacket.setType(LevelEventType.PARTICLE_ELECTRIC_SPARK);                    break;                }                case WAX_ON: {                    effectPacket.setType(LevelEventType.PARTICLE_WAX_ON);                    break;                }                case WAX_OFF: {                    effectPacket.setType(LevelEventType.PARTICLE_WAX_OFF);                    break;                }                case SCRAPE: {                    effectPacket.setType(LevelEventType.PARTICLE_SCRAPE);                    break;                }                default: {                    GeyserConnector.getInstance().getLogger().debug(\"Unhandled particle effect: \" + particleEffect.name());                    return;                }            }            session.sendUpstreamPacket(effectPacket);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;import com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlaySoundPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.SoundMapping;@Translator(packet = ServerPlaySoundPacket.class)public class JavaPlaySoundTranslator extends PacketTranslator<ServerPlaySoundPacket> {    @Override    public void translate(GeyserSession session, ServerPlaySoundPacket packet) {        String packetSound;        if (packet.getSound() instanceof BuiltinSound) {            packetSound = ((BuiltinSound) packet.getSound()).getName();        } else if (packet.getSound() instanceof CustomSound) {            packetSound = ((CustomSound) packet.getSound()).getName();        } else {            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());            return;        }        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));        String playsound;        if (soundMapping == null || soundMapping.getPlaysound() == null) {            session.getConnector().getLogger()                    .debug(\"[PlaySound] Defaulting to sound server gave us for \" + packet.toString());            playsound = packetSound.replace(\"minecraft:\", \"\");        } else {            playsound = soundMapping.getPlaysound();        }        PlaySoundPacket playSoundPacket = new PlaySoundPacket();        playSoundPacket.setSound(playsound);        playSoundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));        playSoundPacket.setVolume(packet.getVolume());        playSoundPacket.setPitch(packet.getPitch());        session.sendUpstreamPacket(playSoundPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;import com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlaySoundPacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.packet.*;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.SoundMapping;@Translator(packet = ServerPlaySoundPacket.class)public class JavaPlaySoundTranslator extends PacketTranslator<ServerPlaySoundPacket> {    @Override    public void translate(ServerPlaySoundPacket packet, GeyserSession session) {        String packetSound;        if (packet.getSound() instanceof BuiltinSound) {            packetSound = ((BuiltinSound) packet.getSound()).getName();        } else if (packet.getSound() instanceof CustomSound) {            packetSound = ((CustomSound) packet.getSound()).getName();        } else {            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());            return;        }        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));        String playsound;        if (soundMapping == null || soundMapping.getPlaysound() == null) {            session.getConnector().getLogger()                    .debug(\"[PlaySound] Defaulting to sound server gave us for \" + packet.toString());            playsound = packetSound.replace(\"minecraft:\", \"\");        } else {            playsound = soundMapping.getPlaysound();        }        PlaySoundPacket playSoundPacket = new PlaySoundPacket();        playSoundPacket.setSound(playsound);        playSoundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));        playSoundPacket.setVolume(packet.getVolume());        playSoundPacket.setPitch(packet.getPitch());        session.sendUpstreamPacket(playSoundPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.world.particle.*;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnParticlePacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.BedrockPacket;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.ParticleMapping;import org.geysermc.connector.utils.DimensionUtils;import java.util.Random;import java.util.concurrent.ThreadLocalRandom;import java.util.function.Function;@Translator(packet = ServerSpawnParticlePacket.class)public class JavaSpawnParticleTranslator extends PacketTranslator<ServerSpawnParticlePacket> {    @Override    public void translate(GeyserSession session, ServerSpawnParticlePacket packet) {        Function<Vector3f, BedrockPacket> particleCreateFunction = createParticle(session, packet.getParticle());        if (particleCreateFunction != null) {            if (packet.getAmount() == 0) {                Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());                session.sendUpstreamPacket(particleCreateFunction.apply(position));            } else {                Random random = ThreadLocalRandom.current();                for (int i = 0; i < packet.getAmount(); i++) {                    double offsetX = random.nextGaussian() * (double) packet.getOffsetX();                    double offsetY = random.nextGaussian() * (double) packet.getOffsetY();                    double offsetZ = random.nextGaussian() * (double) packet.getOffsetZ();                    Vector3f position = Vector3f.from(packet.getX() + offsetX, packet.getY() + offsetY, packet.getZ() + offsetZ);                    session.sendUpstreamPacket(particleCreateFunction.apply(position));                }            }        } else {            session.getConnector().getLogger().debug(\"Unhandled particle packet: \" + packet);        }    }    private Function<Vector3f, BedrockPacket> createParticle(GeyserSession session, Particle particle) {        switch (particle.getType()) {            case BLOCK: {                int blockState = session.getBlockMappings().getBedrockBlockId(((BlockParticleData) particle.getData()).getBlockState());                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_CRACK_BLOCK);                    packet.setPosition(position);                    packet.setData(blockState);                    return packet;                };            }            case FALLING_DUST: {                int blockState = session.getBlockMappings().getBedrockBlockId(((FallingDustParticleData) particle.getData()).getBlockState());                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);                    packet.setData(blockState);                    packet.setPosition(position);                    return packet;                };            }            case ITEM: {                ItemStack javaItem = ((ItemParticleData) particle.getData()).getItemStack();                ItemData bedrockItem = ItemTranslator.translateToBedrock(session, javaItem);                int data = bedrockItem.getId() << 16 | bedrockItem.getDamage();                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_ITEM_BREAK);                    packet.setData(data);                    packet.setPosition(position);                    return packet;                };            }            case DUST:            case DUST_COLOR_TRANSITION: {                 DustParticleData data = (DustParticleData) particle.getData();                int r = (int) (data.getRed() * 255);                int g = (int) (data.getGreen() * 255);                int b = (int) (data.getBlue() * 255);                int rgbData = ((0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);                    packet.setData(rgbData);                    packet.setPosition(position);                    return packet;                };            }            default: {                ParticleMapping particleMapping = Registries.PARTICLES.get(particle.getType());                if (particleMapping == null) {                     return null;                }                if (particleMapping.getLevelEventType() != null) {                    return (position) -> {                        LevelEventPacket packet = new LevelEventPacket();                        packet.setType(particleMapping.getLevelEventType());                        packet.setPosition(position);                        return packet;                    };                } else if (particleMapping.getIdentifier() != null) {                    int dimensionId = DimensionUtils.javaToBedrock(session.getDimension());                    return (position) -> {                        SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();                        stringPacket.setIdentifier(particleMapping.getIdentifier());                        stringPacket.setDimensionId(dimensionId);                        stringPacket.setPosition(position);                        return stringPacket;                    };                } else {                    return null;                }            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.world.particle.*;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnParticlePacket;import com.nukkitx.math.vector.Vector3f;import com.nukkitx.protocol.bedrock.BedrockPacket;import com.nukkitx.protocol.bedrock.data.LevelEventType;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.LevelEventPacket;import com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.ParticleMapping;import org.geysermc.connector.utils.DimensionUtils;import java.util.Random;import java.util.concurrent.ThreadLocalRandom;import java.util.function.Function;@Translator(packet = ServerSpawnParticlePacket.class)public class JavaSpawnParticleTranslator extends PacketTranslator<ServerSpawnParticlePacket> {    @Override    public void translate(ServerSpawnParticlePacket packet, GeyserSession session) {        Function<Vector3f, BedrockPacket> particleCreateFunction = createParticle(session, packet.getParticle());        if (particleCreateFunction != null) {            if (packet.getAmount() == 0) {                Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());                session.sendUpstreamPacket(particleCreateFunction.apply(position));            } else {                Random random = ThreadLocalRandom.current();                for (int i = 0; i < packet.getAmount(); i++) {                    double offsetX = random.nextGaussian() * (double) packet.getOffsetX();                    double offsetY = random.nextGaussian() * (double) packet.getOffsetY();                    double offsetZ = random.nextGaussian() * (double) packet.getOffsetZ();                    Vector3f position = Vector3f.from(packet.getX() + offsetX, packet.getY() + offsetY, packet.getZ() + offsetZ);                    session.sendUpstreamPacket(particleCreateFunction.apply(position));                }            }        } else {            session.getConnector().getLogger().debug(\"Unhandled particle packet: \" + packet);        }    }    private Function<Vector3f, BedrockPacket> createParticle(GeyserSession session, Particle particle) {        switch (particle.getType()) {            case BLOCK: {                int blockState = session.getBlockMappings().getBedrockBlockId(((BlockParticleData) particle.getData()).getBlockState());                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_CRACK_BLOCK);                    packet.setPosition(position);                    packet.setData(blockState);                    return packet;                };            }            case FALLING_DUST: {                int blockState = session.getBlockMappings().getBedrockBlockId(((FallingDustParticleData) particle.getData()).getBlockState());                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);                    packet.setData(blockState);                    packet.setPosition(position);                    return packet;                };            }            case ITEM: {                ItemStack javaItem = ((ItemParticleData) particle.getData()).getItemStack();                ItemData bedrockItem = ItemTranslator.translateToBedrock(session, javaItem);                int data = bedrockItem.getId() << 16 | bedrockItem.getDamage();                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_ITEM_BREAK);                    packet.setData(data);                    packet.setPosition(position);                    return packet;                };            }            case DUST:            case DUST_COLOR_TRANSITION: {                 DustParticleData data = (DustParticleData) particle.getData();                int r = (int) (data.getRed() * 255);                int g = (int) (data.getGreen() * 255);                int b = (int) (data.getBlue() * 255);                int rgbData = ((0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);                return (position) -> {                    LevelEventPacket packet = new LevelEventPacket();                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);                    packet.setData(rgbData);                    packet.setPosition(position);                    return packet;                };            }            default: {                ParticleMapping particleMapping = Registries.PARTICLES.get(particle.getType());                if (particleMapping == null) {                     return null;                }                if (particleMapping.getLevelEventType() != null) {                    return (position) -> {                        LevelEventPacket packet = new LevelEventPacket();                        packet.setType(particleMapping.getLevelEventType());                        packet.setPosition(position);                        return packet;                    };                } else if (particleMapping.getIdentifier() != null) {                    int dimensionId = DimensionUtils.javaToBedrock(session.getDimension());                    return (position) -> {                        SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();                        stringPacket.setIdentifier(particleMapping.getIdentifier());                        stringPacket.setDimensionId(dimensionId);                        stringPacket.setPosition(position);                        return stringPacket;                    };                } else {                    return null;                }            }        }    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnPositionPacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.packet.SetSpawnPositionPacket;import org.geysermc.connector.utils.DimensionUtils;@Translator(packet = ServerSpawnPositionPacket.class)public class JavaSpawnPositionTranslator extends PacketTranslator<ServerSpawnPositionPacket> {    @Override    public void translate(GeyserSession session, ServerSpawnPositionPacket packet) {        SetSpawnPositionPacket spawnPositionPacket = new SetSpawnPositionPacket();        spawnPositionPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));        spawnPositionPacket.setSpawnForced(true);        spawnPositionPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));        spawnPositionPacket.setSpawnType(SetSpawnPositionPacket.Type.WORLD_SPAWN);        session.sendUpstreamPacket(spawnPositionPacket);    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnPositionPacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.protocol.bedrock.packet.SetSpawnPositionPacket;import org.geysermc.connector.utils.DimensionUtils;@Translator(packet = ServerSpawnPositionPacket.class)public class JavaSpawnPositionTranslator extends PacketTranslator<ServerSpawnPositionPacket> {    @Override    public void translate(ServerSpawnPositionPacket packet, GeyserSession session) {        SetSpawnPositionPacket spawnPositionPacket = new SetSpawnPositionPacket();        spawnPositionPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));        spawnPositionPacket.setSpawnForced(true);        spawnPositionPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));        spawnPositionPacket.setSpawnType(SetSpawnPositionPacket.Type.WORLD_SPAWN);        session.sendUpstreamPacket(spawnPositionPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;import com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerStopSoundPacket;import com.nukkitx.protocol.bedrock.packet.StopSoundPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.SoundMapping;@Translator(packet = ServerStopSoundPacket.class)public class JavaStopSoundTranslator extends PacketTranslator<ServerStopSoundPacket> {    @Override    public void translate(GeyserSession session, ServerStopSoundPacket packet) {        if (packet.getSound() == null) {            StopSoundPacket stopPacket = new StopSoundPacket();            stopPacket.setStoppingAllSound(true);            stopPacket.setSoundName(\"\");            session.sendUpstreamPacket(stopPacket);            return;        }        String packetSound;        if (packet.getSound() instanceof BuiltinSound) {            packetSound = ((BuiltinSound) packet.getSound()).getName();        } else if (packet.getSound() instanceof CustomSound) {            packetSound = ((CustomSound) packet.getSound()).getName();        } else {            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());            return;        }        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));        session.getConnector().getLogger()                .debug(\"[StopSound] Sound mapping \" + packetSound + \" -> \"                        + soundMapping + (soundMapping == null ? \"[not found]\" : \"\")                        + \" - \" + packet.toString());        String playsound;        if (soundMapping == null || soundMapping.getPlaysound() == null) {            session.getConnector().getLogger()                    .debug(\"[StopSound] Defaulting to sound server gave us.\");            playsound = packetSound;        } else {            playsound = soundMapping.getPlaysound();        }        StopSoundPacket stopSoundPacket = new StopSoundPacket();        stopSoundPacket.setSoundName(playsound);        stopSoundPacket.setStoppingAllSound(false);        session.sendUpstreamPacket(stopSoundPacket);        session.getConnector().getLogger().debug(\"[StopSound] Packet sent - \" + packet.toString() + \" --> \" + stopSoundPacket);    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;import com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;import com.github.steveice10.mc.protocol.packet.ingame.server.ServerStopSoundPacket;import com.nukkitx.protocol.bedrock.packet.StopSoundPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.registry.Registries;import org.geysermc.connector.registry.type.SoundMapping;@Translator(packet = ServerStopSoundPacket.class)public class JavaStopSoundTranslator extends PacketTranslator<ServerStopSoundPacket> {    @Override    public void translate(ServerStopSoundPacket packet, GeyserSession session) {        if (packet.getSound() == null) {            StopSoundPacket stopPacket = new StopSoundPacket();            stopPacket.setStoppingAllSound(true);            stopPacket.setSoundName(\"\");            session.sendUpstreamPacket(stopPacket);            return;        }        String packetSound;        if (packet.getSound() instanceof BuiltinSound) {            packetSound = ((BuiltinSound) packet.getSound()).getName();        } else if (packet.getSound() instanceof CustomSound) {            packetSound = ((CustomSound) packet.getSound()).getName();        } else {            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());            return;        }        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));        session.getConnector().getLogger()                .debug(\"[StopSound] Sound mapping \" + packetSound + \" -> \"                        + soundMapping + (soundMapping == null ? \"[not found]\" : \"\")                        + \" - \" + packet.toString());        String playsound;        if (soundMapping == null || soundMapping.getPlaysound() == null) {            session.getConnector().getLogger()                    .debug(\"[StopSound] Defaulting to sound server gave us.\");            playsound = packetSound;        } else {            playsound = soundMapping.getPlaysound();        }        StopSoundPacket stopSoundPacket = new StopSoundPacket();        stopSoundPacket.setSoundName(playsound);        stopSoundPacket.setStoppingAllSound(false);        session.sendUpstreamPacket(stopSoundPacket);        session.getConnector().getLogger().debug(\"[StopSound] Packet sent - \" + packet.toString() + \" --> \" + stopSoundPacket);    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerTradeListPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.nbt.NbtType;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.UpdateTradePacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.inventory.MerchantContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.registry.type.ItemMapping;import java.util.ArrayList;import java.util.List;@Translator(packet = ServerTradeListPacket.class)public class JavaTradeListTranslator extends PacketTranslator<ServerTradeListPacket> {    @Override    public void translate(GeyserSession session, ServerTradeListPacket packet) {        Inventory openInventory = session.getOpenInventory();        if (!(openInventory instanceof MerchantContainer && openInventory.getId() == packet.getWindowId())) {            return;        }        MerchantContainer merchantInventory = (MerchantContainer) openInventory;        merchantInventory.setVillagerTrades(packet.getTrades());        Entity villager = merchantInventory.getVillager();        villager.getMetadata().put(EntityData.TRADE_TIER, packet.getVillagerLevel() - 1);        villager.getMetadata().put(EntityData.MAX_TRADE_TIER, 4);        villager.getMetadata().put(EntityData.TRADE_XP, packet.getExperience());        villager.updateBedrockMetadata(session);        UpdateTradePacket updateTradePacket = new UpdateTradePacket();        updateTradePacket.setTradeTier(packet.getVillagerLevel() - 1);        updateTradePacket.setContainerId((short) packet.getWindowId());        updateTradePacket.setContainerType(ContainerType.TRADE);        updateTradePacket.setDisplayName(openInventory.getTitle());        updateTradePacket.setSize(0);        updateTradePacket.setNewTradingUi(true);        updateTradePacket.setUsingEconomyTrade(true);        updateTradePacket.setPlayerUniqueEntityId(session.getPlayerEntity().getGeyserId());        updateTradePacket.setTraderUniqueEntityId(villager.getGeyserId());        NbtMapBuilder builder = NbtMap.builder();        boolean addExtraTrade = packet.isRegularVillager() && packet.getVillagerLevel() < 5;        List<NbtMap> tags = new ArrayList<>(addExtraTrade ? packet.getTrades().length + 1 : packet.getTrades().length);        for (int i = 0; i < packet.getTrades().length; i++) {            VillagerTrade trade = packet.getTrades()[i];            NbtMapBuilder recipe = NbtMap.builder();            recipe.putInt(\"netId\", i + 1);            recipe.putInt(\"maxUses\", trade.isTradeDisabled() ? 0 : trade.getMaxUses());            recipe.putInt(\"traderExp\", trade.getXp());            recipe.putFloat(\"priceMultiplierA\", trade.getPriceMultiplier());            recipe.put(\"sell\", getItemTag(session, trade.getOutput(), 0));            recipe.putFloat(\"priceMultiplierB\", 0.0f);            recipe.putInt(\"buyCountB\", trade.getSecondInput() != null ? trade.getSecondInput().getAmount() : 0);            recipe.putInt(\"buyCountA\", trade.getFirstInput().getAmount());            recipe.putInt(\"demand\", trade.getDemand());            recipe.putInt(\"tier\", packet.getVillagerLevel() > 0 ? packet.getVillagerLevel() - 1 : 0);             recipe.put(\"buyA\", getItemTag(session, trade.getFirstInput(), trade.getSpecialPrice()));            if (trade.getSecondInput() != null) {                recipe.put(\"buyB\", getItemTag(session, trade.getSecondInput(), 0));            }            recipe.putInt(\"uses\", trade.getNumUses());            recipe.putByte(\"rewardExp\", (byte) 1);            tags.add(recipe.build());        }        if (addExtraTrade) {            tags.add(NbtMap.builder()                    .putInt(\"maxUses\", 0)                    .putInt(\"traderExp\", 0)                    .putFloat(\"priceMultiplierA\", 0.0f)                    .putFloat(\"priceMultiplierB\", 0.0f)                    .putInt(\"buyCountB\", 0)                    .putInt(\"buyCountA\", 0)                    .putInt(\"demand\", 0)                    .putInt(\"tier\", 5)                    .putInt(\"uses\", 0)                    .putByte(\"rewardExp\", (byte) 0)                    .build());        }        builder.putList(\"Recipes\", NbtType.COMPOUND, tags);        List<NbtMap> expTags = new ArrayList<>(5);        expTags.add(NbtMap.builder().putInt(\"0\", 0).build());        expTags.add(NbtMap.builder().putInt(\"1\", 10).build());        expTags.add(NbtMap.builder().putInt(\"2\", 70).build());        expTags.add(NbtMap.builder().putInt(\"3\", 150).build());        expTags.add(NbtMap.builder().putInt(\"4\", 250).build());        builder.putList(\"TierExpRequirements\", NbtType.COMPOUND, expTags);        updateTradePacket.setOffers(builder.build());        session.sendUpstreamPacket(updateTradePacket);    }    private NbtMap getItemTag(GeyserSession session, ItemStack stack, int specialPrice) {        ItemData itemData = ItemTranslator.translateToBedrock(session, stack);        ItemMapping mapping = session.getItemMappings().getMapping(stack);        NbtMapBuilder builder = NbtMap.builder();        builder.putByte(\"Count\", (byte) (Math.max(itemData.getCount() + specialPrice, 1)));        builder.putShort(\"Damage\", (short) itemData.getDamage());        builder.putString(\"Name\", mapping.getBedrockIdentifier());        if (itemData.getTag() != null) {            NbtMap tag = itemData.getTag().toBuilder().build();            builder.put(\"tag\", tag);        }        NbtMap blockTag = session.getBlockMappings().getBedrockBlockNbt(mapping.getJavaIdentifier());        if (blockTag != null) {            builder.putCompound(\"Block\", blockTag);            builder.putShort(\"Damage\", (short) 0);        }        return builder.build();    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;import com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;import com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerTradeListPacket;import com.nukkitx.nbt.NbtMap;import com.nukkitx.nbt.NbtMapBuilder;import com.nukkitx.nbt.NbtType;import com.nukkitx.protocol.bedrock.data.entity.EntityData;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.data.inventory.ItemData;import com.nukkitx.protocol.bedrock.packet.UpdateTradePacket;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.inventory.Inventory;import org.geysermc.connector.inventory.MerchantContainer;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.item.ItemTranslator;import org.geysermc.connector.registry.type.ItemMapping;import java.util.ArrayList;import java.util.List;@Translator(packet = ServerTradeListPacket.class)public class JavaTradeListTranslator extends PacketTranslator<ServerTradeListPacket> {    @Override    public void translate(ServerTradeListPacket packet, GeyserSession session) {        Inventory openInventory = session.getOpenInventory();        if (!(openInventory instanceof MerchantContainer && openInventory.getId() == packet.getWindowId())) {            return;        }        MerchantContainer merchantInventory = (MerchantContainer) openInventory;        merchantInventory.setVillagerTrades(packet.getTrades());        Entity villager = merchantInventory.getVillager();        villager.getMetadata().put(EntityData.TRADE_TIER, packet.getVillagerLevel() - 1);        villager.getMetadata().put(EntityData.MAX_TRADE_TIER, 4);        villager.getMetadata().put(EntityData.TRADE_XP, packet.getExperience());        villager.updateBedrockMetadata(session);        UpdateTradePacket updateTradePacket = new UpdateTradePacket();        updateTradePacket.setTradeTier(packet.getVillagerLevel() - 1);        updateTradePacket.setContainerId((short) packet.getWindowId());        updateTradePacket.setContainerType(ContainerType.TRADE);        updateTradePacket.setDisplayName(openInventory.getTitle());        updateTradePacket.setSize(0);        updateTradePacket.setNewTradingUi(true);        updateTradePacket.setUsingEconomyTrade(true);        updateTradePacket.setPlayerUniqueEntityId(session.getPlayerEntity().getGeyserId());        updateTradePacket.setTraderUniqueEntityId(villager.getGeyserId());        NbtMapBuilder builder = NbtMap.builder();        boolean addExtraTrade = packet.isRegularVillager() && packet.getVillagerLevel() < 5;        List<NbtMap> tags = new ArrayList<>(addExtraTrade ? packet.getTrades().length + 1 : packet.getTrades().length);        for (int i = 0; i < packet.getTrades().length; i++) {            VillagerTrade trade = packet.getTrades()[i];            NbtMapBuilder recipe = NbtMap.builder();            recipe.putInt(\"netId\", i + 1);            recipe.putInt(\"maxUses\", trade.isTradeDisabled() ? 0 : trade.getMaxUses());            recipe.putInt(\"traderExp\", trade.getXp());            recipe.putFloat(\"priceMultiplierA\", trade.getPriceMultiplier());            recipe.put(\"sell\", getItemTag(session, trade.getOutput(), 0));            recipe.putFloat(\"priceMultiplierB\", 0.0f);            recipe.putInt(\"buyCountB\", trade.getSecondInput() != null ? trade.getSecondInput().getAmount() : 0);            recipe.putInt(\"buyCountA\", trade.getFirstInput().getAmount());            recipe.putInt(\"demand\", trade.getDemand());            recipe.putInt(\"tier\", packet.getVillagerLevel() > 0 ? packet.getVillagerLevel() - 1 : 0);             recipe.put(\"buyA\", getItemTag(session, trade.getFirstInput(), trade.getSpecialPrice()));            if (trade.getSecondInput() != null) {                recipe.put(\"buyB\", getItemTag(session, trade.getSecondInput(), 0));            }            recipe.putInt(\"uses\", trade.getNumUses());            recipe.putByte(\"rewardExp\", (byte) 1);            tags.add(recipe.build());        }        if (addExtraTrade) {            tags.add(NbtMap.builder()                    .putInt(\"maxUses\", 0)                    .putInt(\"traderExp\", 0)                    .putFloat(\"priceMultiplierA\", 0.0f)                    .putFloat(\"priceMultiplierB\", 0.0f)                    .putInt(\"buyCountB\", 0)                    .putInt(\"buyCountA\", 0)                    .putInt(\"demand\", 0)                    .putInt(\"tier\", 5)                    .putInt(\"uses\", 0)                    .putByte(\"rewardExp\", (byte) 0)                    .build());        }        builder.putList(\"Recipes\", NbtType.COMPOUND, tags);        List<NbtMap> expTags = new ArrayList<>(5);        expTags.add(NbtMap.builder().putInt(\"0\", 0).build());        expTags.add(NbtMap.builder().putInt(\"1\", 10).build());        expTags.add(NbtMap.builder().putInt(\"2\", 70).build());        expTags.add(NbtMap.builder().putInt(\"3\", 150).build());        expTags.add(NbtMap.builder().putInt(\"4\", 250).build());        builder.putList(\"TierExpRequirements\", NbtType.COMPOUND, expTags);        updateTradePacket.setOffers(builder.build());        session.sendUpstreamPacket(updateTradePacket);    }    private NbtMap getItemTag(GeyserSession session, ItemStack stack, int specialPrice) {        ItemData itemData = ItemTranslator.translateToBedrock(session, stack);        ItemMapping mapping = session.getItemMappings().getMapping(stack);        NbtMapBuilder builder = NbtMap.builder();        builder.putByte(\"Count\", (byte) (Math.max(itemData.getCount() + specialPrice, 1)));        builder.putShort(\"Damage\", (short) itemData.getDamage());        builder.putString(\"Name\", mapping.getBedrockIdentifier());        if (itemData.getTag() != null) {            NbtMap tag = itemData.getTag().toBuilder().build();            builder.put(\"tag\", tag);        }        NbtMap blockTag = session.getBlockMappings().getBedrockBlockNbt(mapping.getJavaIdentifier());        if (blockTag != null) {            builder.putCompound(\"Block\", blockTag);            builder.putShort(\"Damage\", (short) 0);        }        return builder.build();    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUnloadChunkPacket;import com.nukkitx.math.vector.Vector3i;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.Iterator;@Translator(packet = ServerUnloadChunkPacket.class)public class JavaUnloadChunkTranslator extends PacketTranslator<ServerUnloadChunkPacket> {    @Override    public void translate(GeyserSession session, ServerUnloadChunkPacket packet) {        session.getChunkCache().removeChunk(packet.getX(), packet.getZ());        Iterator<Vector3i> iterator = session.getSkullCache().keySet().iterator();        while (iterator.hasNext()) {            Vector3i position = iterator.next();            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {                session.getSkullCache().get(position).despawnEntity(session);                iterator.remove();            }        }        iterator = session.getLecternCache().iterator();        while (iterator.hasNext()) {            Vector3i position = iterator.next();            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {                iterator.remove();            }        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUnloadChunkPacket;import com.nukkitx.math.vector.Vector3i;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import java.util.Iterator;@Translator(packet = ServerUnloadChunkPacket.class)public class JavaUnloadChunkTranslator extends PacketTranslator<ServerUnloadChunkPacket> {    @Override    public void translate(ServerUnloadChunkPacket packet, GeyserSession session) {        session.getChunkCache().removeChunk(packet.getX(), packet.getZ());        Iterator<Vector3i> iterator = session.getSkullCache().keySet().iterator();        while (iterator.hasNext()) {            Vector3i position = iterator.next();            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {                session.getSkullCache().get(position).despawnEntity(session);                iterator.remove();            }        }        iterator = session.getLecternCache().iterator();        while (iterator.hasNext()) {            Vector3i position = iterator.next();            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {                iterator.remove();            }        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.data.game.world.block.UpdatedTileType;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTileEntityPacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.nbt.NbtMap;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.network.translators.world.block.entity.BlockEntityTranslator;import org.geysermc.connector.network.translators.world.block.entity.RequiresBlockState;import org.geysermc.connector.network.translators.world.block.entity.SkullBlockEntityTranslator;import org.geysermc.connector.utils.BlockEntityUtils;@Translator(packet = ServerUpdateTileEntityPacket.class)public class JavaUpdateTileEntityTranslator extends PacketTranslator<ServerUpdateTileEntityPacket> {    @Override    public void translate(GeyserSession session, ServerUpdateTileEntityPacket packet) {        String id = BlockEntityUtils.getBedrockBlockEntityId(packet.getType().name());        if (packet.getNbt().isEmpty()) {             BlockEntityUtils.updateBlockEntity(session, NbtMap.EMPTY, packet.getPosition());            return;        }        BlockEntityTranslator translator = BlockEntityUtils.getBlockEntityTranslator(id);        int blockState;        if (translator instanceof RequiresBlockState) {            blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition());        } else {            blockState = BlockStateValues.JAVA_AIR_ID;        }        BlockEntityUtils.updateBlockEntity(session, translator.getBlockEntityTag(id, packet.getNbt(), blockState), packet.getPosition());        if (SkullBlockEntityTranslator.ALLOW_CUSTOM_SKULLS && packet.getNbt().contains(\"SkullOwner\")) {            SkullBlockEntityTranslator.spawnPlayer(session, packet.getNbt(), blockState);        }        if (packet.getType() == UpdatedTileType.COMMAND_BLOCK && session.getOpPermissionLevel() >= 2 &&                session.getGameMode() == GameMode.CREATIVE && packet.getNbt().size() > 5) {            ContainerOpenPacket openPacket = new ContainerOpenPacket();            openPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));            openPacket.setId((byte) 1);            openPacket.setType(ContainerType.COMMAND_BLOCK);            openPacket.setUniqueEntityId(-1);            session.sendUpstreamPacket(openPacket);        }    }}", "nl": "import com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;import com.github.steveice10.mc.protocol.data.game.world.block.UpdatedTileType;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTileEntityPacket;import com.nukkitx.math.vector.Vector3i;import com.nukkitx.nbt.NbtMap;import com.nukkitx.protocol.bedrock.data.inventory.ContainerType;import com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.network.translators.world.block.BlockStateValues;import org.geysermc.connector.network.translators.world.block.entity.BlockEntityTranslator;import org.geysermc.connector.network.translators.world.block.entity.RequiresBlockState;import org.geysermc.connector.network.translators.world.block.entity.SkullBlockEntityTranslator;import org.geysermc.connector.utils.BlockEntityUtils;@Translator(packet = ServerUpdateTileEntityPacket.class)public class JavaUpdateTileEntityTranslator extends PacketTranslator<ServerUpdateTileEntityPacket> {    @Override    public void translate(ServerUpdateTileEntityPacket packet, GeyserSession session) {        String id = BlockEntityUtils.getBedrockBlockEntityId(packet.getType().name());        if (packet.getNbt().isEmpty()) {             BlockEntityUtils.updateBlockEntity(session, NbtMap.EMPTY, packet.getPosition());            return;        }        BlockEntityTranslator translator = BlockEntityUtils.getBlockEntityTranslator(id);        int blockState;        if (translator instanceof RequiresBlockState) {            blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition());        } else {            blockState = BlockStateValues.JAVA_AIR_ID;        }        BlockEntityUtils.updateBlockEntity(session, translator.getBlockEntityTag(id, packet.getNbt(), blockState), packet.getPosition());        if (SkullBlockEntityTranslator.ALLOW_CUSTOM_SKULLS && packet.getNbt().contains(\"SkullOwner\")) {            SkullBlockEntityTranslator.spawnPlayer(session, packet.getNbt(), blockState);        }        if (packet.getType() == UpdatedTileType.COMMAND_BLOCK && session.getOpPermissionLevel() >= 2 &&                session.getGameMode() == GameMode.CREATIVE && packet.getNbt().size() > 5) {            ContainerOpenPacket openPacket = new ContainerOpenPacket();            openPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));            openPacket.setId((byte) 1);            openPacket.setType(ContainerType.COMMAND_BLOCK);            openPacket.setUniqueEntityId(-1);            session.sendUpstreamPacket(openPacket);        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTimePacket;import com.nukkitx.protocol.bedrock.packet.SetTimePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerUpdateTimePacket.class)public class JavaUpdateTimeTranslator extends PacketTranslator<ServerUpdateTimePacket> {    @Override    public void translate(GeyserSession session, ServerUpdateTimePacket packet) {        long time = packet.getTime();        SetTimePacket setTimePacket = new SetTimePacket();        setTimePacket.setTime((int) Math.abs(time) % 24000);        session.sendUpstreamPacket(setTimePacket);        if (!session.isDaylightCycle() && time >= 0) {            session.setDaylightCycle(true);        } else if (session.isDaylightCycle() && time < 0) {            session.setDaylightCycle(false);        }    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTimePacket;import com.nukkitx.protocol.bedrock.packet.SetTimePacket;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerUpdateTimePacket.class)public class JavaUpdateTimeTranslator extends PacketTranslator<ServerUpdateTimePacket> {    @Override    public void translate(ServerUpdateTimePacket packet, GeyserSession session) {        long time = packet.getTime();        SetTimePacket setTimePacket = new SetTimePacket();        setTimePacket.setTime((int) Math.abs(time) % 24000);        session.sendUpstreamPacket(setTimePacket);        if (!session.isDaylightCycle() && time >= 0) {            session.setDaylightCycle(true);        } else if (session.isDaylightCycle() && time < 0) {            session.setDaylightCycle(false);        }    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewDistancePacket;@Translator(packet = ServerUpdateViewDistancePacket.class)public class JavaUpdateViewDistanceTranslator extends PacketTranslator<ServerUpdateViewDistancePacket> {    @Override    public void translate(GeyserSession session, ServerUpdateViewDistancePacket packet) {        session.setRenderDistance(packet.getViewDistance());    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewDistancePacket;@Translator(packet = ServerUpdateViewDistancePacket.class)public class JavaUpdateViewDistanceTranslator extends PacketTranslator<ServerUpdateViewDistancePacket> {    @Override    public void translate(ServerUpdateViewDistancePacket packet, GeyserSession session) {        session.setRenderDistance(packet.getViewDistance());    }}"}
{"code": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.ChunkUtils;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewPositionPacket;import com.nukkitx.math.vector.Vector3i;@Translator(packet = ServerUpdateViewPositionPacket.class)public class JavaUpdateViewPositionTranslator extends PacketTranslator<ServerUpdateViewPositionPacket> {    @Override    public void translate(GeyserSession session, ServerUpdateViewPositionPacket packet) {        if (!session.isSpawned() && session.getLastChunkPosition() == null) {            ChunkUtils.updateChunkPosition(session, Vector3i.from(packet.getChunkX() << 4, 64, packet.getChunkZ() << 4));        }    }}", "nl": "import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;import org.geysermc.connector.utils.ChunkUtils;import com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewPositionPacket;import com.nukkitx.math.vector.Vector3i;@Translator(packet = ServerUpdateViewPositionPacket.class)public class JavaUpdateViewPositionTranslator extends PacketTranslator<ServerUpdateViewPositionPacket> {    @Override    public void translate(ServerUpdateViewPositionPacket packet, GeyserSession session) {        if (!session.isSpawned() && session.getLastChunkPosition() == null) {            ChunkUtils.updateChunkPosition(session, Vector3i.from(packet.getChunkX() << 4, 64, packet.getChunkZ() << 4));        }    }}"}
{"code": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerVehicleMovePacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerVehicleMovePacket.class)public class JavaVehicleMoveTranslator extends PacketTranslator<ServerVehicleMovePacket> {    @Override    public void translate(GeyserSession session, ServerVehicleMovePacket packet) {        Entity entity = session.getRidingVehicleEntity();        if (entity == null) return;        entity.moveAbsolute(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), false, true);    }}", "nl": "import com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerVehicleMovePacket;import com.nukkitx.math.vector.Vector3f;import org.geysermc.connector.entity.Entity;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.translators.PacketTranslator;import org.geysermc.connector.network.translators.Translator;@Translator(packet = ServerVehicleMovePacket.class)public class JavaVehicleMoveTranslator extends PacketTranslator<ServerVehicleMovePacket> {    @Override    public void translate(ServerVehicleMovePacket packet, GeyserSession session) {        Entity entity = session.getRidingVehicleEntity();        if (entity == null) return;        entity.moveAbsolute(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), false, true);    }}"}
{"code": "import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.JsonNodeType;import com.github.steveice10.mc.auth.service.MsaAuthenticationService;import com.nimbusds.jose.JWSObject;import com.nimbusds.jose.shaded.json.JSONObject;import com.nimbusds.jose.shaded.json.JSONValue;import com.nukkitx.network.util.Preconditions;import com.nukkitx.protocol.bedrock.packet.LoginPacket;import com.nukkitx.protocol.bedrock.packet.ServerToClientHandshakePacket;import com.nukkitx.protocol.bedrock.util.EncryptionUtils;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.configuration.GeyserConfiguration;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.auth.AuthData;import org.geysermc.connector.network.session.auth.BedrockClientData;import org.geysermc.cumulus.CustomForm;import org.geysermc.cumulus.ModalForm;import org.geysermc.cumulus.SimpleForm;import org.geysermc.cumulus.response.CustomFormResponse;import org.geysermc.cumulus.response.ModalFormResponse;import org.geysermc.cumulus.response.SimpleFormResponse;import javax.crypto.SecretKey;import java.io.IOException;import java.net.URI;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PublicKey;import java.security.interfaces.ECPublicKey;import java.security.spec.ECGenParameterSpec;import java.util.UUID;public class LoginEncryptionUtils {    private static final ObjectMapper JSON_MAPPER = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);    private static boolean HAS_SENT_ENCRYPTION_MESSAGE = false;    private static boolean validateChainData(JsonNode data) throws Exception {        if (data.size() != 3) {            return false;        }        ECPublicKey lastKey = null;        boolean validChain = false;        for (JsonNode node : data) {            JWSObject jwt = JWSObject.parse(node.asText());            URI x5u = jwt.getHeader().getX509CertURL();            if (x5u == null) {                return false;            }            ECPublicKey expectedKey = EncryptionUtils.generateKey(jwt.getHeader().getX509CertURL().toString());            if (lastKey == null) {                lastKey = expectedKey;            } else if (!lastKey.equals(expectedKey)) {                return false;            }            if (!EncryptionUtils.verifyJwt(jwt, lastKey)) {                return false;            }            if (lastKey.equals(EncryptionUtils.getMojangPublicKey())) {                validChain = true;            }            Object payload = JSONValue.parse(jwt.getPayload().toString());            Preconditions.checkArgument(payload instanceof JSONObject, \"Payload is not an object\");            Object identityPublicKey = ((JSONObject) payload).get(\"identityPublicKey\");            Preconditions.checkArgument(identityPublicKey instanceof String, \"identityPublicKey node is missing in chain\");            lastKey = EncryptionUtils.generateKey((String) identityPublicKey);        }        return validChain;    }    public static void encryptPlayerConnection(GeyserSession session, LoginPacket loginPacket) {        JsonNode certData;        try {            certData = JSON_MAPPER.readTree(loginPacket.getChainData().toByteArray());        } catch (IOException ex) {            throw new RuntimeException(\"Certificate JSON can not be read.\");        }        JsonNode certChainData = certData.get(\"chain\");        if (certChainData.getNodeType() != JsonNodeType.ARRAY) {            throw new RuntimeException(\"Certificate data is not valid\");        }        encryptConnectionWithCert(session, loginPacket.getSkinData().toString(), certChainData);    }    private static void encryptConnectionWithCert(GeyserSession session, String clientData, JsonNode certChainData) {        try {            GeyserConnector connector = session.getConnector();            boolean validChain = validateChainData(certChainData);            connector.getLogger().debug(String.format(\"Is player data valid? %s\", validChain));            if (!validChain && !session.getConnector().getConfig().isEnableProxyConnections()) {                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.remote.invalid_xbox_account\"));                return;            }            JWSObject jwt = JWSObject.parse(certChainData.get(certChainData.size() - 1).asText());            JsonNode payload = JSON_MAPPER.readTree(jwt.getPayload().toBytes());            if (payload.get(\"extraData\").getNodeType() != JsonNodeType.OBJECT) {                throw new RuntimeException(\"AuthData was not found!\");            }            JsonNode extraData = payload.get(\"extraData\");            session.setAuthenticationData(new AuthData(                    extraData.get(\"displayName\").asText(),                    UUID.fromString(extraData.get(\"identity\").asText()),                    extraData.get(\"XUID\").asText(),                    certChainData, clientData            ));            if (payload.get(\"identityPublicKey\").getNodeType() != JsonNodeType.STRING) {                throw new RuntimeException(\"Identity Public Key was not found!\");            }            ECPublicKey identityPublicKey = EncryptionUtils.generateKey(payload.get(\"identityPublicKey\").textValue());            JWSObject clientJwt = JWSObject.parse(clientData);            EncryptionUtils.verifyJwt(clientJwt, identityPublicKey);            JsonNode clientDataJson = JSON_MAPPER.readTree(clientJwt.getPayload().toBytes());            BedrockClientData data = JSON_MAPPER.convertValue(clientDataJson, BedrockClientData.class);            session.setClientData(data);            if (EncryptionUtils.canUseEncryption()) {                try {                    LoginEncryptionUtils.startEncryptionHandshake(session, identityPublicKey);                } catch (Throwable e) {                    if (connector.getConfig().isDebugMode()) {                        e.printStackTrace();                    }                    sendEncryptionFailedMessage(connector);                }            } else {                sendEncryptionFailedMessage(connector);            }        } catch (Exception ex) {            session.disconnect(\"disconnectionScreen.internalError.cantConnect\");            throw new RuntimeException(\"Unable to complete login\", ex);        }    }    private static void startEncryptionHandshake(GeyserSession session, PublicKey key) throws Exception {        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"EC\");        generator.initialize(new ECGenParameterSpec(\"secp384r1\"));        KeyPair serverKeyPair = generator.generateKeyPair();        byte[] token = EncryptionUtils.generateRandomToken();        SecretKey encryptionKey = EncryptionUtils.getSecretKey(serverKeyPair.getPrivate(), key, token);        session.getUpstream().getSession().enableEncryption(encryptionKey);        ServerToClientHandshakePacket packet = new ServerToClientHandshakePacket();        packet.setJwt(EncryptionUtils.createHandshakeJwt(serverKeyPair, token).serialize());        session.sendUpstreamPacketImmediately(packet);    }    private static void sendEncryptionFailedMessage(GeyserConnector connector) {        if (!HAS_SENT_ENCRYPTION_MESSAGE) {            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_1\"));            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_2\", \"https:            HAS_SENT_ENCRYPTION_MESSAGE = true;        }    }    public static void buildAndShowLoginWindow(GeyserSession session) {        session.setDaylightCycle(false);        GeyserConfiguration config = session.getConnector().getConfig();        boolean isPasswordAuthEnabled = config.getRemote().isPasswordAuthentication();        session.sendForm(                SimpleForm.builder()                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())                        .title(\"geyser.auth.login.form.notice.title\")                        .content(\"geyser.auth.login.form.notice.desc\")                        .optionalButton(\"geyser.auth.login.form.notice.btn_login.mojang\", isPasswordAuthEnabled)                        .button(\"geyser.auth.login.form.notice.btn_login.microsoft\")                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")                        .responseHandler((form, responseData) -> {                            SimpleFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowLoginWindow(session);                                return;                            }                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 0) {                                session.setMicrosoftAccount(false);                                buildAndShowLoginDetailsWindow(session);                                return;                            }                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 1) {                                session.setMicrosoftAccount(true);                                buildAndShowMicrosoftAuthenticationWindow(session);                                return;                            }                            if (response.getClickedButtonId() == 0) {                                session.authenticateWithMicrosoftCode();                                return;                            }                            session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));                        }));    }    public static void buildAndShowLoginDetailsWindow(GeyserSession session) {        session.sendForm(                CustomForm.builder()                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())                        .title(\"geyser.auth.login.form.details.title\")                        .label(\"geyser.auth.login.form.details.desc\")                        .input(\"geyser.auth.login.form.details.email\", \"account@geysermc.org\", \"\")                        .input(\"geyser.auth.login.form.details.pass\", \"123456\", \"\")                        .responseHandler((form, responseData) -> {                            CustomFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowLoginDetailsWindow(session);                                return;                            }                            session.authenticate(response.next(), response.next());                        }));    }    public static void buildAndShowMicrosoftAuthenticationWindow(GeyserSession session) {        session.sendForm(                SimpleForm.builder()                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())                        .title(\"geyser.auth.login.form.notice.btn_login.microsoft\")                        .button(\"geyser.auth.login.method.browser\")                        .button(\"geyser.auth.login.method.password\")                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")                        .responseHandler((form, responseData) -> {                            SimpleFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowLoginWindow(session);                                return;                            }                            if (response.getClickedButtonId() == 0) {                                session.authenticateWithMicrosoftCode();                            } else if (response.getClickedButtonId() == 1) {                                buildAndShowLoginDetailsWindow(session);                            } else {                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));                            }                        }));    }    public static void buildAndShowMicrosoftCodeWindow(GeyserSession session, MsaAuthenticationService.MsCodeResponse msCode) {        session.sendForm(                ModalForm.builder()                        .title(\"%xbox.signin\")                        .content(\"%xbox.signin.website\\n%xbox.signin.url\\n%xbox.signin.enterCode\\n\" + msCode.user_code)                        .button1(\"%gui.done\")                        .button2(\"%menu.disconnect\")                        .responseHandler((form, responseData) -> {                            ModalFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowMicrosoftAuthenticationWindow(session);                                return;                            }                            if (response.getClickedButtonId() == 1) {                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));                            }                        })        );    }}", "nl": "import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.JsonNodeType;import com.github.steveice10.mc.auth.service.MsaAuthenticationService;import com.nimbusds.jose.JWSObject;import com.nukkitx.network.util.Preconditions;import com.nukkitx.protocol.bedrock.packet.LoginPacket;import com.nukkitx.protocol.bedrock.packet.ServerToClientHandshakePacket;import com.nukkitx.protocol.bedrock.util.EncryptionUtils;import org.geysermc.connector.GeyserConnector;import org.geysermc.connector.configuration.GeyserConfiguration;import org.geysermc.connector.network.session.GeyserSession;import org.geysermc.connector.network.session.auth.AuthData;import org.geysermc.connector.network.session.auth.BedrockClientData;import org.geysermc.cumulus.CustomForm;import org.geysermc.cumulus.ModalForm;import org.geysermc.cumulus.SimpleForm;import org.geysermc.cumulus.response.CustomFormResponse;import org.geysermc.cumulus.response.ModalFormResponse;import org.geysermc.cumulus.response.SimpleFormResponse;import javax.crypto.SecretKey;import java.io.IOException;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PublicKey;import java.security.interfaces.ECPublicKey;import java.security.spec.ECGenParameterSpec;import java.util.UUID;public class LoginEncryptionUtils {    private static final ObjectMapper JSON_MAPPER = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);    private static boolean HAS_SENT_ENCRYPTION_MESSAGE = false;    private static boolean validateChainData(JsonNode data) throws Exception {        ECPublicKey lastKey = null;        boolean validChain = false;        for (JsonNode node : data) {            JWSObject jwt = JWSObject.parse(node.asText());            if (!validChain) {                validChain = EncryptionUtils.verifyJwt(jwt, EncryptionUtils.getMojangPublicKey());            }            if (lastKey != null) {                if (!EncryptionUtils.verifyJwt(jwt, lastKey)) return false;            }            JsonNode payloadNode = JSON_MAPPER.readTree(jwt.getPayload().toString());            JsonNode ipkNode = payloadNode.get(\"identityPublicKey\");            Preconditions.checkState(ipkNode != null && ipkNode.getNodeType() == JsonNodeType.STRING, \"identityPublicKey node is missing in chain\");            lastKey = EncryptionUtils.generateKey(ipkNode.asText());        }        return validChain;    }    public static void encryptPlayerConnection(GeyserConnector connector, GeyserSession session, LoginPacket loginPacket) {        JsonNode certData;        try {            certData = JSON_MAPPER.readTree(loginPacket.getChainData().toByteArray());        } catch (IOException ex) {            throw new RuntimeException(\"Certificate JSON can not be read.\");        }        JsonNode certChainData = certData.get(\"chain\");        if (certChainData.getNodeType() != JsonNodeType.ARRAY) {            throw new RuntimeException(\"Certificate data is not valid\");        }        encryptConnectionWithCert(connector, session, loginPacket.getSkinData().toString(), certChainData);    }    private static void encryptConnectionWithCert(GeyserConnector connector, GeyserSession session, String clientData, JsonNode certChainData) {        try {            boolean validChain = validateChainData(certChainData);            connector.getLogger().debug(String.format(\"Is player data valid? %s\", validChain));            if (!validChain && !session.getConnector().getConfig().isEnableProxyConnections()) {                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.remote.invalid_xbox_account\"));                return;            }            JWSObject jwt = JWSObject.parse(certChainData.get(certChainData.size() - 1).asText());            JsonNode payload = JSON_MAPPER.readTree(jwt.getPayload().toBytes());            if (payload.get(\"extraData\").getNodeType() != JsonNodeType.OBJECT) {                throw new RuntimeException(\"AuthData was not found!\");            }            JsonNode extraData = payload.get(\"extraData\");            session.setAuthenticationData(new AuthData(                    extraData.get(\"displayName\").asText(),                    UUID.fromString(extraData.get(\"identity\").asText()),                    extraData.get(\"XUID\").asText(),                    certChainData, clientData            ));            if (payload.get(\"identityPublicKey\").getNodeType() != JsonNodeType.STRING) {                throw new RuntimeException(\"Identity Public Key was not found!\");            }            ECPublicKey identityPublicKey = EncryptionUtils.generateKey(payload.get(\"identityPublicKey\").textValue());            JWSObject clientJwt = JWSObject.parse(clientData);            EncryptionUtils.verifyJwt(clientJwt, identityPublicKey);            JsonNode clientDataJson = JSON_MAPPER.readTree(clientJwt.getPayload().toBytes());            BedrockClientData data = JSON_MAPPER.convertValue(clientDataJson, BedrockClientData.class);            session.setClientData(data);            if (EncryptionUtils.canUseEncryption()) {                try {                    LoginEncryptionUtils.startEncryptionHandshake(session, identityPublicKey);                } catch (Throwable e) {                    if (connector.getConfig().isDebugMode()) {                        e.printStackTrace();                    }                    sendEncryptionFailedMessage(connector);                }            } else {                sendEncryptionFailedMessage(connector);            }        } catch (Exception ex) {            session.disconnect(\"disconnectionScreen.internalError.cantConnect\");            throw new RuntimeException(\"Unable to complete login\", ex);        }    }    private static void startEncryptionHandshake(GeyserSession session, PublicKey key) throws Exception {        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"EC\");        generator.initialize(new ECGenParameterSpec(\"secp384r1\"));        KeyPair serverKeyPair = generator.generateKeyPair();        byte[] token = EncryptionUtils.generateRandomToken();        SecretKey encryptionKey = EncryptionUtils.getSecretKey(serverKeyPair.getPrivate(), key, token);        session.getUpstream().getSession().enableEncryption(encryptionKey);        ServerToClientHandshakePacket packet = new ServerToClientHandshakePacket();        packet.setJwt(EncryptionUtils.createHandshakeJwt(serverKeyPair, token).serialize());        session.sendUpstreamPacketImmediately(packet);    }    private static void sendEncryptionFailedMessage(GeyserConnector connector) {        if (!HAS_SENT_ENCRYPTION_MESSAGE) {            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_1\"));            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_2\", \"https:            HAS_SENT_ENCRYPTION_MESSAGE = true;        }    }    public static void buildAndShowLoginWindow(GeyserSession session) {        session.setDaylightCycle(false);        GeyserConfiguration config = session.getConnector().getConfig();        boolean isPasswordAuthEnabled = config.getRemote().isPasswordAuthentication();        session.sendForm(                SimpleForm.builder()                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())                        .title(\"geyser.auth.login.form.notice.title\")                        .content(\"geyser.auth.login.form.notice.desc\")                        .optionalButton(\"geyser.auth.login.form.notice.btn_login.mojang\", isPasswordAuthEnabled)                        .button(\"geyser.auth.login.form.notice.btn_login.microsoft\")                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")                        .responseHandler((form, responseData) -> {                            SimpleFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowLoginWindow(session);                                return;                            }                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 0) {                                session.setMicrosoftAccount(false);                                buildAndShowLoginDetailsWindow(session);                                return;                            }                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 1) {                                session.setMicrosoftAccount(true);                                buildAndShowMicrosoftAuthenticationWindow(session);                                return;                            }                            if (response.getClickedButtonId() == 0) {                                session.authenticateWithMicrosoftCode();                                return;                            }                            session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));                        }));    }    public static void buildAndShowLoginDetailsWindow(GeyserSession session) {        session.sendForm(                CustomForm.builder()                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())                        .title(\"geyser.auth.login.form.details.title\")                        .label(\"geyser.auth.login.form.details.desc\")                        .input(\"geyser.auth.login.form.details.email\", \"account@geysermc.org\", \"\")                        .input(\"geyser.auth.login.form.details.pass\", \"123456\", \"\")                        .responseHandler((form, responseData) -> {                            CustomFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowLoginDetailsWindow(session);                                return;                            }                            session.authenticate(response.next(), response.next());                        }));    }    public static void buildAndShowMicrosoftAuthenticationWindow(GeyserSession session) {        session.sendForm(                SimpleForm.builder()                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())                        .title(\"geyser.auth.login.form.notice.btn_login.microsoft\")                        .button(\"geyser.auth.login.method.browser\")                        .button(\"geyser.auth.login.method.password\")                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")                        .responseHandler((form, responseData) -> {                            SimpleFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowLoginWindow(session);                                return;                            }                            if (response.getClickedButtonId() == 0) {                                session.authenticateWithMicrosoftCode();                            } else if (response.getClickedButtonId() == 1) {                                buildAndShowLoginDetailsWindow(session);                            } else {                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));                            }                        }));    }    public static void buildAndShowMicrosoftCodeWindow(GeyserSession session, MsaAuthenticationService.MsCodeResponse msCode) {        session.sendForm(                ModalForm.builder()                        .title(\"%xbox.signin\")                        .content(\"%xbox.signin.website\\n%xbox.signin.url\\n%xbox.signin.enterCode\\n\" + msCode.user_code)                        .button1(\"%gui.done\")                        .button2(\"%menu.disconnect\")                        .responseHandler((form, responseData) -> {                            ModalFormResponse response = form.parseResponse(responseData);                            if (!response.isCorrect()) {                                buildAndShowMicrosoftAuthenticationWindow(session);                                return;                            }                            if (response.getClickedButtonId() == 1) {                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));                            }                        })        );    }}"}
{"code": "import java.io.File;import java.io.IOException;import java.util.Date;import java.util.List;import java.util.Locale;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;import org.apache.commons.io.IOUtils;import org.apache.logging.log4j.Logger;import org.olat.basesecurity.GroupRoles;import org.olat.core.gui.UserRequest;import org.olat.core.gui.components.stack.BreadcrumbPanel;import org.olat.core.gui.control.Controller;import org.olat.core.gui.control.WindowControl;import org.olat.core.gui.control.generic.tabbable.TabbableController;import org.olat.core.id.Identity;import org.olat.core.id.Organisation;import org.olat.core.logging.Tracing;import org.olat.core.util.ExportUtil;import org.olat.core.util.FileUtils;import org.olat.core.util.Formatter;import org.olat.core.util.StringHelper;import org.olat.core.util.Util;import org.olat.core.util.ValidationStatus;import org.olat.core.util.WebappHelper;import org.olat.core.util.ZipUtil;import org.olat.core.util.nodes.INode;import org.olat.core.util.xml.XStreamHelper;import org.olat.course.CourseFactory;import org.olat.course.ICourse;import org.olat.course.condition.Condition;import org.olat.course.condition.ConditionEditController;import org.olat.course.editor.ConditionAccessEditConfig;import org.olat.course.editor.CourseEditorEnv;import org.olat.course.editor.NodeEditController;import org.olat.course.editor.StatusDescription;import org.olat.course.groupsandrights.CourseGroupManager;import org.olat.course.groupsandrights.CourseRights;import org.olat.course.nodes.AbstractAccessableCourseNode;import org.olat.course.nodes.ArchiveOptions;import org.olat.course.nodes.CourseNode;import org.olat.course.nodes.StatusDescriptionHelper;import org.olat.course.nodes.TitledWrapperHelper;import org.olat.course.properties.CoursePropertyManager;import org.olat.course.run.navigation.NodeRunConstructionResult;import org.olat.course.run.userview.CourseNodeSecurityCallback;import org.olat.course.run.userview.UserCourseEnvironment;import org.olat.modules.ModuleConfiguration;import org.olat.properties.Property;import org.olat.repository.RepositoryEntry;import org.olat.util.logging.activity.LoggingResourceable;import com.thoughtworks.xstream.XStream;import de.bps.course.nodes.cl.ChecklistEditController;import de.bps.olat.modules.cl.Checklist;import de.bps.olat.modules.cl.ChecklistDisplayController;import de.bps.olat.modules.cl.ChecklistManager;import de.bps.olat.modules.cl.Checkpoint;import de.bps.olat.modules.cl.CheckpointMode;public class ChecklistCourseNode extends AbstractAccessableCourseNode {private static final long serialVersionUID = -8978938639489414749L;private static final Logger log = Tracing.createLoggerFor(ChecklistCourseNode.class);private static final String TYPE = \"cl\";public static final String CONF_COURSE_ID = \"cl_course_id\";public static final String CONF_COURSE_NODE_ID = \"cl_course_node_id\";public static final String CONF_CHECKLIST = \"cl_checklist\";public static final String CONF_CHECKLIST_COPY = \"cl_checklist_copy\";public static final String PROPERTY_CHECKLIST_KEY = CONF_CHECKLIST;public ChecklistCourseNode() {this(null);}public ChecklistCourseNode(INode parent) {super(TYPE, parent);initDefaultConfig();}private void initDefaultConfig() {ModuleConfiguration config = getModuleConfiguration();if (config.get(CONF_CHECKLIST) == null) {Checklist initialChecklist = new Checklist();config.set(CONF_CHECKLIST, initialChecklist);ChecklistManager.getInstance().saveChecklist(initialChecklist);}}private void setChecklistKey(final CoursePropertyManager cpm, Long checklistKey) {Property checklistKeyProperty = cpm.createCourseNodePropertyInstance(this, null, null, PROPERTY_CHECKLIST_KEY, null, checklistKey, null, null);cpm.saveProperty(checklistKeyProperty);getModuleConfiguration().set(CONF_CHECKLIST, ChecklistManager.getInstance().loadChecklist(checklistKey));}private Long getChecklistKey(final CoursePropertyManager cpm) {Property checklistKeyProperty = cpm.findCourseNodeProperty(this, null, null, PROPERTY_CHECKLIST_KEY);return checklistKeyProperty != null ? checklistKeyProperty.getLongValue() : null;}private void deleteChecklistKeyConf(final CoursePropertyManager cpm) {cpm.deleteNodeProperties(this, PROPERTY_CHECKLIST_KEY);getModuleConfiguration().remove(CONF_CHECKLIST);}public Checklist loadOrCreateChecklist(final CoursePropertyManager cpm) {Checklist checklist;if(getChecklistKey(cpm) == null) {if(getModuleConfiguration().get(CONF_CHECKLIST_COPY) != null) {checklist = ChecklistManager.getInstance().loadChecklist((Checklist) getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST_COPY));getModuleConfiguration().remove(CONF_CHECKLIST_COPY);} else if(getModuleConfiguration().get(CONF_CHECKLIST) != null) {Checklist confChecklist = (Checklist)getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST);Checklist orgChecklist = ChecklistManager.getInstance().loadChecklist(confChecklist);checklist = ChecklistManager.getInstance().copyChecklist(orgChecklist);} else {checklist = new Checklist();ChecklistManager.getInstance().saveChecklist(checklist);}setChecklistKey(cpm, checklist.getKey());} else {checklist = ChecklistManager.getInstance().loadChecklist(getChecklistKey(cpm));}return checklist;}@Overridepublic TabbableController createEditController(UserRequest ureq, WindowControl wControl, BreadcrumbPanel stackPanel, ICourse course, UserCourseEnvironment euce) {CourseNode chosenNode = course.getEditorTreeModel().getCourseNode(euce.getCourseEditorEnv().getCurrentCourseNodeId());ChecklistEditController editController = new ChecklistEditController(ureq, wControl, this, course);getModuleConfiguration().set(CONF_COURSE_ID, course.getResourceableId());getModuleConfiguration().set(CONF_COURSE_NODE_ID, chosenNode.getIdent());NodeEditController nodeEditController = new NodeEditController(ureq, wControl, course, chosenNode, euce, editController);nodeEditController.addControllerListener(editController);return nodeEditController;}@Overridepublic ConditionAccessEditConfig getAccessEditConfig() {return ConditionAccessEditConfig.regular(false);}@Overridepublic NodeRunConstructionResult createNodeRunConstructionResult(UserRequest ureq, WindowControl wControl,UserCourseEnvironment userCourseEnv, CourseNodeSecurityCallback nodeSecCallback, String nodecmd) {ICourse course = CourseFactory.loadCourse(userCourseEnv.getCourseEnvironment().getCourseResourceableId());CourseGroupManager cgm = course.getCourseEnvironment().getCourseGroupManager();boolean canEdit = userCourseEnv.isAdmin();boolean canManage;if(canEdit) {canManage = true;} else {GroupRoles role = GroupRoles.owner;if (userCourseEnv.isParticipant()) {role = GroupRoles.participant;} else if (userCourseEnv.isCoach()) {role = GroupRoles.coach;}canManage = userCourseEnv.isCoach() || cgm.hasRight(ureq.getIdentity(), CourseRights.RIGHT_GROUPMANAGEMENT, role);}Checklist checklist = loadOrCreateChecklist(userCourseEnv.getCourseEnvironment().getCoursePropertyManager());ChecklistDisplayController checkController = new ChecklistDisplayController(ureq, wControl, checklist,canEdit, canManage, userCourseEnv.isCourseReadOnly(), course);checkController.addLoggingResourceable(LoggingResourceable.wrap(this));Controller controller = TitledWrapperHelper.getWrapper(ureq, wControl, checkController, this, \"o_cl_icon\");return new NodeRunConstructionResult(controller);}@Overridepublic StatusDescription[] isConfigValid(CourseEditorEnv cev) {oneClickStatusCache = null;String translatorStr = Util.getPackageName(ConditionEditController.class);List<StatusDescription> statusDescs = isConfigValidWithTranslator(cev, translatorStr, getConditionExpressions());oneClickStatusCache = StatusDescriptionHelper.sort(statusDescs);return oneClickStatusCache;}@Overridepublic RepositoryEntry getReferencedRepositoryEntry() {return null;}@Overridepublic StatusDescription isConfigValid() {if (oneClickStatusCache != null) { return oneClickStatusCache[0]; }StatusDescription sd = StatusDescription.NOERROR;String transPackage = ChecklistEditController.class.getPackage().getName();if(getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST) == null) {sd = new StatusDescription(ValidationStatus.ERROR, \"config.nocheckpoints.short\", \"config.nocheckpoints.long\", null, transPackage);sd.setDescriptionForUnit(getIdent());sd.setActivateableViewIdentifier(ChecklistEditController.PANE_TAB_CLCONFIG);return sd;}Checklist checklist = (Checklist) getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST);if (!checklist.hasCheckpoints()) {sd = new StatusDescription(ValidationStatus.ERROR, \"config.nocheckpoints.short\", \"config.nocheckpoints.long\", null, transPackage);sd.setDescriptionForUnit(getIdent());sd.setActivateableViewIdentifier(ChecklistEditController.PANE_TAB_CLCONFIG);return sd;}boolean allUnvisible = true;boolean noLearners = false;if (checklist.hasCheckpoints()) {List<Checkpoint> checkpoints = ((Checklist)getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST)).getCheckpoints();for (Checkpoint checkpoint : checkpoints) {if (!checkpoint.getMode().equals(CheckpointMode.MODE_HIDDEN)) allUnvisible = false;}if(allUnvisible) {Condition cond = getPreConditionVisibility();if(cond.isEasyModeCoachesAndAdmins()) noLearners = true;if(!noLearners) {sd = new StatusDescription(ValidationStatus.WARNING, \"config.allhidden.short\", \"config.allhidden.long\", null, transPackage);sd.setDescriptionForUnit(getIdent());sd.setActivateableViewIdentifier(ChecklistEditController.PANE_TAB_CLCONFIG);}}}return sd;}@Overridepublic boolean needsReferenceToARepositoryEntry() {return false;}@Overridepublic void cleanupOnDelete(ICourse course) {super.cleanupOnDelete(course);Checklist checklist = loadOrCreateChecklist(course.getCourseEnvironment().getCoursePropertyManager());ChecklistManager.getInstance().deleteChecklist(checklist);deleteChecklistKeyConf(course.getCourseEnvironment().getCoursePropertyManager());}@Overridepublic void exportNode(File exportDirectory, ICourse course) {XStream xstream = XStreamHelper.createXStreamInstance();XStreamHelper.allowDefaultPackage(xstream);ChecklistManager cm = ChecklistManager.getInstance();Checklist checklist = loadOrCreateChecklist(course.getCourseEnvironment().getCoursePropertyManager());Checklist copy = cm.copyChecklistInRAM(checklist);String exportContent = xstream.toXML(copy);ExportUtil.writeContentToFile(getExportFilename(), exportContent, exportDirectory, WebappHelper.getDefaultCharset());}@Overridepublic void importNode(File importDirectory, ICourse course, Identity owner, Organisation organisation, Locale locale, boolean withReferences) {CoursePropertyManager cpm = course.getCourseEnvironment().getCoursePropertyManager();if(getChecklistKey(cpm) != null) deleteChecklistKeyConf(cpm);File importFile = new File(importDirectory, getExportFilename());String importContent = FileUtils.load(importFile, WebappHelper.getDefaultCharset());if(importContent == null || importContent.isEmpty()) {return;}XStream xstream = XStreamHelper.createXStreamInstance();XStreamHelper.allowDefaultPackage(xstream);Checklist checklist = (Checklist) xstream.fromXML(importContent);if(checklist != null) {checklist = ChecklistManager.getInstance().copyChecklist(checklist);setChecklistKey(cpm, checklist.getKey());}}@Overridepublic boolean archiveNodeData(Locale locale, ICourse course, ArchiveOptions options,ZipOutputStream exportStream, String archivePath, String charset) {String filename = \"checklist_\"+ StringHelper.transformDisplayNameToFileSystemName(getShortName())+ \"_\" + Formatter.formatDatetimeFilesystemSave(new Date(System.currentTimeMillis()));filename = ZipUtil.concat(archivePath, filename);Checklist checklist = loadOrCreateChecklist(course.getCourseEnvironment().getCoursePropertyManager());XStream xstream = XStreamHelper.createXStreamInstance();XStreamHelper.allowDefaultPackage(xstream);String exportContent = xstream.toXML(checklist);try {exportStream.putNextEntry(new ZipEntry(filename));IOUtils.write(exportContent, exportStream, \"UTF-8\");exportStream.closeEntry();} catch (IOException e) {log.error(\"\", e);}return true;}private String getExportFilename() {return \"checklist_\"+this.getIdent()+\".xml\";}@Overridepublic CourseNode createInstanceForCopy(boolean isNewTitle, ICourse course, Identity author) {CourseNode copyInstance = super.createInstanceForCopy(isNewTitle, course, author);ChecklistManager cm = ChecklistManager.getInstance();Checklist checklist = cm.loadChecklist((Checklist) getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST));copyInstance.getModuleConfiguration().remove(ChecklistCourseNode.CONF_CHECKLIST);Checklist initialChecklist = cm.copyChecklist(checklist);copyInstance.getModuleConfiguration().set(CONF_CHECKLIST_COPY, initialChecklist);return copyInstance;}}", "nl": "import java.io.File;import java.io.IOException;import java.util.Date;import java.util.List;import java.util.Locale;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;import org.apache.commons.io.IOUtils;import org.apache.logging.log4j.Logger;import org.olat.basesecurity.GroupRoles;import org.olat.core.gui.UserRequest;import org.olat.core.gui.components.stack.BreadcrumbPanel;import org.olat.core.gui.control.Controller;import org.olat.core.gui.control.WindowControl;import org.olat.core.gui.control.generic.tabbable.TabbableController;import org.olat.core.id.Identity;import org.olat.core.id.Organisation;import org.olat.core.logging.Tracing;import org.olat.core.util.ExportUtil;import org.olat.core.util.FileUtils;import org.olat.core.util.Formatter;import org.olat.core.util.StringHelper;import org.olat.core.util.Util;import org.olat.core.util.ValidationStatus;import org.olat.core.util.WebappHelper;import org.olat.core.util.ZipUtil;import org.olat.core.util.nodes.INode;import org.olat.core.util.xml.XStreamHelper;import org.olat.course.CourseFactory;import org.olat.course.ICourse;import org.olat.course.condition.Condition;import org.olat.course.condition.ConditionEditController;import org.olat.course.editor.ConditionAccessEditConfig;import org.olat.course.editor.CourseEditorEnv;import org.olat.course.editor.NodeEditController;import org.olat.course.editor.StatusDescription;import org.olat.course.groupsandrights.CourseGroupManager;import org.olat.course.groupsandrights.CourseRights;import org.olat.course.nodes.AbstractAccessableCourseNode;import org.olat.course.nodes.ArchiveOptions;import org.olat.course.nodes.CourseNode;import org.olat.course.nodes.StatusDescriptionHelper;import org.olat.course.nodes.TitledWrapperHelper;import org.olat.course.properties.CoursePropertyManager;import org.olat.course.run.navigation.NodeRunConstructionResult;import org.olat.course.run.userview.CourseNodeSecurityCallback;import org.olat.course.run.userview.UserCourseEnvironment;import org.olat.modules.ModuleConfiguration;import org.olat.properties.Property;import org.olat.repository.RepositoryEntry;import org.olat.util.logging.activity.LoggingResourceable;import com.thoughtworks.xstream.XStream;import de.bps.course.nodes.cl.ChecklistEditController;import de.bps.olat.modules.cl.Checklist;import de.bps.olat.modules.cl.ChecklistDisplayController;import de.bps.olat.modules.cl.ChecklistManager;import de.bps.olat.modules.cl.Checkpoint;import de.bps.olat.modules.cl.CheckpointMode;public class ChecklistCourseNode extends AbstractAccessableCourseNode {private static final long serialVersionUID = -8978938639489414749L;private static final Logger log = Tracing.createLoggerFor(ChecklistCourseNode.class);private static final String TYPE = \"cl\";public static final String CONF_COURSE_ID = \"cl_course_id\";public static final String CONF_COURSE_NODE_ID = \"cl_course_node_id\";public static final String CONF_CHECKLIST = \"cl_checklist\";public static final String CONF_CHECKLIST_COPY = \"cl_checklist_copy\";public static final String PROPERTY_CHECKLIST_KEY = CONF_CHECKLIST;public ChecklistCourseNode() {this(null);}public ChecklistCourseNode(INode parent) {super(TYPE, parent);initDefaultConfig();}private void initDefaultConfig() {ModuleConfiguration config = getModuleConfiguration();if (config.get(CONF_CHECKLIST) == null) {Checklist initialChecklist = new Checklist();config.set(CONF_CHECKLIST, initialChecklist);ChecklistManager.getInstance().saveChecklist(initialChecklist);}}private void setChecklistKey(final CoursePropertyManager cpm, Long checklistKey) {Property checklistKeyProperty = cpm.createCourseNodePropertyInstance(this, null, null, PROPERTY_CHECKLIST_KEY, null, checklistKey, null, null);cpm.saveProperty(checklistKeyProperty);getModuleConfiguration().set(CONF_CHECKLIST, ChecklistManager.getInstance().loadChecklist(checklistKey));}private Long getChecklistKey(final CoursePropertyManager cpm) {Property checklistKeyProperty = cpm.findCourseNodeProperty(this, null, null, PROPERTY_CHECKLIST_KEY);return checklistKeyProperty != null ? checklistKeyProperty.getLongValue() : null;}private void deleteChecklistKeyConf(final CoursePropertyManager cpm) {cpm.deleteNodeProperties(this, PROPERTY_CHECKLIST_KEY);getModuleConfiguration().remove(CONF_CHECKLIST);}public Checklist loadOrCreateChecklist(final CoursePropertyManager cpm) {Checklist checklist;if(getChecklistKey(cpm) == null) {if(getModuleConfiguration().get(CONF_CHECKLIST_COPY) != null) {checklist = ChecklistManager.getInstance().loadChecklist((Checklist) getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST_COPY));getModuleConfiguration().remove(CONF_CHECKLIST_COPY);} else if(getModuleConfiguration().get(CONF_CHECKLIST) != null) {Checklist confChecklist = (Checklist)getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST);Checklist orgChecklist = ChecklistManager.getInstance().loadChecklist(confChecklist);checklist = ChecklistManager.getInstance().copyChecklist(orgChecklist);} else {checklist = new Checklist();ChecklistManager.getInstance().saveChecklist(checklist);}setChecklistKey(cpm, checklist.getKey());} else {checklist = ChecklistManager.getInstance().loadChecklist(getChecklistKey(cpm));}return checklist;}@Overridepublic TabbableController createEditController(UserRequest ureq, WindowControl wControl, BreadcrumbPanel stackPanel, ICourse course, UserCourseEnvironment euce) {CourseNode chosenNode = course.getEditorTreeModel().getCourseNode(euce.getCourseEditorEnv().getCurrentCourseNodeId());ChecklistEditController editController = new ChecklistEditController(ureq, wControl, this, course);getModuleConfiguration().set(CONF_COURSE_ID, course.getResourceableId());getModuleConfiguration().set(CONF_COURSE_NODE_ID, chosenNode.getIdent());NodeEditController nodeEditController = new NodeEditController(ureq, wControl, course, chosenNode, euce, editController);nodeEditController.addControllerListener(editController);return nodeEditController;}@Overridepublic ConditionAccessEditConfig getAccessEditConfig() {return ConditionAccessEditConfig.regular(false);}@Overridepublic NodeRunConstructionResult createNodeRunConstructionResult(UserRequest ureq, WindowControl wControl,UserCourseEnvironment userCourseEnv, CourseNodeSecurityCallback nodeSecCallback, String nodecmd) {ICourse course = CourseFactory.loadCourse(userCourseEnv.getCourseEnvironment().getCourseResourceableId());CourseGroupManager cgm = course.getCourseEnvironment().getCourseGroupManager();boolean canEdit = userCourseEnv.isAdmin();boolean canManage;if(canEdit) {canManage = true;} else {GroupRoles role = GroupRoles.owner;if (userCourseEnv.isParticipant()) {role = GroupRoles.participant;} else if (userCourseEnv.isCoach()) {role = GroupRoles.coach;}canManage = userCourseEnv.isCoach() || cgm.hasRight(ureq.getIdentity(), CourseRights.RIGHT_GROUPMANAGEMENT, role);}Checklist checklist = loadOrCreateChecklist(userCourseEnv.getCourseEnvironment().getCoursePropertyManager());ChecklistDisplayController checkController = new ChecklistDisplayController(ureq, wControl, checklist,canEdit, canManage, userCourseEnv.isCourseReadOnly(), course);checkController.addLoggingResourceable(LoggingResourceable.wrap(this));Controller controller = TitledWrapperHelper.getWrapper(ureq, wControl, checkController, this, \"o_cl_icon\");return new NodeRunConstructionResult(controller);}@Overridepublic StatusDescription[] isConfigValid(CourseEditorEnv cev) {oneClickStatusCache = null;String translatorStr = Util.getPackageName(ConditionEditController.class);List<StatusDescription> statusDescs = isConfigValidWithTranslator(cev, translatorStr, getConditionExpressions());oneClickStatusCache = StatusDescriptionHelper.sort(statusDescs);return oneClickStatusCache;}@Overridepublic RepositoryEntry getReferencedRepositoryEntry() {return null;}@Overridepublic StatusDescription isConfigValid() {if (oneClickStatusCache != null) { return oneClickStatusCache[0]; }StatusDescription sd = StatusDescription.NOERROR;String transPackage = ChecklistEditController.class.getPackage().getName();if(getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST) == null) {sd = new StatusDescription(ValidationStatus.ERROR, \"config.nocheckpoints.short\", \"config.nocheckpoints.long\", null, transPackage);sd.setDescriptionForUnit(getIdent());sd.setActivateableViewIdentifier(ChecklistEditController.PANE_TAB_CLCONFIG);return sd;}Checklist checklist = (Checklist) getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST);if (!checklist.hasCheckpoints()) {sd = new StatusDescription(ValidationStatus.ERROR, \"config.nocheckpoints.short\", \"config.nocheckpoints.long\", null, transPackage);sd.setDescriptionForUnit(getIdent());sd.setActivateableViewIdentifier(ChecklistEditController.PANE_TAB_CLCONFIG);return sd;}boolean allUnvisible = true;boolean noLearners = false;if (checklist.hasCheckpoints()) {List<Checkpoint> checkpoints = ((Checklist)getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST)).getCheckpoints();for (Checkpoint checkpoint : checkpoints) {if (!checkpoint.getMode().equals(CheckpointMode.MODE_HIDDEN)) allUnvisible = false;}if(allUnvisible) {Condition cond = getPreConditionVisibility();if(cond.isEasyModeCoachesAndAdmins()) noLearners = true;if(!noLearners) {sd = new StatusDescription(ValidationStatus.WARNING, \"config.allhidden.short\", \"config.allhidden.long\", null, transPackage);sd.setDescriptionForUnit(getIdent());sd.setActivateableViewIdentifier(ChecklistEditController.PANE_TAB_CLCONFIG);}}}return sd;}@Overridepublic boolean needsReferenceToARepositoryEntry() {return false;}@Overridepublic void cleanupOnDelete(ICourse course) {super.cleanupOnDelete(course);Checklist checklist = loadOrCreateChecklist(course.getCourseEnvironment().getCoursePropertyManager());ChecklistManager.getInstance().deleteChecklist(checklist);deleteChecklistKeyConf(course.getCourseEnvironment().getCoursePropertyManager());}@Overridepublic void exportNode(File exportDirectory, ICourse course) {XStream xstream = XStreamHelper.createXStreamInstance();ChecklistManager cm = ChecklistManager.getInstance();Checklist checklist = loadOrCreateChecklist(course.getCourseEnvironment().getCoursePropertyManager());Checklist copy = cm.copyChecklistInRAM(checklist);String exportContent = xstream.toXML(copy);ExportUtil.writeContentToFile(getExportFilename(), exportContent, exportDirectory, WebappHelper.getDefaultCharset());}@Overridepublic void importNode(File importDirectory, ICourse course, Identity owner, Organisation organisation, Locale locale, boolean withReferences) {CoursePropertyManager cpm = course.getCourseEnvironment().getCoursePropertyManager();if(getChecklistKey(cpm) != null) deleteChecklistKeyConf(cpm);File importFile = new File(importDirectory, getExportFilename());String importContent = FileUtils.load(importFile, WebappHelper.getDefaultCharset());if(importContent == null || importContent.isEmpty()) {return;}XStream xstream = XStreamHelper.createXStreamInstance();Checklist checklist = (Checklist) xstream.fromXML(importContent);if(checklist != null) {checklist = ChecklistManager.getInstance().copyChecklist(checklist);setChecklistKey(cpm, checklist.getKey());}}@Overridepublic boolean archiveNodeData(Locale locale, ICourse course, ArchiveOptions options,ZipOutputStream exportStream, String archivePath, String charset) {String filename = \"checklist_\"+ StringHelper.transformDisplayNameToFileSystemName(getShortName())+ \"_\" + Formatter.formatDatetimeFilesystemSave(new Date(System.currentTimeMillis()));filename = ZipUtil.concat(archivePath, filename);Checklist checklist = loadOrCreateChecklist(course.getCourseEnvironment().getCoursePropertyManager());String exportContent = XStreamHelper.createXStreamInstance().toXML(checklist);try {exportStream.putNextEntry(new ZipEntry(filename));IOUtils.write(exportContent, exportStream, \"UTF-8\");exportStream.closeEntry();} catch (IOException e) {log.error(\"\", e);}return true;}private String getExportFilename() {return \"checklist_\"+this.getIdent()+\".xml\";}@Overridepublic CourseNode createInstanceForCopy(boolean isNewTitle, ICourse course, Identity author) {CourseNode copyInstance = super.createInstanceForCopy(isNewTitle, course, author);ChecklistManager cm = ChecklistManager.getInstance();Checklist checklist = cm.loadChecklist((Checklist) getModuleConfiguration().get(ChecklistCourseNode.CONF_CHECKLIST));copyInstance.getModuleConfiguration().remove(ChecklistCourseNode.CONF_CHECKLIST);Checklist initialChecklist = cm.copyChecklist(checklist);copyInstance.getModuleConfiguration().set(CONF_CHECKLIST_COPY, initialChecklist);return copyInstance;}}"}
{"code": "import java.io.File;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.UUID;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.olat.core.gui.UserRequest;import org.olat.core.gui.components.Component;import org.olat.core.gui.control.Controller;import org.olat.core.gui.control.WindowControl;import org.olat.core.gui.control.generic.portal.AbstractPortlet;import org.olat.core.gui.control.generic.portal.Portlet;import org.olat.core.logging.AssertException;import org.apache.logging.log4j.Logger;import org.olat.core.logging.Tracing;import org.olat.core.util.FileUtils;import org.olat.core.util.StringHelper;import org.olat.core.util.Util;import org.olat.core.util.WebappHelper;import org.olat.core.util.xml.XStreamHelper;import com.thoughtworks.xstream.XStream;public class LinksPortlet extends AbstractPortlet {private static final Logger log = Tracing.createLoggerFor(LinksPortlet.class);private String cssWrapperClass = \"o_portlet_links\";protected static final String LANG_ALL = \"*\";protected static final String LANG_DE = \"de\";protected static final String LANG_EN = \"en\";protected static final String ACCESS_GUEST = \"-\";protected static final String ACCESS_REG = \"+\";protected static final String ACCESS_ALL = \"*\";private static final String CONFIG_FILE = \"/WEB-INF/olat_portals_links.xml\";private static final String ELEM_INSTITUTION = \"University\";private static final String ATTR_INSTITUTION_NAME = \"name\";private static final String ELEM_LINK = \"Link\";private static final String ELEM_LINK_TITLE = \"Title\";private static final String ELEM_LINK_URL = \"URL\";private static final String ELEM_LINK_DESC = \"Description\";private static final String ELEM_LINK_IDENT = \"Identifier\";private static final String ELEM_LINK_TARGET = \"Target\";private static final String ELEM_LINK_LANG = \"Language\";private static final XStream xstream = XStreamHelper.createXStreamInstance();static {XStreamHelper.allowDefaultPackage(xstream);xstream.alias(\"LinksPortlet\", Map.class);xstream.alias(ELEM_LINK, PortletLink.class);xstream.alias(ELEM_INSTITUTION, PortletInstitution.class);xstream.aliasAttribute(PortletInstitution.class, ATTR_INSTITUTION_NAME, ATTR_INSTITUTION_NAME);}private static HashMap<String, PortletInstitution> content;private static File fxConfXStreamFile;private Controller runCtr;public Portlet createInstance(WindowControl wControl, UserRequest ureq, Map<String,String> configuration) {if(content == null) init();LinksPortlet p = new LinksPortlet();p.setName(this.getName());p.setConfiguration(configuration);p.setTranslator(Util.createPackageTranslator(LinksPortlet.class, ureq.getLocale()));String cssClass = configuration.get(\"cssWrapperClass\");if (cssClass != null) p.setCssWrapperClass(cssClass);return p;}private static void init() {log.debug(\"START: Loading remote portlets content.\");File configurationFile = new File(WebappHelper.getContextRealPath(CONFIG_FILE));File fxConfFolder = new File(WebappHelper.getUserDataRoot() + \"/customizing/linksPortlet\");if (!fxConfFolder.exists()) {fxConfFolder.mkdir();}File fxConfFile = new File(fxConfFolder + \"/olat_portals_links.xml\");fxConfXStreamFile = new File(fxConfFolder + \"/olat_portals_xstream.xml\");if (!fxConfFile.exists() && !fxConfXStreamFile.exists()) {try {if(fxConfFile.createNewFile()) {FileUtils.copyFileToFile(configurationFile, fxConfFile, false);log.info(\"portal links portlet: copied initial config from \" + CONFIG_FILE);}} catch (IOException e) {new AssertException(\"could not copy an initial portal links config to olatdata\", e);}}HashMap<String, PortletInstitution> portletMap = new HashMap<>();if (!fxConfXStreamFile.exists()){try {SAXReader reader = SAXReader.createDefault();;Document doc = reader.read(fxConfFile);Element rootElement = doc.getRootElement();List<Element> lstInst = rootElement.elements(ELEM_INSTITUTION);for( Element instElem : lstInst ) {String inst = instElem.attributeValue(ATTR_INSTITUTION_NAME);List<Element> lstTmpLinks = instElem.elements(ELEM_LINK);List<PortletLink> lstLinks = new ArrayList<>(lstTmpLinks.size());for( Element linkElem: lstTmpLinks ) {String title = linkElem.elementText(ELEM_LINK_TITLE);String url = linkElem.elementText(ELEM_LINK_URL);String target = linkElem.elementText(ELEM_LINK_TARGET);String lang = linkElem.elementText(ELEM_LINK_LANG);String desc = linkElem.elementText(ELEM_LINK_DESC);String identifier = linkElem.elementText(ELEM_LINK_IDENT);lstLinks.add(new PortletLink(title, url, target, lang, desc, identifier));}portletMap.put(inst, new PortletInstitution(inst, lstLinks));}} catch (Exception e) {log.error(\"Error reading configuration file\", e);} finally {content = portletMap;}saveLinkList(content);FileUtils.copyFileToFile(fxConfFile, new File(fxConfFile + \".bak\"), true);} else {content = (HashMap<String, PortletInstitution>) XStreamHelper.readObject(xstream, fxConfXStreamFile);}}public static boolean saveLinkList(Map<String, PortletInstitution> portletMap){XStreamHelper.writeObject(xstream, fxConfXStreamFile, portletMap);return true;}public static PortletLink getLinkByIdentifier(String identifier){for (Iterator<String> iterator = content.keySet().iterator(); iterator.hasNext();) {String inst = iterator.next();PortletInstitution portletsForInst = content.get(inst);List<PortletLink> instLinks = portletsForInst.getLinks();for (PortletLink portletLink : instLinks) {if (portletLink.getIdentifier().equals(identifier)) return portletLink;}}return null;}public static void removeLink(PortletLink link){if (link == null) return;for (Iterator<String> iterator = content.keySet().iterator(); iterator.hasNext();) {String inst = iterator.next();PortletInstitution portletsForInst = content.get(inst);List<PortletLink> instLinks = portletsForInst.getLinks();for (PortletLink portletLink : instLinks) {if (portletLink.getIdentifier().equals(link.getIdentifier())) {instLinks.remove(link);break;}}}saveLinkList(content);}public static void updateLink(PortletLink link){if (link == null) return;for (Iterator<String> iterator = content.keySet().iterator(); iterator.hasNext();) {String inst = iterator.next();PortletInstitution portletsForInst = content.get(inst);List<PortletLink> instLinks = portletsForInst.getLinks();boolean existingLink = false;for (PortletLink portletLink : instLinks) {if (portletLink.getIdentifier().equals(link.getIdentifier())) {portletLink = link;existingLink = true;break;} }if (!existingLink && portletsForInst == link.getInstitution()) {portletsForInst.addLink(link);break;}}saveLinkList(content);}public String getTitle() {return getTranslator().translate(\"portlet.title\");}public static void reInit(UserRequest ureq){content = null;init();}public String getDescription() {return getTranslator().translate(\"portlet.description\");}public Component getInitialRunComponent(WindowControl wControl, UserRequest ureq) {if(this.runCtr != null) runCtr.dispose();this.runCtr = new LinksPortletRunController(ureq, wControl);return runCtr.getInitialComponent();}public void dispose() {disposeRunComponent();}public String getCssClass() {return cssWrapperClass;}void setCssWrapperClass(String cssWrapperClass) {this.cssWrapperClass = cssWrapperClass;}public void disposeRunComponent() {if (runCtr != null) {runCtr.dispose();runCtr = null;}}public static Map<String, PortletInstitution> getContent() {return content;}}class PortletInstitution {private String name; private List<PortletLink> links;public PortletInstitution(String name) {this.name = name;this.links = new ArrayList<>();}public PortletInstitution(String name, List<PortletLink> links) {this.name = name;this.links = links;}public void addLink(PortletLink link) {links.add(link);}public String getName() {return name;}public void setName(String name) {this.name = name;}public List<PortletLink> getLinks() {return links;}public void setLinks(List<PortletLink> links) {this.links = links;}}class PortletLink {private String title, url, target, language, description;private String identifier;private transient PortletInstitution institution;public PortletLink(String title, String url, String target, String language, String description, String identifier) {setTitle(title);setUrl(url);setTarget(target);setLanguage(language);setDescription(description);setIdentifier(identifier);}public PortletInstitution getInstitution() {return institution;}public void setInstitution(PortletInstitution institution) {this.institution = institution;}public String getTitle() {return title;}public void setTitle(String title) {this.title = title;}public String getUrl() {return url;}public void setUrl(String url) {this.url = url;}public String getTarget() {return target;}public void setTarget(String target) {this.target = target;}public String getLanguage() {return language;}public void setLanguage(String language) {this.language = language;}public String getDescription() {return description;}public void setDescription(String description) {this.description = description;}public void setIdentifier(String identifier){if (identifier == null) {this.identifier = UUID.randomUUID().toString().replace(\"-\", \"\");} else {this.identifier = identifier;}}public String getIdentifier(){if (!StringHelper.containsNonWhitespace(identifier)){setIdentifier(null);}return identifier;}}", "nl": "import java.io.File;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.UUID;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.olat.core.gui.UserRequest;import org.olat.core.gui.components.Component;import org.olat.core.gui.control.Controller;import org.olat.core.gui.control.WindowControl;import org.olat.core.gui.control.generic.portal.AbstractPortlet;import org.olat.core.gui.control.generic.portal.Portlet;import org.olat.core.logging.AssertException;import org.apache.logging.log4j.Logger;import org.olat.core.logging.Tracing;import org.olat.core.util.FileUtils;import org.olat.core.util.StringHelper;import org.olat.core.util.Util;import org.olat.core.util.WebappHelper;import org.olat.core.util.xml.XStreamHelper;import com.thoughtworks.xstream.XStream;public class LinksPortlet extends AbstractPortlet {private static final Logger log = Tracing.createLoggerFor(LinksPortlet.class);private String cssWrapperClass = \"o_portlet_links\";protected static final String LANG_ALL = \"*\";protected static final String LANG_DE = \"de\";protected static final String LANG_EN = \"en\";protected static final String ACCESS_GUEST = \"-\";protected static final String ACCESS_REG = \"+\";protected static final String ACCESS_ALL = \"*\";private static final String CONFIG_FILE = \"/WEB-INF/olat_portals_links.xml\";private static final String ELEM_INSTITUTION = \"University\";private static final String ATTR_INSTITUTION_NAME = \"name\";private static final String ELEM_LINK = \"Link\";private static final String ELEM_LINK_TITLE = \"Title\";private static final String ELEM_LINK_URL = \"URL\";private static final String ELEM_LINK_DESC = \"Description\";private static final String ELEM_LINK_IDENT = \"Identifier\";private static final String ELEM_LINK_TARGET = \"Target\";private static final String ELEM_LINK_LANG = \"Language\";private static HashMap<String, PortletInstitution> content;private static File fxConfXStreamFile;private Controller runCtr;public Portlet createInstance(WindowControl wControl, UserRequest ureq, Map<String,String> configuration) {if(content == null) init();LinksPortlet p = new LinksPortlet();p.setName(this.getName());p.setConfiguration(configuration);p.setTranslator(Util.createPackageTranslator(LinksPortlet.class, ureq.getLocale()));String cssClass = configuration.get(\"cssWrapperClass\");if (cssClass != null) p.setCssWrapperClass(cssClass);return p;}private static void init() {log.debug(\"START: Loading remote portlets content.\");File configurationFile = new File(WebappHelper.getContextRealPath(CONFIG_FILE));File fxConfFolder = new File(WebappHelper.getUserDataRoot() + \"/customizing/linksPortlet\");if (!fxConfFolder.exists()) {fxConfFolder.mkdir();}File fxConfFile = new File(fxConfFolder + \"/olat_portals_links.xml\");fxConfXStreamFile = new File(fxConfFolder + \"/olat_portals_xstream.xml\");if (!fxConfFile.exists() && !fxConfXStreamFile.exists()) {try {if(fxConfFile.createNewFile()) {FileUtils.copyFileToFile(configurationFile, fxConfFile, false);log.info(\"portal links portlet: copied initial config from \" + CONFIG_FILE);}} catch (IOException e) {new AssertException(\"could not copy an initial portal links config to olatdata\", e);}}HashMap<String, PortletInstitution> portletMap = new HashMap<>();if (!fxConfXStreamFile.exists()){try {SAXReader reader = SAXReader.createDefault();;Document doc = reader.read(fxConfFile);Element rootElement = doc.getRootElement();List<Element> lstInst = rootElement.elements(ELEM_INSTITUTION);for( Element instElem : lstInst ) {String inst = instElem.attributeValue(ATTR_INSTITUTION_NAME);List<Element> lstTmpLinks = instElem.elements(ELEM_LINK);List<PortletLink> lstLinks = new ArrayList<>(lstTmpLinks.size());for( Element linkElem: lstTmpLinks ) {String title = linkElem.elementText(ELEM_LINK_TITLE);String url = linkElem.elementText(ELEM_LINK_URL);String target = linkElem.elementText(ELEM_LINK_TARGET);String lang = linkElem.elementText(ELEM_LINK_LANG);String desc = linkElem.elementText(ELEM_LINK_DESC);String identifier = linkElem.elementText(ELEM_LINK_IDENT);lstLinks.add(new PortletLink(title, url, target, lang, desc, identifier));}portletMap.put(inst, new PortletInstitution(inst, lstLinks));}} catch (Exception e) {log.error(\"Error reading configuration file\", e);} finally {content = portletMap;}saveLinkList(content);FileUtils.copyFileToFile(fxConfFile, new File(fxConfFile + \".bak\"), true);} else {XStream xstream = XStreamHelper.createXStreamInstance();xstream.alias(\"LinksPortlet\", Map.class);xstream.alias(ELEM_LINK, PortletLink.class);xstream.alias(ELEM_INSTITUTION, PortletInstitution.class);xstream.aliasAttribute(PortletInstitution.class, ATTR_INSTITUTION_NAME, ATTR_INSTITUTION_NAME);content = (HashMap<String, PortletInstitution>) XStreamHelper.readObject(xstream, fxConfXStreamFile);}}public static boolean saveLinkList(HashMap<String, PortletInstitution> portletMap){XStream xstream = XStreamHelper.createXStreamInstance();xstream.alias(\"LinksPortlet\", Map.class);xstream.alias(ELEM_LINK, PortletLink.class);xstream.alias(ELEM_INSTITUTION, PortletInstitution.class);xstream.aliasAttribute(PortletInstitution.class, ATTR_INSTITUTION_NAME, ATTR_INSTITUTION_NAME);String output = xstream.toXML(portletMap);XStreamHelper.writeObject(xstream, fxConfXStreamFile, portletMap);return (output.length() != 0);}public static PortletLink getLinkByIdentifier(String identifier){for (Iterator<String> iterator = content.keySet().iterator(); iterator.hasNext();) {String inst = iterator.next();PortletInstitution portletsForInst = content.get(inst);List<PortletLink> instLinks = portletsForInst.getLinks();for (PortletLink portletLink : instLinks) {if (portletLink.getIdentifier().equals(identifier)) return portletLink;}}return null;}public static void removeLink(PortletLink link){if (link == null) return;for (Iterator<String> iterator = content.keySet().iterator(); iterator.hasNext();) {String inst = iterator.next();PortletInstitution portletsForInst = content.get(inst);List<PortletLink> instLinks = portletsForInst.getLinks();for (PortletLink portletLink : instLinks) {if (portletLink.getIdentifier().equals(link.getIdentifier())) {instLinks.remove(link);break;}}}saveLinkList(content);}public static void updateLink(PortletLink link){if (link == null) return;for (Iterator<String> iterator = content.keySet().iterator(); iterator.hasNext();) {String inst = iterator.next();PortletInstitution portletsForInst = content.get(inst);List<PortletLink> instLinks = portletsForInst.getLinks();boolean existingLink = false;for (PortletLink portletLink : instLinks) {if (portletLink.getIdentifier().equals(link.getIdentifier())) {portletLink = link;existingLink = true;break;} }if (!existingLink && portletsForInst == link.getInstitution()) {portletsForInst.addLink(link);break;}}saveLinkList(content);}public String getTitle() {return getTranslator().translate(\"portlet.title\");}public static void reInit(UserRequest ureq){content = null;init();}public String getDescription() {return getTranslator().translate(\"portlet.description\");}public Component getInitialRunComponent(WindowControl wControl, UserRequest ureq) {if(this.runCtr != null) runCtr.dispose();this.runCtr = new LinksPortletRunController(ureq, wControl);return runCtr.getInitialComponent();}public void dispose() {disposeRunComponent();}public String getCssClass() {return cssWrapperClass;}void setCssWrapperClass(String cssWrapperClass) {this.cssWrapperClass = cssWrapperClass;}public void disposeRunComponent() {if (runCtr != null) {runCtr.dispose();runCtr = null;}}public static Map<String, PortletInstitution> getContent() {return content;}}class PortletInstitution {private String name; private List<PortletLink> links;public PortletInstitution(String name) {this.name = name;this.links = new ArrayList<>();}public PortletInstitution(String name, List<PortletLink> links) {this.name = name;this.links = links;}public void addLink(PortletLink link) {links.add(link);}public String getName() {return name;}public void setName(String name) {this.name = name;}public List<PortletLink> getLinks() {return links;}public void setLinks(List<PortletLink> links) {this.links = links;}}class PortletLink {private String title, url, target, language, description;private String identifier;private transient PortletInstitution institution;public PortletLink(String title, String url, String target, String language, String description, String identifier) {setTitle(title);setUrl(url);setTarget(target);setLanguage(language);setDescription(description);setIdentifier(identifier);}public PortletInstitution getInstitution() {return institution;}public void setInstitution(PortletInstitution institution) {this.institution = institution;}public String getTitle() {return title;}public void setTitle(String title) {this.title = title;}public String getUrl() {return url;}public void setUrl(String url) {this.url = url;}public String getTarget() {return target;}public void setTarget(String target) {this.target = target;}public String getLanguage() {return language;}public void setLanguage(String language) {this.language = language;}public String getDescription() {return description;}public void setDescription(String description) {this.description = description;}public void setIdentifier(String identifier){if (identifier == null) {this.identifier = UUID.randomUUID().toString().replace(\"-\", \"\");} else {this.identifier = identifier;}}public String getIdentifier(){if (!StringHelper.containsNonWhitespace(identifier)){setIdentifier(null);}return identifier;}}"}
{"code": "import java.util.HashMap;import org.olat.basesecurity.BaseSecurity;import org.olat.core.gui.UserRequest;import org.olat.core.gui.control.WindowControl;import org.olat.core.gui.translator.Translator;import org.olat.core.id.Identity;import org.olat.core.id.User;import org.olat.core.util.StringHelper;import org.olat.core.util.Util;import org.olat.core.util.xml.XStreamHelper;import org.olat.home.HomeMainController;import org.olat.login.SupportsAfterLoginInterceptor;import org.olat.user.ProfileAndHomePageEditController;import org.olat.user.UserManager;import org.springframework.beans.factory.annotation.Autowired;import com.thoughtworks.xstream.XStream;public class ChangeEMailExecuteController extends ChangeEMailController implements SupportsAfterLoginInterceptor {private static final String PRESENTED_EMAIL_CHANGE_REMINDER = \"presentedemailchangereminder\";protected static final String PACKAGE_HOME = ProfileAndHomePageEditController.class.getPackage().getName();@Autowiredprivate UserManager userManager;@Autowiredprivate BaseSecurity securityManager;public ChangeEMailExecuteController(UserRequest ureq, WindowControl wControl) {super(ureq, wControl);this.userRequest = ureq;pT = Util.createPackageTranslator(ProfileAndHomePageEditController.class, userRequest.getLocale());pT = userManager.getPropertyHandlerTranslator(pT);emKey = userRequest.getHttpReq().getParameter(\"key\");if (emKey == null) {emKey = userRequest.getIdentity().getUser().getProperty(\"emchangeKey\", null);}if (emKey != null) {tempKey = rm.loadTemporaryKeyByRegistrationKey(emKey);}}@Overridepublic boolean isUserInteractionRequired(UserRequest ureq) {User user = ureq.getIdentity().getUser();if(StringHelper.containsNonWhitespace(user.getProperty(\"emchangeKey\", null))) {if (isLinkTimeUp()) {deleteRegistrationKey();} else {if (isLinkClicked()) {changeEMail(getWindowControl());} else {    Boolean alreadySeen = ((Boolean)ureq.getUserSession().getEntry(PRESENTED_EMAIL_CHANGE_REMINDER));    if (alreadySeen == null) {    getWindowControl().setWarning(getPackageTranslator().translate(\"email.change.reminder\"));    ureq.getUserSession().putEntry(PRESENTED_EMAIL_CHANGE_REMINDER, Boolean.TRUE);    }}}} else {String value = user.getProperty(\"emailDisabled\", null);if (value != null && value.equals(\"true\")) {Translator translator = Util.createPackageTranslator(HomeMainController.class, ureq.getLocale());getWindowControl().setWarning(translator.translate(\"email.disabled\"));}}return false;}public boolean changeEMail(WindowControl wControl) {XStream xml = XStreamHelper.createXStreamInstance();XStreamHelper.allowDefaultPackage(xml);@SuppressWarnings(\"unchecked\")HashMap<String, String> mails = (HashMap<String, String>) xml.fromXML(tempKey.getEmailAddress());Identity identity = securityManager.loadIdentityByKey(tempKey.getIdentityKey());if (identity != null) {String oldEmail = identity.getUser().getEmail();identity.getUser().setProperty(\"email\", mails.get(\"changedEMail\"));String value = identity.getUser().getProperty(\"emailDisabled\", null);if (value != null && value.equals(\"true\")) {identity.getUser().setProperty(\"emailDisabled\", \"false\");}identity.getUser().setProperty(\"email\", mails.get(\"changedEMail\"));String currentEmailDisplay = userManager.getUserDisplayEmail(mails.get(\"currentEMail\"), userRequest.getLocale());String changedEmailDisplay = userManager.getUserDisplayEmail(mails.get(\"changedEMail\"), userRequest.getLocale());wControl.setInfo(pT.translate(\"success.change.email\", new String[] { currentEmailDisplay, changedEmailDisplay }));identity.getUser().setProperty(\"emchangeKey\", null);userRequest.getUserSession().removeEntryFromNonClearedStore(ChangeEMailController.CHANGE_EMAIL_ENTRY);securityManager.deleteInvalidAuthenticationsByEmail(oldEmail);} else {wControl.setWarning(pT.translate(\"error.change.email.unexpected\", new String[] { mails.get(\"currentEMail\"), mails.get(\"changedEMail\") }));}rm.deleteTemporaryKeyWithId(tempKey.getRegistrationKey());return true;}public boolean isLinkClicked() {Object entry = userRequest.getUserSession().getEntry(ChangeEMailController.CHANGE_EMAIL_ENTRY);return (entry != null);}public Translator getPackageTranslator() {return pT;}}", "nl": "import java.util.HashMap;import org.olat.basesecurity.BaseSecurity;import org.olat.core.gui.UserRequest;import org.olat.core.gui.control.WindowControl;import org.olat.core.gui.translator.Translator;import org.olat.core.id.Identity;import org.olat.core.id.User;import org.olat.core.util.StringHelper;import org.olat.core.util.Util;import org.olat.core.util.xml.XStreamHelper;import org.olat.home.HomeMainController;import org.olat.login.SupportsAfterLoginInterceptor;import org.olat.user.ProfileAndHomePageEditController;import org.olat.user.UserManager;import org.springframework.beans.factory.annotation.Autowired;import com.thoughtworks.xstream.XStream;public class ChangeEMailExecuteController extends ChangeEMailController implements SupportsAfterLoginInterceptor {private static final String PRESENTED_EMAIL_CHANGE_REMINDER = \"presentedemailchangereminder\";protected static final String PACKAGE_HOME = ProfileAndHomePageEditController.class.getPackage().getName();@Autowiredprivate UserManager userManager;@Autowiredprivate BaseSecurity securityManager;public ChangeEMailExecuteController(UserRequest ureq, WindowControl wControl) {super(ureq, wControl);this.userRequest = ureq;pT = Util.createPackageTranslator(ProfileAndHomePageEditController.class, userRequest.getLocale());pT = userManager.getPropertyHandlerTranslator(pT);emKey = userRequest.getHttpReq().getParameter(\"key\");if (emKey == null) {emKey = userRequest.getIdentity().getUser().getProperty(\"emchangeKey\", null);}if (emKey != null) {tempKey = rm.loadTemporaryKeyByRegistrationKey(emKey);}}@Overridepublic boolean isUserInteractionRequired(UserRequest ureq) {User user = ureq.getIdentity().getUser();if(StringHelper.containsNonWhitespace(user.getProperty(\"emchangeKey\", null))) {if (isLinkTimeUp()) {deleteRegistrationKey();} else {if (isLinkClicked()) {changeEMail(getWindowControl());} else {    Boolean alreadySeen = ((Boolean)ureq.getUserSession().getEntry(PRESENTED_EMAIL_CHANGE_REMINDER));    if (alreadySeen == null) {    getWindowControl().setWarning(getPackageTranslator().translate(\"email.change.reminder\"));    ureq.getUserSession().putEntry(PRESENTED_EMAIL_CHANGE_REMINDER, Boolean.TRUE);    }}}} else {String value = user.getProperty(\"emailDisabled\", null);if (value != null && value.equals(\"true\")) {Translator translator = Util.createPackageTranslator(HomeMainController.class, ureq.getLocale());getWindowControl().setWarning(translator.translate(\"email.disabled\"));}}return false;}public boolean changeEMail(WindowControl wControl) {XStream xml = XStreamHelper.createXStreamInstance();@SuppressWarnings(\"unchecked\")HashMap<String, String> mails = (HashMap<String, String>) xml.fromXML(tempKey.getEmailAddress());Identity identity = securityManager.loadIdentityByKey(tempKey.getIdentityKey());if (identity != null) {String oldEmail = identity.getUser().getEmail();identity.getUser().setProperty(\"email\", mails.get(\"changedEMail\"));String value = identity.getUser().getProperty(\"emailDisabled\", null);if (value != null && value.equals(\"true\")) {identity.getUser().setProperty(\"emailDisabled\", \"false\");}identity.getUser().setProperty(\"email\", mails.get(\"changedEMail\"));String currentEmailDisplay = userManager.getUserDisplayEmail(mails.get(\"currentEMail\"), userRequest.getLocale());String changedEmailDisplay = userManager.getUserDisplayEmail(mails.get(\"changedEMail\"), userRequest.getLocale());wControl.setInfo(pT.translate(\"success.change.email\", new String[] { currentEmailDisplay, changedEmailDisplay }));identity.getUser().setProperty(\"emchangeKey\", null);userRequest.getUserSession().removeEntryFromNonClearedStore(ChangeEMailController.CHANGE_EMAIL_ENTRY);securityManager.deleteInvalidAuthenticationsByEmail(oldEmail);} else {wControl.setWarning(pT.translate(\"error.change.email.unexpected\", new String[] { mails.get(\"currentEMail\"), mails.get(\"changedEMail\") }));}rm.deleteTemporaryKeyWithId(tempKey.getRegistrationKey());return true;}public boolean isLinkClicked() {Object entry = userRequest.getUserSession().getEntry(ChangeEMailController.CHANGE_EMAIL_ENTRY);return (entry != null);}public Translator getPackageTranslator() {return pT;}}"}
{"code": "import java.util.ArrayList;import org.olat.admin.landingpages.model.Rule;import org.olat.admin.landingpages.model.Rules;import org.olat.core.configuration.AbstractSpringModule;import org.olat.core.util.StringHelper;import org.olat.core.util.coordinate.CoordinatorManager;import org.olat.core.util.xml.XStreamHelper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.thoughtworks.xstream.XStream;@Service(\"landingPagesModule\")public class LandingPagesModule extends AbstractSpringModule {private static final String CONFIG_RULES = \"rules\";private static final XStream rulesXStream;static {rulesXStream = XStreamHelper.createXStreamInstance();XStreamHelper.allowDefaultPackage(rulesXStream);rulesXStream.alias(\"rules\", Rules.class);rulesXStream.alias(\"rule\", Rule.class);}private Rules rules;@Autowiredpublic LandingPagesModule(CoordinatorManager coordinatorManager) {super(coordinatorManager);}@Overridepublic void init() {String rulesObj = getStringPropertyValue(CONFIG_RULES, true);if(StringHelper.containsNonWhitespace(rulesObj)) {rules = (Rules)rulesXStream.fromXML(rulesObj);} else {rules = new Rules();rules.setRules(new ArrayList<>(1));}}@Overrideprotected void initDefaultProperties() {}@Overrideprotected void initFromChangedProperties() {init();}public Rules getRules() {return rules;}public void setRules(Rules rules) {String value = rulesXStream.toXML(rules);setStringProperty(CONFIG_RULES, value, true);}}", "nl": "import java.util.ArrayList;import org.olat.admin.landingpages.model.Rule;import org.olat.admin.landingpages.model.Rules;import org.olat.core.configuration.AbstractSpringModule;import org.olat.core.util.StringHelper;import org.olat.core.util.coordinate.CoordinatorManager;import org.olat.core.util.xml.XStreamHelper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.thoughtworks.xstream.XStream;@Service(\"landingPagesModule\")public class LandingPagesModule extends AbstractSpringModule {private static final String CONFIG_RULES = \"rules\";private static final XStream rulesXStream;static {rulesXStream = XStreamHelper.createXStreamInstance();rulesXStream.alias(\"rules\", Rules.class);rulesXStream.alias(\"rule\", Rule.class);}private Rules rules;@Autowiredpublic LandingPagesModule(CoordinatorManager coordinatorManager) {super(coordinatorManager);}@Overridepublic void init() {String rulesObj = getStringPropertyValue(CONFIG_RULES, true);if(StringHelper.containsNonWhitespace(rulesObj)) {rules = (Rules)rulesXStream.fromXML(rulesObj);} else {rules = new Rules();rules.setRules(new ArrayList<>(1));}}@Overrideprotected void initDefaultProperties() {}@Overrideprotected void initFromChangedProperties() {init();}public Rules getRules() {return rules;}public void setRules(Rules rules) {String value = rulesXStream.toXML(rules);setStringProperty(CONFIG_RULES, value, true);}}"}
{"code": "import java.io.File;import java.io.IOException;import java.io.OutputStream;import java.io.Writer;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.Properties;import org.olat.core.gui.control.generic.textmarker.TextMarker;import org.olat.core.gui.control.generic.textmarker.TextMarkerManager;import org.olat.core.helpers.Settings;import org.apache.logging.log4j.Logger;import org.olat.core.logging.Tracing;import org.olat.core.util.FileUtils;import org.olat.core.util.StringHelper;import org.olat.core.util.cache.CacheWrapper;import org.olat.core.util.coordinate.CoordinatorManager;import org.olat.core.util.vfs.LocalFileImpl;import org.olat.core.util.vfs.LocalFolderImpl;import org.olat.core.util.vfs.VFSContainer;import org.olat.core.util.vfs.VFSLeaf;import org.olat.core.util.xml.XStreamHelper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.core.util.QuickWriter;import com.thoughtworks.xstream.io.HierarchicalStreamWriter;import com.thoughtworks.xstream.io.xml.PrettyPrintWriter;import com.thoughtworks.xstream.io.xml.XppDriver;@Servicepublic class GlossaryItemManager {private static final Logger log = Tracing.createLoggerFor(GlossaryItemManager.class);private static final String OLD_GLOSSARY_FILENAME = \"glossary.textmarker.xml\";private static final String GLOSSARY_FILENAME = \"glossary.xml\";private static final String XML_GLOSSARY_ITEM_NAME = \"glossentry\";private static final String XML_REVISION_NAME = \"revision\";private static final String GLOSSARY_CONFIG_PROPERTIES_FILE = \"glossary.properties\";public static final String NO_MS_VALUE = \"ms-none\";public static final String MS_KEY = \"morphological.service.identifier\";public static final String REGISTER_ONOFF = \"register.index.enabled\";public static final String EDIT_USERS = \"edit.by.users.enabled\";private static final XStream xstreamReader = XStreamHelper.createXStreamInstance();static {XStreamHelper.allowDefaultPackage(xstreamReader);xstreamReader.alias(XML_GLOSSARY_ITEM_NAME, GlossaryItem.class);xstreamReader.alias(XML_REVISION_NAME, Revision.class);}private static final XStream xstreamWriter = new XStream(new XppDriver() {@Overridepublic HierarchicalStreamWriter createWriter(Writer out) {return new PrettyPrintWriter(out) {@Overrideprotected void writeText(QuickWriter writer, String text) {if (text.contains(\"<\")||text.contains(\">\")||text.contains(\"&\")){writer.write(\"<![CDATA[\");writer.write(text);writer.write(\"]]>\");} else {writer.write(text);}}};}});static {XStreamHelper.allowDefaultPackage(xstreamReader);xstreamWriter.alias(XML_GLOSSARY_ITEM_NAME, GlossaryItem.class);xstreamWriter.alias(XML_REVISION_NAME, Revision.class);}private CacheWrapper<String, List<GlossaryItem>> glossaryCache;@Autowiredprivate TextMarkerManager textMarkerManager;@Autowiredprivate CoordinatorManager coordinatorManager;public void saveGlossaryItemList(VFSContainer glossaryFolder, List<GlossaryItem> glossItemList) {VFSLeaf glossaryFile = getGlossaryFile(glossaryFolder);saveToFile(glossaryFile, glossItemList);glossItemList = removeEmptyGlossaryItems(glossItemList);updateCacheForGlossary(glossaryFolder, glossItemList);}private List<GlossaryItem> removeEmptyGlossaryItems(List<GlossaryItem> glossItemList){List<GlossaryItem> newList = new ArrayList<>();for (Iterator<GlossaryItem> iterator = glossItemList.iterator(); iterator.hasNext();) {GlossaryItem glossaryItem = iterator.next();if (StringHelper.containsNonWhitespace(glossaryItem.getGlossTerm())){newList.add(glossaryItem);}}return newList;}protected void upgradeAndDeleteOldGlossary(VFSContainer folderContainingGlossary, VFSLeaf textMarkerFile) {if (folderContainingGlossary.resolve(GLOSSARY_FILENAME) != null) {log.error(\"Upgrading Glossary in \" + folderContainingGlossary.toString() + \": There is already a new glossary-file. There can't be an old and a new version in the same directory!\");} else { List<TextMarker> textMarkerList = textMarkerManager.loadTextMarkerList(textMarkerFile);Collections.sort(textMarkerList);ArrayList<GlossaryItem> glossaryItemArr = new ArrayList<>();for (TextMarker tm : textMarkerList) {String glossTerm = tm.getMarkedMainText();String glossDef = tm.getHooverText();GlossaryItem glossItem = new GlossaryItem(glossTerm, glossDef);String aliasString = tm.getMarkedAliasText();if (StringHelper.containsNonWhitespace(aliasString)) {String[] aliasArr = aliasString.split(\";\");ArrayList<String> glossSynonyms = new ArrayList<>();glossSynonyms.addAll(Arrays.asList(aliasArr));glossItem.setGlossSynonyms(glossSynonyms);}glossaryItemArr.add(glossItem);}VFSLeaf glossaryFile = folderContainingGlossary.createChildLeaf(GLOSSARY_FILENAME);saveToFile(glossaryFile, glossaryItemArr);if (Settings.isDebuging()) {File tmFile = ((LocalFileImpl) textMarkerFile).getBasefile();File tmCont = ((LocalFolderImpl) folderContainingGlossary).getBasefile();FileUtils.copyFileToDir(tmFile, new File(tmCont + \"/bkp\"), \"backup old glossary\");}textMarkerFile.delete();}}public VFSLeaf getGlossaryFile(VFSContainer folderContainingGlossary) {VFSLeaf glossaryFile = (VFSLeaf) folderContainingGlossary.resolve(OLD_GLOSSARY_FILENAME);if (glossaryFile != null) {upgradeAndDeleteOldGlossary(folderContainingGlossary, glossaryFile);}glossaryFile = (VFSLeaf) folderContainingGlossary.resolve(GLOSSARY_FILENAME);if (glossaryFile == null) {glossaryFile = folderContainingGlossary.createChildLeaf(GLOSSARY_FILENAME);saveToFile(glossaryFile, new ArrayList<GlossaryItem>());}return glossaryFile;}public Long getGlossaryLastModifiedTime(VFSContainer folderContainingGlossary) {return getGlossaryFile(folderContainingGlossary).getLastModified();}public boolean isFolderContainingGlossary(VFSContainer folderContainingGlossary) {VFSLeaf glossaryFileOld = (VFSLeaf) folderContainingGlossary.resolve(OLD_GLOSSARY_FILENAME);VFSLeaf glossaryFileNew = (VFSLeaf) folderContainingGlossary.resolve(GLOSSARY_FILENAME);if (glossaryFileNew == null && glossaryFileOld == null) return false;else return true;}protected final void saveToFile(VFSLeaf glossaryFile, List<GlossaryItem> glossaryItemArr) {glossaryItemArr = removeEmptyGlossaryItems(glossaryItemArr);XStreamHelper.writeObject(xstreamWriter, glossaryFile, glossaryItemArr);}public List<GlossaryItem> getGlossaryItemListByVFSItem(final VFSContainer glossaryFolder){final String glossaryKey = ((LocalFolderImpl)glossaryFolder).getBasefile().toString();if (glossaryCache == null) {glossaryCache = coordinatorManager.getCoordinator().getCacher().getCache(GlossaryItemManager.class.getSimpleName(), \"glossary\");}List<GlossaryItem> glossaryItemList = glossaryCache.get(glossaryKey);if (glossaryItemList != null){if (log.isDebugEnabled()){log.debug(\"Loading glossary from cache.\");}return glossaryItemList;}return glossaryCache.computeIfAbsent(glossaryKey, key -> {if (log.isDebugEnabled()){log.debug(\"Loading glossary from filesystem. Glossary folder: \" + glossaryFolder);}return loadGlossaryItemListFromFile(getGlossaryFile(glossaryFolder));});}private void updateCacheForGlossary(VFSContainer glossaryFolder, List<GlossaryItem> glossItemList) {final String glossaryKey = ((LocalFolderImpl)glossaryFolder).getBasefile().toString();glossaryCache.update(glossaryKey, glossItemList);}@SuppressWarnings(\"unchecked\")protected final List<GlossaryItem> loadGlossaryItemListFromFile(VFSLeaf glossaryFile) {List<GlossaryItem> glossaryItemList = new ArrayList<>();if (glossaryFile == null) { return new ArrayList<>(); }Object glossObj = XStreamHelper.readObject(xstreamReader, glossaryFile);if (glossObj instanceof ArrayList) {ArrayList<GlossaryItem> glossItemsFromFile = (ArrayList<GlossaryItem>) glossObj;glossaryItemList.addAll(glossItemsFromFile);} else {log.error(\"The Glossary-XML-File \" + glossaryFile.toString() + \" seems not to be correct!\");}Collections.sort(glossaryItemList);return glossaryItemList;}public String getGlossaryContent(VFSContainer glossaryFolder){List<GlossaryItem> glossItems = getGlossaryItemListByVFSItem(glossaryFolder);StringBuilder sb = new StringBuilder(1024);for (GlossaryItem glossItem : glossItems) {List<String> allStrings = glossItem.getAllStringsToMarkup();for (String markupStr : allStrings) {sb.append(markupStr);sb.append(\"\\n\");}sb.append(\"\\n\");sb.append(glossItem.getGlossDef());sb.append(\"\\n\\n\");}return sb.toString();}public Properties getGlossaryConfig(VFSContainer glossaryFolder){Properties props = new Properties();VFSLeaf glossProp = (VFSLeaf) glossaryFolder.resolve(GLOSSARY_CONFIG_PROPERTIES_FILE);if(glossProp!=null) {try {props.load(glossProp.getInputStream());} catch (IOException e) {log.error(\"Properties in \" + glossProp + \" could not be read.\", e);}} else {props.put(MS_KEY, NO_MS_VALUE);props.put(REGISTER_ONOFF, \"true\");setGlossaryConfig(glossaryFolder, props);}return props;}public void setGlossaryConfig(VFSContainer glossaryFolder, Properties props){VFSLeaf glossProp = (VFSLeaf) glossaryFolder.resolve(GLOSSARY_CONFIG_PROPERTIES_FILE);if (glossProp==null){glossProp = glossaryFolder.createChildLeaf(GLOSSARY_CONFIG_PROPERTIES_FILE);}try(OutputStream out=glossProp.getOutputStream(false)) {props.store(out, \"Settings for the glossary saved in this folder.\");} catch (IOException e) {log.error(\"Properties in \" + glossProp + \" could not be written.\", e);}}}", "nl": "import java.io.File;import java.io.IOException;import java.io.OutputStream;import java.io.Writer;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.Properties;import org.olat.core.gui.control.generic.textmarker.TextMarker;import org.olat.core.gui.control.generic.textmarker.TextMarkerManager;import org.olat.core.helpers.Settings;import org.apache.logging.log4j.Logger;import org.olat.core.logging.Tracing;import org.olat.core.util.FileUtils;import org.olat.core.util.StringHelper;import org.olat.core.util.cache.CacheWrapper;import org.olat.core.util.coordinate.CoordinatorManager;import org.olat.core.util.vfs.LocalFileImpl;import org.olat.core.util.vfs.LocalFolderImpl;import org.olat.core.util.vfs.VFSContainer;import org.olat.core.util.vfs.VFSLeaf;import org.olat.core.util.xml.XStreamHelper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.core.util.QuickWriter;import com.thoughtworks.xstream.io.HierarchicalStreamWriter;import com.thoughtworks.xstream.io.xml.PrettyPrintWriter;import com.thoughtworks.xstream.io.xml.XppDriver;@Servicepublic class GlossaryItemManager {private static final Logger log = Tracing.createLoggerFor(GlossaryItemManager.class);private static final String OLD_GLOSSARY_FILENAME = \"glossary.textmarker.xml\";private static final String GLOSSARY_FILENAME = \"glossary.xml\";private static final String XML_GLOSSARY_ITEM_NAME = \"glossentry\";private static final String XML_REVISION_NAME = \"revision\";private static final String GLOSSARY_CONFIG_PROPERTIES_FILE = \"glossary.properties\";public static final String NO_MS_VALUE = \"ms-none\";public static final String MS_KEY = \"morphological.service.identifier\";public static final String REGISTER_ONOFF = \"register.index.enabled\";public static final String EDIT_USERS = \"edit.by.users.enabled\";private static final XStream xstreamReader = XStreamHelper.createXStreamInstance();static {xstreamReader.alias(XML_GLOSSARY_ITEM_NAME, GlossaryItem.class);xstreamReader.alias(XML_REVISION_NAME, Revision.class);}private static final XStream xstreamWriter = new XStream(new XppDriver() {@Overridepublic HierarchicalStreamWriter createWriter(Writer out) {return new PrettyPrintWriter(out) {@Overrideprotected void writeText(QuickWriter writer, String text) {if (text.contains(\"<\")||text.contains(\">\")||text.contains(\"&\")){writer.write(\"<![CDATA[\");writer.write(text);writer.write(\"]]>\");} else {writer.write(text);}}};}});static {xstreamWriter.alias(XML_GLOSSARY_ITEM_NAME, GlossaryItem.class);xstreamWriter.alias(XML_REVISION_NAME, Revision.class);}private CacheWrapper<String, List<GlossaryItem>> glossaryCache;@Autowiredprivate TextMarkerManager textMarkerManager;@Autowiredprivate CoordinatorManager coordinatorManager;public void saveGlossaryItemList(VFSContainer glossaryFolder, List<GlossaryItem> glossItemList) {VFSLeaf glossaryFile = getGlossaryFile(glossaryFolder);saveToFile(glossaryFile, glossItemList);glossItemList = removeEmptyGlossaryItems(glossItemList);updateCacheForGlossary(glossaryFolder, glossItemList);}private List<GlossaryItem> removeEmptyGlossaryItems(List<GlossaryItem> glossItemList){List<GlossaryItem> newList = new ArrayList<>();for (Iterator<GlossaryItem> iterator = glossItemList.iterator(); iterator.hasNext();) {GlossaryItem glossaryItem = iterator.next();if (StringHelper.containsNonWhitespace(glossaryItem.getGlossTerm())){newList.add(glossaryItem);}}return newList;}protected void upgradeAndDeleteOldGlossary(VFSContainer folderContainingGlossary, VFSLeaf textMarkerFile) {if (folderContainingGlossary.resolve(GLOSSARY_FILENAME) != null) {log.error(\"Upgrading Glossary in \" + folderContainingGlossary.toString() + \": There is already a new glossary-file. There can't be an old and a new version in the same directory!\");} else { List<TextMarker> textMarkerList = textMarkerManager.loadTextMarkerList(textMarkerFile);Collections.sort(textMarkerList);ArrayList<GlossaryItem> glossaryItemArr = new ArrayList<>();for (TextMarker tm : textMarkerList) {String glossTerm = tm.getMarkedMainText();String glossDef = tm.getHooverText();GlossaryItem glossItem = new GlossaryItem(glossTerm, glossDef);String aliasString = tm.getMarkedAliasText();if (StringHelper.containsNonWhitespace(aliasString)) {String[] aliasArr = aliasString.split(\";\");ArrayList<String> glossSynonyms = new ArrayList<>();glossSynonyms.addAll(Arrays.asList(aliasArr));glossItem.setGlossSynonyms(glossSynonyms);}glossaryItemArr.add(glossItem);}VFSLeaf glossaryFile = folderContainingGlossary.createChildLeaf(GLOSSARY_FILENAME);saveToFile(glossaryFile, glossaryItemArr);if (Settings.isDebuging()) {File tmFile = ((LocalFileImpl) textMarkerFile).getBasefile();File tmCont = ((LocalFolderImpl) folderContainingGlossary).getBasefile();FileUtils.copyFileToDir(tmFile, new File(tmCont + \"/bkp\"), \"backup old glossary\");}textMarkerFile.delete();}}public VFSLeaf getGlossaryFile(VFSContainer folderContainingGlossary) {VFSLeaf glossaryFile = (VFSLeaf) folderContainingGlossary.resolve(OLD_GLOSSARY_FILENAME);if (glossaryFile != null) {upgradeAndDeleteOldGlossary(folderContainingGlossary, glossaryFile);}glossaryFile = (VFSLeaf) folderContainingGlossary.resolve(GLOSSARY_FILENAME);if (glossaryFile == null) {glossaryFile = folderContainingGlossary.createChildLeaf(GLOSSARY_FILENAME);saveToFile(glossaryFile, new ArrayList<GlossaryItem>());}return glossaryFile;}public Long getGlossaryLastModifiedTime(VFSContainer folderContainingGlossary) {return getGlossaryFile(folderContainingGlossary).getLastModified();}public boolean isFolderContainingGlossary(VFSContainer folderContainingGlossary) {VFSLeaf glossaryFileOld = (VFSLeaf) folderContainingGlossary.resolve(OLD_GLOSSARY_FILENAME);VFSLeaf glossaryFileNew = (VFSLeaf) folderContainingGlossary.resolve(GLOSSARY_FILENAME);if (glossaryFileNew == null && glossaryFileOld == null) return false;else return true;}private void saveToFile(VFSLeaf glossaryFile, List<GlossaryItem> glossaryItemArr) {glossaryItemArr = removeEmptyGlossaryItems(glossaryItemArr);XStreamHelper.writeObject(xstreamWriter, glossaryFile, glossaryItemArr);}public List<GlossaryItem> getGlossaryItemListByVFSItem(final VFSContainer glossaryFolder){final String glossaryKey = ((LocalFolderImpl)glossaryFolder).getBasefile().toString();if (glossaryCache == null) {glossaryCache = coordinatorManager.getCoordinator().getCacher().getCache(GlossaryItemManager.class.getSimpleName(), \"glossary\");}List<GlossaryItem> glossaryItemList = glossaryCache.get(glossaryKey);if (glossaryItemList != null){if (log.isDebugEnabled()){log.debug(\"Loading glossary from cache.\");}return glossaryItemList;}return glossaryCache.computeIfAbsent(glossaryKey, key -> {if (log.isDebugEnabled()){log.debug(\"Loading glossary from filesystem. Glossary folder: \" + glossaryFolder);}return loadGlossaryItemListFromFile(getGlossaryFile(glossaryFolder));});}private void updateCacheForGlossary(VFSContainer glossaryFolder, List<GlossaryItem> glossItemList) {final String glossaryKey = ((LocalFolderImpl)glossaryFolder).getBasefile().toString();glossaryCache.update(glossaryKey, glossItemList);}@SuppressWarnings(\"unchecked\")private List<GlossaryItem> loadGlossaryItemListFromFile(VFSLeaf glossaryFile) {List<GlossaryItem> glossaryItemList = new ArrayList<>();if (glossaryFile == null) { return new ArrayList<>(); }Object glossObj = XStreamHelper.readObject(xstreamReader, glossaryFile);if (glossObj instanceof ArrayList) {ArrayList<GlossaryItem> glossItemsFromFile = (ArrayList<GlossaryItem>) glossObj;glossaryItemList.addAll(glossItemsFromFile);} else {log.error(\"The Glossary-XML-File \" + glossaryFile.toString() + \" seems not to be correct!\");}Collections.sort(glossaryItemList);return glossaryItemList;}public String getGlossaryContent(VFSContainer glossaryFolder){List<GlossaryItem> glossItems = getGlossaryItemListByVFSItem(glossaryFolder);StringBuilder sb = new StringBuilder(1024);for (GlossaryItem glossItem : glossItems) {List<String> allStrings = glossItem.getAllStringsToMarkup();for (String markupStr : allStrings) {sb.append(markupStr);sb.append(\"\\n\");}sb.append(\"\\n\");sb.append(glossItem.getGlossDef());sb.append(\"\\n\\n\");}return sb.toString();}public Properties getGlossaryConfig(VFSContainer glossaryFolder){Properties props = new Properties();VFSLeaf glossProp = (VFSLeaf) glossaryFolder.resolve(GLOSSARY_CONFIG_PROPERTIES_FILE);if(glossProp!=null) {try {props.load(glossProp.getInputStream());} catch (IOException e) {log.error(\"Properties in \" + glossProp + \" could not be read.\", e);}} else {props.put(MS_KEY, NO_MS_VALUE);props.put(REGISTER_ONOFF, \"true\");setGlossaryConfig(glossaryFolder, props);}return props;}public void setGlossaryConfig(VFSContainer glossaryFolder, Properties props){VFSLeaf glossProp = (VFSLeaf) glossaryFolder.resolve(GLOSSARY_CONFIG_PROPERTIES_FILE);if (glossProp==null){glossProp = glossaryFolder.createChildLeaf(GLOSSARY_CONFIG_PROPERTIES_FILE);}try(OutputStream out=glossProp.getOutputStream(false)) {props.store(out, \"Settings for the glossary saved in this folder.\");} catch (IOException e) {log.error(\"Properties in \" + glossProp + \" could not be written.\", e);}}}"}
{"code": "import org.olat.core.commons.services.doceditor.discovery.model.ActionImpl;import org.olat.core.commons.services.doceditor.discovery.model.AppImpl;import org.olat.core.commons.services.doceditor.discovery.model.DiscoveryImpl;import org.olat.core.commons.services.doceditor.discovery.model.NetZoneImpl;import org.olat.core.commons.services.doceditor.discovery.model.ProofKeyImpl;import org.olat.core.util.xml.XStreamHelper;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.security.ExplicitTypePermission;class DiscoveryXStream {private static final XStream xstream = XStreamHelper.createXStreamInstance();static {Class<?>[] types = new Class[] {DiscoveryImpl.class, NetZoneImpl.class, AppImpl.class, ActionImpl.class, ProofKeyImpl.class};xstream.addPermission(new ExplicitTypePermission(types));xstream.alias(\"wopi-discovery\", DiscoveryImpl.class);xstream.aliasField(\"proof-key\", DiscoveryImpl.class, \"proofKey\");xstream.addImplicitCollection(DiscoveryImpl.class, \"netZones\");xstream.alias(\"net-zone\", NetZoneImpl.class);xstream.aliasAttribute(NetZoneImpl.class, \"name\", \"name\");xstream.addImplicitCollection(NetZoneImpl.class, \"apps\");xstream.alias(\"app\", AppImpl.class);xstream.aliasAttribute(AppImpl.class, \"name\", \"name\");xstream.aliasAttribute(AppImpl.class, \"favIconUrl\", \"favIconUrl\");xstream.aliasAttribute(AppImpl.class, \"checkLicense\", \"checkLicense\");xstream.addImplicitCollection(AppImpl.class, \"actions\");xstream.alias(\"action\", ActionImpl.class);xstream.aliasAttribute(ActionImpl.class, \"name\", \"name\");xstream.aliasAttribute(ActionImpl.class, \"ext\", \"ext\");xstream.aliasAttribute(ActionImpl.class, \"urlSrc\", \"urlsrc\");xstream.aliasAttribute(ActionImpl.class, \"requires\", \"requires\");xstream.aliasAttribute(ActionImpl.class, \"targetExt\", \"targetext\");xstream.alias(\"proof-key\", ProofKeyImpl.class);xstream.aliasAttribute(ProofKeyImpl.class, \"value\", \"value\");xstream.aliasAttribute(ProofKeyImpl.class, \"modulus\", \"modulus\");xstream.aliasAttribute(ProofKeyImpl.class, \"exponent\", \"exponent\");xstream.aliasAttribute(ProofKeyImpl.class, \"oldValue\", \"oldvalue\");xstream.aliasAttribute(ProofKeyImpl.class, \"oldModulus\", \"oldmodulus\");xstream.aliasAttribute(ProofKeyImpl.class, \"oldExponent\", \"oldexponent\");}@SuppressWarnings(\"unchecked\")static <U> U fromXml(String xml, @SuppressWarnings(\"unused\") Class<U> cl) {Object obj = xstream.fromXML(xml);return (U)obj;}}", "nl": "import org.olat.core.commons.services.doceditor.discovery.model.ActionImpl;import org.olat.core.commons.services.doceditor.discovery.model.AppImpl;import org.olat.core.commons.services.doceditor.discovery.model.DiscoveryImpl;import org.olat.core.commons.services.doceditor.discovery.model.NetZoneImpl;import org.olat.core.commons.services.doceditor.discovery.model.ProofKeyImpl;import org.olat.core.util.xml.XStreamHelper;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.security.ExplicitTypePermission;class DiscoveryXStream {private static final XStream xstream = XStreamHelper.createXStreamInstance();static {XStream.setupDefaultSecurity(xstream);Class<?>[] types = new Class[] {DiscoveryImpl.class, NetZoneImpl.class, AppImpl.class, ActionImpl.class, ProofKeyImpl.class};xstream.addPermission(new ExplicitTypePermission(types));xstream.alias(\"wopi-discovery\", DiscoveryImpl.class);xstream.aliasField(\"proof-key\", DiscoveryImpl.class, \"proofKey\");xstream.addImplicitCollection(DiscoveryImpl.class, \"netZones\");xstream.alias(\"net-zone\", NetZoneImpl.class);xstream.aliasAttribute(NetZoneImpl.class, \"name\", \"name\");xstream.addImplicitCollection(NetZoneImpl.class, \"apps\");xstream.alias(\"app\", AppImpl.class);xstream.aliasAttribute(AppImpl.class, \"name\", \"name\");xstream.aliasAttribute(AppImpl.class, \"favIconUrl\", \"favIconUrl\");xstream.aliasAttribute(AppImpl.class, \"checkLicense\", \"checkLicense\");xstream.addImplicitCollection(AppImpl.class, \"actions\");xstream.alias(\"action\", ActionImpl.class);xstream.aliasAttribute(ActionImpl.class, \"name\", \"name\");xstream.aliasAttribute(ActionImpl.class, \"ext\", \"ext\");xstream.aliasAttribute(ActionImpl.class, \"urlSrc\", \"urlsrc\");xstream.aliasAttribute(ActionImpl.class, \"requires\", \"requires\");xstream.aliasAttribute(ActionImpl.class, \"targetExt\", \"targetext\");xstream.alias(\"proof-key\", ProofKeyImpl.class);xstream.aliasAttribute(ProofKeyImpl.class, \"value\", \"value\");xstream.aliasAttribute(ProofKeyImpl.class, \"modulus\", \"modulus\");xstream.aliasAttribute(ProofKeyImpl.class, \"exponent\", \"exponent\");xstream.aliasAttribute(ProofKeyImpl.class, \"oldValue\", \"oldvalue\");xstream.aliasAttribute(ProofKeyImpl.class, \"oldModulus\", \"oldmodulus\");xstream.aliasAttribute(ProofKeyImpl.class, \"oldExponent\", \"oldexponent\");}@SuppressWarnings(\"unchecked\")static <U> U fromXml(String xml, @SuppressWarnings(\"unused\") Class<U> cl) {Object obj = xstream.fromXML(xml);return (U)obj;}}"}
{"code": "import org.olat.core.commons.services.license.License;import org.olat.core.commons.services.license.model.LicenseImpl;import org.olat.core.commons.services.license.model.LicenseTypeImpl;import org.olat.core.commons.services.license.model.ResourceLicenseImpl;import org.apache.logging.log4j.Logger;import org.olat.core.logging.Tracing;import org.olat.core.util.StringHelper;import org.olat.core.util.xml.XStreamHelper;import org.springframework.stereotype.Component;import com.thoughtworks.xstream.XStream;@Componentclass LicenseXStreamHelper {private static final Logger log = Tracing.createLoggerFor(LicenseXStreamHelper.class);private static final XStream licenseXStream = XStreamHelper.createXStreamInstanceForDBObjects();static {XStreamHelper.allowDefaultPackage(licenseXStream);licenseXStream.alias(\"license\", LicenseImpl.class);licenseXStream.alias(\"license\", ResourceLicenseImpl.class);licenseXStream.alias(\"licenseType\", LicenseTypeImpl.class);licenseXStream.ignoreUnknownElements();licenseXStream.omitField(LicenseImpl.class, \"creationDate\");licenseXStream.omitField(LicenseImpl.class, \"lastModified\");licenseXStream.omitField(ResourceLicenseImpl.class, \"creationDate\");licenseXStream.omitField(ResourceLicenseImpl.class, \"lastModified\");licenseXStream.omitField(LicenseTypeImpl.class, \"creationDate\");licenseXStream.omitField(LicenseTypeImpl.class, \"lastModified\");}String toXml(License license) {if (license == null) return null;return licenseXStream.toXML(license);}License licenseFromXml(String xml) {License license = null;if(StringHelper.containsNonWhitespace(xml)) {try {Object obj = licenseXStream.fromXML(xml);if(obj instanceof License) {license = (License) obj;}} catch (Exception e) {log.error(\"\", e);}}return license;}}", "nl": "import org.olat.core.commons.services.license.License;import org.olat.core.commons.services.license.model.LicenseImpl;import org.olat.core.commons.services.license.model.LicenseTypeImpl;import org.olat.core.commons.services.license.model.ResourceLicenseImpl;import org.apache.logging.log4j.Logger;import org.olat.core.logging.Tracing;import org.olat.core.util.StringHelper;import org.olat.core.util.xml.XStreamHelper;import org.springframework.stereotype.Component;import com.thoughtworks.xstream.XStream;@Componentclass LicenseXStreamHelper {private static final Logger log = Tracing.createLoggerFor(LicenseXStreamHelper.class);private static final XStream licenseXStream = XStreamHelper.createXStreamInstanceForDBObjects();static {licenseXStream.alias(\"license\", LicenseImpl.class);licenseXStream.alias(\"license\", ResourceLicenseImpl.class);licenseXStream.alias(\"licenseType\", LicenseTypeImpl.class);licenseXStream.ignoreUnknownElements();licenseXStream.omitField(LicenseImpl.class, \"creationDate\");licenseXStream.omitField(LicenseImpl.class, \"lastModified\");licenseXStream.omitField(ResourceLicenseImpl.class, \"creationDate\");licenseXStream.omitField(ResourceLicenseImpl.class, \"lastModified\");licenseXStream.omitField(LicenseTypeImpl.class, \"creationDate\");licenseXStream.omitField(LicenseTypeImpl.class, \"lastModified\");}String toXml(License license) {if (license == null) return null;return licenseXStream.toXML(license);}License licenseFromXml(String xml) {License license = null;if(StringHelper.containsNonWhitespace(xml)) {try {Object obj = licenseXStream.fromXML(xml);if(obj instanceof License) {license = (License) obj;}} catch (Exception e) {log.error(\"\", e);}}return license;}}"}